# Python: Математические вычисления

Этот документ содержит подробное описание встроенных библиотек Python для математических вычислений. Документация ориентирована на Python 3.8+ и предназначена для senior-разработчиков.

## Содержание

- [math](#math)
- [cmath](#cmath)
- [decimal](#decimal)
- [fractions](#fractions)
- [random](#random)
- [statistics](#statistics)
- [itertools](#itertools)
- [functools](#functools)
- [operator](#operator)
- [numbers](#numbers)

## math

Модуль `math` предоставляет доступ к математическим функциям, определенным стандартом C.

**Описание:** Содержит функции для работы с действительными числами, тригонометрические, логарифмические и другие математические операции.

**Внутреннее устройство:**
- Реализован в виде оберток над функциями математической библиотеки C.
- Работает только с действительными числами (для комплексных чисел используйте `cmath`).
- Оптимизирован для высокой точности и следования стандартам IEEE-754.

**Ключевые константы:**
- `math.pi` - число π (примерно 3.14159265359).
- `math.e` - число e (основание натурального логарифма, примерно 2.71828182846).
- `math.tau` - число τ (2π, примерно 6.28318530718).
- `math.inf` - положительная бесконечность (float('inf')).
- `math.nan` - "не число" (float('nan')).

**Ключевые функции:**
- **Основные функции:**
  - `math.ceil(x)` - округление вверх.
  - `math.floor(x)` - округление вниз.
  - `math.trunc(x)` - усечение до целого.
  - `math.fabs(x)` - абсолютное значение (возвращает float).
  - `math.factorial(n)` - факториал числа n.
  - `math.gcd(a, b)` - наибольший общий делитель.
  - `math.lcm(a, b)` - наименьшее общее кратное (Python 3.9+).
  - `math.fmod(x, y)` - остаток от деления x на y.
  - `math.remainder(x, y)` - остаток IEEE 754 от деления x на y.
  - `math.modf(x)` - возвращает дробную и целую части x.

- **Степени и логарифмы:**
  - `math.pow(x, y)` - возведение в степень (x^y).
  - `math.sqrt(x)` - квадратный корень.
  - `math.exp(x)` - экспонента (e^x).
  - `math.log(x[, base])` - логарифм по основанию (по умолчанию натуральный).
  - `math.log10(x)` - десятичный логарифм.
  - `math.log2(x)` - двоичный логарифм.
  - `math.log1p(x)` - натуральный логарифм от (1+x) (точнее для малых x).
  - `math.expm1(x)` - e^x - 1 (точнее для малых x).

- **Тригонометрические функции:**
  - `math.sin(x)`, `math.cos(x)`, `math.tan(x)` - синус, косинус, тангенс.
  - `math.asin(x)`, `math.acos(x)`, `math.atan(x)` - арксинус, арккосинус, арктангенс.
  - `math.atan2(y, x)` - арктангенс y/x с учетом квадранта.
  - `math.sinh(x)`, `math.cosh(x)`, `math.tanh(x)` - гиперболические функции.
  - `math.asinh(x)`, `math.acosh(x)`, `math.atanh(x)` - обратные гиперболические функции.
  - `math.degrees(x)` - преобразование радиан в градусы.
  - `math.radians(x)` - преобразование градусов в радианы.

- **Специальные функции:**
  - `math.erf(x)`, `math.erfc(x)` - функция ошибок и её дополнение.
  - `math.gamma(x)` - гамма-функция.
  - `math.lgamma(x)` - натуральный логарифм гамма-функции.

- **Проверки:**
  - `math.isfinite(x)` - проверка на конечность.
  - `math.isinf(x)` - проверка на бесконечность.
  - `math.isnan(x)` - проверка на "не число".
  - `math.isclose(a, b, *, rel_tol=1e-9, abs_tol=0.0)` - проверка приблизительного равенства.

**Примеры:**
```python
import math

# Округления
print(f"Округление вверх 3.2: {math.ceil(3.2)}")  # 4
print(f"Округление вниз 3.8: {math.floor(3.8)}")  # 3
print(f"Усечение -3.8: {math.trunc(-3.8)}")       # -3

# Степени и корни
print(f"2 в степени 10: {math.pow(2, 10)}")       # 1024.0
print(f"Корень из 25: {math.sqrt(25)}")           # 5.0
print(f"e в степени 2: {math.exp(2)}")            # 7.3890560989306495

# Логарифмы
print(f"ln(10): {math.log(10)}")                  # 2.302585092994046
print(f"log10(100): {math.log10(100)}")           # 2.0
print(f"log2(8): {math.log2(8)}")                 # 3.0

# Тригонометрия
print(f"sin(pi/2): {math.sin(math.pi/2)}")        # 1.0
print(f"cos(pi): {math.cos(math.pi)}")            # -1.0
print(f"tan(pi/4): {math.tan(math.pi/4)}")        # 0.9999999999999999 (≈ 1)

# Преобразование радианов и градусов
print(f"45 градусов в радианах: {math.radians(45)}")  # 0.7853981633974483
print(f"π/4 радиан в градусах: {math.degrees(math.pi/4)}")  # 45.0

# Гиперболические функции
print(f"sinh(1): {math.sinh(1)}")                 # 1.1752011936438014
print(f"cosh(1): {math.cosh(1)}")                 # 1.5430806348152437
print(f"tanh(1): {math.tanh(1)}")                 # 0.7615941559557649

# Факториал и НОД
print(f"5!: {math.factorial(5)}")                 # 120
print(f"НОД(18, 24): {math.gcd(18, 24)}")         # 6
try:
    print(f"НОК(18, 24): {math.lcm(18, 24)}")     # 72 (только в Python 3.9+)
except AttributeError:
    print("math.lcm() доступен только в Python 3.9+")

# Проверки значений
print(f"isfinite(10): {math.isfinite(10)}")       # True
print(f"isfinite(math.inf): {math.isfinite(math.inf)}")  # False
print(f"isinf(math.inf): {math.isinf(math.inf)}")  # True
print(f"isnan(math.nan): {math.isnan(math.nan)}")  # True

# Проверка на приблизительное равенство
print(f"isclose(0.1+0.2, 0.3): {math.isclose(0.1+0.2, 0.3)}")  # True
print(f"0.1+0.2 == 0.3: {0.1+0.2 == 0.3}")        # False

# Остаток от деления
print(f"fmod(10, 3): {math.fmod(10, 3)}")         # 1.0
print(f"10 % 3: {10 % 3}")                        # 1

# Извлечение дробной и целой части
print(f"modf(3.14): {math.modf(3.14)}")           # (0.14000000000000012, 3.0)

# Специальные функции
print(f"gamma(5): {math.gamma(5)}")               # 24.0 (4!)
print(f"erf(1): {math.erf(1)}")                   # 0.8427007929497149
```

**Особенности для senior-разработчиков:**
- Функции в `math` работают с типом `float`, который имеет ограниченную точность (обычно 15-17 значащих цифр). Для высокоточных вычислений используйте `decimal`.
- Функция `math.isclose()` решает проблему неточного сравнения чисел с плавающей точкой. Параметр `rel_tol` определяет относительную погрешность, а `abs_tol` - абсолютную.
- `math.fmod(x, y)` и оператор `%` дают разные результаты для отрицательных чисел. `fmod` следует правилу остатка в C, а `%` гарантирует, что результат имеет тот же знак, что и делитель.
- `math.pow(x, y)` и оператор `**` могут давать разные результаты в краевых случаях (например, для отрицательных чисел).
- Некоторые функции (например, `math.log1p(x)` и `math.expm1(x)`) оптимизированы для работы с малыми значениями, где прямой расчет может давать неточные результаты из-за потери значимости.
- При выполнении геометрических расчетов (например, вычисление расстояний) помните о численной нестабильности прямых формул. Часто можно найти математически эквивалентные, но численно более стабильные алгоритмы.
- При использовании функций модуля в циклах с большим количеством итераций, рассмотрите возможность работы с векторизованными операциями, например, из NumPy, для повышения производительности.

## cmath

Модуль `cmath` предоставляет математические функции для работы с комплексными числами.

**Описание:** Содержит функции, аналогичные функциям модуля `math`, но адаптированные для работы с комплексными числами.

**Внутреннее устройство:**
- Реализован на основе стандартной библиотеки C для комплексных чисел.
- Работает с типом `complex` в Python.
- Обеспечивает корректную обработку аргументов и выбор ветвей для многозначных функций.

**Ключевые константы:**
- `cmath.pi` - число π (аналогично `math.pi`).
- `cmath.e` - число e (аналогично `math.e`).
- `cmath.tau` - число τ (2π, аналогично `math.tau`).
- `cmath.inf` - положительная бесконечность.
- `cmath.nan` - "не число".
- `cmath.infj` - мнимая бесконечность.

**Ключевые функции:**
- **Основные функции:**
  - `cmath.phase(z)` - фаза (аргумент) комплексного числа.
  - `cmath.polar(z)` - преобразование в полярные координаты (r, φ).
  - `cmath.rect(r, phi)` - преобразование из полярных координат.
  - `cmath.real(z)`, `cmath.imag(z)` - действительная и мнимая части.

- **Степени и логарифмы:**
  - `cmath.sqrt(z)` - квадратный корень.
  - `cmath.exp(z)` - экспонента (e^z).
  - `cmath.log(z[, base])` - логарифм по основанию (по умолчанию натуральный).
  - `cmath.log10(z)` - десятичный логарифм.

- **Тригонометрические функции:**
  - `cmath.sin(z)`, `cmath.cos(z)`, `cmath.tan(z)` - синус, косинус, тангенс.
  - `cmath.asin(z)`, `cmath.acos(z)`, `cmath.atan(z)` - арксинус, арккосинус, арктангенс.
  - `cmath.sinh(z)`, `cmath.cosh(z)`, `cmath.tanh(z)` - гиперболические функции.
  - `cmath.asinh(z)`, `cmath.acosh(z)`, `cmath.atanh(z)` - обратные гиперболические функции.

- **Проверки:**
  - `cmath.isfinite(z)` - проверка на конечность.
  - `cmath.isinf(z)` - проверка на бесконечность.
  - `cmath.isnan(z)` - проверка на "не число".
  - `cmath.isclose(a, b, *, rel_tol=1e-9, abs_tol=0.0)` - проверка приблизительного равенства.

**Примеры:**
```python
import cmath
import math

# Создание комплексных чисел
z1 = complex(3, 4)  # 3 + 4j
z2 = 2 + 5j

print(f"z1 = {z1}")
print(f"z2 = {z2}")

# Базовые операции с комплексными числами
print(f"z1 + z2 = {z1 + z2}")
print(f"z1 * z2 = {z1 * z2}")
print(f"z1 / z2 = {z1 / z2}")

# Модуль и аргумент комплексного числа
print(f"Модуль z1: {abs(z1)}")  # или math.sqrt(z1.real**2 + z1.imag**2)
print(f"Аргумент z1: {cmath.phase(z1)} радиан")
print(f"Аргумент z1: {math.degrees(cmath.phase(z1))} градусов")

# Преобразование между формами представления
polar_form = cmath.polar(z1)
print(f"z1 в полярной форме: r={polar_form[0]}, phi={polar_form[1]}")

z_from_polar = cmath.rect(*polar_form)
print(f"Восстановленное из полярной формы: {z_from_polar}")

# Извлечение действительной и мнимой частей
print(f"Действительная часть z1: {z1.real}")
print(f"Мнимая часть z1: {z1.imag}")

# Комплексные математические функции
print(f"Корень из z1: {cmath.sqrt(z1)}")
print(f"e^z1: {cmath.exp(z1)}")
print(f"ln(z1): {cmath.log(z1)}")
print(f"log10(z1): {cmath.log10(z1)}")

# Тригонометрические функции
print(f"sin(z1): {cmath.sin(z1)}")
print(f"cos(z1): {cmath.cos(z1)}")
print(f"tan(z1): {cmath.tan(z1)}")

# Обратные тригонометрические функции
print(f"asin(z1): {cmath.asin(z1)}")
print(f"acos(z1): {cmath.acos(z1)}")
print(f"atan(z1): {cmath.atan(z1)}")

# Гиперболические функции
print(f"sinh(z1): {cmath.sinh(z1)}")
print(f"cosh(z1): {cmath.cosh(z1)}")
print(f"tanh(z1): {cmath.tanh(z1)}")

# Обратные гиперболические функции
print(f"asinh(z1): {cmath.asinh(z1)}")
print(f"acosh(z1): {cmath.acosh(z1)}")
print(f"atanh(z1/10): {cmath.atanh(z1/10)}")  # |z| должно быть < 1 для atanh

# Проверки значений
print(f"isfinite(z1): {cmath.isfinite(z1)}")
print(f"isinf(complex(cmath.inf, 0)): {cmath.isinf(complex(cmath.inf, 0))}")
print(f"isnan(complex(cmath.nan, 0)): {cmath.isnan(complex(cmath.nan, 0))}")

# Комплексный корень из отрицательного числа
print(f"Корень из -1: {cmath.sqrt(-1)}")  # Результат в math.sqrt(-1) был бы ошибкой
```

**Особенности для senior-разработчиков:**
- Многие функции в `cmath` являются многозначными на комплексной плоскости, и модуль выбирает определённую ветвь для возвращения однозначного результата.
- Функция `cmath.phase()` возвращает угол в диапазоне (-π, π], что важно учитывать при работе с полярными координатами.
- При потребности в высокой точности для комплексных вычислений, рассмотрите использование NumPy или SymPy, которые могут предложить дополнительные возможности и оптимизации.
- Операция `abs(z)` для комплексного числа вычисляет его модуль; для отдельного вычисления действительной и мнимой частей используйте `z.real` и `z.imag`.
- При переходе с действительных на комплексные вычисления помните, что некоторые оптимизации, применимые для действительных чисел, могут не работать для комплексных.
- Модуль `cmath` работает с типом `complex`, который имеет ограниченную точность. Если требуется высокая точность, рассмотрите специализированные библиотеки, такие как mpmath.
- Функция `cmath.isclose()` учитывает как действительную, так и мнимую части при определении "близости" комплексных чисел.

## decimal

Модуль `decimal` обеспечивает поддержку десятичной арифметики с фиксированной и плавающей точкой.

**Описание:** Предоставляет тип данных `Decimal` для точных десятичных расчетов, избегая проблем с точностью, присущих типу `float`.

**Внутреннее устройство:**
- Реализует стандарт IEEE 854 для десятичной арифметики.
- Обеспечивает контроль над точностью, округлением и обработкой исключений.
- Позволяет настраивать поведение арифметики через контекст.

**Ключевые компоненты:**
- `decimal.Decimal` - класс для представления десятичных чисел.
- `decimal.getcontext()` - возвращает текущий контекст для управления арифметикой.
- `decimal.localcontext()` - контекстный менеджер для временного изменения настроек.

**Опции контекста:**
- `prec` - точность (количество значащих цифр).
- `rounding` - метод округления.
- `traps` - обработка исключений.
- `Emin`, `Emax` - минимальная и максимальная экспонента.
- `capitals` - использование заглавных букв в представлении.
- `clamp` - ограничение экспоненты.

**Методы округления:**
- `ROUND_CEILING` - округление к +∞.
- `ROUND_DOWN` - округление к 0.
- `ROUND_FLOOR` - округление к -∞.
- `ROUND_HALF_DOWN` - округление до ближайшего, при равенстве к 0.
- `ROUND_HALF_EVEN` - банковское округление (к ближайшему четному).
- `ROUND_HALF_UP` - округление до ближайшего, при равенстве от 0.
- `ROUND_UP` - округление от 0.
- `ROUND_05UP` - округление от 0, если последняя цифра 0 или 5.

**Примеры:**
```python
from decimal import Decimal, getcontext, localcontext, ROUND_HALF_UP, ROUND_DOWN

# Проблема точности с float
print(f"0.1 + 0.2 = {0.1 + 0.2}")  # 0.30000000000000004

# Использование Decimal для точных расчетов
a = Decimal('0.1')
b = Decimal('0.2')
print(f"Decimal('0.1') + Decimal('0.2') = {a + b}")  # 0.3

# Различные способы создания Decimal
a = Decimal('0.1')    # Из строки (рекомендуется)
b = Decimal(0.1)      # Из float (может быть неточным из-за представления float)
c = Decimal((0, (1,), -1))  # Из кортежа (знак, цифры, экспонента)
print(f"Из строки: {a}")
print(f"Из float: {b}")
print(f"Из кортежа: {c}")

# Управление точностью через контекст
print("\nУправление точностью:")
getcontext().prec = 28  # Установка глобальной точности
print(f"1/7 с точностью 28: {Decimal(1) / Decimal(7)}")

with localcontext() as ctx:
    ctx.prec = 10  # Временное изменение точности
    print(f"1/7 с точностью 10: {Decimal(1) / Decimal(7)}")

print(f"1/7 с исходной точностью: {Decimal(1) / Decimal(7)}")  # Вернулась к 28

# Управление округлением
print("\nУправление округлением:")
getcontext().rounding = ROUND_HALF_UP  # Стандартное математическое округление
print(f"1/7 округлено HALF_UP: {Decimal(1) / Decimal(7)}")

with localcontext() as ctx:
    ctx.rounding = ROUND_DOWN  # Округление к нулю
    print(f"1/7 округлено DOWN: {Decimal(1) / Decimal(7)}")

# Математические операции
print("\nМатематические операции:")
x = Decimal('10.5')
y = Decimal('3.25')

print(f"{x} + {y} = {x + y}")
print(f"{x} - {y} = {x - y}")
print(f"{x} * {y} = {x * y}")
print(f"{x} / {y} = {x / y}")
print(f"{x} % {y} = {x % y}")  # Остаток
print(f"{x} // {y} = {x // y}")  # Целочисленное деление

# Сравнение
print("\nСравнение:")
print(f"Decimal('0.1') == Decimal('0.10'): {Decimal('0.1') == Decimal('0.10')}")  # True
print(f"Decimal('1.0') == 1: {Decimal('1.0') == 1}")  # True
print(f"Decimal('1.0') == 1.0: {Decimal('1.0') == 1.0}")  # False (из-за точности float)

# Точные финансовые расчеты
print("\nФинансовые расчеты:")
item_price = Decimal('9.99')
quantity = 3
tax_rate = Decimal('0.0875')  # 8.75%

subtotal = item_price * quantity
tax = subtotal * tax_rate
total = subtotal + tax

print(f"Цена: {item_price}")
print(f"Количество: {quantity}")
print(f"Подытог: {subtotal}")
print(f"Налог ({tax_rate*100}%): {tax}")
print(f"Итого: {total}")

# Научные расчеты с высокой точностью
print("\nНаучные расчеты:")
getcontext().prec = 50  # Увеличиваем точность

# Вычисление π через ряд Лейбница
pi_approx = Decimal(0)
for k in range(100000):
    pi_term = Decimal(4) / Decimal(2*k + 1)
    if k % 2 == 0:
        pi_approx += pi_term
    else:
        pi_approx -= pi_term

print(f"π (приближение): {pi_approx}")

# Использование quantize для форматирования
print("\nФорматирование чисел:")
price = Decimal('123.456')
print(f"Исходная цена: {price}")
print(f"Округление до центов: {price.quantize(Decimal('0.01'))}")
print(f"Округление до долларов: {price.quantize(Decimal('1.'))}")
```

**Особенности для senior-разработчиков:**
- При создании объектов `Decimal` всегда предпочитайте строковое представление числа `Decimal('0.1')` вместо `Decimal(0.1)`, чтобы избежать неточности, свойственной float.
- Используйте контекстный менеджер `localcontext()` для временного изменения настроек точности или округления, чтобы не затрагивать глобальные настройки.
- Округление `ROUND_HALF_EVEN` (банковское) является стандартным и рекомендуется для финансовых вычислений, поскольку минимизирует накопление ошибок при многократном округлении.
- Метод `quantize()` полезен для форматирования десятичных чисел с определённым количеством знаков после запятой.
- Тип `Decimal` значительно медленнее, чем `float`, поэтому используйте его только там, где необходима точность (например, финансовые расчеты) или контроль над округлением.
- При сериализации объектов `Decimal` (например, в JSON) может потребоваться дополнительная обработка, так как стандартные сериализаторы часто не поддерживают этот тип.
- Модуль `decimal` не поддерживает некоторые математические функции напрямую (например, тригонометрические). Для таких случаев можно использовать библиотеку `mpmath`.
- При работе с очень большими или очень маленькими числами `Decimal` может обеспечить более стабильное поведение, чем `float`, благодаря настраиваемым параметрам обработки исключений.

## fractions

Модуль `fractions` предоставляет поддержку для рациональных чисел.

**Описание:** Обеспечивает точное представление рациональных чисел (дробей) через тип `Fraction`.

**Внутреннее устройство:**
- Представляет дроби как пару целых чисел: числитель и знаменатель.
- Автоматически сокращает дроби, используя НОД.
- Реализует операции над рациональными числами с гарантированной точностью.

**Ключевые компоненты:**
- `fractions.Fraction` - класс для представления рациональных чисел.
- `fractions.gcd(a, b)` - получение наибольшего общего делителя (устаревшее, используйте `math.gcd()`).

**Примеры:**
```python
from fractions import Fraction
import math
import decimal

# Создание дробей различными способами
a = Fraction(1, 3)  # Из числителя и знаменателя
b = Fraction('1/4')  # Из строки
c = Fraction(0.25)   # Из float
d = Fraction(decimal.Decimal('0.1'))  # Из Decimal

print(f"a = {a}")
print(f"b = {b}")
print(f"c = {c}")
print(f"d = {d}")

# Арифметические операции
print(f"\nАрифметические операции:")
print(f"{a} + {b} = {a + b}")  # 1/3 + 1/4 = 7/12
print(f"{a} - {b} = {a - b}")  # 1/3 - 1/4 = 1/12
print(f"{a} * {b} = {a * b}")  # 1/3 * 1/4 = 1/12
print(f"{a} / {b} = {a / b}")  # 1/3 / 1/4 = 4/3

# Автоматическое сокращение
e = Fraction(2, 4)
print(f"Fraction(2, 4) = {e}")  # Автоматически сократится до 1/2

# Преобразование типов
print(f"\nПреобразование типов:")
print(f"float({a}) = {float(a)}")  # 0.3333333333333333
print(f"int({e}) = {int(e)}")      # 0 (только целая часть)

# Проблема представления float
f = Fraction(1.1)  # 1.1 не может быть точно представлено как float
print(f"Fraction(1.1) = {f}")  # 2476979795053773/2251799813685248

# Использование limit_denominator для упрощения
simple_f = f.limit_denominator(100)  # Ограничение знаменателя до 100
print(f"f.limit_denominator(100) = {simple_f}")  # 11/10

# Решение задач с рациональными числами
print(f"\nРешение задач:")

# Нахождение медианты (медианта двух дробей a/b и c/d равна (a+c)/(b+d))
def mediant(frac1, frac2):
    return Fraction(frac1.numerator + frac2.numerator, 
                   frac1.denominator + frac2.denominator)

frac1 = Fraction(1, 2)
frac2 = Fraction(3, 5)
med = mediant(frac1, frac2)
print(f"Медианта {frac1} и {frac2} = {med}")  # 4/7

# Продолжая дробь для аппроксимации иррациональных чисел
def approximate_pi(steps):
    # Аппроксимация π с помощью непрерывной дроби [3; 7, 15, 1, 292, ...]
    result = Fraction(0, 1)
    coeffs = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1]  # Коэффициенты для π
    
    for i in range(min(steps, len(coeffs)) - 1, -1, -1):
        result = Fraction(1, result + coeffs[i]) if i < len(coeffs) - 1 else coeffs[i]
    
    return result if steps == 1 else result + Fraction(coeffs[0])

for i in range(1, 6):
    approx = approximate_pi(i)
    error = abs(float(approx) - math.pi)
    print(f"π ≈ {approx} (шаг {i}, ошибка {error:.10f})")

# Преобразование периодических десятичных дробей в обыкновенные
def periodic_to_fraction(integer_part, non_periodic_part, periodic_part):
    """Преобразует периодическую десятичную дробь в обыкновенную."""
    if not periodic_part:
        # Если нет периодической части
        if not non_periodic_part:
            return Fraction(integer_part, 1)
        return Fraction(integer_part) + Fraction(non_periodic_part, 10**len(non_periodic_part))
    
    # Для периодической части: x = 0.non_periodic(periodic)
    # x = non_periodic/10^len(non_periodic) + periodic/10^len(non_periodic) * (1/(1-1/10^len(periodic)))
    non_periodic_denom = 10**len(non_periodic_part)
    periodic_denom = 10**len(periodic_part) - 1
    periodic_factor = 10**len(non_periodic_part)
    
    numerator = int(non_periodic_part or '0') * periodic_denom + int(periodic_part)
    denominator = non_periodic_denom * periodic_denom
    
    return Fraction(integer_part) + Fraction(numerator, denominator)

print(f"\nПреобразование периодических дробей:")
print(f"0.3(3) = {periodic_to_fraction(0, '', '3')}")  # 1/3
print(f"0.(142857) = {periodic_to_fraction(0, '', '142857')}")  # 1/7
print(f"1.41(6) = {periodic_to_fraction(1, '41', '6')}")  # 1275/900 = 17/12
```

**Особенности для senior-разработчиков:**
- Использование `Fraction` обеспечивает абсолютную точность для рациональных чисел, что важно в алгебраических вычислениях, когда требуется избежать накопления ошибок.
- При создании `Fraction` из `float` обратите внимание, что неточности в представлении `float` могут привести к неожиданным результатам. Предпочтительнее создавать дроби из строк или целых чисел.
- Метод `limit_denominator(max_denominator)` полезен для аппроксимации иррациональных чисел или упрощения сложных дробей.
- Операции с `Fraction` могут приводить к большим числителям и знаменателям, что может замедлить вычисления. В критичных по производительности приложениях рассмотрите использование `float` или NumPy.
- Комбинирование `Fraction` с другими числовыми типами следует правилам преобразования типов Python: `Fraction + int` дает `Fraction`, но `Fraction + float` дает `float`.
- `Fraction` не имеет ограничений на размер числителя и знаменателя, кроме ограничений памяти, так как использует `int` для представления, что позволяет работать с очень большими рациональными числами.
- При сериализации или сохранении `Fraction` рекомендуется конвертировать его в пару `(numerator, denominator)` или в строку.
- Класс `Fraction` может быть полезен в образовательных приложениях, где важно показать точное представление дробей без округления.

## random

Модуль `random` предоставляет функции для генерации псевдослучайных чисел.

**Описание:** Реализует генераторы псевдослучайных чисел для различных распределений и случайных выборок.

**Внутреннее устройство:**
- Основан на алгоритме Mersenne Twister, который является высококачественным генератором псевдослучайных чисел.
- Использует системные источники энтропии для инициализации (по умолчанию текущее время).
- Псевдослучайная последовательность детерминирована для заданного начального значения (seed).

**Ключевые функции:**
- **Базовые генераторы:**
  - `random.random()` - случайное число в диапазоне [0.0, 1.0).
  - `random.uniform(a, b)` - случайное число в диапазоне [a, b] или [b, a].
  - `random.randint(a, b)` - случайное целое число в диапазоне [a, b].
  - `random.randrange(start, stop[, step])` - случайный элемент из range(start, stop, step).
  - `random.getrandbits(k)` - случайное целое число с k случайными битами.

- **Функции для последовательностей:**
  - `random.choice(seq)` - случайный элемент из непустой последовательности.
  - `random.choices(population, weights=None, *, cum_weights=None, k=1)` - k случайных элементов с повторениями и весами.
  - `random.sample(population, k)` - k уникальных случайных элементов.
  - `random.shuffle(x)` - перемешивает последовательность на месте.

- **Функции для распределений:**
  - `random.gauss(mu, sigma)` - нормальное распределение.
  - `random.normalvariate(mu, sigma)` - нормальное распределение (другая реализация).
  - `random.lognormvariate(mu, sigma)` - логнормальное распределение.
  - `random.expovariate(lambd)` - экспоненциальное распределение.
  - `random.gammavariate(alpha, beta)` - гамма-распределение.
  - `random.betavariate(alpha, beta)` - бета-распределение.
  - `random.paretovariate(alpha)` - распределение Парето.
  - `random.weibullvariate(alpha, beta)` - распределение Вейбулла.

- **Управление генератором:**
  - `random.seed(a=None)` - инициализация генератора.
  - `random.getstate()` - возвращает текущее внутреннее состояние генератора.
  - `random.setstate(state)` - восстанавливает внутреннее состояние генератора.

**Примеры:**
```python
import random
import statistics
import matplotlib.pyplot as plt

# Установка начального значения для воспроизводимости
random.seed(42)

# Базовые генераторы
print("Базовые генераторы случайных чисел:")
print(f"random.random(): {random.random()}")  # Число от 0.0 до 1.0
print(f"random.uniform(1, 10): {random.uniform(1, 10)}")  # Число от 1.0 до 10.0
print(f"random.randint(1, 10): {random.randint(1, 10)}")  # Целое число от 1 до 10
print(f"random.randrange(1, 10, 2): {random.randrange(1, 10, 2)}")  # Нечетное число от 1 до 9
print(f"random.getrandbits(8): {random.getrandbits(8)}")  # Случайное 8-битное число

# Работа с последовательностями
print("\nРабота с последовательностями:")
my_list = ['яблоко', 'банан', 'апельсин', 'груша', 'киви']
print(f"random.choice(my_list): {random.choice(my_list)}")  # Случайный элемент

# Выборка с повторениями и весами
fruits_weights = [10, 5, 3, 2, 1]  # Веса для выбора (яблоки в 10 раз чаще киви)
sample_with_weights = random.choices(my_list, weights=fruits_weights, k=5)
print(f"random.choices() с весами: {sample_with_weights}")

# Выборка без повторений
sample_unique = random.sample(my_list, k=3)
print(f"random.sample(my_list, 3): {sample_unique}")

# Перемешивание списка
shuffled_list = my_list.copy()
random.shuffle(shuffled_list)
print(f"Перемешанный список: {shuffled_list}")

# Генерация случайных данных с различными распределениями
print("\nГенерация с различными распределениями:")

# Нормальное распределение
normal_values = [random.normalvariate(0, 1) for _ in range(1000)]
print(f"Нормальное распределение (µ=0, σ=1): "
      f"ср. = {statistics.mean(normal_values):.4f}, "
      f"станд.откл. = {statistics.stdev(normal_values):.4f}")

# Экспоненциальное распределение
exp_values = [random.expovariate(1) for _ in range(1000)]
print(f"Экспоненциальное распределение (λ=1): "
      f"ср. = {statistics.mean(exp_values):.4f}, "
      f"станд.откл. = {statistics.stdev(exp_values):.4f}")

# Равномерное распределение
uniform_values = [random.uniform(0, 1) for _ in range(1000)]
print(f"Равномерное распределение [0, 1]: "
      f"ср. = {statistics.mean(uniform_values):.4f}, "
      f"станд.откл. = {statistics.stdev(uniform_values):.4f}")

# Сохранение и восстановление состояния генератора
print("\nСохранение и восстановление состояния генератора:")
state = random.getstate()  # Сохраняем текущее состояние
print(f"Следующие случайные числа: {random.random()}, {random.random()}")

random.setstate(state)  # Восстанавливаем состояние
print(f"После восстановления состояния: {random.random()}, {random.random()}")

# Практический пример: моделирование бросков монеты
print("\nМоделирование бросков монеты:")
def simulate_coin_flips(n):
    """Симулирует n бросков монеты и возвращает количество выпавших орлов."""
    return sum(random.choice([0, 1]) for _ in range(n))

# Моделируем 10 экспериментов с 100 бросками монеты
experiments = [simulate_coin_flips(100) for _ in range(10)]
print(f"Результаты 10 экспериментов со 100 бросками: {experiments}")
print(f"Среднее число орлов: {statistics.mean(experiments)}")

# Пример: генерация случайных паролей
def generate_password(length=12, use_punct=True, use_digits=True, use_upper=True):
    """Генерирует случайный пароль указанной длины."""
    import string
    characters = string.ascii_lowercase
    if use_upper:
        characters += string.ascii_uppercase
    if use_digits:
        characters += string.digits
    if use_punct:
        characters += string.punctuation
    
    return ''.join(random.choice(characters) for _ in range(length))

print("\nГенерация случайных паролей:")
print(f"Пароль (12 символов): {generate_password(12)}")
print(f"Пароль (без спецсимволов): {generate_password(12, use_punct=False)}")
print(f"PIN-код: {generate_password(6, use_punct=False, use_upper=False)}")
```

**Особенности для senior-разработчиков:**
- Модуль `random` использует генератор Mersenne Twister, который является криптографически небезопасным. Для криптографических приложений используйте модуль `secrets`.
- Для воспроизводимых результатов всегда устанавливайте начальное значение через `random.seed()`, особенно в научных исследованиях и тестах.
- При параллельных вычислениях каждый поток должен иметь свой экземпляр генератора, иначе возникнут состояния гонки. Используйте `random.Random()` для создания независимых генераторов.
- Функция `random.choices()` (с Python 3.6+) эффективнее для взвешенных выборок с повторениями, чем ручная реализация через `random.random()`.
- Для эффективного перемешивания очень больших последовательностей можно использовать частичное перемешивание с `random.sample()`.
- Функции `random.gauss()` и `random.normalvariate()` реализуют одно и то же распределение, но `gauss()` немного быстрее.
- При необходимости высокопроизводительных или специализированных генераторов случайных чисел, рассмотрите NumPy (`numpy.random`), который предоставляет более быстрые и разнообразные генераторы.
- Состояние генератора, полученное через `getstate()`, может быть очень большим. При сериализации рассмотрите более компактные альтернативы, например, сохранение только начального значения и количества выполненных итераций.

## statistics

Модуль `statistics` предоставляет функции для статистических расчетов.

**Описание:** Содержит функции для вычисления базовых статистических показателей на основе данных.

**Внутреннее устройство:**
- Реализует алгоритмы для точного вычисления статистических параметров.
- Использует оптимизированные методы для повышения численной стабильности.
- Работает как с числовыми типами данных, так и со специализированными типами вроде `Decimal`.

**Ключевые функции:**
- **Средние значения:**
  - `statistics.mean(data)` - среднее арифметическое.
  - `statistics.harmonic_mean(data)` - среднее гармоническое.
  - `statistics.geometric_mean(data)` - среднее геометрическое (Python 3.8+).
  - `statistics.median(data)` - медиана.
  - `statistics.median_low(data)` - низкая медиана.
  - `statistics.median_high(data)` - высокая медиана.
  - `statistics.median_grouped(data, interval=1)` - сгруппированная медиана.
  - `statistics.mode(data)` - мода (наиболее часто встречающееся значение).
  - `statistics.multimode(data)` - список всех мод (Python 3.8+).
  - `statistics.quantiles(data, *, n=4, method='exclusive')` - квантили (Python 3.8+).

- **Меры разброса:**
  - `statistics.pvariance(data, mu=None)` - дисперсия генеральной совокупности.
  - `statistics.variance(data, xbar=None)` - дисперсия выборки.
  - `statistics.pstdev(data, mu=None)` - стандартное отклонение генеральной совокупности.
  - `statistics.stdev(data, xbar=None)` - стандартное отклонение выборки.

- **Дополнительные функции:**
  - `statistics.covariance(x, y)` - ковариация (Python 3.10+).
  - `statistics.correlation(x, y)` - коэффициент корреляции Пирсона (Python 3.10+).
  - `statistics.linear_regression(x, y)` - линейная регрессия, возвращает (slope, intercept) (Python 3.10+).
  - `statistics.NormalDist` - класс для работы с нормальным распределением (Python 3.8+).

**Примеры:**
```python
import statistics
import math
from decimal import Decimal
import random

# Создаем набор данных
data = [2, 4, 4, 4, 5, 5, 7, 9]
large_data = [random.gauss(100, 15) for _ in range(1000)]  # Большой набор с нормальным распределением

# Меры центральной тенденции
print("Меры центральной тенденции:")
print(f"Среднее арифметическое: {statistics.mean(data)}")
print(f"Медиана: {statistics.median(data)}")
print(f"Мода: {statistics.mode(data)}")
try:
    print(f"Все моды: {statistics.multimode(data)}")  # Python 3.8+
except AttributeError:
    print("statistics.multimode() доступна только в Python 3.8+")

print(f"Низкая медиана: {statistics.median_low(data)}")
print(f"Высокая медиана: {statistics.median_high(data)}")
print(f"Среднее гармоническое: {statistics.harmonic_mean(data)}")

try:
    print(f"Среднее геометрическое: {statistics.geometric_mean(data)}")  # Python 3.8+
except AttributeError:
    # Собственная реализация для более старых версий Python
    geom_mean = math.exp(sum(math.log(x) for x in data) / len(data))
    print(f"Среднее геометрическое: {geom_mean}")

# Меры разброса
print("\nМеры разброса:")
print(f"Дисперсия выборки: {statistics.variance(data)}")
print(f"Стандартное отклонение выборки: {statistics.stdev(data)}")
print(f"Дисперсия генеральной совокупности: {statistics.pvariance(data)}")
print(f"Стандартное отклонение генеральной совокупности: {statistics.pstdev(data)}")

# Квантили
try:
    quartiles = statistics.quantiles(data, n=4)
    print(f"\nКвартили: {quartiles}")  # Python 3.8+
    
    deciles = statistics.quantiles(data, n=10)
    print(f"Децили: {deciles}")
except AttributeError:
    print("\nstatistics.quantiles() доступна только в Python 3.8+")

# Работа с типом Decimal для высокой точности
decimal_data = [Decimal(x) for x in data]
print(f"\nСреднее с Decimal: {statistics.mean(decimal_data)}")

# Корреляция и регрессия (Python 3.10+)
try:
    x = [1, 2, 3, 4, 5]
    y = [2, 4, 5, 6, 8]
    
    print("\nАнализ корреляции и регрессии:")
    print(f"Ковариация: {statistics.covariance(x, y)}")
    print(f"Корреляция Пирсона: {statistics.correlation(x, y)}")
    
    slope, intercept = statistics.linear_regression(x, y)
    print(f"Линейная регрессия: y = {slope}x + {intercept}")
    
    # Предсказание значения
    x_pred = 6
    y_pred = slope * x_pred + intercept
    print(f"Предсказание для x = {x_pred}: {y_pred}")
except (AttributeError, NameError):
    print("\nФункции ковариации и регрессии доступны только в Python 3.10+")

# Работа с нормальным распределением (Python 3.8+)
try:
    # Создание нормального распределения из данных
    normal_dist = statistics.NormalDist.from_samples(large_data)
    
    print("\nНормальное распределение:")
    print(f"Среднее: {normal_dist.mean}")
    print(f"Стандартное отклонение: {normal_dist.stdev}")
    
    # Вероятностные расчеты
    x = 120
    print(f"CDF для x = {x}: {normal_dist.cdf(x)}")  # Вероятность X ≤ x
    print(f"Обратный CDF для p = 0.95: {normal_dist.inv_cdf(0.95)}")  # x, для которого P(X ≤ x) = 0.95
    
    # Доверительный интервал
    confidence = 0.95
    interval = normal_dist.interval(confidence)
    print(f"{confidence*100}% доверительный интервал: {interval}")
    
    # Операции с распределениями
    other_dist = statistics.NormalDist(105, 10)
    sum_dist = normal_dist + other_dist
    print(f"Сумма распределений: Mean = {sum_dist.mean}, StdDev = {sum_dist.stdev}")
    
    scaled_dist = normal_dist * 2
    print(f"Масштабированное распределение: Mean = {scaled_dist.mean}, StdDev = {scaled_dist.stdev}")
except (AttributeError, NameError):
    print("\nКласс NormalDist доступен только в Python 3.8+")

# Пример: анализ набора данных
def analyze_dataset(data):
    """Выполняет базовый статистический анализ набора данных."""
    if not data:
        return "Пустой набор данных"
    
    results = {
        "Количество": len(data),
        "Минимум": min(data),
        "Максимум": max(data),
        "Размах": max(data) - min(data),
        "Среднее": statistics.mean(data),
        "Медиана": statistics.median(data),
        "Стандартное отклонение": statistics.stdev(data) if len(data) > 1 else 0,
        "Коэффициент вариации": statistics.stdev(data) / statistics.mean(data) if len(data) > 1 else 0
    }
    
    try:  # Python 3.8+
        results["Мода"] = statistics.multimode(data)
        quartiles = statistics.quantiles(data, n=4)
        results["Q1"] = quartiles[0]
        results["Q3"] = quartiles[2]
        results["IQR"] = quartiles[2] - quartiles[0]  # Межквартильный размах
    except AttributeError:
        results["Мода"] = statistics.mode(data) if len(set(data)) < len(data) else "Нет моды"
    
    return results

# Применяем анализ к нашим данным
scores = [85, 92, 78, 90, 87, 86, 91, 88, 95, 82]
analysis = analyze_dataset(scores)
print("\nАнализ оценок студентов:")
for key, value in analysis.items():
    print(f"{key}: {value}")
```

**Особенности для senior-разработчиков:**
- Модуль `statistics` сохраняет тип данных в результатах. Если вход - целые числа, и результат тоже целое число, оно будет возвращено как `int`, а не как `float`.
- При работе с `Decimal` модуль сохраняет высокую точность, что важно для финансовых расчетов.
- Функции для вычисления выборочных статистик (variance, stdev) используют знаменатель n-1 для несмещенности, а функции для популяционных статистик (pvariance, pstdev) используют n.
- В Python 3.8+ появились важные добавления: класс `NormalDist`, функции `geometric_mean()`, `multimode()` и `quantiles()`.
- В Python 3.10+ добавлены функции для ковариации, корреляции и линейной регрессии, что значительно расширяет возможности модуля.
- В отличие от `numpy` или `scipy`, модуль `statistics` имеет более ограниченный функционал, но является частью стандартной библиотеки и не требует установки дополнительных пакетов.
- Для больших наборов данных функции модуля `statistics` могут быть медленнее, чем эквивалентные функции в `numpy`. Рассмотрите использование специализированных библиотек для интенсивных вычислений.
- Класс `NormalDist` в Python 3.8+ поддерживает операции сложения, вычитания, умножения и деления, что позволяет моделировать суммы независимых нормально распределенных случайных величин.

## itertools

Модуль `itertools` предоставляет функции для эффективной работы с итераторами.

**Описание:** Содержит функции, создающие итераторы для эффективного прохода по данным.

**Внутреннее устройство:**
- Реализован на C для высокой производительности.
- Создает итераторы, которые генерируют элементы "лениво" (по требованию).
- Минимизирует использование памяти благодаря итеративному подходу.

**Ключевые функции:**
- **Бесконечные итераторы:**
  - `itertools.count(start=0, step=1)` - бесконечная последовательность чисел.
  - `itertools.cycle(iterable)` - бесконечно повторяет элементы итерируемого объекта.
  - `itertools.repeat(object[, times])` - повторяет объект указанное количество раз или бесконечно.

- **Итераторы, завершающиеся по кратчайшему входу:**
  - `itertools.accumulate(iterable[, func, *, initial=None])` - накопительные суммы (или другая функция).
  - `itertools.chain(*iterables)` - объединяет итерируемые объекты в один итератор.
  - `itertools.chain.from_iterable(iterable)` - объединяет вложенные итерируемые объекты.
  - `itertools.compress(data, selectors)` - фильтрует элементы по селекторам.
  - `itertools.dropwhile(predicate, iterable)` - отбрасывает элементы, пока предикат истинен.
  - `itertools.filterfalse(predicate, iterable)` - противоположность filter().
  - `itertools.groupby(iterable, key=None)` - группирует элементы по ключу.
  - `itertools.islice(iterable, stop)` или `islice(iterable, start, stop[, step])` - срез итератора.
  - `itertools.starmap(function, iterable)` - применяет функцию к распакованным кортежам.
  - `itertools.takewhile(predicate, iterable)` - берет элементы, пока предикат истинен.
  - `itertools.tee(iterable, n=2)` - создает n независимых итераторов.
  - `itertools.zip_longest(*iterables, fillvalue=None)` - аналог zip, но заполняет короткие итераторы.

- **Комбинаторные итераторы:**
  - `itertools.product(*iterables, repeat=1)` - декартово произведение.
  - `itertools.permutations(iterable, r=None)` - перестановки указанной длины.
  - `itertools.combinations(iterable, r)` - сочетания без повторений.
  - `itertools.combinations_with_replacement(iterable, r)` - сочетания с повторениями.

**Примеры:**
```python
import itertools
import operator
from collections import Counter

# Бесконечные итераторы
print("Бесконечные итераторы:")

# count() - бесконечная последовательность чисел
counter = itertools.count(10, 2)  # Начиная с 10, с шагом 2
print(f"itertools.count(10, 2): {[next(counter) for _ in range(5)]}")

# cycle() - бесконечный цикл по итерируемому объекту
cycler = itertools.cycle('ABC')
print(f"itertools.cycle('ABC'): {[next(cycler) for _ in range(7)]}")

# repeat() - повторение объекта
repeater = itertools.repeat(5, 3)  # Повторить 5 три раза
print(f"itertools.repeat(5, 3): {list(repeater)}")

# Итераторы, завершающиеся по кратчайшему входу
print("\nИтераторы, завершающиеся по кратчайшему входу:")

# accumulate() - накопительные значения
data = [1, 2, 3, 4, 5]
print(f"accumulate([1, 2, 3, 4, 5]): {list(itertools.accumulate(data))}")  # [1, 3, 6, 10, 15]
print(f"accumulate с умножением: {list(itertools.accumulate(data, operator.mul))}")  # [1, 2, 6, 24, 120]

try:
    # initial параметр добавлен в Python 3.8
    print(f"accumulate с начальным значением: {list(itertools.accumulate(data, initial=100))}")
except TypeError:
    print("Параметр initial доступен только в Python 3.8+")

# chain() - объединение итераторов
print(f"chain('ABC', 'DEF'): {list(itertools.chain('ABC', 'DEF'))}")  # ['A', 'B', 'C', 'D', 'E', 'F']

# chain.from_iterable() - объединение вложенных итераторов
print(f"chain.from_iterable(['ABC', 'DEF']): {list(itertools.chain.from_iterable(['ABC', 'DEF']))}")

# compress() - фильтрация по селекторам
print(f"compress('ABCDEF', [1,0,1,0,1,1]): {list(itertools.compress('ABCDEF', [1,0,1,0,1,1]))}")

# dropwhile() и takewhile() - фильтрация по предикату
print(f"dropwhile(lambda x: x<5, [1,3,6,2,1]): {list(itertools.dropwhile(lambda x: x<5, [1,3,6,2,1]))}")
print(f"takewhile(lambda x: x<5, [1,3,6,2,1]): {list(itertools.takewhile(lambda x: x<5, [1,3,6,2,1]))}")

# filterfalse() - противоположность filter()
print(f"filterfalse(lambda x: x%2==0, range(10)): {list(itertools.filterfalse(lambda x: x%2==0, range(10)))}")

# groupby() - группировка последовательных элементов
animals = ['duck', 'eagle', 'rat', 'giraffe', 'bear', 'bat', 'dolphin', 'shark', 'lion']
sorted_animals = sorted(animals, key=lambda x: x[0])  # Сортировка по первой букве для группировки
print("\nGroupby для животных, отсортированных по первой букве:")
for key, group in itertools.groupby(sorted_animals, key=lambda x: x[0]):
    print(f"{key}: {list(group)}")

# islice() - срез итератора
print(f"islice('ABCDEFG', 2, 6): {list(itertools.islice('ABCDEFG', 2, 6))}")  # ['C', 'D', 'E', 'F']

# starmap() - применяет функцию к распакованным кортежам
print(f"starmap(pow, [(2,3), (4,2)]): {list(itertools.starmap(pow, [(2,3), (4,2)]))}")  # [8, 16]

# zip_longest() - zip с заполнением коротких итераторов
print(f"zip_longest('ABC', '12', fillvalue='?'): {list(itertools.zip_longest('ABC', '12', fillvalue='?'))}")

# tee() - создает n независимых копий итератора
iter1, iter2 = itertools.tee([1, 2, 3], 2)
next(iter1)  # Продвигаем первый итератор на один шаг
print(f"tee после продвижения iter1: {list(iter1)}, {list(iter2)}")

# Комбинаторные итераторы
print("\nКомбинаторные итераторы:")

# product() - декартово произведение
print(f"product('AB', '12'): {list(itertools.product('AB', '12'))}")
print(f"product('AB', repeat=2): {list(itertools.product('AB', repeat=2))}")  # Эквивалент product('AB', 'AB')

# permutations() - перестановки
print(f"permutations('ABC', 2): {list(itertools.permutations('ABC', 2))}")

# combinations() - сочетания без повторений
print(f"combinations('ABC', 2): {list(itertools.combinations('ABC', 2))}")

# combinations_with_replacement() - сочетания с повторениями
print(f"combinations_with_replacement('ABC', 2): {list(itertools.combinations_with_replacement('ABC', 2))}")

# Практические примеры использования itertools
print("\nПрактические примеры:")

# 1. Скользящее окно (sliding window)
def sliding_window(iterable, n):
    """Создает скользящее окно размера n по итерируемому объекту."""
    iterables = itertools.tee(iterable, n)
    for i, it in enumerate(iterables):
        for _ in range(i):
            next(it, None)
    return zip(*iterables)

text = "ABCDEFG"
print(f"Скользящее окно размера 3 для '{text}': {list(sliding_window(text, 3))}")

# 2. Нахождение пар с заданной суммой
def find_pairs_with_sum(numbers, target_sum):
    """Находит все пары чисел с заданной суммой."""
    num_set = set(numbers)
    return [(x, target_sum - x) for x in num_set if target_sum - x in num_set and x <= target_sum - x]

numbers = [1, 4, 6, 8, 10, 15, 22]
target = 16
print(f"Пары с суммой {target} в {numbers}: {find_pairs_with_sum(numbers, target)}")

# 3. Подсчет частот n-грамм
def ngrams(sequence, n):
    """Создает n-граммы из последовательности."""
    return zip(*[itertools.islice(sequence, i, None) for i in range(n)])

text = "banana"
bigrams = list(ngrams(text, 2))
counts = Counter(bigrams)
print(f"Биграммы в '{text}': {dict(counts)}")

# 4. Разбиение последовательности на чанки
def chunked(iterable, n):
    """Разбивает итерируемый объект на чанки размера n."""
    # Аналог grouper из рецептов itertools
    args = [iter(iterable)] * n
    return zip(*args)

data = list(range(10))
print(f"Разбиение {data} на чанки по 3: {[chunk for chunk in chunked(data, 3)]}")
```

**Особенности для senior-разработчиков:**
- Многие функции `itertools` реализованы на C и значительно быстрее, чем их эквиваленты на Python.
- При работе с большими данными использование итераторов может существенно снизить потребление памяти, поскольку элементы генерируются "по требованию".
- Функции `tee()` кэшируют элементы, поэтому если одна копия итератора продвигается значительно дальше других, это может привести к чрезмерному использованию памяти.
- Для бесконечных итераторов (`count()`, `cycle()`, `repeat()`) важно ограничивать их потребление, например, с помощью `islice()`, иначе программа может зависнуть.
- `groupby()` работает только с последовательными одинаковыми элементами. Для группировки по произвольному признаку необходимо предварительно отсортировать данные.
- Для создания кастомных комбинаторных итераторов часто эффективнее использовать комбинацию существующих функций `itertools`, чем писать свои.
- При работе с цепочками функций `itertools` помните, что результаты промежуточных операций не сохраняются, если их не преобразовать в список или другую структуру данных.
- Для сложных преобразований данных рассмотрите использование `itertools` в сочетании с `operator` для замены лямбда-функций, что может улучшить производительность.

## functools

Модуль `functools` предоставляет инструменты для функционального программирования.

**Описание:** Содержит функции высшего порядка и декораторы для работы с функциями и вызываемыми объектами.

**Внутреннее устройство:**
- Реализует паттерны функционального программирования.
- Предоставляет средства для оптимизации вызовов функций.
- Включает инструменты для манипулирования функциями и их аргументами.

**Ключевые функции и декораторы:**
- `functools.partial(func, *args, **kwargs)` - создает новую функцию с частично зафиксированными аргументами.
- `functools.partialmethod(func, *args, **kwargs)` - аналог partial для методов.
- `@functools.lru_cache(maxsize=128, typed=False)` - кэширует результаты функции.
- `@functools.cache` - неограниченный кэш функции (Python 3.9+).
- `@functools.wraps(wrapped)` - сохраняет метаданные при создании декораторов.
- `@functools.total_ordering` - генерирует методы сравнения на основе одного метода.
- `functools.reduce(function, iterable[, initializer])` - применяет функцию к элементам итерируемого объекта.
- `@functools.singledispatch` - функции с диспетчеризацией на основе типа первого аргумента.
- `@functools.singledispatchmethod` - методы с диспетчеризацией (Python 3.8+).
- `functools.cmp_to_key(func)` - преобразует функцию сравнения в ключевую функцию.
- `@functools.cached_property` - кэшируемое свойство (Python 3.8+).

**Примеры:**
```python
import functools
import time
import operator
from datetime import datetime

# partial - частичное применение функции
print("Примеры partial:")
base2 = functools.partial(int, base=2)
base16 = functools.partial(int, base=16)

print(f"base2('1010'): {base2('1010')}")  # 10
print(f"base16('1A'): {base16('1A')}")    # 26

# Использование partial для предустановки параметров
power_of_2 = functools.partial(pow, 2)
print(f"2^10: {power_of_2(10)}")  # 1024

# reduce - свертка списка
print("\nПримеры reduce:")
numbers = [1, 2, 3, 4, 5]
sum_result = functools.reduce(operator.add, numbers)
product_result = functools.reduce(operator.mul, numbers)
print(f"Sum of {numbers}: {sum_result}")  # 15
print(f"Product of {numbers}: {product_result}")  # 120

# reduce с инициализатором
max_with_default = functools.reduce(max, [], default=0)
print(f"Max of empty list with default: {max_with_default}")  # 0

# lru_cache - кэширование для оптимизации
print("\nПримеры lru_cache:")

@functools.lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

start = time.time()
print(f"fibonacci(35): {fibonacci(35)}")
print(f"Время выполнения: {time.time() - start:.6f} секунд")
print(f"Info: {fibonacci.cache_info()}")

# wraps - сохранение метаданных функции при декорировании
print("\nПримеры wraps:")

def my_decorator(func):
    @functools.wraps(func)  # Сохраняет __name__, __doc__, и т.д.
    def wrapper(*args, **kwargs):
        print(f"Before calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"After calling {func.__name__}")
        return result
    return wrapper

@my_decorator
def greet(name):
    """Функция для приветствия пользователя."""
    return f"Hello, {name}!"

print(greet("World"))
print(f"Function name: {greet.__name__}")  # 'greet', а не 'wrapper'
print(f"Function docstring: {greet.__doc__}")  # Docstring сохранен

# total_ordering - генерация методов сравнения
print("\nПримеры total_ordering:")

@functools.total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __eq__(self, other):
        if not isinstance(other, Person):
            return NotImplemented
        return self.age == other.age
    
    def __lt__(self, other):
        if not isinstance(other, Person):
            return NotImplemented
        return self.age < other.age

alice = Person("Alice", 30)
bob = Person("Bob", 25)
charlie = Person("Charlie", 30)

print(f"alice == bob: {alice == bob}")
print(f"alice > bob: {alice > bob}")
print(f"alice == charlie: {alice == charlie}")
print(f"alice <= charlie: {alice <= charlie}")

# singledispatch - диспетчеризация на основе типа
print("\nПримеры singledispatch:")

@functools.singledispatch
def process(arg):
    print(f"Default implementation for {type(arg).__name__}: {arg}")

@process.register
def _(arg: int):
    print(f"Implementation for int: {arg * 2}")

@process.register
def _(arg: list):
    print(f"Implementation for list: {sum(arg)}")

@process.register(str)  # Альтернативный синтаксис
def _(arg):
    print(f"Implementation for str: {arg.upper()}")

process(10)       # Implementation for int: 20
process([1, 2, 3])  # Implementation for list: 6
process("hello")  # Implementation for str: HELLO
process(1.5)      # Default implementation for float: 1.5

# cmp_to_key - преобразование функции сравнения в ключевую функцию
print("\nПримеры cmp_to_key:")

def compare_version(a, b):
    """Сравнивает версии в формате 'x.y.z'."""
    a_parts = list(map(int, a.split('.')))
    b_parts = list(map(int, b.split('.')))
    
    for a_part, b_part in zip(a_parts, b_parts):
        if a_part < b_part:
            return -1
        if a_part > b_part:
            return 1
    
    # Если все равны, проверяем длину
    return len(a_parts) - len(b_parts)

versions = ['1.10.0', '1.3.2', '1.3', '2.0.1', '1.3.3']
sorted_versions = sorted(versions, key=functools.cmp_to_key(compare_version))
print(f"Отсортированные версии: {sorted_versions}")

# cached_property - кэшированное свойство (Python 3.8+)
try:
    class WebData:
        def __init__(self, url):
            self.url = url
            self._fetch_count = 0
            
        @functools.cached_property
        def content(self):
            self._fetch_count += 1
            print(f"Fetching data from {self.url} (call {self._fetch_count})")
            # В реальном коде здесь был бы запрос к серверу
            return f"Content from {self.url}"
    
    print("\nПримеры cached_property:")
    data = WebData("https://example.com")
    print(f"First access: {data.content}")
    print(f"Second access: {data.content}")  # Не будет повторно запрашивать
    
except AttributeError:
    print("\nfunctools.cached_property доступен только в Python 3.8+")

# cache - неограниченный кэш (Python 3.9+)
try:
    @functools.cache
    def factorial(n):
        return n * factorial(n-1) if n else 1
    
    print("\nПримеры cache:")
    print(f"factorial(10): {factorial(10)}")
    print(f"factorial(15): {factorial(15)}")
    print(f"Info: {factorial.cache_info()}")
    
except AttributeError:
    print("\nfunctools.cache доступен только в Python 3.9+")
```

**Особенности для senior-разработчиков:**
- `@lru_cache` эффективен для рекурсивных функций и функций с дорогостоящими вычислениями, но может привести к утечкам памяти, если кэшируются объекты, содержащие ссылки на большие структуры данных.
- Параметр `typed=True` в `@lru_cache` заставляет функцию различать аргументы разных типов (например, 1 и 1.0), что может быть важно для строгой типизации.
- При использовании `@lru_cache` помните, что аргументы функции должны быть хэшируемыми. Для кэширования функций с нехэшируемыми аргументами потребуется написание собственного декоратора или преобразование аргументов.
- `@functools.wraps` особенно важен для сохранения метаданных декорированных функций, что влияет на документацию, интроспекцию и возможности отладки.
- `functools.partial` позволяет реализовать карринг (currying) - технику функционального программирования для преобразования функций с несколькими аргументами в цепочку функций с одним аргументом.
- `@functools.singledispatch` предоставляет элегантную альтернативу условным операторам для выбора реализации на основе типа, что делает код более поддерживаемым и расширяемым.
- `@functools.total_ordering` генерирует методы сравнения (`__le__`, `__gt__`, `__ge__`), но требует, чтобы вы реализовали хотя бы `__eq__` и один из методов сравнения (обычно `__lt__`).
- `@functools.cached_property` (Python 3.8+) объединяет преимущества `@property` и кэширования, что особенно полезно для свойств с дорогостоящими вычислениями или запросами к внешним ресурсам.

## operator

Модуль `operator` предоставляет эффективные функции, соответствующие операторам Python.

**Описание:** Содержит функции, которые реализуют стандартные операторы Python (сложение, умножение, доступ к элементам и т.д.).

**Внутреннее устройство:**
- Предоставляет функции, которые работают так же, как встроенные операторы.
- Оптимизирован для использования с функциями высшего порядка, такими как `map()` и `filter()`.
- Реализует эффективные операции доступа к атрибутам и элементам последовательностей.

**Ключевые функции:**
- **Арифметические операции:**
  - `operator.add(a, b)` - сложение (a + b).
  - `operator.sub(a, b)` - вычитание (a - b).
  - `operator.mul(a, b)` - умножение (a * b).
  - `operator.truediv(a, b)` - деление (a / b).
  - `operator.floordiv(a, b)` - целочисленное деление (a // b).
  - `operator.mod(a, b)` - остаток от деления (a % b).
  - `operator.pow(a, b)` - возведение в степень (a ** b).
  - `operator.neg(a)` - отрицание (-a).
  - `operator.pos(a)` - унарный плюс (+a).
  - `operator.abs(a)` - абсолютное значение (abs(a)).

- **Логические операции:**
  - `operator.truth(a)` - проверка истинности (bool(a)).
  - `operator.not_(a)` - логическое отрицание (not a).
  - `operator.and_(a, b)` - логическое И (a and b).
  - `operator.or_(a, b)` - логическое ИЛИ (a or b).

- **Побитовые операции:**
  - `operator.invert(a)` - побитовое НЕ (~a).
  - `operator.lshift(a, b)` - сдвиг влево (a << b).
  - `operator.rshift(a, b)` - сдвиг вправо (a >> b).
  - `operator.and_(a, b)` - побитовое И (a & b).
  - `operator.or_(a, b)` - побитовое ИЛИ (a | b).
  - `operator.xor(a, b)` - побитовое исключающее ИЛИ (a ^ b).

- **Операции сравнения:**
  - `operator.lt(a, b)` - меньше (a < b).
  - `operator.le(a, b)` - меньше или равно (a <= b).
  - `operator.eq(a, b)` - равно (a == b).
  - `operator.ne(a, b)` - не равно (a != b).
  - `operator.ge(a, b)` - больше или равно (a >= b).
  - `operator.gt(a, b)` - больше (a > b).

- **Операции с последовательностями:**
  - `operator.getitem(a, b)` - получение элемента (a[b]).
  - `operator.setitem(a, b, c)` - установка элемента (a[b] = c).
  - `operator.delitem(a, b)` - удаление элемента (del a[b]).
  - `operator.concat(a, b)` - конкатенация (a + b).
  - `operator.contains(a, b)` - проверка включения (b in a).

- **Операции с атрибутами:**
  - `operator.attrgetter(attr)` - получение атрибута (a.attr).
  - `operator.setattr(a, b, c)` - установка атрибута (a.b = c).
  - `operator.delattr(a, b)` - удаление атрибута (del a.b).

- **Функции-генераторы:**
  - `operator.itemgetter(*items)` - создает функцию, получающую указанные элементы.
  - `operator.attrgetter(*attrs)` - создает функцию, получающую указанные атрибуты.
  - `operator.methodcaller(name, *args, **kwargs)` - создает функцию, вызывающую указанный метод.

**Примеры:**
```python
import operator
import functools
from collections import namedtuple

# Арифметические операции
print("Арифметические операторы:")
print(f"add(5, 3): {operator.add(5, 3)}")  # 8
print(f"sub(5, 3): {operator.sub(5, 3)}")  # 2
print(f"mul(5, 3): {operator.mul(5, 3)}")  # 15
print(f"truediv(5, 3): {operator.truediv(5, 3)}")  # 1.6666...
print(f"floordiv(5, 3): {operator.floordiv(5, 3)}")  # 1
print(f"mod(5, 3): {operator.mod(5, 3)}")  # 2
print(f"pow(5, 3): {operator.pow(5, 3)}")  # 125
print(f"neg(5): {operator.neg(5)}")  # -5

# Сравнения
print("\nОператоры сравнения:")
print(f"lt(5, 3): {operator.lt(5, 3)}")  # False
print(f"le(5, 5): {operator.le(5, 5)}")  # True
print(f"eq(5, 3): {operator.eq(5, 3)}")  # False
print(f"ne(5, 3): {operator.ne(5, 3)}")  # True
print(f"ge(5, 3): {operator.ge(5, 3)}")  # True
print(f"gt(5, 3): {operator.gt(5, 3)}")  # True

# Логические операторы
print("\nЛогические операторы:")
print(f"truth(0): {operator.truth(0)}")  # False
print(f"truth(1): {operator.truth(1)}")  # True
print(f"not_(True): {operator.not_(True)}")  # False
print(f"and_(True, False): {operator.and_(True, False)}")  # False
print(f"or_(True, False): {operator.or_(True, False)}")  # True

# Операции с последовательностями
print("\nОперации с последовательностями:")
a = [1, 2, 3]
print(f"getitem(a, 1): {operator.getitem(a, 1)}")  # 2

b = [4, 5, 6]
operator.setitem(a, 1, 10)
print(f"После setitem(a, 1, 10): {a}")  # [1, 10, 3]

print(f"concat(a, b): {operator.concat(a, b)}")  # [1, 10, 3, 4, 5, 6]
print(f"contains(a, 10): {operator.contains(a, 10)}")  # True

# Операции с атрибутами
print("\nОперации с атрибутами:")
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
p = Person("Alice", 30)
print(f"attrgetter('name')(p): {operator.attrgetter('name')(p)}")  # 'Alice'
print(f"attrgetter('name', 'age')(p): {operator.attrgetter('name', 'age')(p)}")  # ('Alice', 30)

# Использование itemgetter
print("\nПример использования itemgetter:")
inventory = [
    {'name': 'apples', 'quantity': 10},
    {'name': 'bananas', 'quantity': 5},
    {'name': 'oranges', 'quantity': 15}
]

# Сортировка по количеству
sorted_by_quantity = sorted(inventory, key=operator.itemgetter('quantity'))
print(f"Отсортировано по количеству: {sorted_by_quantity}")

# Извлечение нескольких элементов
get_name_quantity = operator.itemgetter('name', 'quantity')
result = [get_name_quantity(item) for item in inventory]
print(f"Извлечение name и quantity: {result}")

# Использование methodcaller
print("\nПример использования methodcaller:")
strings = ['apple', 'banana', 'CHERRY', 'Date']
upper = list(map(operator.methodcaller('upper'), strings))
print(f"После вызова upper(): {upper}")

# Практический пример: сортировка наборов данных
Person = namedtuple('Person', ['name', 'age', 'height'])
people = [
    Person('Alice', 30, 165),
    Person('Bob', 25, 180),
    Person('Charlie', 35, 175),
    Person('David', 30, 190)
]

# Сортировка по возрасту, затем по росту
by_age_height = sorted(people, key=operator.attrgetter('age', 'height'))
print("\nСортировка по возрасту, затем по росту:")
for person in by_age_height:
    print(f"{person.name}: возраст {person.age}, рост {person.height}")

# Использование reduce с операторами
print("\nИспользование functools.reduce с операторами:")
numbers = [1, 2, 3, 4, 5]
total = functools.reduce(operator.add, numbers)
product = functools.reduce(operator.mul, numbers)
print(f"Сумма: {total}")  # 15
print(f"Произведение: {product}")  # 120

# Использование для обработки данных
print("\nИспользование для обработки данных:")
data = [
    {'name': 'Alice', 'scores': [85, 90, 92]},
    {'name': 'Bob', 'scores': [76, 80, 75]},
    {'name': 'Charlie', 'scores': [95, 88, 91]}
]

# Вычисление среднего балла для каждого студента
get_scores = operator.itemgetter('scores')
for student in data:
    avg_score = sum(get_scores(student)) / len(get_scores(student))
    print(f"{student['name']}: средний балл {avg_score:.2f}")
```

**Особенности для senior-разработчиков:**
- Использование функций из модуля `operator` вместо лямбда-выражений может значительно повысить читаемость кода, особенно в сложных функциональных конструкциях.
- Функции `itemgetter`, `attrgetter` и `methodcaller` эффективнее эквивалентных лямбда-выражений, так как они оптимизированы на уровне C.
- При множественных обращениях к одним и тем же атрибутам или элементам эффективнее создать функцию-геттер один раз и повторно использовать её.
- При сортировке сложных структур данных комбинирование `sorted` с `itemgetter` или `attrgetter` обеспечивает более ясный и эффективный код.
- `operator.add` и другие функции также могут работать с объектами, перегружающими соответствующие операторы, что делает их универсальными для различных типов данных.
- При использовании с `map`, `filter` или `reduce`, функции из `operator` могут обеспечить лучшую производительность, чем эквивалентные лямбда-функции.
- Для комбинирования нескольких операций можно использовать `functools.partial` в сочетании с функциями из `operator`.
- Многие операторы имеют специфические правила приоритета; при использовании функций из `operator` эти правила уже встроены в функции.

## numbers

Модуль `numbers` определяет абстрактную иерархию числовых типов в Python.

**Описание:** Предоставляет абстрактные базовые классы (ABC) для различных числовых типов, определяющие интерфейсы и иерархию наследования.

**Внутреннее устройство:**
- Определяет числовую башню (numeric tower) в соответствии с математическими принципами.
- Используется для проверки, относится ли объект к определенному виду чисел.
- Служит основой для создания пользовательских числовых типов.

**Ключевые абстрактные базовые классы:**
- `numbers.Number` - базовый класс для всех числовых типов.
- `numbers.Complex` - комплексные числа (подкласс Number).
- `numbers.Real` - действительные числа (подкласс Complex).
- `numbers.Rational` - рациональные числа (подкласс Real).
- `numbers.Integral` - целые числа (подкласс Rational).

**Иерархия классов:**
```
Number
  ├── Complex
  │     └── Real
  │           └── Rational
  │                 └── Integral
  └── (другие числовые типы, например, кватернионы)
```

**Примеры:**
```python
import numbers
from fractions import Fraction
import decimal

# Проверка типов на соответствие числовым ABC
def check_number_types(value):
    type_info = []
    if isinstance(value, numbers.Number):
        type_info.append("Number")
        if isinstance(value, numbers.Complex):
            type_info.append("Complex")
            if isinstance(value, numbers.Real):
                type_info.append("Real")
                if isinstance(value, numbers.Rational):
                    type_info.append("Rational")
                    if isinstance(value, numbers.Integral):
                        type_info.append("Integral")
    return value, type_info

# Проверка различных числовых типов
test_values = [
    42,                  # int
    3.14,                # float
    complex(1, 2),       # complex
    Fraction(2, 3),      # Fraction
    decimal.Decimal('1.5')  # Decimal
]

print("Проверка числовых типов:")
for value in test_values:
    value, types = check_number_types(value)
    print(f"{value} ({type(value).__name__}): {', '.join(types)}")

# Создание функции, принимающей только определенные числовые типы
def safe_sqrt(x):
    """Вычисляет квадратный корень для действительных чисел >= 0."""
    if not isinstance(x, numbers.Real):
        raise TypeError("Аргумент должен быть действительным числом")
    if x < 0:
        raise ValueError("Невозможно вычислить квадратный корень отрицательного числа")
    return x ** 0.5

# Тестирование функции с различными входными данными
print("\nТестирование safe_sqrt:")
try:
    print(f"safe_sqrt(16): {safe_sqrt(16)}")
    print(f"safe_sqrt(2.25): {safe_sqrt(2.25)}")
    print(f"safe_sqrt(Fraction(1, 4)): {safe_sqrt(Fraction(1, 4))}")
    
    # Эти вызовы должны вызвать исключения
    print(f"safe_sqrt(-1): {safe_sqrt(-1)}")
except ValueError as e:
    print(f"Ошибка значения: {e}")

try:
    print(f"safe_sqrt(complex(1, 0)): {safe_sqrt(complex(1, 0))}")
except TypeError as e:
    print(f"Ошибка типа: {e}")

# Создание пользовательского числового типа
class EvenIntegral(int):
    """Целое число, которое всегда округляется до ближайшего четного числа."""
    
    def __new__(cls, value):
        value = int(value)
        if value % 2 == 1:
            value += 1  # Округляем до следующего четного
        return super(EvenIntegral, cls).__new__(cls, value)
    
    def __add__(self, other):
        result = super(EvenIntegral, self).__add__(other)
        return EvenIntegral(result)
    
    def __sub__(self, other):
        result = super(EvenIntegral, self).__sub__(other)
        return EvenIntegral(result)
    
    def __mul__(self, other):
        result = super(EvenIntegral, self).__mul__(other)
        return EvenIntegral(result)
    
    # Другие операции также следует переопределить...

# Проверка, что наш класс соответствует иерархии numbers
print("\nПроверка пользовательского числового типа:")
even_num = EvenIntegral(7)
print(f"EvenIntegral(7): {even_num}")  # 8 (округлено до четного)
print(f"even_num + 5: {even_num + 5}")  # 14 (8 + 5 = 13, округлено до 14)

value, types = check_number_types(even_num)
print(f"{value} ({type(value).__name__}): {', '.join(types)}")

# Пример функции, принимающей любые дробные числа
def calculate_percentage(value, total):
    """Вычисляет процентное отношение value к total."""
    if not isinstance(value, numbers.Real) or not isinstance(total, numbers.Real):
        raise TypeError("Оба аргумента должны быть действительными числами")
    if total == 0:
        raise ZeroDivisionError("Общее значение не может быть нулем")
    return (value / total) * 100

# Тестирование с разными типами
print("\nТестирование calculate_percentage:")
print(f"calculate_percentage(25, 100): {calculate_percentage(25, 100)}%")  # 25.0%
print(f"calculate_percentage(Fraction(1, 4), 1): {calculate_percentage(Fraction(1, 4), 1)}%")  # 25.0%
print(f"calculate_percentage(decimal.Decimal('0.75'), 1): {calculate_percentage(decimal.Decimal('0.75'), 1)}%")  # 75.0%
```

**Особенности для senior-разработчиков:**
- Абстрактные базовые классы из `numbers` полезны для создания универсальных функций, работающих с разными числовыми типами. Вместо проверки конкретных типов (`isinstance(x, int) or isinstance(x, float)`) лучше использовать `isinstance(x, numbers.Real)`.
- Модуль `numbers` использует механизм перегрузки операторов Python. При создании пользовательских числовых типов важно правильно реализовать нужные магические методы (`__add__`, `__mul__` и т.д.).
- Абстрактные базовые классы определяют только контракт (интерфейс), но не реализацию. Это отличается от традиционного наследования, где базовые классы часто предоставляют некоторую функциональность.
- При реализации пользовательских числовых типов помните о математических свойствах. Например, сложение должно быть коммутативным, а умножение - дистрибутивным относительно сложения.
- Встроенные типы (`int`, `float`, `complex`, `Fraction`, `Decimal`) уже интегрированы с модулем `numbers` и соответствуют нужным ABC.
- Использование `numbers` важно для библиотек, которые должны работать с различными числовыми типами, такими как математические или научные пакеты.
- Проверка с помощью `isinstance(x, numbers.Real)` быстрее, чем написание собственной проверки для всех возможных числовых типов.
- Данный модуль особенно полезен при создании API, в которых пользователи могут передавать собственные числовые типы, соответствующие определенным абстрактным классам.