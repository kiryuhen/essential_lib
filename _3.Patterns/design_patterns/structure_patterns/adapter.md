# Паттерн Adapter (Адаптер)

## Описание

Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он выступает в роли переводчика, трансформируя интерфейс или данные одного объекта в понятный другому объекту формат.

## Когда использовать

- Когда нужно использовать существующий класс, но его интерфейс не соответствует требуемому
- Когда требуется использовать несколько существующих подклассов, но нецелесообразно адаптировать их интерфейс путем создания новых подклассов для каждого
- Когда нужно интегрировать внешнюю библиотеку или компонент, не изменяя их код
- Когда нужно повторно использовать существующий класс, работающий с несовместимым интерфейсом
- При необходимости унифицировать интерфейс разнородных классов в систему с единым подходом

## Преимущества

- Отделяет интерфейс от реализации, позволяя им изменяться независимо
- Улучшает повторное использование кода, делая несовместимые классы совместимыми
- Упрощает структуру системы, выделяя код адаптации в отдельный класс
- Позволяет подключать новые типы классов без изменения существующего кода
- Повышает открытость системы для изменений

## Недостатки

- Может увеличить сложность кода из-за введения дополнительных классов
- Иногда более целесообразно изменить сервисный класс, чтобы он соответствовал остальной системе
- Требует дополнительной работы по созданию адаптеров, особенно при частых изменениях
- Может скрывать проблемы проектирования, являясь временным решением

## Реализация на Python

В Python адаптер может быть реализован двумя способами:

### 1. Адаптер на основе композиции (объектный адаптер)

```python
# Существующий класс с несовместимым интерфейсом
class LegacyRectangle:
    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
    
    def draw(self):
        print(f"Рисуем прямоугольник с координатами ({self.x1}, {self.y1}) и ({self.x2}, {self.y2})")
        
# Целевой интерфейс
class Shape:
    def draw_shape(self):
        pass

# Адаптер
class RectangleAdapter(Shape):
    def __init__(self, x, y, width, height):
        self.adaptee = LegacyRectangle(x, y, x + width, y + height)
    
    def draw_shape(self):
        self.adaptee.draw()
```

### 2. Адаптер на основе наследования (классовый адаптер)

```python
# Целевой интерфейс
class Target:
    def request(self):
        return "Target: стандартное поведение цели"

# Существующий класс с несовместимым интерфейсом
class Adaptee:
    def specific_request(self):
        return "Adaptee: специфичное поведение"

# Адаптер через множественное наследование
class Adapter(Target, Adaptee):
    def request(self):
        return f"Adapter: (ПЕРЕВЕДЕНО) {self.specific_request()}"
```

## Где применяется в реальных проектах

- Интеграция с внешними библиотеками и API
- Работа с унаследованным кодом
- Взаимодействие между новыми и старыми системами
- Адаптация разных форматов данных
- ORM-системы, адаптирующие объекты приложения к базе данных
- Фреймворки для работы с различными драйверами
- Унификация интерфейсов различных платежных систем
- В графических библиотеках для адаптации разных форматов изображений

## Связанные паттерны

- **Мост**: Оба паттерна имеют схожую структуру, но решают разные проблемы
- **Декоратор**: Декоратор расширяет объект, не изменяя его интерфейс
- **Прокси**: Прокси имеет тот же интерфейс, что и оригинальный объект
- **Фасад**: Фасад определяет новый интерфейс, а адаптер повторно использует старый
- **Стратегия**: Адаптер изменяет интерфейс существующего объекта, стратегия делегирует работу подклассам

## Рекомендации по использованию

- Используйте композицию (объектный адаптер) вместо наследования, когда это возможно
- Определите четкий интерфейс, к которому должен адаптироваться класс
- При разработке API предусмотрите будущие изменения и создавайте адаптеры для обратной совместимости
- Рассмотрите альтернативы перед применением адаптера (возможно, переработка исходного кода проще)
- В Python часто можно обойтись без формального адаптера благодаря динамической типизации и утиной типизации
- При работе с большим количеством адаптеров рассмотрите фабрику адаптеров
