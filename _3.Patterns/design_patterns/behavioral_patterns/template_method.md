# Паттерн Template Method (Шаблонный метод)

## Описание
Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма в базовом классе, но позволяет подклассам переопределять определенные шаги алгоритма, не изменяя его структуру.

## Проблема
Необходимо определить алгоритм, состоящий из нескольких шагов, при этом некоторые шаги могут различаться в разных реализациях. Дублирование кода нежелательно, но необходима гибкость для изменения отдельных шагов алгоритма.

## Решение
Паттерн Template Method предлагает разбить алгоритм на последовательность шагов, затем превратить эти шаги в методы и вызвать их в одном шаблонном методе. Части алгоритма, которые могут различаться в разных реализациях, становятся абстрактными методами, которые должны быть реализованы в подклассах.

## Структура
- **AbstractClass** — абстрактный класс, содержащий шаблонный метод и абстрактные методы для переопределения
- **ConcreteClass** — конкретный класс, реализующий абстрактные методы базового класса

## Пример на Python

```python
from abc import ABC, abstractmethod

# AbstractClass
class AbstractDocument(ABC):
    def save(self):
        """Шаблонный метод, определяющий скелет алгоритма"""
        self.open_document()
        self.process_content()
        self.write_document()
        self.close_document()
        if self.hook_should_compress():
            self.compress_document()
    
    def open_document(self):
        print("Открытие документа")
    
    @abstractmethod
    def process_content(self):
        pass
    
    @abstractmethod
    def write_document(self):
        pass
    
    def close_document(self):
        print("Закрытие документа")
    
    def compress_document(self):
        print("Сжатие документа")
    
    def hook_should_compress(self):
        """Хук с возможностью переопределения в подклассах"""
        return True

# ConcreteClass
class TextDocument(AbstractDocument):
    def process_content(self):
        print("Обработка текстового содержимого")
    
    def write_document(self):
        print("Запись текстового документа на диск")
    
    def hook_should_compress(self):
        # Переопределяем хук
        return False

# ConcreteClass
class ImageDocument(AbstractDocument):
    def process_content(self):
        print("Обработка изображения")
    
    def write_document(self):
        print("Запись изображения на диск")
```

## Применение
В реальных приложениях Шаблонный метод часто используется для:
- Реализации скелета алгоритма с изменяемыми деталями
- Каркасов для различных типов документов, отчетов, экспортеров
- Обработки данных с различными форматами ввода/вывода
- Создания шаблонов для обработчиков запросов
- Определения структуры классов тестирования с различными настройками

## Плюсы
1. **Устранение дублирования кода**: Общая часть алгоритма вынесена в базовый класс.
2. **Гибкость**: Подклассы могут изменять определенные шаги алгоритма.
3. **Контроль точек расширения**: Базовый класс определяет, какие шаги могут быть переопределены.
4. **Инверсия контроля**: Реализуется принцип "Голливуда" — "Не вызывайте нас, мы вас сами вызовем".
5. **Повторное использование**: Общая логика определена один раз и используется всеми подклассами.

## Минусы
1. **Ограничение структуры алгоритма**: Некоторые реализации могут быть ограничены скелетом алгоритма.
2. **Нарушение принципа Лисков**: При неправильной реализации подклассы могут нарушать поведение базового класса.
3. **Сложность сопровождения**: При изменении шаблонного метода все подклассы могут потребовать изменений.
4. **Принудительное наследование**: Вынуждает использовать наследование вместо композиции.
5. **Усложнение при большом количестве шагов**: При большом количестве шагов алгоритма, структура шаблонного метода может стать сложной.

## Когда использовать
- Когда подклассы должны расширять только определенные части алгоритма, но не всю структуру
- Когда общая функциональность должна быть сосредоточена в одном месте
- Когда необходимо контролировать расширения, которые могут сделать подклассы
- Когда можно выделить инвариантную часть алгоритма и переменные шаги