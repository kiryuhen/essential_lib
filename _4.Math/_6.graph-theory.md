# Теория графов

## Введение

Теория графов — это раздел математики, который изучает графы — структуры, состоящие из вершин (точек) и рёбер (линий), соединяющих эти вершины. Графы помогают нам моделировать отношения между объектами. 

Представьте, что вы рисуете карту своего района, где дома — это точки, а дороги между ними — линии. Вот вам и граф! Эта простая идея оказывается невероятно полезной в программировании, сетевых технологиях, транспортных системах и многих других областях.

## Основные понятия

### Граф

Граф состоит из:
- **Вершин** (узлов)
- **Рёбер** (связей между вершинами)

Граф обычно обозначается как G = (V, E), где:
- V — множество вершин
- E — множество рёбер

### Типы графов

#### По направленности рёбер

**Неориентированный граф**: рёбра не имеют направления. Связь между вершинами A и B означает, что можно двигаться как от A к B, так и от B к A.

**Ориентированный граф (орграф)**: рёбра имеют направление. Связь от A к B не обязательно означает, что есть связь от B к A.

#### По наличию весов

**Невзвешенный граф**: все рёбра одинаковы, без дополнительных значений.

**Взвешенный граф**: каждому ребру присвоен вес (число), который может представлять расстояние, стоимость, время и т.д.

#### По связности

**Связный граф**: существует путь между любыми двумя вершинами.

**Несвязный граф**: есть хотя бы две вершины, между которыми нет пути.

#### Специальные графы

**Полный граф**: каждая вершина соединена с каждой другой вершиной. В полном графе с n вершинами будет n(n-1)/2 рёбер.

**Двудольный граф**: вершины можно разделить на две группы так, что рёбра соединяют только вершины из разных групп.

**Дерево**: связный граф без циклов. В дереве с n вершинами всегда ровно n-1 ребро.

### Степень вершины

Степень вершины — это количество рёбер, которые входят в вершину.

В ориентированном графе различают:
- **Входящая степень**: количество рёбер, которые входят в вершину
- **Исходящая степень**: количество рёбер, которые выходят из вершины

### Путь и цикл

**Путь** — это последовательность вершин, где каждая пара соседних вершин соединена ребром.

**Цикл** — это путь, который начинается и заканчивается в одной и той же вершине.

**Простой путь** — путь без повторяющихся вершин.

**Простой цикл** — цикл без повторяющихся вершин (кроме первой и последней).

## Представление графов

### Матрица смежности

Матрица смежности — это двумерный массив, где элемент [i][j] указывает, есть ли ребро от вершины i к вершине j.

Для невзвешенного графа:
- 0 — нет ребра
- 1 — есть ребро

Для взвешенного графа:
- Значение веса — есть ребро с указанным весом
- Бесконечность (или другое специальное значение) — нет ребра

**Пример матрицы смежности для графа с 4 вершинами:**

```
  | 0 1 2 3
--+--------
0 | 0 1 0 1
1 | 1 0 1 0
2 | 0 1 0 1
3 | 1 0 1 0
```

Преимущества:
- Быстрая проверка наличия ребра между двумя вершинами O(1)
- Простая реализация

Недостатки:
- Занимает O(V²) памяти
- Неэффективно для разреженных графов (с малым количеством рёбер)

### Список смежности

Список смежности — это массив списков, где для каждой вершины хранится список смежных с ней вершин.

**Пример списка смежности для того же графа:**

```
0: [1, 3]
1: [0, 2]
2: [1, 3]
3: [0, 2]
```

Преимущества:
- Экономит память для разреженных графов
- Быстрый перебор соседей вершины

Недостатки:
- Проверка наличия ребра требует O(E) времени в худшем случае

## Алгоритмы на графах

### Поиск в ширину (BFS)

Поиск в ширину исследует все вершины на текущем уровне удаленности от стартовой вершины, прежде чем перейти на следующий уровень.

**Применение**:
- Поиск кратчайшего пути в невзвешенном графе
- Определение компонент связности
- Проверка двудольности графа

**Алгоритм (псевдокод)**:
```
function BFS(graph, start):
    создать очередь queue
    добавить start в queue
    отметить start как посещенную
    
    while queue не пуста:
        vertex = удалить первый элемент из queue
        for each сосед neighbor вершины vertex:
            if neighbor не посещен:
                добавить neighbor в queue
                отметить neighbor как посещенный
```

**Временная сложность**: O(V + E), где V — количество вершин, E — количество рёбер.

### Поиск в глубину (DFS)

Поиск в глубину исследует ветку до конца, прежде чем возвращаться и исследовать другие ветки.

**Применение**:
- Топологическая сортировка
- Определение компонент сильной связности
- Поиск циклов
- Построение каркасных деревьев

**Алгоритм (псевдокод)**:
```
function DFS(graph, start):
    отметить start как посещенную
    
    for each сосед neighbor вершины start:
        if neighbor не посещен:
            DFS(graph, neighbor)
```

**Временная сложность**: O(V + E), где V — количество вершин, E — количество рёбер.

### Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных во взвешенном графе с неотрицательными весами.

**Алгоритм (псевдокод)**:
```
function Dijkstra(graph, start):
    создать массив distance[размер графа], инициализировать бесконечностями
    distance[start] = 0
    создать приоритетную очередь queue
    добавить (start, 0) в queue
    
    while queue не пуста:
        vertex = извлечь вершину с наименьшим расстоянием из queue
        
        for each сосед neighbor вершины vertex:
            если distance[vertex] + вес(vertex, neighbor) < distance[neighbor]:
                distance[neighbor] = distance[vertex] + вес(vertex, neighbor)
                добавить (neighbor, distance[neighbor]) в queue
    
    return distance
```

**Временная сложность**: O((V+E) log V) с бинарной кучей.

### Алгоритм Прима

Алгоритм Прима находит минимальное остовное дерево (MST) взвешенного неориентированного графа.

**Минимальное остовное дерево** — это подмножество рёбер, которые соединяют все вершины с минимальной общей суммой весов.

**Алгоритм (псевдокод)**:
```
function Prim(graph, start):
    создать пустой набор MST
    создать приоритетную очередь queue
    добавить все рёбра, инцидентные start, в queue
    
    while queue не пуста и MST не включает все вершины:
        edge = извлечь ребро с минимальным весом из queue
        если edge соединяет вершину в MST с вершиной вне MST:
            добавить edge в MST
            добавить все рёбра, инцидентные новой вершине, в queue
    
    return MST
```

**Временная сложность**: O(E log V) с бинарной кучей.

### Алгоритм Крускала

Алгоритм Крускала — это ещё один алгоритм для нахождения минимального остовного дерева.

**Алгоритм (псевдокод)**:
```
function Kruskal(graph):
    создать пустой набор MST
    отсортировать все рёбра по весу
    
    for each ребро edge в порядке возрастания веса:
        если edge не создаёт цикл в MST:
            добавить edge в MST
    
    return MST
```

**Временная сложность**: O(E log E) или O(E log V), так как E не больше V².

### Топологическая сортировка

Топологическая сортировка — это линейное упорядочивание вершин ориентированного ациклического графа (DAG) таким образом, что для каждого ребра (u, v) вершина u идёт перед v.

**Применение**:
- Планирование задач с зависимостями
- Определение порядка компиляции исходных файлов
- Анализ зависимостей в пакетных менеджерах

**Алгоритм (псевдокод с использованием DFS)**:
```
function TopologicalSort(graph):
    создать стек stack
    
    for each вершина vertex в graph:
        if vertex не посещена:
            TopologicalSortUtil(graph, vertex, stack)
    
    return stack
    
function TopologicalSortUtil(graph, vertex, stack):
    отметить vertex как посещенную
    
    for each сосед neighbor вершины vertex:
        if neighbor не посещен:
            TopologicalSortUtil(graph, neighbor, stack)
    
    добавить vertex в начало stack
```

**Временная сложность**: O(V + E).

## Применение теории графов в программировании

### Сетевые алгоритмы

- **Маршрутизация в компьютерных сетях**: нахождение оптимальных путей для передачи данных
- **Анализ социальных сетей**: выявление сообществ, определение влиятельных узлов
- **Веб-краулинг**: обход веб-страниц для индексации

### Базы данных и системы хранения

- **Графовые базы данных**: Neo4j, Amazon Neptune
- **Оптимизация запросов**: представление плана запроса как графа

### Компьютерная графика и игры

- **Поиск пути в играх**: алгоритмы A* и Дейкстры для перемещения персонажей
- **Определение видимых объектов**: с помощью графов видимости

### Искусственный интеллект

- **Представление знаний**: семантические сети
- **Экспертные системы**: графы вывода
- **Машинное обучение**: графовые нейронные сети

## Решение практических задач

### Пример 1: Поиск кратчайшего пути

**Задача**: Найти кратчайший путь от вершины A до вершины E в следующем графе:
- A соединена с B (вес 4) и C (вес 2)
- B соединена с C (вес 1) и D (вес 5)
- C соединена с D (вес 8) и E (вес 10)
- D соединена с E (вес 2)

**Решение с использованием алгоритма Дейкстры**:
1. Расстояние до A = 0, до остальных = бесконечность
2. Посещаем A, обновляем: B = 4, C = 2
3. Посещаем C (ближайшая), обновляем: D = 10, E = 12
4. Посещаем B, обновляем: D = min(10, 4+5) = 9
5. Посещаем D, обновляем: E = min(12, 9+2) = 11
6. Посещаем E

Кратчайший путь: A → B → D → E с общим весом 11.

### Пример 2: Проверка связности

**Задача**: Определить, сколько компонент связности в неориентированном графе:
- Вершины: 1, 2, 3, 4, 5, 6
- Рёбра: (1,2), (2,3), (1,3), (4,5)

**Решение с использованием BFS**:
1. Начинаем с вершины 1, посещаем 1, 2, 3
2. Все соседи посещены, но остались вершины 4, 5, 6
3. Начинаем с вершины 4, посещаем 4, 5
4. Все соседи посещены, но осталась вершина 6
5. Начинаем с вершины 6, посещаем 6
6. Все вершины посещены

Результат: 3 компоненты связности: {1,2,3}, {4,5}, {6}.

## Практические упражнения

1. Нарисуйте граф, представляющий дружеские связи в вашем классе. Какова степень каждой вершины? Есть ли изолированные вершины?

2. Используя алгоритм BFS, найдите кратчайший путь от дома до школы в графе вашего района.

3. Представьте следующий граф в виде матрицы смежности и списка смежности:
   - Вершины: A, B, C, D
   - Рёбра: (A,B), (A,C), (B,C), (C,D)

4. Для графа из упражнения 3 выполните обход в глубину, начиная с вершины A.

5. Для взвешенного графа:
   - Вершины: 1, 2, 3, 4
   - Рёбра: (1,2) с весом 5, (1,3) с весом 3, (2,3) с весом 1, (2,4) с весом 6, (3,4) с весом 2
   
   Найдите минимальное остовное дерево, используя алгоритм Прима или Крускала.

## Ответы к упражнениям

3. Матрица смежности:
   ```
     | A B C D
   --+--------
   A | 0 1 1 0
   B | 1 0 1 0
   C | 1 1 0 1
   D | 0 0 1 0
   ```

   Список смежности:
   ```
   A: [B, C]
   B: [A, C]
   C: [A, B, D]
   D: [C]
   ```

4. Порядок обхода в глубину (DFS), начиная с A: A, B, C, D

5. Минимальное остовное дерево содержит рёбра:
   - (2,3) с весом 1
   - (3,4) с весом 2
   - (1,3) с весом 3
   
   Общий вес минимального остовного дерева: 6
