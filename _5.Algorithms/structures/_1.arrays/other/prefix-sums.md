# Префиксные суммы (Prefix Sums)

## Определение и концепция

**Префиксные суммы** — это алгоритмический паттерн, который предварительно вычисляет сумму элементов массива от начала до каждой позиции. Это позволяет мгновенно находить сумму любого подмассива за O(1) времени после предварительной обработки.

Для массива `A[0...n-1]` префиксная сумма `prefix[i]` определяется как сумма всех элементов от `A[0]` до `A[i]` включительно:

```
prefix[i] = A[0] + A[1] + A[2] + ... + A[i]
```

После вычисления массива префиксных сумм, сумма любого подмассива `A[i...j]` может быть найдена за O(1) времени:

```
sum(A[i...j]) = prefix[j] - prefix[i-1]
```

Для удобства обычно создают массив префиксных сумм с дополнительным элементом в начале (`prefix[0] = 0`), чтобы упростить вычисления и избежать проверки граничных случаев.

## Основные характеристики

- **Временная сложность (построение)**: O(n), где n — размер исходного массива
- **Временная сложность (запросы)**: O(1) для каждого запроса суммы подмассива
- **Пространственная сложность**: O(n) для хранения массива префиксных сумм

## Примеры задач и их решения

### Пример 1: Вычисление сумм подмассивов

**Задача:** Дан массив целых чисел и m запросов. Каждый запрос состоит из двух индексов i и j. Для каждого запроса найдите сумму элементов в подмассиве от i до j включительно.

**Решение с использованием префиксных сумм:**

```python
def range_sum_queries(arr, queries):
    n = len(arr)
    
    # Создаем массив префиксных сумм с дополнительным элементом в начале
    prefix = [0] * (n + 1)
    
    # Вычисляем префиксные суммы
    for i in range(n):
        # Префиксная сумма до индекса i равна сумме до i-1 плюс элемент i
        prefix[i + 1] = prefix[i] + arr[i]
    
    # Обрабатываем запросы
    results = []
    for left, right in queries:
        # Сумма подмассива от left до right равна
        # префиксной сумме до right минус префиксная сумма до left-1
        sum_range = prefix[right + 1] - prefix[left]
        results.append(sum_range)
    
    return results
```

Временная сложность: O(n + m), где n — размер массива, m — количество запросов.
Пространственная сложность: O(n).

### Пример 2: Подмассив с заданной суммой

**Задача:** Дан массив целых чисел и целевое значение sum, определить, существует ли подмассив с суммой, равной sum.

**Решение с использованием префиксных сумм и хеш-таблицы:**

```python
def has_subarray_with_sum(arr, target_sum):
    n = len(arr)
    
    # Инициализируем текущую сумму и хеш-таблицу
    # Хеш-таблица хранит префиксные суммы и их индексы
    current_sum = 0
    prefix_sums = {0: -1}  # Сумма 0 встречается перед началом массива (индекс -1)
    
    for i in range(n):
        # Обновляем текущую сумму
        current_sum += arr[i]
        
        # Если current_sum - target_sum существует в хеш-таблице,
        # значит сумма подмассива между этими позициями равна target_sum
        if current_sum - target_sum in prefix_sums:
            # Возвращаем начальный и конечный индексы подмассива
            start_index = prefix_sums[current_sum - target_sum] + 1
            end_index = i
            return True, (start_index, end_index)
        
        # Сохраняем текущую сумму и индекс в хеш-таблице
        prefix_sums[current_sum] = i
    
    # Если подмассив не найден
    return False, None
```

Временная сложность: O(n).
Пространственная сложность: O(n).

### Пример 3: Количество подмассивов с суммой, кратной k

**Задача:** Дан массив целых чисел и число k, найти количество подмассивов, сумма элементов которых кратна k.

**Решение с использованием префиксных сумм и остатков от деления:**

```python
def count_subarrays_divisible_by_k(arr, k):
    n = len(arr)
    
    # Словарь для хранения остатков от деления префиксных сумм на k
    # remainder_count[r] = количество префиксных сумм с остатком r при делении на k
    remainder_count = {0: 1}  # Начальное значение для пустого массива
    
    current_sum = 0
    count = 0
    
    for i in range(n):
        # Обновляем текущую сумму
        current_sum += arr[i]
        
        # Вычисляем остаток от деления текущей суммы на k
        # (добавляем k перед взятием остатка для обработки отрицательных чисел)
        remainder = ((current_sum % k) + k) % k
        
        # Если такой остаток уже встречался, добавляем количество таких префиксных сумм к результату
        if remainder in remainder_count:
            count += remainder_count[remainder]
        
        # Увеличиваем счетчик для текущего остатка
        remainder_count[remainder] = remainder_count.get(remainder, 0) + 1
    
    return count
```

Временная сложность: O(n).
Пространственная сложность: O(min(n, k)).

### Пример 4: Наибольший подмассив с равным количеством 0 и 1

**Задача:** Дан бинарный массив (содержащий только 0 и 1), найти длину наибольшего подмассива, содержащего равное количество 0 и 1.

**Решение с использованием префиксных сумм:**

```python
def find_largest_subarray_with_equal_0_1(arr):
    n = len(arr)
    
    # Заменяем 0 на -1 для упрощения задачи:
    # теперь ищем подмассив с суммой 0
    converted_arr = [-1 if x == 0 else 1 for x in arr]
    
    # Словарь для хранения первого вхождения каждой префиксной суммы
    sum_index = {0: -1}  # Сумма 0 встречается перед началом массива
    
    current_sum = 0
    max_length = 0
    start_index = end_index = -1
    
    for i in range(n):
        # Обновляем текущую сумму
        current_sum += converted_arr[i]
        
        # Если текущая сумма уже встречалась,
        # значит между этими позициями сумма равна 0
        if current_sum in sum_index:
            length = i - sum_index[current_sum]
            if length > max_length:
                max_length = length
                start_index = sum_index[current_sum] + 1
                end_index = i
        else:
            # Сохраняем первое вхождение текущей суммы
            sum_index[current_sum] = i
    
    if max_length > 0:
        return max_length, (start_index, end_index)
    else:
        return 0, None
```

Временная сложность: O(n).
Пространственная сложность: O(n).

## Расширения и вариации

### 1. Двумерные префиксные суммы

Паттерн префиксных сумм можно расширить для работы с двумерными массивами (матрицами). Для матрицы A[m][n] префиксная сумма prefixSum[i][j] будет равна сумме всех элементов в подматрице от A[0][0] до A[i][j].

Такая структура данных позволяет мгновенно находить сумму любой подматрицы.

```python
def build_2d_prefix_sum(matrix):
    if not matrix or not matrix[0]:
        return []
    
    m, n = len(matrix), len(matrix[0])
    prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # Префиксная сумма в точке (i, j) равна:
            # сумма до (i-1, j) + сумма до (i, j-1) - сумма до (i-1, j-1) + текущий элемент
            prefix_sum[i][j] = (prefix_sum[i-1][j] + prefix_sum[i][j-1] - 
                               prefix_sum[i-1][j-1] + matrix[i-1][j-1])
    
    return prefix_sum

def get_submatrix_sum(prefix_sum, row1, col1, row2, col2):
    # Вычисляем сумму подматрицы от (row1, col1) до (row2, col2) включительно
    return (prefix_sum[row2 + 1][col2 + 1] - prefix_sum[row1][col2 + 1] - 
            prefix_sum[row2 + 1][col1] + prefix_sum[row1][col1])
```

### 2. Префиксное произведение

По аналогии с префиксными суммами можно использовать префиксные произведения для быстрого вычисления произведения элементов подмассива.

### 3. XOR-префиксы

Префиксный XOR используется для быстрого вычисления XOR элементов подмассива.

```python
def build_xor_prefix(arr):
    n = len(arr)
    xor_prefix = [0] * (n + 1)
    
    for i in range(n):
        xor_prefix[i + 1] = xor_prefix[i] ^ arr[i]
    
    return xor_prefix

def get_range_xor(xor_prefix, left, right):
    # XOR элементов от left до right включительно
    return xor_prefix[right + 1] ^ xor_prefix[left]
```

## Когда использовать паттерн префиксных сумм

Паттерн префиксных сумм особенно полезен в следующих ситуациях:

1. **Многократные запросы сумм подмассивов**: Когда нужно обрабатывать много запросов на суммы различных подмассивов.

2. **Поиск подмассивов с определенными свойствами**: Например, с заданной суммой, с суммой, кратной k, и т.д.

3. **Задачи на нахождение количества подмассивов**: Когда требуется подсчитать количество подмассивов, удовлетворяющих определенным условиям.

4. **Оптимизация динамического программирования**: В некоторых задачах ДП префиксные суммы могут ускорить вычисления.

5. **Обработка двумерных массивов**: Для быстрого вычисления сумм в прямоугольных областях.

## Советы по применению на собеседованиях

1. **Распознавание паттерна**: Если задача связана с многократными запросами сумм подмассивов или с поиском подмассивов с определенной суммой, подумайте о применении префиксных сумм.

2. **Учет модуля или других операций**: В некоторых задачах суммы нужно рассматривать по модулю или использовать другие операции (XOR, произведение).

3. **Обработка краевых случаев**: Обратите внимание на пустые массивы, массивы из одного элемента, отрицательные числа и переполнение.

4. **Оптимизация пространства**: В некоторых случаях можно оптимизировать пространственную сложность, храня только необходимые остатки или используя скользящее окно.

5. **Индексация массива**: Убедитесь, что правильно понимаете, начинается ли индексация с 0 или с 1, и соответственно адаптируйте формулы.

## Заключение

Паттерн префиксных сумм — это мощный инструмент для оптимизации алгоритмов, работающих с подмассивами и их суммами. Он позволяет значительно улучшить временную сложность многих задач, особенно связанных с повторяющимися вычислениями сумм.

Префиксные суммы часто используются в сочетании с другими техниками, такими как хеширование, скользящее окно или двоичный поиск, для решения более сложных задач. Овладение этим паттерном и его вариациями расширит ваш арсенал алгоритмических приемов и поможет эффективно решать широкий спектр задач на собеседованиях и в реальной разработке программного обеспечения.