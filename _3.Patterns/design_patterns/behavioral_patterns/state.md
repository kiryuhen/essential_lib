# Паттерн State (Состояние)

## Описание
Паттерн State — это поведенческий паттерн проектирования, который позволяет объекту изменять своё поведение в зависимости от внутреннего состояния. Внешне это выглядит так, будто объект меняет свой класс.

## Проблема
Объекты часто меняют своё поведение в зависимости от внутреннего состояния, что приводит к большому количеству условных операторов для проверки состояния и выбора соответствующего поведения. Это делает код сложным для поддержки и расширения.

## Решение
Паттерн состояние предлагает создать отдельные классы для каждого состояния, в котором может находиться объект, и вынести туда поведение, связанное с этим состоянием. Вместо хранения состояния и условной логики, объект хранит ссылку на один из объектов-состояний и делегирует ему работу.

## Структура
- **Context** — основной класс, который содержит ссылку на текущее состояние
- **State** — интерфейс состояния, определяющий методы, которые должны реализовать все конкретные состояния
- **ConcreteState** — классы конкретных состояний, реализующие поведение, связанное с определенным состоянием контекста

## Применение
В реальных приложениях State часто используется для:
- Реализации объектов, поведение которых зависит от внутреннего состояния
- Замены больших условных операторов, которые выбирают поведение в зависимости от состояния
- Реализации конечных автоматов
- Управления поведением пользовательского интерфейса в зависимости от состояния
- Реализации различных этапов обработки в рабочих процессах (workflows)

## Плюсы
1. **Устраняет множественные условные операторы**: Вместо множества условий, проверяющих состояние, код обрабатывается соответствующими классами состояний.
2. **Локализация поведения**: Весь код, относящийся к определенному состоянию, находится в одном классе.
3. **Упрощение контекста**: Контекст делегирует поведение текущему состоянию, упрощая свою реализацию.
4. **Простота добавления новых состояний**: Можно легко добавить новые состояния, не изменяя существующие классы.
5. **Явное представление переходов между состояниями**: Переходы между состояниями явно выражены в коде.

## Минусы
1. **Увеличение числа классов**: Для каждого состояния создается отдельный класс, что может привести к разрастанию кодовой базы.
2. **Избыточность кода**: Если состояний немного и они не меняются часто, паттерн может быть избыточным.
3. **Возможная сложность переходов**: При большом количестве связей между состояниями код переходов может стать сложным.
4. **Распределение логики**: Логика переходов может быть распределена между разными классами состояний, что усложняет понимание общей картины.
5. **Сложность отладки**: Отслеживание последовательности переходов между состояниями может быть сложным при отладке.

## Пример на Python

```python
from abc import ABC, abstractmethod

# Интерфейс состояния
class State(ABC):
    @abstractmethod
    def handle(self, context):
        pass

# Конкретные состояния
class ConcreteStateA(State):
    def handle(self, context):
        print("Выполнение действий в состоянии A")
        context.state = ConcreteStateB()

class ConcreteStateB(State):
    def handle(self, context):
        print("Выполнение действий в состоянии B")
        context.state = ConcreteStateA()

# Контекст
class Context:
    def __init__(self, state):
        self.state = state
    
    def request(self):
        self.state.handle(self)
```

## Применение
В реальных приложениях State часто используется для:
- Реализация различных состояний документа (черновик, на рассмотрении, опубликован, архивирован)
- Реализация игровых персонажей с различными состояниями (стояние, ходьба, бег, прыжок)
- Управление состояниями заказа в интернет-магазине (оформлен, оплачен, доставляется, доставлен)
- Реализация рабочих процессов с различными этапами
- Управление доступом к функциональности в зависимости от роли пользователя

## Когда использовать
- Когда поведение объекта зависит от его состояния и должно изменяться во время выполнения
- Когда в коде множество условных операторов, которые выбирают поведение в зависимости от текущего состояния
- Когда логика перехода между состояниями сложна и требует явного представления
- Когда требуется добавлять новые состояния и правила переходов без изменения существующего кода
