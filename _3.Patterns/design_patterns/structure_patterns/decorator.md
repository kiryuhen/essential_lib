# Паттерн Decorator (Декоратор)

## Описание
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные "обёртки". В отличие от наследования, декораторы позволяют расширять функциональность объекта во время выполнения программы.

## Проблема
Необходимо добавить дополнительное поведение или ответственность к объекту, не изменяя его код и не используя наследование, которое может привести к большому количеству подклассов.

## Решение
Паттерн Декоратор создаёт обёрточный класс, который реализует тот же интерфейс, что и оригинальный класс, но добавляет к нему новую функциональность до и/или после делегирования методов исходному объекту.

## Структура
- **Component** — интерфейс, который определяет поведение, которое может изменяться декораторами.
- **ConcreteComponent** — конкретная реализация Component, которую можно "украшать".
- **Decorator** — абстрактный класс, который содержит ссылку на объект Component и реализует тот же интерфейс.
- **ConcreteDecorator** — конкретная реализация Decorator, которая добавляет новую функциональность.

## Пример на Python

```python
from abc import ABC, abstractmethod

# Component
class Component(ABC):
    @abstractmethod
    def operation(self) -> str:
        pass

# ConcreteComponent
class ConcreteComponent(Component):
    def operation(self) -> str:
        return "ConcreteComponent"

# Decorator
class Decorator(Component):
    def __init__(self, component: Component):
        self._component = component

    @property
    def component(self) -> Component:
        return self._component

    def operation(self) -> str:
        return self._component.operation()

# ConcreteDecorator
class ConcreteDecoratorA(Decorator):
    def operation(self) -> str:
        return f"ConcreteDecoratorA({self.component.operation()})"

# ConcreteDecorator
class ConcreteDecoratorB(Decorator):
    def operation(self) -> str:
        return f"ConcreteDecoratorB({self.component.operation()})"
```

## Применение
В реальных приложениях декораторы часто используются для:
- Добавления функциональности логирования
- Кэширования результатов
- Авторизации и аутентификации
- Сжатия или шифрования данных
- Добавления дополнительных проверок или валидаций

Python имеет встроенную поддержку декораторов через синтаксис `@decorator`, что делает этот паттерн особенно удобным в использовании.

## Плюсы
1. Позволяет добавлять функциональность объектам во время выполнения программы
2. Следует принципу открытости/закрытости (SOLID)
3. Более гибкая альтернатива наследованию
4. Можно комбинировать несколько декораторов для получения сложного поведения
5. Можно добавлять и удалять обязанности во время выполнения программы

## Минусы
1. Может привести к большому количеству маленьких классов
2. Код с большим количеством декораторов может быть трудно понять и отлаживать
3. Декораторы могут усложнить процесс инстанцирования компонентов
4. Трудно реализовать декоратор, который не зависит от порядка применения с другими декораторами

## Когда использовать
- Когда нужно добавить обязанности объекту динамически и прозрачно, не затрагивая другие объекты
- Когда нельзя использовать наследование для расширения функциональности
- Когда нужно добавить функциональность, которую можно будет удалить
- Когда необходимо добавить несколько комбинаций функциональностей к объекту