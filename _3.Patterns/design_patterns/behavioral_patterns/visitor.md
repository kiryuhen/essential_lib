# Паттерн Visitor (Посетитель)

## Описание
Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять новые операции к объектам без изменения их классов. Посетитель отделяет алгоритмы от объектов, над которыми эти алгоритмы работают.

## Проблема
Необходимо выполнять различные операции над группой объектов с разными типами, при этом не загрязняя классы этих объектов новыми методами. Например, вы разработали структуру элементов графического интерфейса и хотите добавить функционал экспорта в различные форматы без изменения кода элементов.

## Решение
Паттерн Visitor предлагает создать отдельный класс для каждой операции (посетителя), который реализует методы для работы с каждым типом объектов. Объекты же предоставляют метод accept(), принимающий посетителя и вызывающий соответствующий метод посетителя.

## Структура
- **Visitor** — интерфейс посетителя, определяющий методы для каждого типа объектов
- **ConcreteVisitor** — конкретная реализация посетителя, выполняющая операции над объектами
- **Element** — интерфейс элемента, определяющий метод accept()
- **ConcreteElement** — конкретная реализация элемента
- **ObjectStructure** — структура объектов, может предоставлять интерфейс для обхода своих элементов

## Пример на Python

```python
from abc import ABC, abstractmethod
from typing import List

# Element interface
class Element(ABC):
    @abstractmethod
    def accept(self, visitor: 'Visitor') -> None:
        pass

# Concrete Elements
class ConcreteElementA(Element):
    def accept(self, visitor: 'Visitor') -> None:
        visitor.visit_concrete_element_a(self)
    
    def operation_a(self) -> str:
        return "A"

class ConcreteElementB(Element):
    def accept(self, visitor: 'Visitor') -> None:
        visitor.visit_concrete_element_b(self)
    
    def operation_b(self) -> str:
        return "B"

# Visitor interface
class Visitor(ABC):
    @abstractmethod
    def visit_concrete_element_a(self, element: ConcreteElementA) -> None:
        pass
    
    @abstractmethod
    def visit_concrete_element_b(self, element: ConcreteElementB) -> None:
        pass

# Concrete Visitors
class ConcreteVisitor1(Visitor):
    def visit_concrete_element_a(self, element: ConcreteElementA) -> None:
        print(f"Visitor1: {element.operation_a()}")
    
    def visit_concrete_element_b(self, element: ConcreteElementB) -> None:
        print(f"Visitor1: {element.operation_b()}")

class ConcreteVisitor2(Visitor):
    def visit_concrete_element_a(self, element: ConcreteElementA) -> None:
        print(f"Visitor2: {element.operation_a()}")
    
    def visit_concrete_element_b(self, element: ConcreteElementB) -> None:
        print(f"Visitor2: {element.operation_b()}")
```

## Применение
В реальных приложениях Посетитель часто используется для:
- Операций над сложными структурами объектов (деревья XML, AST компиляторов)
- Добавления функционала к существующим классам без их изменения
- Организации функционала в отдельные классы по принципу единой ответственности
- Обработки разнородных объектов с разными интерфейсами
- Реализации операций формирования отчетов по различным бизнес-объектам
- Парсинга и валидации сложных структур данных

## Плюсы
1. Соблюдение принципа открытости/закрытости: можно добавлять новые операции без изменения классов элементов
2. Объединение родственных операций в одном классе
3. Накопление состояния в процессе обхода объектной структуры
4. Упрощение добавления новых операций
5. Централизованное место для алгоритмов, работающих с различными классами

## Минусы
1. Нарушение инкапсуляции — посетитель может требовать доступа к деталям элементов
2. Сложность добавления новых классов элементов — требуется обновить все существующие посетители
3. Может привести к сложной иерархии классов при большом количестве элементов и посетителей
4. Проблемы с двойной диспетчеризацией в некоторых языках
5. Негибкость при необходимости новых типов элементов

## Когда использовать
- Когда необходимо выполнять операции над объектами, но не хочется загрязнять их классы новыми методами
- Когда операции должны выполняться над объектами разных типов с разными интерфейсами
- Когда классы элементов редко меняются, но часто появляются новые операции над ними
- Когда нужно собирать статистику по сложной объектной структуре
- Когда алгоритмы часто меняются и должны быть выделены в отдельные классы