# Документирование кода в Python

## Содержание
1. [Введение в документирование кода](#введение-в-документирование-кода)
2. [Docstrings в Python](#docstrings-в-python)
3. [Стили документирования](#стили-документирования)
4. [Автоматическая генерация документации с Sphinx](#автоматическая-генерация-документации-с-sphinx)
5. [Расширенные возможности Sphinx](#расширенные-возможности-sphinx)
6. [Документирование проектов с помощью Read the Docs](#документирование-проектов-с-помощью-read-the-docs)
7. [Типизация в Python и аннотации типов](#типизация-в-python-и-аннотации-типов)
8. [Практические задания](#практические-задания)
9. [Мини-проект: Документирование библиотеки](#мини-проект-документирование-библиотеки)

## Введение в документирование кода

Документирование кода — это процесс добавления пояснений и комментариев к исходному коду программы, чтобы сделать его более понятным для разработчиков, пользователей и других заинтересованных лиц. Документация кода играет важную роль в разработке программного обеспечения, особенно в проектах, над которыми работает несколько разработчиков или которые развиваются в течение длительного времени.

### Почему документирование кода важно?

1. **Улучшение понимания** — хорошая документация делает код более понятным для других разработчиков (и для вас самих через некоторое время).
2. **Упрощение сопровождения** — документация упрощает внесение изменений и исправление ошибок в коде.
3. **Облегчение использования** — документация API помогает пользователям понять, как использовать ваш код.
4. **Сохранение знаний** — документация фиксирует дизайн и решения, принятые в ходе разработки.
5. **Повышение качества кода** — процесс написания документации часто выявляет проблемы и недостатки в дизайне.

### Типы документации кода

1. **Комментарии в коде** — краткие пояснения отдельных частей кода.
2. **Docstrings** — строки документации, встроенные в код для описания модулей, классов, функций и методов.
3. **API-документация** — подробное описание интерфейсов программирования приложений.
4. **Руководства и учебники** — пошаговые инструкции по использованию кода.
5. **Примеры кода** — демонстрация использования кода в различных сценариях.
6. **Архитектурная документация** — описание высокоуровневого дизайна и структуры проекта.

### Принципы хорошей документации

1. **Ясность** — документация должна быть понятной и недвусмысленной.
2. **Полнота** — документация должна охватывать все важные аспекты кода.
3. **Краткость** — документация должна быть лаконичной, без лишней информации.
4. **Актуальность** — документация должна поддерживаться в актуальном состоянии.
5. **Доступность** — документация должна быть легко доступной для целевой аудитории.
6. **Консистентность** — документация должна следовать единому стилю и формату.

## Docstrings в Python

Docstrings (строки документации) — это строки, размещаемые в определенных местах кода Python, которые описывают модули, классы, функции или методы. Они играют важную роль в документировании Python-кода и могут быть доступны через встроенную функцию `help()` или атрибут `__doc__`.

### Синтаксис docstrings

Docstrings могут быть определены с использованием тройных кавычек (одинарных или двойных) и должны быть первым выражением в определении модуля, класса, функции или метода.

```python
def add(a, b):
    """
    Возвращает сумму двух чисел.
    
    Args:
        a: Первое число.
        b: Второе число.
        
    Returns:
        Сумма a и b.
    """
    return a + b
```

### Доступ к docstrings

Можно получить доступ к docstrings через атрибут `__doc__` или функцию `help()`:

```python
# Через атрибут __doc__
print(add.__doc__)

# Через функцию help()
help(add)
```

### Многострочные и однострочные docstrings

**Однострочные docstrings** используются для простых функций или методов:

```python
def square(n):
    """Возвращает квадрат числа n."""
    return n ** 2
```

**Многострочные docstrings** используются для более сложных функций, классов или модулей:

```python
def calculate_statistics(numbers):
    """
    Рассчитывает базовую статистику для списка чисел.
    
    Эта функция вычисляет среднее значение, медиану, минимум,
    максимум и стандартное отклонение для заданного списка чисел.
    
    Args:
        numbers (list): Список чисел.
        
    Returns:
        dict: Словарь с рассчитанными статистическими показателями.
        
    Raises:
        ValueError: Если список пуст.
    """
    if not numbers:
        raise ValueError("Список чисел не может быть пустым")
    
    # ... код вычисления статистики ...
    
    return statistics
```

### Документирование модулей

Docstring модуля должен быть размещен в начале файла, после импортов, но перед остальным кодом:

```python
"""
Модуль utilities предоставляет набор вспомогательных функций
для работы с данными и файлами.

Этот модуль включает функции для:
    - Чтения данных из различных форматов файлов
    - Обработки и преобразования данных
    - Сохранения результатов
"""

import os
import json
import csv

# Остальной код модуля...
```

### Документирование классов

Docstring класса должен описывать назначение класса и его основные характеристики:

```python
class DataProcessor:
    """
    Класс для обработки и анализа данных.
    
    DataProcessor предоставляет методы для загрузки, преобразования,
    анализа и сохранения данных. Он поддерживает различные форматы
    данных, включая CSV, JSON и Excel.
    
    Attributes:
        data (pandas.DataFrame): Данные для обработки.
        config (dict): Конфигурационные параметры.
    """
    
    def __init__(self, data=None, config=None):
        """
        Инициализирует новый экземпляр DataProcessor.
        
        Args:
            data (pandas.DataFrame, optional): Исходные данные.
            config (dict, optional): Конфигурационные параметры.
        """
        self.data = data
        self.config = config or {}
```

### Документирование методов

Docstring метода аналогичен docstring функции, но может ссылаться на атрибуты класса:

```python
def process_data(self, transformations=None):
    """
    Применяет указанные преобразования к данным.
    
    Args:
        transformations (list, optional): Список функций преобразования.
            Если None, используются преобразования из self.config.
            
    Returns:
        pandas.DataFrame: Обработанные данные.
        
    Raises:
        ValueError: Если данные не были загружены.
    """
    if self.data is None:
        raise ValueError("Данные не загружены")
    
    # ... код преобразования данных ...
    
    return transformed_data
```

## Стили документирования

В Python существует несколько распространенных стилей форматирования docstrings. Каждый стиль имеет свои особенности и преимущества. Выбор стиля часто зависит от предпочтений команды разработчиков или соглашений проекта.

### Google Style

Стиль Google использует разделы с названиями и отступами для описания аргументов, возвращаемых значений и исключений.

```python
def fetch_data(url, timeout=30, max_retries=3):
    """
    Получает данные с указанного URL.
    
    Args:
        url (str): URL для запроса данных.
        timeout (int, optional): Время ожидания в секундах. По умолчанию 30.
        max_retries (int, optional): Максимальное количество попыток. По умолчанию 3.
    
    Returns:
        dict: Данные, полученные от сервера в формате JSON.
    
    Raises:
        ConnectionError: Если не удается подключиться к серверу.
        TimeoutError: Если сервер не отвечает в течение timeout секунд.
        ValueError: Если URL имеет неверный формат.
    
    Examples:
        >>> data = fetch_data('https://api.example.com/data')
        >>> print(data['status'])
        'success'
    """
    # Реализация функции...
```

### NumPy/SciPy Style

Стиль NumPy/SciPy использует reStructuredText (reST) разметку и секции, обозначенные подчеркиванием.

```python
def fetch_data(url, timeout=30, max_retries=3):
    """
    Получает данные с указанного URL.
    
    Parameters
    ----------
    url : str
        URL для запроса данных.
    timeout : int, optional
        Время ожидания в секундах. По умолчанию 30.
    max_retries : int, optional
        Максимальное количество попыток. По умолчанию 3.
    
    Returns
    -------
    dict
        Данные, полученные от сервера в формате JSON.
    
    Raises
    ------
    ConnectionError
        Если не удается подключиться к серверу.
    TimeoutError
        Если сервер не отвечает в течение timeout секунд.
    ValueError
        Если URL имеет неверный формат.
    
    Examples
    --------
    >>> data = fetch_data('https://api.example.com/data')
    >>> print(data['status'])
    'success'
    """
    # Реализация функции...
```

### reStructuredText (reST) Style

Стиль reST, используемый в Sphinx, применяет явную разметку reStructuredText для форматирования.

```python
def fetch_data(url, timeout=30, max_retries=3):
    """
    Получает данные с указанного URL.
    
    :param url: URL для запроса данных.
    :type url: str
    :param timeout: Время ожидания в секундах. По умолчанию 30.
    :type timeout: int, optional
    :param max_retries: Максимальное количество попыток. По умолчанию 3.
    :type max_retries: int, optional
    
    :return: Данные, полученные от сервера в формате JSON.
    :rtype: dict
    
    :raises ConnectionError: Если не удается подключиться к серверу.
    :raises TimeoutError: Если сервер не отвечает в течение timeout секунд.
    :raises ValueError: Если URL имеет неверный формат.
    
    .. code-block:: python
    
        >>> data = fetch_data('https://api.example.com/data')
        >>> print(data['status'])
        'success'
    """
    # Реализация функции...
```

### Epydoc Style

Стиль Epydoc использует теги для обозначения различных элементов документации.

```python
def fetch_data(url, timeout=30, max_retries=3):
    """
    Получает данные с указанного URL.
    
    @param url: URL для запроса данных.
    @type url: str
    @param timeout: Время ожидания в секундах. По умолчанию 30.
    @type timeout: int
    @param max_retries: Максимальное количество попыток. По умолчанию 3.
    @type max_retries: int
    
    @return: Данные, полученные от сервера в формате JSON.
    @rtype: dict
    
    @raise ConnectionError: Если не удается подключиться к серверу.
    @raise TimeoutError: Если сервер не отвечает в течение timeout секунд.
    @raise ValueError: Если URL имеет неверный формат.
    
    @example:
        >>> data = fetch_data('https://api.example.com/data')
        >>> print(data['status'])
        'success'
    """
    # Реализация функции...
```

### Сравнение стилей и рекомендации

Каждый стиль имеет свои преимущества:

- **Google Style**: легко читается как в исходном коде, так и в сгенерированной документации, относительно компактный.
- **NumPy/SciPy Style**: хорошо подходит для научных проектов, имеет более строгую структуру.
- **reStructuredText Style**: полная интеграция со Sphinx, более гибкое форматирование.
- **Epydoc Style**: простой синтаксис с тегами, но менее популярен в новых проектах.

Рекомендации по выбору стиля:

1. **Согласованность** — используйте один стиль во всем проекте.
2. **Соответствие экосистеме** — выбирайте стиль, популярный в вашей области (например, NumPy style для научных проектов).
3. **Интеграция с инструментами** — учитывайте, какие инструменты генерации документации вы планируете использовать.
4. **Google или NumPy** — эти два стиля наиболее популярны и хорошо поддерживаются современными инструментами.

## Автоматическая генерация документации с Sphinx

Sphinx — это мощный инструмент для создания документации из docstrings и дополнительных файлов документации. Он используется для документирования самого Python и многих других проектов.

### Установка Sphinx

```bash
pip install sphinx sphinx-rtd-theme
```

### Создание проекта документации

Для создания нового проекта документации используйте команду `sphinx-quickstart`:

```bash
mkdir docs
cd docs
sphinx-quickstart
```

Вам будет предложено ответить на несколько вопросов:

- Разделить исходники и сборку (рекомендуется: да)
- Имя проекта
- Автор(ы)
- Версия проекта
- Язык документации (по умолчанию: en)

### Структура проекта Sphinx

После запуска `sphinx-quickstart` будет создана следующая структура:

```
docs/
├── build/      # Сгенерированная документация
├── make.bat    # Скрипт сборки для Windows
├── Makefile    # Скрипт сборки для Unix/Linux
└── source/     # Исходники документации
    ├── _static/      # Статические файлы (CSS, изображения)
    ├── _templates/   # Шаблоны HTML
    ├── conf.py       # Конфигурационный файл Sphinx
    └── index.rst     # Корневой файл документации
```

### Настройка Sphinx для автоматической документации кода

Для автоматической генерации документации из docstrings нужно настроить Sphinx. Отредактируйте файл `conf.py`:

```python
# Добавьте эти строки в начало файла
import os
import sys
sys.path.insert(0, os.path.abspath('../..'))  # Путь к вашему Python пакету

# Расширения Sphinx
extensions = [
    'sphinx.ext.autodoc',     # Автоматическая документация из docstrings
    'sphinx.ext.viewcode',    # Добавление ссылок на исходный код
    'sphinx.ext.napoleon',    # Поддержка Google и NumPy стилей docstrings
    'sphinx.ext.intersphinx', # Ссылки на документацию других проектов
    'sphinx.ext.todo',        # Поддержка TODO заметок
]

# Настройка темы
html_theme = 'sphinx_rtd_theme'  # Тема Read the Docs
```

### Создание файлов документации модулей

Создайте файл `modules.rst` в директории `source` для документирования модулей:

```rst
Модули
======

.. toctree::
   :maxdepth: 4

   mypackage
```

Создайте файл `mypackage.rst` для документирования пакета:

```rst
mypackage package
=================

Submodules
----------

mypackage.module1 module
------------------------

.. automodule:: mypackage.module1
   :members:
   :undoc-members:
   :show-inheritance:

mypackage.module2 module
------------------------

.. automodule:: mypackage.module2
   :members:
   :undoc-members:
   :show-inheritance:
```

### Сборка документации

Для сборки документации используйте команду:

```bash
cd docs
make html
```

После сборки документация будет доступна в директории `build/html`. Откройте файл `index.html` в браузере, чтобы просмотреть документацию.

### Директивы autodoc

Sphinx autodoc предоставляет несколько директив для включения документации из docstrings:

- `.. automodule::` — документирует модуль
- `.. autoclass::` — документирует класс
- `.. autofunction::` — документирует функцию
- `.. automethod::` — документирует метод класса
- `.. autoattribute::` — документирует атрибут класса

```rst
.. automodule:: mypackage.module1
   :members:         # Включить все общедоступные объекты модуля
   :undoc-members:   # Включить объекты без docstrings
   :show-inheritance: # Показать информацию о наследовании классов
   :private-members: # Включить приватные объекты (_name)
   :special-members: # Включить специальные объекты (__name__)
```

## Расширенные возможности Sphinx

Sphinx предоставляет множество расширенных возможностей для создания профессиональной документации.

### Перекрестные ссылки

Sphinx позволяет создавать перекрестные ссылки между различными частями документации:

```rst
См. функцию :func:`mypackage.module1.some_function` для дополнительной информации.

Класс :class:`mypackage.module2.SomeClass` предоставляет расширенные возможности.
```

### Использование математических формул

С помощью расширения `sphinx.ext.mathjax` можно добавлять математические формулы в документацию:

```rst
.. math::

   E = mc^2
```

Добавьте `'sphinx.ext.mathjax'` в список расширений в `conf.py`.

### Включение примеров кода

Для включения примеров кода используйте директиву `.. code-block::`:

```rst
.. code-block:: python

   def example():
       """Пример функции."""
       return "Hello, World!"
```

### Интерактивные примеры с doctest

Расширение `sphinx.ext.doctest` позволяет проверять примеры кода в документации:

```rst
.. doctest::

   >>> 2 + 2
   4
   >>> print("Hello")
   Hello
```

### Автоматическая проверка ссылок

Расширение `sphinx.ext.linkcheck` проверяет все внешние ссылки в документации:

```bash
make linkcheck
```

### Поддержка различных форматов вывода

Sphinx может генерировать документацию в различных форматах:

```bash
make html       # HTML
make latexpdf   # PDF через LaTeX
make epub       # EPUB для электронных книг
make text       # Простой текст
```

### Темы оформления

Sphinx поддерживает различные темы для оформления HTML-документации:

```python
# В conf.py
html_theme = 'sphinx_rtd_theme'  # Read the Docs
# или
html_theme = 'alabaster'         # Alabaster (по умолчанию)
# или
html_theme = 'sphinx_book_theme' # Интерактивная тема (требует установки)
```

### Создание собственных расширений

Sphinx позволяет создавать собственные расширения для специфических нужд:

```python
# myext.py
from docutils import nodes
from docutils.parsers.rst import Directive

class TodoDirective(Directive):
    has_content = True
    
    def run(self):
        para = nodes.paragraph()
        para += nodes.strong(text='TODO: ')
        para += nodes.Text(' '.join(self.content))
        return [para]

def setup(app):
    app.add_directive('todo', TodoDirective)
    return {
        'version': '0.1',
        'parallel_read_safe': True,
        'parallel_write_safe': True,
    }
```

Затем добавьте путь к расширению в `conf.py`:

```python
extensions = [
    # ...
    'myext',
]
```

## Документирование проектов с помощью Read the Docs

Read the Docs — это бесплатный хостинг для документации проектов с открытым исходным кодом, который автоматически собирает и публикует документацию из репозитория.

### Подготовка проекта для Read the Docs

1. **Создайте файл `.readthedocs.yml`** в корне проекта:

```yaml
# .readthedocs.yml
version: 2

sphinx:
  configuration: docs/source/conf.py

python:
  version: 3.8
  install:
    - requirements: docs/requirements.txt
    - method: pip
      path: .
```

2. **Создайте файл `docs/requirements.txt`** с зависимостями для документации:

```
sphinx>=4.0.0
sphinx-rtd-theme>=1.0.0
# Другие необходимые пакеты
```

### Интеграция с GitHub

1. Разместите ваш проект на GitHub.
2. Зарегистрируйтесь на [Read the Docs](https://readthedocs.org/).
3. Импортируйте ваш репозиторий в Read the Docs.
4. Read the Docs автоматически настроит вебхуки для сборки документации при каждом коммите.

### Настройка версий документации

Read the Docs автоматически создает документацию для каждой ветки и тега в репозитории. Вы можете настраивать активные версии в панели управления проектом.

### Собственный домен

Можно настроить собственный домен для документации вашего проекта:

1. В панели управления проектом перейдите в раздел Admin -> Domains.
2. Добавьте свой домен (например, `docs.myproject.com`).
3. Настройте DNS-записи в соответствии с инструкциями.

### Отслеживание изменений в ветках

Read the Docs позволяет автоматически отслеживать изменения в разных ветках репозитория:

```yaml
# .readthedocs.yml
version: 2

sphinx:
  configuration: docs/source/conf.py

python:
  version: 3.8
  install:
    - requirements: docs/requirements.txt
    - method: pip
      path: .

# Настройка отслеживаемых веток
branches:
  only:
    - main     # Основная ветка
    - develop  # Ветка разработки
    - /^v\d+\.\d+\.x$/  # Регулярное выражение для веток выпусков
```

## Типизация в Python и аннотации типов

С Python 3.5 была введена система аннотаций типов, которая позволяет указывать ожидаемые типы аргументов и возвращаемых значений функций. Это улучшает документацию и позволяет использовать инструменты статического анализа кода.

### Основы аннотаций типов

```python
def greet(name: str) -> str:
    """
    Возвращает приветствие для указанного имени.
    
    Args:
        name: Имя для приветствия.
        
    Returns:
        Строка приветствия.
    """
    return f"Hello, {name}!"
```

### Использование типов из модуля typing

Модуль `typing` предоставляет расширенные типы для аннотаций:

```python
from typing import List, Dict, Tuple, Optional, Union, Any, Callable

def process_data(
    items: List[Dict[str, Any]],
    transform_func: Callable[[Dict[str, Any]], Dict[str, Any]],
    filter_key: Optional[str] = None
) -> Tuple[List[Dict[str, Any]], int]:
    """
    Обрабатывает список элементов.
    
    Args:
        items: Список словарей для обработки.
        transform_func: Функция преобразования элементов.
        filter_key: Ключ для фильтрации. Если None, фильтрация не применяется.
        
    Returns:
        Кортеж из обработанного списка и количества обработанных элементов.
    """
    result = []
    
    for item in items:
        transformed = transform_func(item)
        
        if filter_key is None or filter_key in transformed:
            result.append(transformed)
    
    return result, len(result)
```

### Документирование классов с аннотациями типов

```python
from typing import List, Dict, Optional, Any

class DataProcessor:
    """
    Класс для обработки данных.
    
    Attributes:
        data: Данные для обработки.
        config: Конфигурационные параметры.
    """
    
    def __init__(self, data: List[Dict[str, Any]], config: Optional[Dict[str, Any]] = None) -> None:
        """
        Инициализирует новый экземпляр DataProcessor.
        
        Args:
            data: Исходные данные для обработки.
            config: Конфигурационные параметры. По умолчанию None.
        """
        self.data = data
        self.config = config or {}
    
    def process(self) -> List[Dict[str, Any]]:
        """
        Обрабатывает данные согласно конфигурации.
        
        Returns:
            Обработанные данные.
        """
        # ... код обработки данных ...
        return processed_data
```

### Интеграция аннотаций типов с документацией

Аннотации типов автоматически интегрируются со Sphinx через расширение `sphinx.ext.autodoc`:

```python
# В conf.py
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.napoleon',
]

# Опционально: явно указать обработку аннотаций типов
autodoc_typehints = 'description'  # Включить аннотации типов в описание
# или
autodoc_typehints = 'signature'    # Включить аннотации типов в сигнатуру функции
```

### Проверка типов с mypy

Инструмент `mypy` позволяет проверять соответствие аннотаций типов в коде:

```bash
pip install mypy
mypy mypackage/
```

Пример файла конфигурации `mypy.ini`:

```ini
[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = False
disallow_incomplete_defs = False

[mypy.plugins.numpy.ndarray]
plugin_is_instance = True
```

## Практические задания

### Задание 1: Документирование функций и классов

Напишите документацию для следующих функций и классов:

```python
def calculate_statistics(numbers):
    if not numbers:
        raise ValueError("Empty list provided")
    
    stats = {
        "count": len(numbers),
        "sum": sum(numbers),
        "mean": sum(numbers) / len(numbers),
        "min": min(numbers),
        "max": max(numbers)
    }
    
    # Calculate median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    mid = n // 2
    
    if n % 2 == 0:
        stats["median"] = (sorted_numbers[mid-1] + sorted_numbers[mid]) / 2
    else:
        stats["median"] = sorted_numbers[mid]
    
    # Calculate standard deviation
    variance = sum((x - stats["mean"]) ** 2 for x in numbers) / len(numbers)
    stats["std_dev"] = variance ** 0.5
    
    return stats


class DataAnalyzer:
    def __init__(self, data=None):
        self.data = data or []
        self.results = {}
    
    def load_data_from_file(self, filename, delimiter=','):
        with open(filename, 'r') as file:
            self.data = []
            for line in file:
                values = line.strip().split(delimiter)
                try:
                    numeric_values = [float(value) for value in values]
                    self.data.append(numeric_values)
                except ValueError:
                    # Skip header or non-numeric lines
                    continue
        return len(self.data)
    
    def analyze_column(self, column_index):
        if not self.data:
            raise ValueError("No data loaded")
        
        if column_index < 0 or (self.data and column_index >= len(self.data[0])):
            raise IndexError(f"Column index {column_index} out of range")
        
        column_data = [row[column_index] for row in self.data if column_index < len(row)]
        self.results[column_index] = calculate_statistics(column_data)
        return self.results[column_index]
    
    def get_correlation(self, column1, column2):
        if not self.data:
            raise ValueError("No data loaded")
        
        if column1 not in self.results:
            self.analyze_column(column1)
        if column2 not in self.results:
            self.analyze_column(column2)
        
        col1_data = [row[column1] for row in self.data if column1 < len(row)]
        col2_data = [row[column2] for row in self.data if column2 < len(row)]
        
        if len(col1_data) != len(col2_data):
            # Use only rows with both columns
            valid_indices = [i for i, row in enumerate(self.data) 
                            if column1 < len(row) and column2 < len(row)]
            col1_data = [self.data[i][column1] for i in valid_indices]
            col2_data = [self.data[i][column2] for i in valid_indices]
        
        n = len(col1_data)
        mean1 = self.results[column1]["mean"]
        mean2 = self.results[column2]["mean"]
        std1 = self.results[column1]["std_dev"]
        std2 = self.results[column2]["std_dev"]
        
        if std1 == 0 or std2 == 0:
            return 0  # No correlation if either column has no variation
        
        covariance = sum((col1_data[i] - mean1) * (col2_data[i] - mean2) for i in range(n)) / n
        correlation = covariance / (std1 * std2)
        
        return correlation
```

#### Решение

```python
def calculate_statistics(numbers):
    """
    Рассчитывает статистические показатели для списка чисел.
    
    Эта функция вычисляет следующие статистические показатели:
    - количество элементов
    - сумму элементов
    - среднее значение
    - минимум
    - максимум
    - медиану
    - стандартное отклонение
    
    Args:
        numbers (list): Список чисел для анализа.
        
    Returns:
        dict: Словарь с рассчитанными статистическими показателями:
            - count: количество элементов
            - sum: сумма элементов
            - mean: среднее арифметическое
            - min: минимальное значение
            - max: максимальное значение
            - median: медиана
            - std_dev: стандартное отклонение
            
    Raises:
        ValueError: Если передан пустой список.
        
    Examples:
        >>> calculate_statistics([1, 2, 3, 4, 5])
        {'count': 5, 'sum': 15, 'mean': 3.0, 'min': 1, 'max': 5, 'median': 3, 'std_dev': 1.4142135623730951}
    """
    if not numbers:
        raise ValueError("Empty list provided")
    
    stats = {
        "count": len(numbers),
        "sum": sum(numbers),
        "mean": sum(numbers) / len(numbers),
        "min": min(numbers),
        "max": max(numbers)
    }
    
    # Calculate median
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    mid = n // 2
    
    if n % 2 == 0:
        stats["median"] = (sorted_numbers[mid-1] + sorted_numbers[mid]) / 2
    else:
        stats["median"] = sorted_numbers[mid]
    
    # Calculate standard deviation
    variance = sum((x - stats["mean"]) ** 2 for x in numbers) / len(numbers)
    stats["std_dev"] = variance ** 0.5
    
    return stats


class DataAnalyzer:
    """
    Класс для анализа числовых данных.
    
    DataAnalyzer предоставляет методы для загрузки данных из файла,
    анализа отдельных столбцов и вычисления корреляции между столбцами.
    
    Attributes:
        data (list): Список списков с числовыми данными. Каждый внутренний список 
                    представляет одну строку данных.
        results (dict): Словарь с результатами анализа. Ключи - индексы столбцов,
                    значения - словари со статистическими показателями.
    """
    
    def __init__(self, data=None):
        """
        Инициализирует новый экземпляр DataAnalyzer.
        
        Args:
            data (list, optional): Исходные данные для анализа. Должны быть представлены
                                  в виде списка списков (список строк, где каждая строка - 
                                  список числовых значений). По умолчанию пустой список.
        """
        self.data = data or []
        self.results = {}
    
    def load_data_from_file(self, filename, delimiter=','):
        """
        Загружает данные из текстового файла.
        
        Читает файл построчно, разделяет каждую строку по указанному разделителю,
        преобразует значения в числа и добавляет в self.data. Строки, содержащие
        нечисловые значения (например, заголовки), пропускаются.
        
        Args:
            filename (str): Путь к файлу с данными.
            delimiter (str, optional): Разделитель значений в файле. По умолчанию ','.
            
        Returns:
            int: Количество загруженных строк данных.
            
        Raises:
            FileNotFoundError: Если файл не найден.
            PermissionError: Если нет прав на чтение файла.
        """
        with open(filename, 'r') as file:
            self.data = []
            for line in file:
                values = line.strip().split(delimiter)
                try:
                    numeric_values = [float(value) for value in values]
                    self.data.append(numeric_values)
                except ValueError:
                    # Skip header or non-numeric lines
                    continue
        return len(self.data)
    
    def analyze_column(self, column_index):
        """
        Анализирует указанный столбец данных.
        
        Извлекает значения из указанного столбца и вычисляет для них
        статистические показатели с помощью функции calculate_statistics.
        Результаты сохраняются в self.results.
        
        Args:
            column_index (int): Индекс столбца для анализа (начиная с 0).
            
        Returns:
            dict: Словарь со статистическими показателями для столбца.
            
        Raises:
            ValueError: Если данные не загружены.
            IndexError: Если индекс столбца выходит за пределы допустимого диапазона.
        """
        if not self.data:
            raise ValueError("No data loaded")
        
        if column_index < 0 or (self.data and column_index >= len(self.data[0])):
            raise IndexError(f"Column index {column_index} out of range")
        
        column_data = [row[column_index] for row in self.data if column_index < len(row)]
        self.results[column_index] = calculate_statistics(column_data)
        return self.results[column_index]
    
    def get_correlation(self, column1, column2):
        """
        Вычисляет коэффициент корреляции Пирсона между двумя столбцами.
        
        Если статистические показатели для указанных столбцов еще не вычислены,
        сначала вызывается метод analyze_column для каждого столбца.
        
        Args:
            column1 (int): Индекс первого столбца.
            column2 (int): Индекс второго столбца.
            
        Returns:
            float: Коэффициент корреляции Пирсона. Значение от -1 до 1, где:
                  1 - полная положительная корреляция,
                  0 - отсутствие корреляции,
                  -1 - полная отрицательная корреляция.
            
        Raises:
            ValueError: Если данные не загружены.
        """
        if not self.data:
            raise ValueError("No data loaded")
        
        if column1 not in self.results:
            self.analyze_column(column1)
        if column2 not in self.results:
            self.analyze_column(column2)
        
        col1_data = [row[column1] for row in self.data if column1 < len(row)]
        col2_data = [row[column2] for row in self.data if column2 < len(row)]
        
        if len(col1_data) != len(col2_data):
            # Use only rows with both columns
            valid_indices = [i for i, row in enumerate(self.data) 
                            if column1 < len(row) and column2 < len(row)]
            col1_data = [self.data[i][column1] for i in valid_indices]
            col2_data = [self.data[i][column2] for i in valid_indices]
        
        n = len(col1_data)
        mean1 = self.results[column1]["mean"]
        mean2 = self.results[column2]["mean"]
        std1 = self.results[column1]["std_dev"]
        std2 = self.results[column2]["std_dev"]
        
        if std1 == 0 or std2 == 0:
            return 0  # No correlation if either column has no variation
        
        covariance = sum((col1_data[i] - mean1) * (col2_data[i] - mean2) for i in range(n)) / n
        correlation = covariance / (std1 * std2)
        
        return correlation
```

### Задание 2: Создание документации с использованием Sphinx

1. Создайте простой Python пакет с 2-3 модулями.
2. Добавьте полную документацию к функциям и классам пакета.
3. Настройте Sphinx для генерации документации из docstrings.
4. Сгенерируйте HTML-документацию.

#### Решение

Создадим простой Python пакет с математическими утилитами. Структура пакета:

```
mathutils/
├── __init__.py
├── stats.py
├── algebra.py
├── docs/
    ├── source/
    │   ├── conf.py
    │   ├── index.rst
    │   └── modules.rst
    └── Makefile
```

**mathutils/\_\_init\_\_.py**:

```python
"""
MathUtils - пакет для работы с математическими операциями.

Этот пакет предоставляет модули для работы со статистикой
и алгебраическими операциями.
"""

__version__ = '0.1.0'
```

**mathutils/stats.py**:

```python
"""
Модуль для статистических вычислений.

Этот модуль предоставляет функции для расчета различных
статистических показателей, таких как среднее, медиана,
стандартное отклонение и т.д.
"""

def mean(numbers):
    """
    Вычисляет среднее арифметическое списка чисел.
    
    Args:
        numbers (list): Список чисел.
        
    Returns:
        float: Среднее арифметическое.
        
    Raises:
        ValueError: Если список пуст.
        
    Examples:
        >>> mean([1, 2, 3, 4, 5])
        3.0
    """
    if not numbers:
        raise ValueError("Empty list provided")
    return sum(numbers) / len(numbers)

def median(numbers):
    """
    Вычисляет медиану списка чисел.
    
    Args:
        numbers (list): Список чисел.
        
    Returns:
        float: Медиана. Если длина списка четная, возвращается
              среднее арифметическое двух средних значений.
        
    Raises:
        ValueError: Если список пуст.
        
    Examples:
        >>> median([1, 2, 3, 4, 5])
        3
        >>> median([1, 2, 3, l4])
        2.5
    """
    if not numbers:
        raise ValueError("Empty list provided")
    
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    mid = n // 2
    
    if n % 2 == 0:
        return (sorted_numbers[mid-1] + sorted_numbers[mid]) / 2
    else:
        return sorted_numbers[mid]

def standard_deviation(numbers):
    """
    Вычисляет стандартное отклонение списка чисел.
    
    Args:
        numbers (list): Список чисел.
        
    Returns:
        float: Стандартное отклонение.
        
    Raises:
        ValueError: Если список пуст.
        
    Examples:
        >>> standard_deviation([1, 2, 3, 4, 5])
        1.4142135623730951
    """
    if not numbers:
        raise ValueError("Empty list provided")
    
    avg = mean(numbers)
    variance = sum((x - avg) ** 2 for x in numbers) / len(numbers)
    return variance ** 0.5

class StatisticsCalculator:
    """
    Класс для расчета статистических показателей.
    
    Attributes:
        data (list): Список чисел для анализа.
        results (dict): Словарь с результатами расчетов.
    """
    
    def __init__(self, data=None):
        """
        Инициализирует новый экземпляр StatisticsCalculator.
        
        Args:
            data (list, optional): Исходные данные. По умолчанию пустой список.
        """
        self.data = data or []
        self.results = {}
    
    def add_data(self, value):
        """
        Добавляет новое значение в набор данных.
        
        Args:
            value (float): Значение для добавления.
        """
        self.data.append(value)
        self.results = {}  # Сбрасываем результаты
    
    def calculate_all(self):
        """
        Рассчитывает все статистические показатели.
        
        Returns:
            dict: Словарь с рассчитанными показателями.
        
        Raises:
            ValueError: Если данные не загружены.
        """
        if not self.data:
            raise ValueError("No data available")
        
        self.results = {
            "count": len(self.data),
            "mean": mean(self.data),
            "median": median(self.data),
            "std_dev": standard_deviation(self.data),
            "min": min(self.data),
            "max": max(self.data)
        }
        
        return self.results
```

**mathutils/algebra.py**:

```python
"""
Модуль для алгебраических операций.

Этот модуль предоставляет функции для выполнения
различных алгебраических операций, таких как решение
уравнений и работа с матрицами.
"""

def solve_quadratic(a, b, c):
    """
    Решает квадратное уравнение ax^2 + bx + c = 0.
    
    Args:
        a (float): Коэффициент a.
        b (float): Коэффициент b.
        c (float): Коэффициент c.
        
    Returns:
        tuple: Кортеж с корнями уравнения. Если корней нет, возвращается
               пустой кортеж. Если корень один, он будет повторен дважды.
        
    Raises:
        ValueError: Если a = 0 (не квадратное уравнение).
        
    Examples:
        >>> solve_quadratic(1, -3, 2)
        (2.0, 1.0)
        >>> solve_quadratic(1, 2, 1)
        (-1.0, -1.0)
        >>> solve_quadratic(1, 0, 1)
        ()
    """
    if a == 0:
        raise ValueError("Not a quadratic equation (a = 0)")
    
    discriminant = b**2 - 4*a*c
    
    if discriminant < 0:
        return ()
    elif discriminant == 0:
        x = -b / (2*a)
        return (x, x)
    else:
        x1 = (-b + discriminant**0.5) / (2*a)
        x2 = (-b - discriminant**0.5) / (2*a)
        return (x1, x2)

class Matrix:
    """
    Класс для работы с матрицами.
    
    Attributes:
        rows (int): Количество строк.
        cols (int): Количество столбцов.
        data (list): Данные матрицы в виде списка списков.
    """
    
    def __init__(self, data):
        """
        Инициализирует новый экземпляр Matrix.
        
        Args:
            data (list): Данные матрицы в виде списка списков.
            
        Raises:
            ValueError: Если строки матрицы имеют разную длину.
        """
        if not data:
            self.rows = 0
            self.cols = 0
            self.data = []
            return
        
        row_lengths = [len(row) for row in data]
        if min(row_lengths) != max(row_lengths):
            raise ValueError("All rows must have the same length")
        
        self.rows = len(data)
        self.cols = row_lengths[0] if self.rows > 0 else 0
        self.data = [row[:] for row in data]  # Создаем копию данных
    
    def transpose(self):
        """
        Возвращает транспонированную матрицу.
        
        Returns:
            Matrix: Новая транспонированная матрица.
        """
        if not self.data:
            return Matrix([])
        
        transposed_data = [[self.data[i][j] for i in range(self.rows)] 
                           for j in range(self.cols)]
        
        return Matrix(transposed_data)
    
    def __add__(self, other):
        """
        Складывает две матрицы.
        
        Args:
            other (Matrix): Другая матрица для сложения.
            
        Returns:
            Matrix: Результат сложения матриц.
            
        Raises:
            ValueError: Если размеры матриц не совпадают.
        """
        if self.rows != other.rows or self.cols != other.cols:
            raise ValueError("Matrix dimensions must match for addition")
        
        result_data = [[self.data[i][j] + other.data[i][j] 
                        for j in range(self.cols)] 
                        for i in range(self.rows)]
        
        return Matrix(result_data)
    
    def __str__(self):
        """
        Возвращает строковое представление матрицы.
        
        Returns:
            str: Строковое представление матрицы.
        """
        if not self.data:
            return "[]"
        
        result = []
        for row in self.data:
            result.append("[" + ", ".join(str(x) for x in row) + "]")
        
        return "[" + ",\n ".join(result) + "]"
```

**docs/source/conf.py**:

```python
import os
import sys
sys.path.insert(0, os.path.abspath('../..'))

# Configuration file for the Sphinx documentation builder.

# -- Project information -----------------------------------------------------

project = 'MathUtils'
copyright = '2023, Example Author'
author = 'Example Author'

# The full version, including alpha/beta/rc tags
release = '0.1.0'

# -- General configuration ---------------------------------------------------

extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.viewcode',
    'sphinx.ext.napoleon',
    'sphinx.ext.todo',
    'sphinx.ext.mathjax',
]

templates_path = ['_templates']
exclude_patterns = []

# -- Options for HTML output -------------------------------------------------

html_theme = 'sphinx_rtd_theme'
html_static_path = ['_static']

# -- Extension configuration -------------------------------------------------

# Napoleon settings
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = True
napoleon_include_private_with_doc = False
napoleon_include_special_with_doc = True
napoleon_use_admonition_for_examples = True
napoleon_use_admonition_for_notes = True
napoleon_use_admonition_for_references = True
napoleon_use_ivar = False
napoleon_use_param = True
napoleon_use_rtype = True
napoleon_preprocess_types = False
napoleon_type_aliases = None
napoleon_attr_annotations = True
```

**docs/source/index.rst**:

```rst
.. MathUtils documentation master file

Добро пожаловать в документацию MathUtils!
==========================================

MathUtils - это простая библиотека для математических вычислений.

.. toctree::
   :maxdepth: 2
   :caption: Содержание:

   modules

Индексы и таблицы
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
```

**docs/source/modules.rst**:

```rst
MathUtils
=========

.. toctree::
   :maxdepth: 4

   mathutils
```

**docs/source/mathutils.rst**:

```rst
mathutils package
================

Submodules
----------

mathutils.algebra module
-----------------------

.. automodule:: mathutils.algebra
   :members:
   :undoc-members:
   :show-inheritance:

mathutils.stats module
---------------------

.. automodule:: mathutils.stats
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
--------------

.. automodule:: mathutils
   :members:
   :undoc-members:
   :show-inheritance:
```

**Сборка документации**:

```bash
cd docs
make html
```

После выполнения команды HTML-документация будет сгенерирована в директории `docs/build/html`. Откройте файл `index.html` в браузере для просмотра документации.

### Задание 3: Добавление аннотаций типов

Добавьте аннотации типов к следующему коду и обновите документацию:

```python
def process_text(text, filters=None, max_length=None):
    """
    Обрабатывает текст с применением фильтров и ограничением длины.
    
    Args:
        text: Текст для обработки.
        filters: Список функций-фильтров для применения к тексту.
        max_length: Максимальная длина результата.
        
    Returns:
        Обработанный текст.
    """
    result = text
    
    if filters:
        for filter_func in filters:
            result = filter_func(result)
    
    if max_length is not None and len(result) > max_length:
        result = result[:max_length]
    
    return result


class TextProcessor:
    def __init__(self, default_filters=None):
        """
        Инициализирует обработчик текста.
        
        Args:
            default_filters: Список функций-фильтров, применяемых по умолчанию.
        """
        self.default_filters = default_filters or []
        self.history = []
    
    def process(self, text, additional_filters=None, save_history=True):
        """
        Обрабатывает текст с применением фильтров.
        
        Args:
            text: Текст для обработки.
            additional_filters: Дополнительные фильтры для применения.
            save_history: Флаг для сохранения истории обработки.
            
        Returns:
            Обработанный текст.
        """
        all_filters = self.default_filters.copy()
        
        if additional_filters:
            all_filters.extend(additional_filters)
        
        result = process_text(text, all_filters)
        
        if save_history:
            self.history.append((text, result))
        
        return result
    
    def get_history(self, max_items=None):
        """
        Возвращает историю обработки.
        
        Args:
            max_items: Максимальное количество элементов для возврата.
            
        Returns:
            Список кортежей (исходный текст, обработанный текст).
        """
        if max_items is None:
            return self.history
        
        return self.history[-max_items:]
```

#### Решение

```python
from typing import List, Tuple, Callable, Optional, Union

def process_text(text: str, 
                filters: Optional[List[Callable[[str], str]]] = None, 
                max_length: Optional[int] = None) -> str:
    """
    Обрабатывает текст с применением фильтров и ограничением длины.
    
    Args:
        text: Текст для обработки.
        filters: Список функций-фильтров для применения к тексту.
        max_length: Максимальная длина результата.
        
    Returns:
        Обработанный текст.
    """
    result = text
    
    if filters:
        for filter_func in filters:
            result = filter_func(result)
    
    if max_length is not None and len(result) > max_length:
        result = result[:max_length]
    
    return result


class TextProcessor:
    """
    Класс для обработки текста с применением фильтров.
    
    Attributes:
        default_filters: Список функций-фильтров, применяемых по умолчанию.
        history: История обработки в виде пар (исходный текст, обработанный текст).
    """
    
    def __init__(self, default_filters: Optional[List[Callable[[str], str]]] = None) -> None:
        """
        Инициализирует обработчик текста.
        
        Args:
            default_filters: Список функций-фильтров, применяемых по умолчанию.
        """
        self.default_filters: List[Callable[[str], str]] = default_filters or []
        self.history: List[Tuple[str, str]] = []
    
    def process(self, 
               text: str, 
               additional_filters: Optional[List[Callable[[str], str]]] = None, 
               save_history: bool = True) -> str:
        """
        Обрабатывает текст с применением фильтров.
        
        Args:
            text: Текст для обработки.
            additional_filters: Дополнительные фильтры для применения.
            save_history: Флаг для сохранения истории обработки.
            
        Returns:
            Обработанный текст.
        """
        all_filters: List[Callable[[str], str]] = self.default_filters.copy()
        
        if additional_filters:
            all_filters.extend(additional_filters)
        
        result: str = process_text(text, all_filters)
        
        if save_history:
            self.history.append((text, result))
        
        return result
    
    def get_history(self, max_items: Optional[int] = None) -> List[Tuple[str, str]]:
        """
        Возвращает историю обработки.
        
        Args:
            max_items: Максимальное количество элементов для возврата.
                      Если None, возвращается вся история.
            
        Returns:
            Список кортежей (исходный текст, обработанный текст).
        """
        if max_items is None:
            return self.history
        
        return self.history[-max_items:]
```

## Мини-проект: Документирование библиотеки

В этом мини-проекте мы создадим и документируем простую библиотеку для работы с геометрическими фигурами.

### Шаг 1: Создание структуры проекта

Создайте следующую структуру проекта:

```
geometry/
├── __init__.py
├── shapes.py
├── utils.py
├── calculations.py
├── docs/
│   ├── source/
│   │   ├── conf.py
│   │   ├── index.rst
│   │   └── modules.rst
│   └── Makefile
└── examples/
    └── basic_usage.py
```

### Шаг 2: Реализация кода библиотеки

**geometry/\_\_init\_\_.py**:

```python
"""
Geometry - библиотека для работы с геометрическими фигурами.

Эта библиотека предоставляет классы и функции для создания,
манипуляции и расчета свойств геометрических фигур, таких как
круги, прямоугольники, треугольники и многоугольники.
"""

from .shapes import Circle, Rectangle, Triangle, Polygon
from .calculations import calculate_area, calculate_perimeter

__version__ = '0.1.0'
```

**geometry/shapes.py**:

```python
"""
Модуль, содержащий классы геометрических фигур.

Этот модуль предоставляет классы для представления различных
геометрических фигур, таких как круги, прямоугольники,
треугольники и многоугольники.
"""
from typing import List, Tuple, Optional, Union, Dict, Any
import math
from .utils import distance, is_valid_triangle

class Shape:
    """
    Базовый класс для всех геометрических фигур.
    
    Attributes:
        name (str): Название фигуры.
    """
    
    def __init__(self, name: str) -> None:
        """
        Инициализирует геометрическую фигуру.
        
        Args:
            name: Название фигуры.
        """
        self.name = name
    
    def area(self) -> float:
        """
        Вычисляет площадь фигуры.
        
        Returns:
            Площадь фигуры.
            
        Raises:
            NotImplementedError: Если метод не переопределен в подклассе.
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def perimeter(self) -> float:
        """
        Вычисляет периметр фигуры.
        
        Returns:
            Периметр фигуры.
            
        Raises:
            NotImplementedError: Если метод не переопределен в подклассе.
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Возвращает словарное представление фигуры.
        
        Returns:
            Словарь с атрибутами фигуры.
        """
        return {
            "name": self.name,
            "type": self.__class__.__name__,
            "area": self.area(),
            "perimeter": self.perimeter()
        }

class Circle(Shape):
    """
    Класс, представляющий круг.
    
    Attributes:
        radius (float): Радиус круга.
        center (tuple): Координаты центра круга (x, y).
    """
    
    def __init__(self, radius: float, center: Tuple[float, float] = (0, 0)) -> None:
        """
        Инициализирует круг.
        
        Args:
            radius: Радиус круга. Должен быть положительным числом.
            center: Координаты центра круга (x, y). По умолчанию (0, 0).
            
        Raises:
            ValueError: Если радиус не является положительным числом.
        """
        super().__init__("Круг")
        if radius <= 0:
            raise ValueError("Radius must be positive")
        
        self.radius = radius
        self.center = center
    
    def area(self) -> float:
        """
        Вычисляет площадь круга.
        
        Returns:
            Площадь круга (πr²).
        """
        return math.pi * self.radius ** 2
    
    def perimeter(self) -> float:
        """
        Вычисляет длину окружности.
        
        Returns:
            Длина окружности (2πr).
        """
        return 2 * math.pi * self.radius
    
    def contains_point(self, point: Tuple[float, float]) -> bool:
        """
        Проверяет, находится ли точка внутри круга.
        
        Args:
            point: Координаты точки (x, y).
            
        Returns:
            True, если точка находится внутри круга, иначе False.
        """
        return distance(self.center, point) <= self.radius
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Возвращает словарное представление круга.
        
        Returns:
            Словарь с атрибутами круга.
        """
        result = super().to_dict()
        result.update({
            "radius": self.radius,
            "center": self.center
        })
        return result

class Rectangle(Shape):
    """
    Класс, представляющий прямоугольник.
    
    Attributes:
        width (float): Ширина прямоугольника.
        height (float): Высота прямоугольника.
        position (tuple): Координаты левого нижнего угла прямоугольника (x, y).
    """
    
    def __init__(self, width: float, height: float, position: Tuple[float, float] = (0, 0)) -> None:
        """
        Инициализирует прямоугольник.
        
        Args:
            width: Ширина прямоугольника. Должна быть положительным числом.
            height: Высота прямоугольника. Должна быть положительным числом.
            position: Координаты левого нижнего угла прямоугольника (x, y).
                      По умолчанию (0, 0).
                      
        Raises:
            ValueError: Если ширина или высота не являются положительными числами.
        """
        super().__init__("Прямоугольник")
        if width <= 0 or height <= 0:
            raise ValueError("Width and height must be positive")
        
        self.width = width
        self.height = height
        self.position = position
    
    def area(self) -> float:
        """
        Вычисляет площадь прямоугольника.
        
        Returns:
            Площадь прямоугольника (width × height).
        """
        return self.width * self.height
    
    def perimeter(self) -> float:
        """
        Вычисляет периметр прямоугольника.
        
        Returns:
            Периметр прямоугольника (2 × (width + height)).
        """
        return 2 * (self.width + self.height)
    
    def contains_point(self, point: Tuple[float, float]) -> bool:
        """
        Проверяет, находится ли точка внутри прямоугольника.
        
        Args:
            point: Координаты точки (x, y).
            
        Returns:
            True, если точка находится внутри прямоугольника, иначе False.
        """
        x, y = point
        left, bottom = self.position
        right, top = left + self.width, bottom + self.height
        
        return left <= x <= right and bottom <= y <= top
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Возвращает словарное представление прямоугольника.
        
        Returns:
            Словарь с атрибутами прямоугольника.
        """
        result = super().to_dict()
        result.update({
            "width": self.width,
            "height": self.height,
            "position": self.position
        })
        return result

class Triangle(Shape):
    """
    Класс, представляющий треугольник.
    
    Attributes:
        points (list): Список координат вершин треугольника [(x1, y1), (x2, y2), (x3, y3)].
    """
    
    def __init__(self, points: List[Tuple[float, float]]) -> None:
        """
        Инициализирует треугольник.
        
        Args:
            points: Список координат вершин треугольника [(x1, y1), (x2, y2), (x3, y3)].
            
        Raises:
            ValueError: Если количество точек не равно 3 или точки не образуют треугольник.
        """
        super().__init__("Треугольник")
        if len(points) != 3:
            raise ValueError("Triangle must have exactly 3 points")
        
        if not is_valid_triangle(points):
            raise ValueError("Points do not form a valid triangle")
        
        self.points = points
    
    def area(self) -> float:
        """
        Вычисляет площадь треугольника по формуле Герона.
        
        Returns:
            Площадь треугольника.
        """
        a = distance(self.points[0], self.points[1])
        b = distance(self.points[1], self.points[2])
        c = distance(self.points[2], self.points[0])
        
        s = (a + b + c) / 2  # Полупериметр
        return math.sqrt(s * (s - a) * (s - b) * (s - c))
    
    def perimeter(self) -> float:
        """
        Вычисляет периметр треугольника.
        
        Returns:
            Периметр треугольника.
        """
        a = distance(self.points[0], self.points[1])
        b = distance(self.points[1], self.points[2])
        c = distance(self.points[2], self.points[0])
        
        return a + b + c
    
    def contains_point(self, point: Tuple[float, float]) -> bool:
        """
        Проверяет, находится ли точка внутри треугольника.
        
        Args:
            point: Координаты точки (x, y).
            
        Returns:
            True, если точка находится внутри треугольника, иначе False.
        """
        def sign(p1, p2, p3):
            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])
        
        d1 = sign(point, self.points[0], self.points[1])
        d2 = sign(point, self.points[1], self.points[2])
        d3 = sign(point, self.points[2], self.points[0])
        
        has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
        has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)
        
        return not (has_neg and has_pos)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Возвращает словарное представление треугольника.
        
        Returns:
            Словарь с атрибутами треугольника.
        """
        result = super().to_dict()
        result.update({
            "points": self.points
        })
        return result

class Polygon(Shape):
    """
    Класс, представляющий многоугольник.
    
    Attributes:
        points (list): Список координат вершин многоугольника [(x1, y1), (x2, y2), ...].
    """
    
    def __init__(self, points: List[Tuple[float, float]]) -> None:
        """
        Инициализирует многоугольник.
        
        Args:
            points: Список координат вершин многоугольника [(x1, y1), (x2, y2), ...].
            
        Raises:
            ValueError: Если количество точек меньше 3.
        """
        super().__init__("Многоугольник")
        if len(points) < 3:
            raise ValueError("Polygon must have at least 3 points")
        
        self.points = points
    
    def area(self) -> float:
        """
        Вычисляет площадь многоугольника по формуле Гаусса.
        
        Note:
            Формула Гаусса работает только для простых многоугольников
            (без самопересечений).
        
        Returns:
            Площадь многоугольника.
        """
        n = len(self.points)
        area = 0.0
        
        for i in range(n):
            j = (i + 1) % n
            area += self.points[i][0] * self.points[j][1]
            area -= self.points[j][0] * self.points[i][1]
        
        return abs(area) / 2.0
    
    def perimeter(self) -> float:
        """
        Вычисляет периметр многоугольника.
        
        Returns:
            Периметр многоугольника.
        """
        n = len(self.points)
        perimeter = 0.0
        
        for i in range(n):
            j = (i + 1) % n
            perimeter += distance(self.points[i], self.points[j])
        
        return perimeter
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Возвращает словарное представление многоугольника.
        
        Returns:
            Словарь с атрибутами многоугольника.
        """
        result = super().to_dict()
        result.update({
            "points": self.points,
            "vertices": len(self.points)
        })
        return result
```

**geometry/utils.py**:

```python
"""
Модуль с утилитами для геометрических вычислений.

Этот модуль содержит вспомогательные функции, которые используются
в других модулях библиотеки, такие как вычисление расстояния между
точками и проверка валидности треугольника.
"""
import math
from typing import Tuple, List

def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:
    """
    Вычисляет евклидово расстояние между двумя точками.
    
    Args:
        point1: Координаты первой точки (x1, y1).
        point2: Координаты второй точки (x2, y2).
        
    Returns:
        Расстояние между точками.
    """
    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)

def is_valid_triangle(points: List[Tuple[float, float]]) -> bool:
    """
    Проверяет, образуют ли три точки правильный треугольник.
    
    Три точки образуют правильный треугольник, если они не лежат на одной прямой
    и расстояние между любыми двумя точками меньше суммы расстояний между другими
    парами точек (неравенство треугольника).
    
    Args:
        points: Список из трех точек [(x1, y1), (x2, y2), (x3, y3)].
        
    Returns:
        True, если точки образуют правильный треугольник, иначе False.
    """
    if len(points) != 3:
        return False
    
    a = distance(points[0], points[1])
    b = distance(points[1], points[2])
    c = distance(points[2], points[0])
    
    # Проверка неравенства треугольника
    if a + b <= c or b + c <= a or c + a <= b:
        return False
    
    # Проверка, что точки не лежат на одной прямой
    area = abs((points[0][0] * (points[1][1] - points[2][1]) +
                points[1][0] * (points[2][1] - points[0][1]) +
                points[2][0] * (points[0][1] - points[1][1])) / 2.0)
    
    return area > 1e-10  # Используем маленькое положительное значение из-за погрешности вычислений
```

**geometry/calculations.py**:

```python
"""
Модуль с функциями для геометрических вычислений.

Этот модуль предоставляет функции для вычисления различных
геометрических свойств, таких как площадь и периметр фигур.
"""
from typing import Union, List, Tuple, Dict
from .shapes import Shape, Circle, Rectangle, Triangle, Polygon

def calculate_area(shape: Union[Shape, List[Shape]]) -> Union[float, Dict[str, float]]:
    """
    Вычисляет площадь геометрической фигуры или нескольких фигур.
    
    Args:
        shape: Геометрическая фигура (объект класса Shape) или список фигур.
        
    Returns:
        Площадь фигуры или словарь с площадями фигур, если передан список.
    
    Examples:
        >>> circle = Circle(5)
        >>> calculate_area(circle)
        78.53981633974483
        
        >>> shapes = [Circle(5), Rectangle(3, 4)]
        >>> calculate_area(shapes)
        {'Круг': 78.53981633974483, 'Прямоугольник': 12.0}
    """
    if isinstance(shape, list):
        result = {}
        for s in shape:
            result[s.name] = s.area()
        return result
    
    return shape.area()

def calculate_perimeter(shape: Union[Shape, List[Shape]]) -> Union[float, Dict[str, float]]:
    """
    Вычисляет периметр геометрической фигуры или нескольких фигур.
    
    Args:
        shape: Геометрическая фигура (объект класса Shape) или список фигур.
        
    Returns:
        Периметр фигуры или словарь с периметрами фигур, если передан список.
    
    Examples:
        >>> circle = Circle(5)
        >>> calculate_perimeter(circle)
        31.41592653589793
        
        >>> shapes = [Circle(5), Rectangle(3, 4)]
        >>> calculate_perimeter(shapes)
        {'Круг': 31.41592653589793, 'Прямоугольник': 14.0}
    """
    if isinstance(shape, list):
        result = {}
        for s in shape:
            result[s.name] = s.perimeter()
        return result
    
    return shape.perimeter()
```

**examples/basic_usage.py**:

```python
"""
Пример использования библиотеки geometry.

Этот скрипт демонстрирует основные возможности библиотеки,
такие как создание фигур, вычисление их свойств и выполнение
операций с ними.
"""
import sys
import os

# Добавляем родительскую директорию в sys.path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from geometry import Circle, Rectangle, Triangle, Polygon
from geometry import calculate_area, calculate_perimeter

def main():
    # Создание фигур
    circle = Circle(radius=5, center=(0, 0))
    rectangle = Rectangle(width=10, height=5, position=(0, 0))
    triangle = Triangle(points=[(0, 0), (5, 8), (10, 0)])
    polygon = Polygon(points=[(0, 0), (5, 5), (10, 0), (5, -5)])
    
    # Вычисление площади и периметра
    print(f"Circle area: {circle.area():.2f}, perimeter: {circle.perimeter():.2f}")
    print(f"Rectangle area: {rectangle.area():.2f}, perimeter: {rectangle.perimeter():.2f}")
    print(f"Triangle area: {triangle.area():.2f}, perimeter: {triangle.perimeter():.2f}")
    print(f"Polygon area: {polygon.area():.2f}, perimeter: {polygon.perimeter():.2f}")
    
    # Использование функций из модуля calculations
    shapes = [circle, rectangle, triangle, polygon]
    areas = calculate_area(shapes)
    perimeters = calculate_perimeter(shapes)
    
    print("\nAreas of all shapes:")
    for shape_name, area in areas.items():
        print(f"{shape_name}: {area:.2f}")
    
    print("\nPerimeters of all shapes:")
    for shape_name, perimeter in perimeters.items():
        print(f"{shape_name}: {perimeter:.2f}")
    
    # Проверка, содержит ли фигура точку
    point = (2, 2)
    print(f"\nPoint {point} is inside the circle: {circle.contains_point(point)}")
    print(f"Point {point} is inside the rectangle: {rectangle.contains_point(point)}")
    print(f"Point {point} is inside the triangle: {triangle.contains_point(point)}")

if __name__ == "__main__":
    main()
```

### Шаг 3: Настройка Sphinx для документации

**docs/source/conf.py**:

```python
# Configuration file for the Sphinx documentation builder.

import os
import sys
sys.path.insert(0, os.path.abspath('../..'))

# -- Project information -----------------------------------------------------

project = 'Geometry'
copyright = '2023, Example Author'
author = 'Example Author'

# The full version, including alpha/beta/rc tags
release = '0.1.0'

# -- General configuration ---------------------------------------------------

extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.viewcode',
    'sphinx.ext.napoleon',
    'sphinx.ext.todo',
    'sphinx.ext.mathjax',
]

templates_path = ['_templates']
exclude_patterns = []

# -- Options for HTML output -------------------------------------------------

html_theme = 'sphinx_rtd_theme'
html_static_path = ['_static']

# -- Extension configuration -------------------------------------------------

# Napoleon settings
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = True
napoleon_include_private_with_doc = False
napoleon_include_special_with_doc = True
napoleon_use_admonition_for_examples = True
napoleon_use_admonition_for_notes = True
napoleon_use_admonition_for_references = True
napoleon_use_ivar = False
napoleon_use_param = True
napoleon_use_rtype = True
napoleon_preprocess_types = False
napoleon_type_aliases = None
napoleon_attr_annotations = True
```

**docs/source/index.rst**:

```rst
.. Geometry documentation master file

Документация библиотеки Geometry
================================

Geometry - это простая библиотека для работы с геометрическими фигурами,
такими как круги, прямоугольники, треугольники и многоугольники.

Основные возможности
-------------------

* Создание и манипуляция различными геометрическими фигурами
* Вычисление площади и периметра фигур
* Проверка, содержит ли фигура точку
* Экспорт фигур в словарное представление

Установка
--------

.. code-block:: bash

   pip install geometry

Быстрый старт
-----------

.. code-block:: python

   from geometry import Circle, Rectangle, Triangle
   from geometry import calculate_area, calculate_perimeter

   # Создание фигуры
   circle = Circle(radius=5)
   
   # Вычисление свойств
   area = circle.area()       # Площадь
   perimeter = circle.perimeter()  # Периметр
   
   # Проверка, содержит ли фигура точку
   contains = circle.contains_point((2, 2))

.. toctree::
   :maxdepth: 2
   :caption: Содержание:

   modules

Индексы и таблицы
===============

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
```

**docs/source/modules.rst**:

```rst
Modules
=======

.. toctree::
   :maxdepth: 4

   geometry
```

**docs/source/geometry.rst**:

```rst
geometry package
===============

Submodules
---------

geometry.shapes module
--------------------

.. automodule:: geometry.shapes
   :members:
   :undoc-members:
   :show-inheritance:

geometry.utils module
-------------------

.. automodule:: geometry.utils
   :members:
   :undoc-members:
   :show-inheritance:

geometry.calculations module
--------------------------

.. automodule:: geometry.calculations
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
-------------

.. automodule:: geometry
   :members:
   :undoc-members:
   :show-inheritance:
```

### Шаг 4: Сборка документации

```bash
cd docs
make html
```

После выполнения команды HTML-документация будет сгенерирована в директории `docs/build/html`. Откройте файл `index.html` в браузере для просмотра документации.

### Шаг 5: Анализ и результаты

В этом мини-проекте мы создали и документировали библиотеку для работы с геометрическими фигурами. Основные достижения:

1. **Хорошо структурированный код** — разделение функциональности по модулям, использование наследования для фигур.
2. **Полная документация** — каждый класс, метод и функция имеют docstrings с описанием, аргументами, возвращаемыми значениями и исключениями.
3. **Аннотации типов** — использование подсказок типов для улучшения документации и позволения статического анализа кода.
4. **Автоматическая генерация документации** — настройка Sphinx для создания профессиональной HTML-документации.
5. **Примеры использования** — демонстрация основных возможностей библиотеки в примерах.

Такая документация значительно упрощает использование библиотеки и ее сопровождение. Она позволяет:

- Новым пользователям быстро начать работу с библиотекой
- Разработчикам понять, как работает код и как его можно расширить
- Поддерживать единый стиль документирования во всем проекте
- Автоматически обновлять документацию при изменении кода

## Заключение

Документирование кода — это важная часть разработки программного обеспечения, которая часто недооценивается. Хорошая документация делает код более понятным, упрощает его сопровождение и использование, а также сохраняет знания о проекте.

В этом материале мы рассмотрели различные аспекты документирования кода в Python:

1. **Docstrings** — встроенный в Python механизм для документирования модулей, классов, функций и методов.
2. **Стили документирования** — различные форматы для структурирования docstrings, такие как Google Style, NumPy/SciPy Style и reStructuredText Style.
3. **Автоматическая генерация документации** — использование Sphinx для создания профессиональной документации на основе docstrings.
4. **Расширенные возможности Sphinx** — перекрестные ссылки, математические формулы, примеры кода и другие функции для улучшения документации.
5. **Использование Read the Docs** — публикация документации в интернете для легкого доступа пользователям.
6. **Аннотации типов** — улучшение документации с помощью подсказок типов.

Следуя принципам и методам, описанным в этом материале, вы сможете создавать качественную документацию для ваших проектов, которая будет полезна как для вас, так и для других разработчиков и пользователей.

Помните, что хорошая документация — это инвестиция в будущее вашего проекта. Она экономит время при введении новых разработчиков в проект, помогает избежать ошибок и улучшает общее качество кода.
