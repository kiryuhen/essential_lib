# Шаблон Guarded Suspension (Охраняемое ожидание)

## Описание
Guarded Suspension — это паттерн, при котором метод приостанавливает своё выполнение, если предикат (guard) возвращает `False`, и возобновляет его, когда условие становится истинным.

## Проблема
Некоторые операции возможны только при выполнении определённого состояния (например, строго последовательное получение данных или заполненность буфера). Без механизма ожидания поток будет активно опрашивать состояние или рисковать некорректным выполнением.

## Решение
Guarded Suspension инкапсулирует проверку предиката и ожидание под защитой мьютекса и условной переменной. Если предикат ложен, поток ждёт на условной переменной; когда состояние изменяется, другой поток уведомляет всех или одного ожидающего, и выполнение возобновляется.

## Структура
1. **Guard (Предикат)** — логическое условие готовности ресурса или состояния.
2. **Mutex (Мьютекс)** — защищает общие данные и предикат.
3. **Condition (Условная переменная)** — позволяет потокам ждать и пробуждаться.
4. **Access Method** — метод, проверяющий guard и выполняющий wait/notify.

## Пример на Python
```python
import threading

class Holder:
    def __init__(self):
        self._value = None
        self._lock = threading.Lock()
        self._cond = threading.Condition(self._lock)

    def set(self, v):
        with self._lock:
            self._value = v
            self._cond.notify_all()

    def get(self):
        with self._cond:
            while self._value is None:  # guard: значение готово?
                self._cond.wait()
            return self._value

# Использование
holder = Holder()

def producer():
    holder.set(42)

def consumer():
    val = holder.get()
    print("Получено значение:", val)

import threading
t1 = threading.Thread(target=consumer)
t2 = threading.Thread(target=producer)
t1.start(); t2.start()
t1.join(); t2.join()
```

## Применение
- Асинхронное получение данных (I/O, сеть)
- Буферы и очереди между потоками
- Протоколы запрос-ответ с ожиданием состояния

## Плюсы
1. Гарантия выполнения операции только при готовом состоянии
2. Эффективное ожидание без активного опроса (busy-wait)
3. Инкапсуляция логики ожидания внутри объекта

## Минусы
1. Возможная бесконечная блокировка, если никто не уведомит
2. Необходимость корректного вызова notify для пробуждения
3. Сложность при сложных или комбинированных предикатах

## Когда использовать
- Когда метод требует предварительного условия для выполнения
- Для синхронизации состояний между производителем и потребителем
- В протоколах, где нужно ждать события перед продолжением

