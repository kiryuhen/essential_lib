# Структуры данных

## Содержание
- [Массивы, матрицы](#массивы-матрицы)
- [Связанные списки](#связанные-списки)
- [Стеки и очереди](#стеки-и-очереди)
- [Хэш-таблицы](#хэш-таблицы)
- [Деревья](#деревья)
- [Графы и алгоритмы обхода](#графы-и-алгоритмы-обхода)

## Массивы, матрицы

### Общий обзор

Массивы — фундаментальная структура данных, представляющая собой непрерывную область памяти, разделенную на элементы одинакового размера. Каждый элемент доступен по индексу, что обеспечивает быстрый доступ O(1) к любому элементу.

### Одномерные массивы

#### Как работают под капотом:

Когда вы создаете массив, компьютер выделяет непрерывный блок памяти. Если известен адрес начала массива и размер каждого элемента, то адрес любого элемента можно вычислить:

```
адрес элемента[i] = начальный_адрес + i * размер_элемента
```

Это объясняет, почему доступ к элементам по индексу происходит за O(1).

#### Массивы в Python (списки):

```python
# Создание массива (в Python используются динамические списки)
arr = [1, 2, 3, 4, 5]

# Доступ по индексу: O(1)
print(arr[2])  # 3

# Длина массива: O(1)
print(len(arr))  # 5

# Добавление элемента (амортизированное O(1))
arr.append(6)  
print(arr)  # [1, 2, 3, 4, 5, 6]

# Вставка элемента (O(n))
arr.insert(1, 10)  
print(arr)  # [1, 10, 2, 3, 4, 5, 6]

# Удаление элемента (O(n))
arr.pop(1)  
print(arr)  # [1, 2, 3, 4, 5, 6]

# Поиск элемента (O(n))
print(3 in arr)  # True
print(arr.index(3))  # 2

# Слайсинг
print(arr[1:4])  # [2, 3, 4]
```

#### Динамические массивы в Python:

В отличие от массивов в языках типа C/C++, списки в Python являются динамическими массивами — они автоматически изменяют размер.

**Как это работает:**
1. При создании списка выделяется память с некоторым запасом
2. Когда список заполняется, Python:
   - Выделяет новый, больший блок памяти (обычно в 1.125 раз больше при малых размерах и в 1.5 раза при больших)
   - Копирует все элементы в новый блок
   - Освобождает старую память

```python
import sys

arr = []
for i in range(10):
    arr.append(i)
    # Размер массива в байтах и количество выделенных ячеек
    print(f"Размер: {sys.getsizeof(arr)} байт, Элементов: {len(arr)}, Выделено места: {sys.getsizeof(arr) // 8}")
```

#### Эффективные массивы для числовых данных:

Модуль `array` из стандартной библиотеки и NumPy предоставляют более эффективные массивы:

```python
import array
import numpy as np

# Типизированный массив (только int)
int_array = array.array('i', [1, 2, 3, 4])

# NumPy массив
np_array = np.array([1, 2, 3, 4])

# NumPy операции выполняются быстрее
print(np_array * 2)  # [2 4 6 8]

# Память
print(f"Список: {sys.getsizeof([1, 2, 3, 4])} байт")
print(f"Array: {sys.getsizeof(int_array)} байт")
print(f"NumPy: {sys.getsizeof(np_array)} + {np_array.nbytes} байт")
```

### Многомерные массивы и матрицы

#### Матрицы с использованием вложенных списков:

```python
# Создание матрицы 3x3
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Доступ к элементам
print(matrix[1][2])  # 6

# Обход матрицы
for row in matrix:
    for element in row:
        print(element, end=' ')
    print()
```

#### Матрицы с помощью NumPy:

```python
import numpy as np

# Создание матрицы 3x3
np_matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

# Матричные операции
print(np_matrix.T)  # Транспонирование
print(np_matrix @ np_matrix)  # Матричное умножение

# Операции с элементами
print(np_matrix * 2)  # Умножение каждого элемента на 2

# Срезы
print(np_matrix[:, 1])  # Второй столбец

# Фильтрация
print(np_matrix[np_matrix > 5])  # Элементы больше 5
```

### Алгоритмическая сложность операций с массивами

| Операция             | Сложность  | Пояснение                                       |
|----------------------|------------|------------------------------------------------|
| Доступ по индексу    | O(1)       | Прямая адресация                               |
| Изменение по индексу | O(1)       | Прямая адресация                               |
| Поиск элемента       | O(n)       | Требуется просмотр всех элементов              |
| Вставка в конец      | O(1)*      | В Python - амортизированное O(1)               |
| Вставка в середину   | O(n)       | Требуется сдвиг элементов                      |
| Удаление из конца    | O(1)       | Просто уменьшаем счетчик длины                 |
| Удаление из середины | O(n)       | Требуется сдвиг элементов                      |

### Типичное применение

1. **Временные ряды и последовательности данных**
2. **Двумерные изображения (как двумерные массивы)**
3. **Обработка табличных данных**
4. **Реализация других структур данных (стеки, очереди)**

### Распространенные приемы и шаблоны

1. **Двухуказательная техника**:
   ```python
   def two_pointer_technique(arr, target):
       left, right = 0, len(arr) - 1
       while left < right:
           current_sum = arr[left] + arr[right]
           if current_sum == target:
               return left, right
           elif current_sum < target:
               left += 1
           else:
               right -= 1
       return None
   
   # Пример: найти пару чисел, дающую сумму 10
   arr = [1, 2, 5, 7, 9]
   print(two_pointer_technique(arr, 10))  # (1, 4) -> 2 + 9 = 10
   ```

2. **Скользящее окно**:
   ```python
   def sliding_window(arr, k):
       window_sum = sum(arr[:k])
       result = [window_sum]
       
       for i in range(len(arr) - k):
           window_sum = window_sum - arr[i] + arr[i + k]
           result.append(window_sum)
       
       return result
   
   # Пример: найти суммы в окне размера 3
   arr = [1, 2, 3, 4, 5, 6]
   print(sliding_window(arr, 3))  # [6, 9, 12, 15]
   ```

3. **Префиксные суммы**:
   ```python
   def prefix_sum(arr):
       prefix = [0] * (len(arr) + 1)
       for i in range(len(arr)):
           prefix[i + 1] = prefix[i] + arr[i]
       return prefix
   
   # Пример: вычисление суммы на отрезке [l, r]
   arr = [1, 2, 3, 4, 5]
   pref = prefix_sum(arr)
   # Сумма arr[1:4] = arr[1] + arr[2] + arr[3]
   l, r = 1, 4
   print(pref[r] - pref[l])  # 9 (= 2 + 3 + 4)
   ```

### Дополнительные ресурсы
- [NumPy документация](https://numpy.org/doc/stable/)
- [Python Lists vs NumPy Arrays](https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference)
- [Алгоритмы на массивах на LeetCode](https://leetcode.com/tag/array/)

## Связанные списки

### Общий обзор

Связанный список — это структура данных, в которой элементы (узлы) хранятся в произвольных местах памяти. Каждый узел содержит значение и указатель на следующий узел. В отличие от массивов, связанные списки не требуют непрерывного блока памяти.

### Типы связанных списков

1. **Односвязный список (Singly Linked List)**:
   - Каждый узел имеет указатель только на следующий узел
   - Обход только в одном направлении

2. **Двусвязный список (Doubly Linked List)**:
   - Каждый узел имеет указатели на следующий и предыдущий узлы
   - Обход в обоих направлениях

3. **Кольцевой список (Circular Linked List)**:
   - Последний узел указывает на первый, образуя кольцо

### Реализация односвязного списка в Python

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        
class LinkedList:
    def __init__(self):
        self.head = None
    
    def is_empty(self):
        return self.head is None
    
    def append(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    def insert_after(self, prev_node, data):
        if not prev_node:
            print("Предыдущий узел должен существовать")
            return
        
        new_node = Node(data)
        new_node.next = prev_node.next
        prev_node.next = new_node
    
    def delete_node(self, key):
        current = self.head
        
        # Если удаляемый узел — первый
        if current and current.data == key:
            self.head = current.next
            current = None
            return
        
        # Поиск узла для удаления
        prev = None
        while current and current.data != key:
            prev = current
            current = current.next
        
        # Если узел не найден
        if not current:
            return
        
        # Удаление узла
        prev.next = current.next
        current = None
    
    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Пример использования
linked_list = LinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.prepend(0)
linked_list.print_list()  # 0 -> 1 -> 2 -> 3 -> None

linked_list.delete_node(2)
linked_list.print_list()  # 0 -> 1 -> 3 -> None
```

### Реализация двусвязного списка в Python

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
        
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        new_node = Node(data)
        
        if not self.head:
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        
        current.next = new_node
        new_node.prev = current
    
    def prepend(self, data):
        new_node = Node(data)
        
        if not self.head:
            self.head = new_node
            return
        
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node
    
    def delete_node(self, key):
        current = self.head
        
        # Если список пуст
        if not current:
            return
        
        # Если удаляемый узел — первый
        if current.data == key:
            self.head = current.next
            if self.head:
                self.head.prev = None
            current = None
            return
        
        # Поиск узла для удаления
        while current and current.data != key:
            current = current.next
        
        # Если узел не найден
        if not current:
            return
        
        # Если удаляемый узел — последний
        if not current.next:
            current.prev.next = None
            current = None
            return
        
        # Удаление узла из середины
        current.prev.next = current.next
        current.next.prev = current.prev
        current = None
    
    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

# Пример использования
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.prepend(0)
dll.print_list()  # 0 <-> 1 <-> 2 <-> 3 <-> None

dll.delete_node(2)
dll.print_list()  # 0 <-> 1 <-> 3 <-> None
```

### Алгоритмическая сложность операций со связанными списками

| Операция             | Сложность  | Пояснение                                          |
|----------------------|------------|---------------------------------------------------|
| Доступ по индексу    | O(n)       | Требуется перебор с начала или конца списка       |
| Вставка в начало     | O(1)       | Просто меняем указатели                           |
| Вставка в конец      | O(n)/O(1)* | O(n) без указателя на хвост, O(1) с указателем    |
| Вставка в середину   | O(n)       | Требуется сначала найти позицию                   |
| Удаление из начала   | O(1)       | Просто меняем указатели                           |
| Удаление из конца    | O(n)/O(1)* | O(n) для односвязного, O(1) для двусвязного       |
| Удаление из середины | O(n)       | Требуется сначала найти позицию                   |
| Поиск элемента       | O(n)       | Требуется перебор всего списка в худшем случае    |

### Сравнение связанных списков и массивов

| Критерий             | Массив                     | Связанный список             |
|----------------------|----------------------------|------------------------------|
| Доступ к элементам   | О(1) — прямой доступ       | O(n) — последовательный      |
| Вставка/удаление     | О(n) в общем случае        | O(1) при известной позиции   |
| Память               | Непрерывный блок           | Разбросанные узлы + указатели|
| Размер               | Часто фиксированный        | Динамический                 |
| Кэширование          | Хорошее (локальность)      | Плохое (разбросаны в памяти) |
| Случайный доступ     | Эффективный                | Неэффективный                |
| Использование памяти | Только данные              | Данные + указатели           |

### Типичные примеры использования

1. **Реализация других структур данных:**
   - Стеки, очереди, графы

2. **Системное программирование:**
   - Управление памятью (списки свободных блоков)
   - Обработка прерываний

3. **Кэши LRU (Least Recently Used):**
   - Часто используют двусвязные списки

4. **Списки воспроизведения и плейлисты:**
   - Особенно кольцевые списки

5. **Большие числа и полиномы:**
   - Каждый узел хранит одну цифру или коэффициент

### Распространенные приемы и задачи

1. **Обнаружение цикла (алгоритм "черепахи и зайца"):**
   ```python
   def has_cycle(head):
       if not head or not head.next:
           return False
       
       slow = head
       fast = head.next
       
       while slow != fast:
           if not fast or not fast.next:
               return False
           slow = slow.next
           fast = fast.next.next
       
       return True
   ```

2. **Разворот связанного списка:**
   ```python
   def reverse_list(head):
       prev = None
       current = head
       
       while current:
           next_temp = current.next
           current.next = prev
           prev = current
           current = next_temp
       
       return prev  # новая голова списка
   ```

3. **Нахождение середины списка:**
   ```python
   def find_middle(head):
       if not head:
           return None
       
       slow = head
       fast = head
       
       while fast and fast.next:
           slow = slow.next
           fast = fast.next.next
       
       return slow
   ```

4. **Удаление n-го узла с конца:**
   ```python
   def remove_nth_from_end(head, n):
       dummy = Node(0)
       dummy.next = head
       
       first = dummy
       second = dummy
       
       # Продвигаем first на n+1 шагов вперед
       for i in range(n + 1):
           first = first.next
       
       # Двигаем first и second одновременно
       while first:
           first = first.next
           second = second.next
       
       # Удаляем узел
       second.next = second.next.next
       
       return dummy.next
   ```

### Дополнительные ресурсы
- [Визуализация связанных списков](https://visualgo.net/en/list)
- [Задачи по связанным спискам на LeetCode](https://leetcode.com/tag/linked-list/)
- [Implementing Linked List in Python](https://realpython.com/linked-lists-python/)

## Стеки и очереди

### Общий обзор

Стеки и очереди — это абстрактные структуры данных, которые отличаются порядком доступа к элементам. Они являются фундаментальными структурами данных и широко используются в программировании.

### Стек (Stack)

Стек работает по принципу LIFO (Last-In-First-Out): последний добавленный элемент извлекается первым. Представьте стопку тарелок — вы кладете и берете тарелку сверху.

#### Основные операции:

- **push(item)** — добавляет элемент на вершину стека
- **pop()** — удаляет элемент с вершины стека и возвращает его
- **peek()** или **top()** — возвращает верхний элемент без удаления
- **isEmpty()** — проверяет, пуст ли стек

#### Реализация стека через список в Python:

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return len(self.items) == 0
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def size(self):
        return len(self.items)
    
    def __str__(self):
        return str(self.items)

# Пример использования
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack)  # [1, 2, 3]

print(stack.pop())  # 3
print(stack.peek())  # 2
print(stack.size())  # 2
```

#### Реализация стека через связанный список:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedStack:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def pop(self):
        if self.is_empty():
            return None
        
        popped = self.head.data
        self.head = self.head.next
        self.size -= 1
        return popped
    
    def peek(self):
        if self.is_empty():
            return None
        return self.head.data
    
    def get_size(self):
        return self.size
```

### Очередь (Queue)

Очередь работает по принципу FIFO (First-In-First-Out): первый добавленный элемент извлекается первым. Представьте очередь людей — первый пришедший будет обслужен первым.

#### Основные операции:

- **enqueue(item)** — добавляет элемент в конец очереди
- **dequeue()** — удаляет элемент из начала очереди и возвращает его
- **peek()** или **front()** — возвращает первый элемент без удаления
- **isEmpty()** — проверяет, пуста ли очередь

#### Реализация очереди через список в Python:

```python
class Queue:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return len(self.items) == 0
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)  # Неэффективно! O(n)
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[0]
        return None
    
    def size(self):
        return len(self.items)
    
    def __str__(self):
        return str(self.items)

# Пример использования
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue)  # [1, 2, 3]

print(queue.dequeue())  # 1
print(queue.peek())  # 2
print(queue.size())  # 2
```

#### Более эффективная реализация очереди с использованием collections.deque:

```python
from collections import deque

class EfficientQueue:
    def __init__(self):
        self.items = deque()
    
    def is_empty(self):
        return len(self.items) == 0
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()  # O(1)
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[0]
        return None
    
    def size(self):
        return len(self.items)
    
    def __str__(self):
        return str(list(self.items))

# Пример использования
efficient_queue = EfficientQueue()
efficient_queue.enqueue(1)
efficient_queue.enqueue(2)
efficient_queue.enqueue(3)
print(efficient_queue)  # [1, 2, 3]

print(efficient_queue.dequeue())  # 1
```

#### Реализация очереди через связанный список:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedQueue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0
    
    def is_empty(self):
        return self.front is None
    
    def enqueue(self, data):
        new_node = Node(data)
        
        if self.is_empty():
            self.front = new_node
        else:
            self.rear.next = new_node
            
        self.rear = new_node
        self.size += 1
    
    def dequeue(self):
        if self.is_empty():
            return None
        
        data = self.front.data
        self.front = self.front.next
        
        # Если после удаления очередь пуста
        if self.front is None:
            self.rear = None
            
        self.size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            return None
        return self.front.data
    
    def get_size(self):
        return self.size
```

### Двусторонняя очередь (Deque)

Двусторонняя очередь (deque, произносится "дек") позволяет добавлять и удалять элементы с обоих концов.

#### Основные операции:

- **append(item)** — добавляет элемент в конец
- **appendleft(item)** — добавляет элемент в начало
- **pop()** — удаляет и возвращает элемент из конца
- **popleft()** — удаляет и возвращает элемент из начала

```python
from collections import deque

d = deque()
d.append(1)      # [1]
d.append(2)      # [1, 2]
d.appendleft(0)  # [0, 1, 2]
print(d)         # deque([0, 1, 2])

print(d.pop())    # 2, теперь d = [0, 1]
print(d.popleft()) # 0, теперь d = [1]
```

### Алгоритмическая сложность операций

| Структура данных | Операция           | Сложность | Пояснение                                |
|------------------|---------------------|-----------|------------------------------------------|
| Стек (список)    | push               | O(1)*     | Амортизированное время                   |
|                  | pop                | O(1)      | Извлечение с конца списка                |
|                  | peek               | O(1)      | Доступ по индексу                        |
| Очередь (список) | enqueue            | O(1)*     | Добавление в конец                       |
|                  | dequeue            | O(n)      | Требуется сдвиг всех элементов           |
| Очередь (deque)  | enqueue            | O(1)      | Эффективная реализация                   |
|                  | dequeue            | O(1)      | Удаление с начала за O(1)                |
| Deque            | append/appendleft  | O(1)      | Добавление с обоих концов                |
|                  | pop/popleft        | O(1)      | Удаление с обоих концов                  |

### Типичные примеры использования

#### Стек:

1. **Отмена операций (undo)** в текстовых редакторах
2. **Вызовы функций и рекурсия** — система использует стек вызовов
3. **Проверка сбалансированности скобок**:
   ```python
   def is_balanced(expression):
       stack = []
       brackets = {')': '(', '}': '{', ']': '['}
       
       for char in expression:
           if char in '({[':
               stack.append(char)
           elif char in ')}]':
               if not stack or stack.pop() != brackets[char]:
                   return False
                   
       return len(stack) == 0
   
   print(is_balanced("({[]}())"))  # True
   print(is_balanced("({[}])"))    # False
   ```
4. **Вычисление выражений в обратной польской записи**:
   ```python
   def eval_rpn(tokens):
       stack = []
       operations = {
           '+': lambda a, b: a + b,
           '-': lambda a, b: a - b,
           '*': lambda a, b: a * b,
           '/': lambda a, b: int(a / b)  # В задаче требуется целочисленное деление
       }
       
       for token in tokens:
           if token in operations:
               b = stack.pop()
               a = stack.pop()
               stack.append(operations[token](a, b))
           else:
               stack.append(int(token))
               
       return stack[0]
   
   print(eval_rpn(["2", "1", "+", "3", "*"]))  # 9
   print(eval_rpn(["4", "13", "5", "/", "+"]))  # 6
   ```
5. **Обход дерева в глубину**

#### Очередь:

1. **Обработка задач** - асинхронные запросы, печать
2. **Планирование процессов** в операционных системах
3. **Буферизация данных** - сглаживание потока данных
4. **BFS (обход графа в ширину)**:
   ```python
   from collections import deque
   
   def bfs(graph, start):
       visited = set()
       queue = deque([start])
       visited.add(start)
       
       while queue:
           vertex = queue.popleft()
           print(vertex, end=" ")
           
           for neighbor in graph[vertex]:
               if neighbor not in visited:
                   visited.add(neighbor)
                   queue.append(neighbor)
   
   # Пример графа в виде списка смежности
   graph = {
       0: [1, 2],
       1: [0, 2, 3],
       2: [0, 1, 4],
       3: [1, 4],
       4: [2, 3]
   }
   
   bfs(graph, 0)  # 0 1 2 3 4
   ```
5. **Реализация кэша на основе алгоритма LRU**

### Приоритетная очередь

Приоритетная очередь — это специальная очередь, где каждый элемент имеет "приоритет". Элементы с высоким приоритетом обслуживаются раньше, чем с низким.

#### Реализация с использованием модуля heapq (мин-куча):

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.elements = []
        self.counter = 0  # Для элементов с одинаковым приоритетом
    
    def is_empty(self):
        return len(self.elements) == 0
    
    def put(self, item, priority):
        # Добавляем счетчик для стабильной сортировки
        heapq.heappush(self.elements, (priority, self.counter, item))
        self.counter += 1
    
    def get(self):
        if self.is_empty():
            return None
        return heapq.heappop(self.elements)[2]
    
    def peek(self):
        if self.is_empty():
            return None
        return self.elements[0][2]
    
    def __str__(self):
        return str(self.elements)

# Пример использования
pq = PriorityQueue()
pq.put("Task 1", 3)
pq.put("Task 2", 1)
pq.put("Task 3", 2)

print(pq.get())  # "Task 2" (наивысший приоритет - наименьшее значение)
print(pq.get())  # "Task 3"
print(pq.get())  # "Task 1"
```

#### Применение приоритетных очередей:

1. **Планирование процессов в ОС**
2. **Алгоритм Дейкстры** для поиска кратчайшего пути
3. **Сжатие данных** (алгоритм Хаффмана)
4. **Симуляция событий** в дискретно-событийных моделях

### Дополнительные ресурсы
- [Визуализация стеков и очередей](https://visualgo.net/en/list)
- [Python's collections.deque](https://docs.python.org/3/library/collections.html#collections.deque)
- [Priority Queues with Python's heapq](https://docs.python.org/3/library/heapq.html)
- [Задачи на стеки на LeetCode](https://leetcode.com/tag/stack/)
- [Задачи на очереди на LeetCode](https://leetcode.com/tag/queue/)

## Хэш-таблицы

### Общий обзор

Хеш-таблица (hash table) — это структура данных, которая позволяет хранить пары ключ-значение и обеспечивает быстрый доступ к значениям по их ключам. В большинстве случаев операции поиска, вставки и удаления выполняются за время O(1).

В Python хеш-таблицы реализованы в виде типа `dict` (словарь) и `set` (множество).

### Как работают хеш-таблицы "под капотом"

Хеш-таблицы используют хеш-функцию для преобразования ключа в индекс массива, где хранится значение.

#### Основные шаги работы:

1. **Хеширование**: Вычисляем хеш ключа с помощью хеш-функции
2. **Индексирование**: Преобразуем хеш в индекс массива (обычно с помощью операции остатка от деления)
3. **Доступ**: Получаем значение по индексу

```
┌─────┐     ┌────────────┐     ┌───┐
│ ключ│ ──> │хеш-функция │ ──> │хеш│
└─────┘     └────────────┘     └───┘
                                 │
                                 ▼
                   ┌────────────────────────┐
        ┌────────►│ индекс = хеш % размер  │
        │          └────────────────────────┘
        │                      │
        │                      ▼
┌───────────────┐    ┌───────────────────────┐
│ Реорганизация │<───┤ Проверка на коллизию  │
└───────────────┘    └───────────────────────┘
                                │
                                ▼
                      ┌───────────────┐
                      │ Доступ/запись │
                      └───────────────┘
```

### Хеш-функции

Хорошая хеш-функция должна:
1. Быть быстрой для вычисления
2. Равномерно распределять ключи по пространству хешей
3. Минимизировать коллизии (ситуации, когда разные ключи дают одинаковый хеш)

Пример простой хеш-функции для строк:

```python
def simple_hash(s, table_size):
    hash_value = 0
    for char in s:
        hash_value = (hash_value * 31 + ord(char)) % table_size
    return hash_value

# Пример
print(simple_hash("hello", 100))  # Какое-то число от 0 до 99
```

В Python встроенная функция `hash()` возвращает хеш объекта:

```python
print(hash("hello"))  # -2318911503114295439
print(hash("world"))  # -2981825425787704383
```

### Обработка коллизий

Коллизии — неизбежная проблема хеш-таблиц. Существует несколько методов их обработки:

#### 1. Метод цепочек (Chaining)

При коллизии элементы с одинаковым хешем хранятся в связанном списке:

```
┌───┬───┐     ┌───┬───┐     ┌───┬───┐
│ k1│ v1│---->│ k2│ v2│---->│ k3│ v3│
└───┴───┘     └───┴───┘     └───┴───┘
    ▲
    │
┌───┐
│ i │
└───┘
```

Простая реализация:

```python
class HashTable:
    def __init__(self, size=100):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def insert(self, key, value):
        index = self._hash(key)
        
        # Проверяем, существует ли уже такой ключ
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
                
        # Добавляем новую пару ключ-значение
        self.table[index].append((key, value))
    
    def get(self, key):
        index = self._hash(key)
        
        for k, v in self.table[index]:
            if k == key:
                return v
                
        raise KeyError(f"Key {key} not found")
    
    def remove(self, key):
        index = self._hash(key)
        
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return
                
        raise KeyError(f"Key {key} not found")

# Пример использования
ht = HashTable()
ht.insert("apple", 5)
ht.insert("banana", 7)
ht.insert("cherry", 9)

print(ht.get("banana"))  # 7
ht.remove("banana")
# print(ht.get("banana"))  # KeyError
```

#### 2. Открытая адресация (Open Addressing)

При коллизии ищем следующую свободную ячейку согласно некоторой стратегии:

- **Линейное пробирование**: проверяем следующие ячейки (index + 1, index + 2, ...)
- **Квадратичное пробирование**: проверяем ячейки с шагом квадрата (index + 1², index + 2², ...)
- **Двойное хеширование**: используем вторую хеш-функцию для определения шага

### Хеш-таблицы в Python

#### 1. Словарь (dict)

```python
# Создание словаря
my_dict = {'a': 1, 'b': 2, 'c': 3}
my_dict2 = dict(a=1, b=2, c=3)

# Доступ к элементам
print(my_dict['a'])  # 1
print(my_dict.get('d', 'Not found'))  # 'Not found' (возвращает значение по умолчанию)

# Добавление/изменение элементов
my_dict['d'] = 4
my_dict['a'] = 10

# Удаление элементов
del my_dict['b']
popped_value = my_dict.pop('c')

# Проверка наличия ключа
print('a' in my_dict)  # True

# Получение ключей и значений
print(list(my_dict.keys()))  # ['a', 'd']
print(list(my_dict.values()))  # [10, 4]
print(list(my_dict.items()))  # [('a', 10), ('d', 4)]

# Итерация по словарю
for key in my_dict:
    print(key, my_dict[key])

for key, value in my_dict.items():
    print(key, value)
```

#### 2. Множество (set)

Множество — это реализация хеш-таблицы, где хранятся только ключи (без значений):

```python
# Создание множества
my_set = {1, 2, 3, 4}
my_set2 = set([1, 2, 3, 4])

# Добавление элементов
my_set.add(5)

# Удаление элементов
my_set.remove(3)  # Вызывает ошибку, если элемента нет
my_set.discard(10)  # Не вызывает ошибку

# Проверка наличия элемента
print(2 in my_set)  # True

# Операции над множествами
set1 = {1, 2, 3}
set2 = {3, 4, 5}

# Объединение
print(set1 | set2)  # {1, 2, 3, 4, 5}
print(set1.union(set2))  # То же самое

# Пересечение
print(set1 & set2)  # {3}
print(set1.intersection(set2))  # То же самое

# Разность
print(set1 - set2)  # {1, 2}
print(set1.difference(set2))  # То же самое

# Симметрическая разность
print(set1 ^ set2)  # {1, 2, 4, 5}
print(set1.symmetric_difference(set2))  # То же самое
```

### Counter и defaultdict

Полезные расширения словарей из модуля `collections`:

```python
from collections import Counter, defaultdict

# Counter подсчитывает количество каждого элемента
counter = Counter("hello world")
print(counter)  # Counter({'l': 3, 'o': 2, ' ': 1, 'h': 1, 'e': 1, 'w': 1, 'r': 1, 'd': 1})
print(counter.most_common(2))  # [('l', 3), ('o', 2)]

# defaultdict создает элемент с дефолтным значением при обращении к отсутствующему ключу
default_dict = defaultdict(list)  # Дефолтное значение - пустой список
default_dict['a'].append(1)
default_dict['a'].append(2)
print(default_dict['a'])  # [1, 2]
print(default_dict['b'])  # [] (создался автоматически)
```

### Алгоритмическая сложность операций с хеш-таблицами

| Операция    | Средний случай | Худший случай | Пояснение                               |
|-------------|----------------|---------------|------------------------------------------|
| Поиск       | O(1)           | O(n)          | Худший случай при множестве коллизий    |
| Вставка     | O(1)           | O(n)          | То же самое                             |
| Удаление    | O(1)           | O(n)          | То же самое                             |
| Итерация    | O(n)           | O(n)          | Необходимо просмотреть все элементы     |

### Типичные примеры использования хеш-таблиц

1. **Кэширование данных**:
   ```python
   # Простая функция с мемоизацией (кешированием результатов)
   def fibonacci_with_cache():
       cache = {}
       
       def fib(n):
           if n in cache:
               return cache[n]
           
           if n < 2:
               result = n
           else:
               result = fib(n-1) + fib(n-2)
               
           cache[n] = result
           return result
           
       return fib
   
   fib = fibonacci_with_cache()
   print(fib(100))  # Быстрый результат благодаря кешированию
   ```

2. **Подсчёт частоты элементов**:
   ```python
   def count_frequency(items):
       frequency = {}
       for item in items:
           if item in frequency:
               frequency[item] += 1
           else:
               frequency[item] = 1
       return frequency
   
   # Или проще с использованием Counter
   from collections import Counter
   
   def count_frequency_counter(items):
       return Counter(items)
   
   words = ["apple", "banana", "apple", "orange", "banana", "apple"]
   print(count_frequency(words))
   # {'apple': 3, 'banana': 2, 'orange': 1}
   ```

3. **Удаление дубликатов**:
   ```python
   def remove_duplicates(items):
       return list(set(items))
   
   duplicated = [1, 2, 3, 1, 2, 4, 5, 4]
   print(remove_duplicates(duplicated))
   # [1, 2, 3, 4, 5]
   ```

4. **Поиск пары с заданной суммой**:
   ```python
   def find_pair_with_sum(numbers, target):
       seen = {}
       for i, num in enumerate(numbers):
           complement = target - num
           if complement in seen:
               return seen[complement], i
           seen[num] = i
       return None
   
   numbers = [2, 7, 11, 15]
   target = 9
   print(find_pair_with_sum(numbers, target))  # (0, 1) -> индексы элементов 2 и 7
   ```

5. **Проверка анаграмм**:
   ```python
   def are_anagrams(str1, str2):
       return Counter(str1) == Counter(str2)
   
   print(are_anagrams("listen", "silent"))  # True
   print(are_anagrams("hello", "world"))    # False
   ```

### Дополнительные ресурсы
- [Детальное объяснение хеш-таблиц в Python](https://realpython.com/python-hash-table/)
- [collections.Counter documentation](https://docs.python.org/3/library/collections.html#collections.Counter)
- [collections.defaultdict documentation](https://docs.python.org/3/library/collections.html#collections.defaultdict)
- [Задачи на хеш-таблицы на LeetCode](https://leetcode.com/tag/hash-table/)

## Деревья

### Общий обзор

Дерево — это иерархическая структура данных, состоящая из узлов (вершин), которые связаны направленными ребрами. Деревья широко используются для представления иерархических отношений, организации данных для быстрого поиска и многих других задач.

### Основные терминология:

- **Корень (Root)** — верхний узел дерева, у которого нет родителя
- **Лист (Leaf)** — узел без потомков
- **Ребро (Edge)** — связь между двумя узлами
- **Родитель (Parent)** — узел, от которого есть ребро к другому узлу
- **Потомок (Child)** — узел, к которому идет ребро от другого узла
- **Уровень (Level)** — расстояние от корня до узла (количество ребер)
- **Высота (Height)** — максимальное расстояние от корня до листа
- **Поддерево (Subtree)** — дерево, образованное узлом и всеми его потомками

```
        A         <- корень (уровень 0)
       / \
      B   C       <- узлы на уровне 1
     / \   \
    D   E   F     <- узлы на уровне 2 (D, E, F - листья)
```

### Двоичное дерево

Двоичное дерево — это дерево, в котором каждый узел имеет не более двух потомков, обычно называемых левым и правым.

#### Реализация двоичного дерева:

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# Пример создания дерева
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
```

### Двоичное дерево поиска (BST)

Двоичное дерево поиска — это двоичное дерево, которое удовлетворяет следующему свойству:
- Для каждого узла все значения в его левом поддереве меньше его значения, а все значения в его правом поддереве больше его значения.

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

#### Реализация двоичного дерева поиска:

```python
class BSTNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        if not self.root:
            self.root = BSTNode(value)
            return
            
        self._insert_recursive(self.root, value)
    
    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = BSTNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = BSTNode(value)
            else:
                self._insert_recursive(node.right, value)
    
    def search(self, value):
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, node, value):
        if node is None or node.value == value:
            return node
            
        if value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)
    
    def delete(self, value):
        self.root = self._delete_recursive(self.root, value)
    
    def _delete_recursive(self, node, value):
        if node is None:
            return None
            
        if value < node.value:
            node.left = self._delete_recursive(node.left, value)
        elif value > node.value:
            node.right = self._delete_recursive(node.right, value)
        else:
            # Узел с одним потомком или без потомков
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
                
            # Узел с двумя потомками: получаем наименьший узел в правом поддереве
            node.value = self._find_min_value(node.right)
            node.right = self._delete_recursive(node.right, node.value)
            
        return node
    
    def _find_min_value(self, node):
        current = node
        while current.left:
            current = current.left
        return current.value
    
    def in_order_traversal(self):
        result = []
        self._in_order_recursive(self.root, result)
        return result
    
    def _in_order_recursive(self, node, result):
        if node:
            self._in_order_recursive(node.left, result)
            result.append(node.value)
            self._in_order_recursive(node.right, result)

# Пример использования
bst = BinarySearchTree()
values = [8, 3, 10, 1, 6, 14, 4, 7, 13]
for value in values:
    bst.insert(value)

print(bst.in_order_traversal())  # [1, 3, 4, 6, 7, 8, 10, 13, 14]

print(bst.search(6).value)  # 6
print(bst.search(15))       # None

bst.delete(3)
print(bst.in_order_traversal())  # [1, 4, 6, 7, 8, 10, 13, 14]
```

### Обходы дерева

Существует несколько способов обхода дерева:

1. **Обход в глубину (DFS)**:
   - **Предварительный (Pre-order)**: Корень → Левое поддерево → Правое поддерево
   - **Симметричный (In-order)**: Левое поддерево → Корень → Правое поддерево
   - **Обратный (Post-order)**: Левое поддерево → Правое поддерево → Корень

2. **Обход в ширину (BFS)** - обход по уровням сверху вниз, слева направо

```python
def pre_order_traversal(node, result=None):
    if result is None:
        result = []
    if node:
        result.append(node.value)
        pre_order_traversal(node.left, result)
        pre_order_traversal(node.right, result)
    return result

def in_order_traversal(node, result=None):
    if result is None:
        result = []
    if node:
        in_order_traversal(node.left, result)
        result.append(node.value)
        in_order_traversal(node.right, result)
    return result

def post_order_traversal(node, result=None):
    if result is None:
        result = []
    if node:
        post_order_traversal(node.left, result)
        post_order_traversal(node.right, result)
        result.append(node.value)
    return result

from collections import deque

def breadth_first_traversal(root):
    if not root:
        return []
        
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.value)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result

# Пример обходов для нашего BST
print("Pre-order:", pre_order_traversal(bst.root))  # [8, 1, 4, 6, 7, 10, 14, 13]
print("In-order:", in_order_traversal(bst.root))    # [1, 4, 6, 7, 8, 10, 13, 14]
print("Post-order:", post_order_traversal(bst.root)) # [1, 7, 6, 4, 13, 14, 10, 8]
print("BFS:", breadth_first_traversal(bst.root))     # [8, 1, 10, 4, 14, 6, 13, 7]
```

### Сбалансированные деревья поиска

Эффективность операций BST зависит от его сбалансированности. В худшем случае, если дерево вырождается в линейную структуру, сложность операций становится O(n).

Существуют самобалансирующиеся деревья, которые поддерживают операции вставки, удаления и поиска со сложностью O(log n):

1. **AVL деревья** — обеспечивают строгий баланс, разница высот левого и правого поддерева не более 1
2. **Красно-черные деревья** — используют цвета узлов для поддержания баланса
3. **B-деревья** — обобщение BST для эффективного хранения данных на диске

### Куча (Heap)

Куча — это полное двоичное дерево, удовлетворяющее свойству кучи:
- **Мин-куча**: значение в каждом узле не больше значений в его дочерних узлах
- **Макс-куча**: значение в каждом узле не меньше значений в его дочерних узлах

Кучи часто реализуются на массивах, где для узла с индексом i:
- левый потомок имеет индекс 2i + 1
- правый потомок имеет индекс 2i + 2
- родитель имеет индекс (i-1) // 2

```python
import heapq

# Создание пустой кучи
heap = []

# Добавление элементов (по умолчанию мин-куча)
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 4)
heapq.heappush(heap, 2)

print(heap)  # [1, 2, 4, 3] — представление в виде массива

# Извлечение минимального элемента
min_element = heapq.heappop(heap)
print(min_element)  # 1
print(heap)  # [2, 3, 4]

# Преобразование списка в кучу за O(n)
nums = [5, 7, 9, 1, 3]
heapq.heapify(nums)
print(nums)  # [1, 3, 9, 7, 5]

# Макс-куча через инверсию значений
max_heap = []
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -1)
heapq.heappush(max_heap, -4)
heapq.heappush(max_heap, -2)

max_element = -heapq.heappop(max_heap)
print(max_element)  # 4
```

### Префиксное дерево (Trie)

Префиксное дерево или бор — это дерево, используемое для хранения строк и эффективного поиска по префиксу.

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
    
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
    
    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# Пример использования
trie = Trie()
words = ["apple", "app", "apricot", "banana", "ball"]
for word in words:
    trie.insert(word)

print(trie.search("apple"))   # True
print(trie.search("app"))     # True
print(trie.search("appl"))    # False
print(trie.starts_with("ap")) # True
print(trie.starts_with("ba")) # True
print(trie.starts_with("cat")) # False
```

### Алгоритмическая сложность операций с деревьями

| Структура             | Операция       | Средний случай | Худший случай |
|-----------------------|----------------|----------------|---------------|
| BST                   | Поиск          | O(log n)       | O(n)          |
|                       | Вставка        | O(log n)       | O(n)          |
|                       | Удаление       | O(log n)       | O(n)          |
| AVL/Красно-черное     | Поиск          | O(log n)       | O(log n)      |
|                       | Вставка        | O(log n)       | O(log n)      |
|                       | Удаление       | O(log n)       | O(log n)      |
| Куча                  | Поиск мин/макс  | O(1)           | O(1)          |
|                       | Вставка        | O(log n)       | O(log n)      |
|                       | Извлечение     | O(log n)       | O(log n)      |
| Префиксное дерево     | Поиск          | O(m)           | O(m)          |
|                       | Вставка        | O(m)           | O(m)          |
|                       | Префиксный поиск| O(p)           | O(p)          |

Где n — количество узлов, m — длина строки, p — длина префикса.

### Типичные примеры использования

1. **Представление иерархических данных**:
   - Файловые системы
   - Организационные структуры
   - Синтаксические деревья в компиляторах

2. **Быстрый поиск**:
   - Словари и множества в Python реализованы с использованием хеш-таблиц, но могут использовать деревья
   - Базы данных используют B-деревья для индексов

3. **Сортировка**:
   - Сортировка кучей (Heap sort)

4. **Автодополнение и проверка правописания**:
   - Префиксные деревья для быстрого поиска слов

5. **Планирование задач**:
   - Приоритетные очереди на основе куч

### Дополнительные ресурсы
- [Визуализация деревьев и алгоритмов](https://visualgo.net/en/bst)
- [Python heapq module](https://docs.python.org/3/library/heapq.html)
- [Интерактивная визуализация красно-черных деревьев](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)
- [Задачи на деревья на LeetCode](https://leetcode.com/tag/tree/)

## Графы и алгоритмы обхода

### Общий обзор

Граф — это структура данных, состоящая из множества вершин (узлов) и множества ребер, которые соединяют эти вершины. Графы используются для моделирования отношений между объектами и решения широкого спектра задач — от поиска кратчайших путей до анализа социальных сетей.

### Основные термины и определения

- **Вершина (Vertex/Node)** — элемент графа, может содержать данные
- **Ребро (Edge)** — связь между двумя вершинами
- **Направленный граф (Directed Graph)** — граф, в котором ребра имеют направление
- **Ненаправленный граф (Undirected Graph)** — граф, в котором ребра не имеют направления
- **Взвешенный граф (Weighted Graph)** — граф, в котором ребрам присвоены веса/стоимости
- **Путь (Path)** — последовательность вершин, соединенных ребрами
- **Цикл (Cycle)** — путь, в котором начальная и конечная вершины совпадают
- **Связный граф (Connected Graph)** — граф, в котором существует путь между любыми двумя вершинами
- **Дерево (Tree)** — связный ациклический граф
- **Смежность (Adjacency)** — отношение между вершинами, соединенными ребром

```
Ненаправленный граф:        Направленный граф:
    A --- B                    A ---> B
    |     |                    |      ^
    |     |                    v      |
    C --- D                    C ---> D
```

### Представление графов

#### 1. Матрица смежности

Двумерный массив, где element[i][j] указывает, есть ли ребро от вершины i к вершине j.

```python
# Представление направленного графа с помощью матрицы смежности
# 0 -> 1, 0 -> 2, 1 -> 3, 2 -> 1
graph = [
    [0, 1, 1, 0],  # Ребра из вершины 0
    [0, 0, 0, 1],  # Ребра из вершины 1
    [0, 1, 0, 0],  # Ребра из вершины 2
    [0, 0, 0, 0]   # Ребра из вершины 3
]

# Для взвешенного графа можно хранить веса вместо 0/1
weighted_graph = [
    [0, 5, 2, 0],
    [0, 0, 0, 3],
    [0, 1, 0, 0],
    [0, 0, 0, 0]
]
```

Преимущества:
- Быстрая проверка наличия ребра O(1)
- Хорошо подходит для плотных графов

Недостатки:
- Требует O(V²) памяти, где V - количество вершин
- Неэффективно для разреженных графов

#### 2. Список смежности

Для каждой вершины хранится список смежных с ней вершин.

```python
# Представление направленного графа с помощью списка смежности
# 0 -> 1, 0 -> 2, 1 -> 3, 2 -> 1
graph = {
    0: [1, 2],
    1: [3],
    2: [1],
    3: []
}

# Для взвешенного графа можно хранить пары (вершина, вес)
weighted_graph = {
    0: [(1, 5), (2, 2)],
    1: [(3, 3)],
    2: [(1, 1)],
    3: []
}
```

Преимущества:
- Экономия памяти для разреженных графов O(V + E)
- Быстрый перебор соседей
- Удобно для алгоритмов обхода

Недостатки:
- Проверка наличия ребра занимает O(V) в худшем случае
- Сложнее для реализации некоторых алгоритмов

#### 3. Множество рёбер

Список всех рёбер графа, часто используется для взвешенных графов.

```python
# Представление ненаправленного графа с помощью списка рёбер
# A-B, A-C, B-D, C-D
edges = [
    ('A', 'B'),
    ('A', 'C'),
    ('B', 'D'),
    ('C', 'D')
]

# Для взвешенного графа:
weighted_edges = [
    ('A', 'B', 5),
    ('A', 'C', 2),
    ('B', 'D', 3),
    ('C', 'D', 1)
]
```

Преимущества:
- Просто реализовать
- Хорошо подходит для некоторых алгоритмов (например, Крускала)

Недостатки:
- Неэффективно для многих операций
- Требует дополнительной структуры для быстрого доступа к вершинам

### Реализация графа в Python

#### Класс графа с помощью списка смежности:

```python
class Graph:
    def __init__(self, directed=False):
        self.graph = {}
        self.directed = directed
    
    def add_vertex(self, vertex):
        if vertex not in self.graph:
            self.graph[vertex] = []
    
    def add_edge(self, vertex1, vertex2, weight=None):
        if vertex1 not in self.graph:
            self.add_vertex(vertex1)
        if vertex2 not in self.graph:
            self.add_vertex(vertex2)
        
        # Добавляем ребро от vertex1 к vertex2
        if weight is not None:
            self.graph[vertex1].append((vertex2, weight))
        else:
            self.graph[vertex1].append(vertex2)
        
        # Если граф ненаправленный, добавляем ребро и в обратную сторону
        if not self.directed:
            if weight is not None:
                self.graph[vertex2].append((vertex1, weight))
            else:
                self.graph[vertex2].append(vertex1)
    
    def get_vertices(self):
        return list(self.graph.keys())
    
    def get_edges(self):
        edges = []
        for vertex in self.graph:
            for neighbor in self.graph[vertex]:
                if isinstance(neighbor, tuple):  # Взвешенный граф
                    edges.append((vertex, neighbor[0], neighbor[1]))
                else:  # Невзвешенный граф
                    # Для ненаправленного графа избегаем дублирования
                    if self.directed or (vertex, neighbor) not in edges:
                        edges.append((vertex, neighbor))
        return edges
    
    def get_neighbors(self, vertex):
        return self.graph.get(vertex, [])
    
    def __str__(self):
        result = "Graph:\n"
        for vertex, neighbors in self.graph.items():
            result += f"{vertex} -> {neighbors}\n"
        return result

# Пример использования
g = Graph(directed=True)
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')

print(g)
# Graph:
# A -> ['B', 'C']
# B -> ['D']
# C -> ['D']
# D -> []

# Взвешенный граф
wg = Graph(directed=True)
wg.add_edge('A', 'B', 5)
wg.add_edge('A', 'C', 2)
wg.add_edge('B', 'D', 3)
wg.add_edge('C', 'D', 1)

print(wg)
# Graph:
# A -> [('B', 5), ('C', 2)]
# B -> [('D', 3)]
# C -> [('D', 1)]
# D -> []
```

### Алгоритмы обхода графа

#### 1. Поиск в глубину (DFS)

DFS использует стек (или рекурсию) для обхода графа, идя как можно глубже по каждой ветви, прежде чем вернуться и исследовать другие ветви.

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph.get_neighbors(start):
        # Если граф взвешенный, neighbor будет кортежем (vertex, weight)
        if isinstance(neighbor, tuple):
            neighbor = neighbor[0]
            
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    
    return visited

# Нерекурсивная версия с использованием стека
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=' ')
            
            neighbors = graph.get_neighbors(vertex)
            # Добавляем соседей в обратном порядке, чтобы обход был тем же, что и в рекурсивной версии
            if isinstance(neighbors[0], tuple) if neighbors else False:
                neighbors = [n[0] for n in neighbors]
                
            stack.extend(reversed([n for n in neighbors if n not in visited]))
    
    return visited

# Пример
dfs(g, 'A')  # A B D C
print()
dfs_iterative(g, 'A')  # A C D B
```

#### 2. Поиск в ширину (BFS)

BFS использует очередь для обхода графа по уровням, посещая сначала все вершины на одном уровне, прежде чем перейти к следующему.

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor in graph.get_neighbors(vertex):
            if isinstance(neighbor, tuple):
                neighbor = neighbor[0]
                
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return visited

# Пример
bfs(g, 'A')  # A B C D
```

### Алгоритмы поиска кратчайшего пути

#### 1. Алгоритм Дейкстры

Находит кратчайшие пути от одной вершины до всех остальных вершин взвешенного графа с неотрицательными весами.

```python
import heapq

def dijkstra(graph, start):
    # Инициализация расстояний и предшественников
    distances = {vertex: float('infinity') for vertex in graph.get_vertices()}
    predecessors = {vertex: None for vertex in graph.get_vertices()}
    distances[start] = 0
    
    # Приоритетная очередь для выбора вершины с минимальным расстоянием
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        # Если мы уже нашли более короткий путь, пропускаем
        if current_distance > distances[current_vertex]:
            continue
        
        # Проверяем всех соседей текущей вершины
        for neighbor in graph.get_neighbors(current_vertex):
            if isinstance(neighbor, tuple):
                neighbor_vertex, weight = neighbor
            else:
                neighbor_vertex, weight = neighbor, 1  # Если граф невзвешенный
            
            distance = current_distance + weight
            
            # Если найден более короткий путь
            if distance < distances[neighbor_vertex]:
                distances[neighbor_vertex] = distance
                predecessors[neighbor_vertex] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor_vertex))
    
    return distances, predecessors

# Функция для восстановления пути
def get_path(predecessors, destination):
    path = []
    current = destination
    
    while current:
        path.append(current)
        current = predecessors[current]
    
    return path[::-1]  # Разворачиваем путь

# Пример
distances, predecessors = dijkstra(wg, 'A')
print("Distances from A:", distances)
# Distances from A: {'A': 0, 'B': 5, 'C': 2, 'D': 3}

print("Path from A to D:", get_path(predecessors, 'D'))
# Path from A to D: ['A', 'C', 'D']
```

#### 2. Алгоритм Беллмана-Форда

Находит кратчайшие пути от одной вершины до всех остальных, даже при наличии отрицательных весов (но без отрицательных циклов).

```python
def bellman_ford(graph, start):
    # Инициализация расстояний и предшественников
    distances = {vertex: float('infinity') for vertex in graph.get_vertices()}
    predecessors = {vertex: None for vertex in graph.get_vertices()}
    distances[start] = 0
    
    # Получаем все рёбра из графа
    edges = []
    for u in graph.get_vertices():
        for v in graph.get_neighbors(u):
            if isinstance(v, tuple):
                v_vertex, weight = v
                edges.append((u, v_vertex, weight))
            else:
                edges.append((u, v, 1))  # Если граф невзвешенный
    
    # Релаксация рёбер |V| - 1 раз
    V = len(graph.get_vertices())
    for _ in range(V - 1):
        for u, v, weight in edges:
            if distances[u] != float('infinity') and distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight
                predecessors[v] = u
    
    # Проверка на отрицательные циклы
    for u, v, weight in edges:
        if distances[u] != float('infinity') and distances[u] + weight < distances[v]:
            raise ValueError("Graph contains a negative weight cycle")
    
    return distances, predecessors

# Пример
try:
    distances, predecessors = bellman_ford(wg, 'A')
    print("Distances from A:", distances)
    # Distances from A: {'A': 0, 'B': 5, 'C': 2, 'D': 3}
except ValueError as e:
    print(e)
```

#### 3. Алгоритм Флойда-Уоршелла

Находит кратчайшие пути между всеми парами вершин.

```python
def floyd_warshall(graph):
    # Инициализация матрицы расстояний
    vertices = graph.get_vertices()
    n = len(vertices)
    vertex_indices = {vertex: i for i, vertex in enumerate(vertices)}
    
    # Создаём матрицу расстояний
    dist = [[float('infinity') for _ in range(n)] for _ in range(n)]
    
    # Устанавливаем расстояния для существующих рёбер
    for i in range(n):
        dist[i][i] = 0  # Расстояние до самого себя
        
        vertex = vertices[i]
        for neighbor in graph.get_neighbors(vertex):
            if isinstance(neighbor, tuple):
                neighbor_vertex, weight = neighbor
            else:
                neighbor_vertex, weight = neighbor, 1
                
            j = vertex_indices[neighbor_vertex]
            dist[i][j] = weight
    
    # Алгоритм Флойда-Уоршелла
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    # Преобразуем индексы обратно в вершины
    result = {}
    for i, vertex1 in enumerate(vertices):
        result[vertex1] = {}
        for j, vertex2 in enumerate(vertices):
            result[vertex1][vertex2] = dist[i][j]
    
    return result

# Пример
all_paths = floyd_warshall(wg)
print("Distance from A to D:", all_paths['A']['D'])  # 3
print("Distance from B to C:", all_paths['B']['C'])  # infinity (нет пути)
```

### Алгоритмы для деревьев остова (для ненаправленных графов)

#### 1. Алгоритм Крускала

Находит минимальное остовное дерево, добавляя рёбра в порядке возрастания весов, избегая циклов.

```python
def kruskal(graph):
    # Создаём множество рёбер и сортируем по весу
    edges = []
    for vertex in graph.get_vertices():
        for neighbor in graph.get_neighbors(vertex):
            if isinstance(neighbor, tuple):
                neighbor_vertex, weight = neighbor
                # Для ненаправленного графа добавляем ребро только один раз
                if (neighbor_vertex, vertex, weight) not in edges:
                    edges.append((vertex, neighbor_vertex, weight))
    
    edges.sort(key=lambda x: x[2])  # Сортировка по весу
    
    # Инициализация системы непересекающихся множеств
    parent = {vertex: vertex for vertex in graph.get_vertices()}
    
    def find(vertex):
        if parent[vertex] != vertex:
            parent[vertex] = find(parent[vertex])
        return parent[vertex]
    
    def union(vertex1, vertex2):
        root1 = find(vertex1)
        root2 = find(vertex2)
        parent[root2] = root1
    
    # Создание минимального остовного дерева
    minimum_spanning_tree = []
    
    for vertex1, vertex2, weight in edges:
        if find(vertex1) != find(vertex2):  # Проверка на отсутствие цикла
            union(vertex1, vertex2)
            minimum_spanning_tree.append((vertex1, vertex2, weight))
    
    return minimum_spanning_tree

# Пример (для ненаправленного графа)
ug = Graph(directed=False)
ug.add_edge('A', 'B', 4)
ug.add_edge('A', 'C', 2)
ug.add_edge('B', 'C', 1)
ug.add_edge('B', 'D', 5)
ug.add_edge('C', 'D', 8)
ug.add_edge('C', 'E', 10)
ug.add_edge('D', 'E', 2)

mst = kruskal(ug)
print("Minimum Spanning Tree:")
for edge in mst:
    print(f"{edge[0]} -- {edge[1]} : {edge[2]}")
# Minimum Spanning Tree:
# B -- C : 1
# A -- C : 2
# D -- E : 2
# B -- D : 5
```

#### 2. Алгоритм Прима

Находит минимальное остовное дерево, начиная с одной вершины и добавляя ближайшие вершины.

```python
def prim(graph, start):
    # Инициализация
    vertices = graph.get_vertices()
    included = {vertex: False for vertex in vertices}
    distances = {vertex: float('infinity') for vertex in vertices}
    parent = {vertex: None for vertex in vertices}
    
    distances[start] = 0
    
    for _ in range(len(vertices)):
        # Выбираем вершину с минимальным расстоянием
        u = min([v for v in vertices if not included[v]], key=lambda x: distances[x])
        included[u] = True
        
        # Обновляем расстояния до соседних вершин
        for neighbor in graph.get_neighbors(u):
            if isinstance(neighbor, tuple):
                v, weight = neighbor
            else:
                v, weight = neighbor, 1
                
            if not included[v] and weight < distances[v]:
                distances[v] = weight
                parent[v] = u
    
    # Формируем результат
    minimum_spanning_tree = []
    for vertex in vertices:
        if parent[vertex] is not None:
            minimum_spanning_tree.append((parent[vertex], vertex, distances[vertex]))
    
    return minimum_spanning_tree

# Пример
mst_prim = prim(ug, 'A')
print("Minimum Spanning Tree (Prim):")
for edge in mst_prim:
    print(f"{edge[0]} -- {edge[1]} : {edge[2]}")
```

### Алгоритмы для проверки свойств графа

#### 1. Проверка на связность

```python
def is_connected(graph):
    vertices = graph.get_vertices()
    if not vertices:
        return True
    
    # Запускаем DFS из первой вершины
    visited = dfs(graph, vertices[0], set())
    
    # Проверяем, что посетили все вершины
    return len(visited) == len(vertices)
```

#### 2. Проверка на наличие цикла

```python
def has_cycle_directed(graph):
    vertices = graph.get_vertices()
    visited = set()
    rec_stack = set()
    
    def dfs_cycle(vertex):
        visited.add(vertex)
        rec_stack.add(vertex)
        
        for neighbor in graph.get_neighbors(vertex):
            if isinstance(neighbor, tuple):
                neighbor = neighbor[0]
                
            if neighbor not in visited:
                if dfs_cycle(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True
        
        rec_stack.remove(vertex)
        return False
    
    for vertex in vertices:
        if vertex not in visited:
            if dfs_cycle(vertex):
                return True
    
    return False

# Проверка для ненаправленного графа
def has_cycle_undirected(graph):
    vertices = graph.get_vertices()
    visited = set()
    
    def dfs_cycle(vertex, parent):
        visited.add(vertex)
        
        for neighbor in graph.get_neighbors(vertex):
            if isinstance(neighbor, tuple):
                neighbor = neighbor[0]
                
            if neighbor not in visited:
                if dfs_cycle(neighbor, vertex):
                    return True
            elif neighbor != parent:
                return True
        
        return False
    
    for vertex in vertices:
        if vertex not in visited:
            if dfs_cycle(vertex, None):
                return True
    
    return False
```

### Типичные примеры использования графов

1. **Сетевые модели**:
   - Социальные сети (люди как вершины, связи как рёбра)
   - Компьютерные сети (устройства как вершины, соединения как рёбра)
   - Транспортные системы (города как вершины, дороги как рёбра)

2. **Алгоритмы навигации**:
   - Поиск кратчайшего пути в GPS-навигаторах (алгоритм Дейкстры)
   - Маршрутизация в сетях
   - Планирование путей для роботов

3. **Моделирование зависимостей**:
   - Анализ зависимостей в программных проектах
   - Планирование задач (топологическая сортировка)
   - Анализ критического пути в управлении проектами

4. **Распознавание образов и машинное обучение**:
   - Графовые нейронные сети
   - Анализ изображений
   - Кластеризация данных

5. **Базы данных**:
   - Графовые базы данных (Neo4j, Amazon Neptune)
   - Моделирование сложных связей между данными

6. **Компиляторы и языки программирования**:
   - Построение абстрактных синтаксических деревьев
   - Анализ потока управления и данных

### Дополнительные ресурсы
- [Визуализация графовых алгоритмов](https://visualgo.net/en/graphds)
- [NetworkX - библиотека для работы с графами в Python](https://networkx.org/)
- [Алгоритмы на графах на LeetCode](https://leetcode.com/tag/graph/)
- [Graph Theory and Its Applications - книга](https://www.amazon.com/Graph-Theory-Applications-Jonathan-Gross/dp/158488505X)
- [Курс по алгоритмам на графах на Coursera](https://www.coursera.org/learn/algorithms-on-graphs)
- [igraph - библиотека для анализа больших графов](https://igraph.org/python/)