# Регулярные выражения в Python

## Введение

Регулярные выражения (regular expressions, или сокращенно regex) — это мощный инструмент для работы с текстом, который позволяет искать, извлекать и манипулировать строками по определенным шаблонам. Регулярные выражения используются во многих языках программирования, и Python предоставляет удобный модуль `re` для работы с ними.

В этом уроке мы рассмотрим основы регулярных выражений в Python и научимся решать различные задачи, связанные с обработкой текста.

## Основы регулярных выражений

Регулярное выражение — это последовательность символов, которая определяет шаблон поиска. Этот шаблон может использоваться для поиска, извлечения или замены текста в строке.

### Модуль re в Python

Для работы с регулярными выражениями в Python используется модуль `re`:

```python
import re
```

Основные функции модуля `re`:

- `re.search()` — ищет первое совпадение шаблона в строке
- `re.match()` — ищет совпадение только в начале строки
- `re.fullmatch()` — проверяет, совпадает ли вся строка с шаблоном
- `re.findall()` — находит все совпадения шаблона в строке
- `re.finditer()` — возвращает итератор по всем совпадениям
- `re.sub()` — заменяет совпадения шаблона на указанную строку
- `re.split()` — разделяет строку по совпадениям шаблона
- `re.compile()` — компилирует регулярное выражение для повторного использования

### Простые шаблоны

Простейшие регулярные выражения — это обычные строки:

```python
import re

# Поиск подстроки в строке
result = re.search('Python', 'I love Python programming')
print(result)  # <re.Match object; span=(7, 13), match='Python'>

# Если совпадение не найдено, возвращается None
result = re.search('Java', 'I love Python programming')
print(result)  # None

# Проверка наличия совпадения
if re.search('Python', 'I love Python programming'):
    print('Подстрока "Python" найдена')
else:
    print('Подстрока "Python" не найдена')
```

### Специальные символы и метасимволы

Регулярные выражения становятся по-настоящему мощными благодаря специальным символам и метасимволам:

- `.` — любой символ, кроме новой строки
- `^` — начало строки
- `$` — конец строки
- `*` — 0 или более повторений предыдущего символа/группы
- `+` — 1 или более повторений предыдущего символа/группы
- `?` — 0 или 1 повторение предыдущего символа/группы
- `{n}` — ровно n повторений предыдущего символа/группы
- `{n,m}` — от n до m повторений предыдущего символа/группы
- `{n,}` — n или более повторений предыдущего символа/группы
- `[]` — набор символов (например, `[abc]` — a, b или c)
- `[^]` — отрицание набора символов (например, `[^abc]` — любой символ, кроме a, b, c)
- `|` — альтернатива (ИЛИ)
- `()` — группировка выражений
- `\` — экранирование специальных символов

```python
import re

# . — любой символ
result = re.search('Py...n', 'Python')
print(result)  # <re.Match object; span=(0, 6), match='Python'>

# ^ — начало строки
result = re.search('^Python', 'Python rules')
print(result)  # <re.Match object; span=(0, 6), match='Python'>
result = re.search('^Python', 'I love Python')
print(result)  # None

# $ — конец строки
result = re.search('Python$', 'I love Python')
print(result)  # <re.Match object; span=(7, 13), match='Python'>
result = re.search('Python$', 'Python rules')
print(result)  # None

# * — 0 или более повторений
result = re.search('ab*c', 'ac')
print(result)  # <re.Match object; span=(0, 2), match='ac'>
result = re.search('ab*c', 'abc')
print(result)  # <re.Match object; span=(0, 3), match='abc'>
result = re.search('ab*c', 'abbc')
print(result)  # <re.Match object; span=(0, 4), match='abbc'>

# + — 1 или более повторений
result = re.search('ab+c', 'ac')
print(result)  # None
result = re.search('ab+c', 'abc')
print(result)  # <re.Match object; span=(0, 3), match='abc'>

# ? — 0 или 1 повторение
result = re.search('ab?c', 'ac')
print(result)  # <re.Match object; span=(0, 2), match='ac'>
result = re.search('ab?c', 'abc')
print(result)  # <re.Match object; span=(0, 3), match='abc'>
result = re.search('ab?c', 'abbc')
print(result)  # None

# {n} — ровно n повторений
result = re.search('a{3}', 'aaa')
print(result)  # <re.Match object; span=(0, 3), match='aaa'>
result = re.search('a{3}', 'aa')
print(result)  # None

# {n,m} — от n до m повторений
result = re.search('a{2,4}', 'a')
print(result)  # None
result = re.search('a{2,4}', 'aa')
print(result)  # <re.Match object; span=(0, 2), match='aa'>
result = re.search('a{2,4}', 'aaaa')
print(result)  # <re.Match object; span=(0, 4), match='aaaa'>
result = re.search('a{2,4}', 'aaaaa')
print(result)  # <re.Match object; span=(0, 4), match='aaaa'>

# [] — набор символов
result = re.search('[abc]', 'b')
print(result)  # <re.Match object; span=(0, 1), match='b'>
result = re.search('[abc]', 'd')
print(result)  # None

# [^] — отрицание набора символов
result = re.search('[^abc]', 'b')
print(result)  # None
result = re.search('[^abc]', 'd')
print(result)  # <re.Match object; span=(0, 1), match='d'>

# | — альтернатива (ИЛИ)
result = re.search('a|b', 'a')
print(result)  # <re.Match object; span=(0, 1), match='a'>
result = re.search('a|b', 'b')
print(result)  # <re.Match object; span=(0, 1), match='b'>
result = re.search('a|b', 'c')
print(result)  # None

# () — группировка выражений
result = re.search('(ab)+', 'ababab')
print(result)  # <re.Match object; span=(0, 6), match='ababab'>

# \ — экранирование специальных символов
result = re.search('\+', '+')  # Ищем символ +
print(result)  # <re.Match object; span=(0, 1), match='+'>
```

### Предопределенные классы символов

Python предоставляет ряд предопределенных классов символов для часто используемых наборов:

- `\d` — цифры (эквивалентно `[0-9]`)
- `\D` — не цифры (эквивалентно `[^0-9]`)
- `\w` — буквы, цифры и подчеркивание (эквивалентно `[a-zA-Z0-9_]`)
- `\W` — не буквы, не цифры и не подчеркивание (эквивалентно `[^a-zA-Z0-9_]`)
- `\s` — пробельные символы (пробел, табуляция, новая строка и т.д.)
- `\S` — не пробельные символы
- `\b` — граница слова
- `\B` — не граница слова

```python
import re

# \d — цифры
result = re.search('\d+', 'abc123')
print(result)  # <re.Match object; span=(3, 6), match='123'>

# \D — не цифры
result = re.search('\D+', '123abc')
print(result)  # <re.Match object; span=(3, 6), match='abc'>

# \w — буквы, цифры и подчеркивание
result = re.search('\w+', 'abc_123')
print(result)  # <re.Match object; span=(0, 7), match='abc_123'>

# \W — не буквы, не цифры и не подчеркивание
result = re.search('\W+', 'abc!@#123')
print(result)  # <re.Match object; span=(3, 6), match='!@#'>

# \s — пробельные символы
result = re.search('\s+', 'abc 123')
print(result)  # <re.Match object; span=(3, 4), match=' '>

# \S — не пробельные символы
result = re.search('\S+', ' abc ')
print(result)  # <re.Match object; span=(1, 4), match='abc'>

# \b — граница слова
result = re.search(r'\bworld\b', 'Hello world!')
print(result)  # <re.Match object; span=(6, 11), match='world'>
result = re.search(r'\bworld\b', 'Hello worldly!')
print(result)  # None

# \B — не граница слова
result = re.search(r'\Bworld\B', 'Helloworld!')
print(result)  # None
result = re.search(r'\Bworld\B', 'HelloworldlyPerson')
print(result)  # <re.Match object; span=(5, 10), match='world'>
```

**Примечание**: При использовании предопределенных классов с обратной косой чертой (`\`) рекомендуется использовать сырые строки (`r''`), чтобы избежать проблем с экранированием.

## Группы и захваты

Группы позволяют захватывать части совпадения для дальнейшего использования.

### Создание групп

Группы создаются с помощью круглых скобок `()`:

```python
import re

# Простая группа
result = re.search('(Python)', 'I love Python programming')
if result:
    print(result.group(0))  # Python (все совпадение)
    print(result.group(1))  # Python (первая группа)

# Несколько групп
result = re.search('(I) (love) (Python)', 'I love Python programming')
if result:
    print(result.group(0))  # I love Python (все совпадение)
    print(result.group(1))  # I (первая группа)
    print(result.group(2))  # love (вторая группа)
    print(result.group(3))  # Python (третья группа)
    print(result.groups())  # ('I', 'love', 'Python') (все группы)

# Вложенные группы
result = re.search('(I (love) Python)', 'I love Python programming')
if result:
    print(result.group(0))  # I love Python (все совпадение)
    print(result.group(1))  # I love Python (первая группа)
    print(result.group(2))  # love (вторая группа)
```

### Именованные группы

Вместо доступа к группам по индексам, можно назначать им имена с помощью синтаксиса `(?P<name>pattern)`:

```python
import re

# Именованные группы
pattern = r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})'
result = re.search(pattern, 'Today is 2023-05-15')
if result:
    print(result.group('year'))   # 2023
    print(result.group('month'))  # 05
    print(result.group('day'))    # 15
    print(result.groupdict())     # {'year': '2023', 'month': '05', 'day': '15'}
```

### Несохраняющие группы

Если вам нужна группировка, но не нужно сохранять результат, можно использовать несохраняющие группы с синтаксисом `(?:pattern)`:

```python
import re

# Обычные группы
result = re.search('(abc)(def)', 'abcdef')
print(result.groups())  # ('abc', 'def')

# Несохраняющая группа
result = re.search('(?:abc)(def)', 'abcdef')
print(result.groups())  # ('def',)
```

## Функции модуля re

### re.search()

Ищет первое совпадение шаблона в строке:

```python
import re

result = re.search('Python', 'I love Python programming')
if result:
    print(f'Найдено "{result.group()}" на позиции {result.start()}')  # Найдено "Python" на позиции 7

# Дополнительные атрибуты объекта Match
if result:
    print(f'Начало: {result.start()}')  # 7
    print(f'Конец: {result.end()}')     # 13
    print(f'Диапазон: {result.span()}')  # (7, 13)
```

### re.match()

Ищет совпадение только в начале строки:

```python
import re

# Совпадение в начале строки
result = re.match('Python', 'Python programming')
print(result)  # <re.Match object; span=(0, 6), match='Python'>

# Нет совпадения в начале строки
result = re.match('Python', 'I love Python programming')
print(result)  # None
```

### re.fullmatch()

Проверяет, совпадает ли вся строка с шаблоном:

```python
import re

# Полное совпадение
result = re.fullmatch('Python', 'Python')
print(result)  # <re.Match object; span=(0, 6), match='Python'>

# Неполное совпадение
result = re.fullmatch('Python', 'Python programming')
print(result)  # None
```

### re.findall()

Находит все совпадения шаблона в строке:

```python
import re

# Найти все числа в строке
result = re.findall('\d+', 'The price is 1500 rubles or 25 dollars')
print(result)  # ['1500', '25']

# Найти все слова
result = re.findall('\w+', 'Hello, world! How are you?')
print(result)  # ['Hello', 'world', 'How', 'are', 'you']

# Использование групп в findall
result = re.findall('(\d+)-(\d+)', '10-20, 30-40, 50-60')
print(result)  # [('10', '20'), ('30', '40'), ('50', '60')]
```

### re.finditer()

Возвращает итератор по всем совпадениям:

```python
import re

# Найти все числа в строке
results = re.finditer('\d+', 'The price is 1500 rubles or 25 dollars')
for match in results:
    print(f'Найдено {match.group()} на позиции {match.start()}')
# Найдено 1500 на позиции 13
# Найдено 25 на позиции 28
```

### re.sub()

Заменяет совпадения шаблона указанной строкой:

```python
import re

# Простая замена
result = re.sub('Java', 'Python', 'I love Java programming')
print(result)  # I love Python programming

# Замена нескольких совпадений
result = re.sub('\d+', 'X', 'The price is 1500 rubles or 25 dollars')
print(result)  # The price is X rubles or X dollars

# Использование функции для замены
def replace_numbers(match):
    number = int(match.group(0))
    return str(number * 2)

result = re.sub('\d+', replace_numbers, 'The price is 1500 rubles or 25 dollars')
print(result)  # The price is 3000 rubles or 50 dollars

# Использование групп в re.sub
result = re.sub(r'(\d+)-(\d+)', r'\2-\1', '10-20, 30-40, 50-60')
print(result)  # 20-10, 40-30, 60-50
```

### re.split()

Разделяет строку по совпадениям шаблона:

```python
import re

# Разделение по пробелам
result = re.split('\s+', 'Hello   world   how  are  you')
print(result)  # ['Hello', 'world', 'how', 'are', 'you']

# Разделение по нескольким разделителям
result = re.split('[,;]', 'apple,banana;cherry,orange;grape')
print(result)  # ['apple', 'banana', 'cherry', 'orange', 'grape']

# Ограничение количества разделений
result = re.split('\s+', 'Hello world how are you', maxsplit=2)
print(result)  # ['Hello', 'world', 'how are you']

# Сохранение разделителей в результате
result = re.split('(\s+)', 'Hello   world')
print(result)  # ['Hello', '   ', 'world']
```

### re.compile()

Компилирует регулярное выражение для повторного использования:

```python
import re

# Компиляция регулярного выражения
pattern = re.compile('\d+')

# Использование скомпилированного выражения
result = pattern.search('The price is 1500 rubles')
print(result.group())  # 1500

# Использование других методов скомпилированного выражения
result = pattern.findall('The price is 1500 rubles or 25 dollars')
print(result)  # ['1500', '25']

result = pattern.sub('X', 'The price is 1500 rubles or 25 dollars')
print(result)  # The price is X rubles or X dollars
```

Компиляция регулярных выражений рекомендуется, если вы используете одно и то же выражение многократно, так как это повышает производительность.

## Флаги регулярных выражений

Флаги позволяют изменить поведение регулярных выражений:

- `re.IGNORECASE` или `re.I` — игнорирование регистра
- `re.MULTILINE` или `re.M` — работа в многострочном режиме (^ и $ соответствуют началу и концу каждой строки)
- `re.DOTALL` или `re.S` — точка (.) соответствует любому символу, включая новую строку
- `re.VERBOSE` или `re.X` — разрешает комментарии и пробелы в шаблоне
- `re.ASCII` или `re.A` — \w, \W, \b, \B, \d, \D, \s и \S соответствуют только ASCII символам
- `re.UNICODE` или `re.U` — \w, \W, \b, \B, \d, \D, \s и \S соответствуют Unicode символам (по умолчанию в Python 3)

```python
import re

# re.IGNORECASE — игнорирование регистра
result = re.search('python', 'I love Python programming')
print(result)  # None
result = re.search('python', 'I love Python programming', re.IGNORECASE)
print(result)  # <re.Match object; span=(7, 13), match='Python'>

# re.MULTILINE — многострочный режим
text = """First line
Second line
Third line"""
result = re.findall('^.+$', text)
print(result)  # ['First line\nSecond line\nThird line']
result = re.findall('^.+$', text, re.MULTILINE)
print(result)  # ['First line', 'Second line', 'Third line']

# re.DOTALL — точка соответствует любому символу, включая новую строку
result = re.search('First.+Third', text)
print(result)  # None
result = re.search('First.+Third', text, re.DOTALL)
print(result)  # <re.Match object; span=(0, 31), match='First line\nSecond line\nThird'>

# re.VERBOSE — разрешает комментарии и пробелы в шаблоне
phone_pattern = re.compile(r'''
    \((\d{3})\)  # код города
    \s*          # необязательные пробелы
    (\d{3})      # первые три цифры
    -            # разделитель
    (\d{4})      # последние четыре цифры
    ''', re.VERBOSE)
result = phone_pattern.search('Call me at (123) 456-7890')
print(result.groups())  # ('123', '456', '7890')
```

Флаги можно комбинировать с помощью оператора `|`:

```python
import re

result = re.search('python.+end', 'Python\nmultiline\nend', re.IGNORECASE | re.DOTALL)
print(result)  # <re.Match object; span=(0, 22), match='Python\nmultiline\nend'>
```

## Жадные и ленивые квантификаторы

По умолчанию квантификаторы (`*`, `+`, `?`, `{n,m}`) являются "жадными" — они стараются захватить как можно больше символов:

```python
import re

# Жадный квантификатор
result = re.search('<.+>', '<tag>content</tag>')
print(result.group())  # <tag>content</tag>
```

Чтобы сделать квантификатор "ленивым" (захватывающим как можно меньше символов), добавьте после него вопросительный знак (`?`):

```python
import re

# Ленивый квантификатор
result = re.search('<.+?>', '<tag>content</tag>')
print(result.group())  # <tag>
```

## Опережающие и ретроспективные проверки

Эти конструкции позволяют проверить, что перед или после определенного фрагмента есть (или нет) определенный шаблон, не включая его в результат:

- Положительная опережающая проверка: `(?=pattern)` — проверяет, что после текущей позиции есть шаблон
- Отрицательная опережающая проверка: `(?!pattern)` — проверяет, что после текущей позиции нет шаблона
- Положительная ретроспективная проверка: `(?<=pattern)` — проверяет, что перед текущей позицией есть шаблон
- Отрицательная ретроспективная проверка: `(?<!pattern)` — проверяет, что перед текущей позицией нет шаблона

```python
import re

# Положительная опережающая проверка
# Найти все числа, за которыми следует слово "dollars"
result = re.findall('\d+(?=\s*dollars)', 'It costs 10 dollars, 20 euros, and 30 dollars')
print(result)  # ['10', '30']

# Отрицательная опережающая проверка
# Найти все числа, за которыми НЕ следует слово "dollars"
result = re.findall('\d+(?!\s*dollars)', 'It costs 10 dollars, 20 euros, and 30 dollars')
print(result)  # ['20']

# Положительная ретроспективная проверка
# Найти все числа, перед которыми есть слово "price"
result = re.findall('(?<=price\s*)\d+', 'The price 100, not the price 200.')
print(result)  # ['100', '200']

# Отрицательная ретроспективная проверка
# Найти все числа, перед которыми НЕТ слова "price"
result = re.findall('(?<!price\s*)\d+', 'Cost is 50, the price 100.')
print(result)  # ['50']
```

## Практические примеры

### Пример 1: Валидация электронной почты

```python
import re

def is_valid_email(email):
    """Проверяет, является ли строка корректным email-адресом"""
    # Простой паттерн для проверки email
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

# Тестирование
emails = [
    'user@example.com',
    'john.doe@company-name.co.uk',
    'invalid.email@',
    '@example.com',
    'user@.com',
    'user@example.',
    'user@example.c',
    'user@example..com'
]

for email in emails:
    valid = is_valid_email(email)
    print(f'{email}: {"Валидный" if valid else "Невалидный"}')
```

Результат:

```
user@example.com: Валидный
john.doe@company-name.co.uk: Валидный
invalid.email@: Невалидный
@example.com: Невалидный
user@.com: Невалидный
user@example.: Невалидный
user@example.c: Невалидный
user@example..com: Невалидный
```

### Пример 2: Извлечение данных из текста

```python
import re

def extract_phone_numbers(text):
    """Извлекает телефонные номера из текста"""
    # Шаблон для российских номеров: +7(XXX)XXX-XX-XX или +7 XXX XXX XX XX
    pattern = r'(?:\+7|8)[- (]*(\d{3})[- )]*(\d{3})[- ]*(\d{2})[- ]*(\d{2})'
    matches = re.findall(pattern, text)
    
    # Форматируем найденные номера
    formatted_numbers = []
    for match in matches:
        formatted = f'+7({match[0]}){match[1]}-{match[2]}-{match[3]}'
        formatted_numbers.append(formatted)
    
    return formatted_numbers

def extract_urls(text):
    """Извлекает URL-адреса из текста"""
    # Шаблон для поиска URL
    pattern = r'https?://[^\s<>"]+|www\.[^\s<>"]+'
    return re.findall(pattern, text)

def extract_dates(text):
    """Извлекает даты из текста в формате DD.MM.YYYY"""
    pattern = r'\b(\d{1,2})\.(\d{1,2})\.(\d{4})\b'
    matches = re.findall(pattern, text)
    
    # Форматируем найденные даты
    formatted_dates = []
    for day, month, year in matches:
        formatted = f'{int(day):02d}.{int(month):02d}.{year}'
        formatted_dates.append(formatted)
    
    return formatted_dates

# Пример использования
text = """
Добрый день! Свяжитесь со мной по номеру +7(123)456-78-90 или по электронной почте user@example.com.
Встреча состоится 15.05.2023. Дополнительная информация на сайте https://example.com/meeting.
Вы также можете позвонить по номеру 8 987 654 32 10.
"""

print("Телефонные номера:")
phones = extract_phone_numbers(text)
for phone in phones:
    print(f"  - {phone}")

print("\nURL-адреса:")
urls = extract_urls(text)
for url in urls:
    print(f"  - {url}")

print("\nДаты:")
dates = extract_dates(text)
for date in dates:
    print(f"  - {date}")
```

Результат:

```
Телефонные номера:
  - +7(123)456-78-90
  - +7(987)654-32-10

URL-адреса:
  - https://example.com/meeting

Даты:
  - 15.05.2023
```

### Пример 3: Парсинг логов

```python
import re

def parse_apache_log(log_file):
    """Парсинг лог-файла Apache и извлечение информации о запросах"""
    # Шаблон для парсинга строки лога Apache
    pattern = r'(\d+\.\d+\.\d+\.\d+) - - \[(.*?)\] "(.*?)" (\d+) (\d+|-)'
    
    results = {
        'total_requests': 0,
        'status_codes': {},
        'request_methods': {},
        'urls': {},
        'client_ips': {}
    }
    
    with open(log_file, 'r') as file:
        for line in file:
            match = re.search(pattern, line)
            if match:
                ip, date, request, status, size = match.groups()
                
                results['total_requests'] += 1
                
                # Подсчет по статус-кодам
                if status in results['status_codes']:
                    results['status_codes'][status] += 1
                else:
                    results['status_codes'][status] = 1
                
                # Разбор строки запроса на метод и URL
                request_parts = request.split()
                if len(request_parts) >= 2:
                    method, url = request_parts[0], request_parts[1]
                    
                    # Подсчет по методам запроса
                    if method in results['request_methods']:
                        results['request_methods'][method] += 1
                    else:
                        results['request_methods'][method] = 1
                    
                    # Подсчет по URL
                    if url in results['urls']:
                        results['urls'][url] += 1
                    else:
                        results['urls'][url] = 1
                
                # Подсчет по IP-адресам
                if ip in results['client_ips']:
                    results['client_ips'][ip] += 1
                else:
                    results['client_ips'][ip] = 1
    
    return results

# Пример использования функции
# results = parse_apache_log('access.log')
# print(f"Всего запросов: {results['total_requests']}")
# print(f"Статус-коды: {results['status_codes']}")
# print(f"Методы запросов: {results['request_methods']}")
# print(f"Топ 5 URL: {sorted(results['urls'].items(), key=lambda x: x[1], reverse=True)[:5]}")
# print(f"Топ 5 IP-адресов: {sorted(results['client_ips'].items(), key=lambda x: x[1], reverse=True)[:5]}")

# Имитация лог-файла для демонстрации
def generate_mock_log(file_name, num_entries=100):
    """Генерирует имитацию лог-файла Apache"""
    import random
    from datetime import datetime, timedelta
    
    ip_addresses = [f"192.168.1.{random.randint(1, 255)}" for _ in range(10)]
    urls = ["/", "/home", "/about", "/contact", "/products", "/services", "/login", "/logout"]
    methods = ["GET", "POST", "PUT", "DELETE"]
    status_codes = ["200", "301", "404", "500"]
    
    with open(file_name, 'w') as file:
        start_time = datetime.now() - timedelta(days=1)
        
        for i in range(num_entries):
            ip = random.choice(ip_addresses)
            date = start_time + timedelta(seconds=random.randint(1, 86400))
            date_str = date.strftime("%d/%b/%Y:%H:%M:%S %z")
            method = random.choice(methods)
            url = random.choice(urls)
            protocol = "HTTP/1.1"
            status = random.choice(status_codes)
            size = str(random.randint(100, 10000)) if status != "500" else "-"
            
            log_line = f'{ip} - - [{date_str}] "{method} {url} {protocol}" {status} {size}\n'
            file.write(log_line)
    
    return file_name

# Создаем имитацию лог-файла
log_file = generate_mock_log('mock_apache.log', 1000)

# Анализируем лог
results = parse_apache_log(log_file)

# Выводим результаты
print(f"Всего запросов: {results['total_requests']}")
print("\nСтатус-коды:")
for status, count in sorted(results['status_codes'].items()):
    print(f"  {status}: {count} ({count/results['total_requests']*100:.1f}%)")

print("\nМетоды запросов:")
for method, count in sorted(results['request_methods'].items()):
    print(f"  {method}: {count} ({count/results['total_requests']*100:.1f}%)")

print("\nТоп 5 URL:")
for url, count in sorted(results['urls'].items(), key=lambda x: x[1], reverse=True)[:5]:
    print(f"  {url}: {count} ({count/results['total_requests']*100:.1f}%)")

print("\nТоп 5 IP-адресов:")
for ip, count in sorted(results['client_ips'].items(), key=lambda x: x[1], reverse=True)[:5]:
    print(f"  {ip}: {count} ({count/results['total_requests']*100:.1f}%)")
```

## Практические задания

### Задание 1: Валидатор паролей

Создайте функцию, которая проверяет, соответствует ли пароль следующим требованиям:

1. Длина не менее 8 символов
2. Содержит хотя бы одну заглавную букву
3. Содержит хотя бы одну строчную букву
4. Содержит хотя бы одну цифру
5. Содержит хотя бы один специальный символ из набора !@#$%^&*()_+-=[]{}|;:,.<>?

**Решение:**

```python
import re

def validate_password(password):
    """
    Проверяет, соответствует ли пароль требованиям безопасности
    
    Возвращает:
    - True, если пароль соответствует всем требованиям
    - Список нарушенных требований в противном случае
    """
    violations = []
    
    # Проверка длины
    if len(password) < 8:
        violations.append("Длина пароля должна быть не менее 8 символов")
    
    # Проверка наличия заглавной буквы
    if not re.search(r'[A-Z]', password):
        violations.append("Пароль должен содержать хотя бы одну заглавную букву")
    
    # Проверка наличия строчной буквы
    if not re.search(r'[a-z]', password):
        violations.append("Пароль должен содержать хотя бы одну строчную букву")
    
    # Проверка наличия цифры
    if not re.search(r'\d', password):
        violations.append("Пароль должен содержать хотя бы одну цифру")
    
    # Проверка наличия специального символа
    if not re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
        violations.append("Пароль должен содержать хотя бы один специальный символ")
    
    # Если список нарушений пуст, пароль валидный
    if not violations:
        return True
    
    return violations

# Функция для интерактивной проверки паролей
def check_password_interactive():
    while True:
        password = input("Введите пароль для проверки (или 'выход' для завершения): ")
        
        if password.lower() == 'выход':
            break
        
        result = validate_password(password)
        
        if result is True:
            print("Пароль соответствует всем требованиям безопасности!")
        else:
            print("Пароль не соответствует следующим требованиям:")
            for violation in result:
                print(f"- {violation}")

# Тестирование функции
test_passwords = [
    "password",  # слишком простой
    "Password",  # нет цифры и спецсимвола
    "Password1",  # нет спецсимвола
    "password1!",  # нет заглавной буквы
    "PASSWORD1!",  # нет строчной буквы
    "Pa55w0rd!",  # валидный
    "Tr0ub4dor&3"  # валидный
]

print("Тестирование валидатора паролей:\n")
for password in test_passwords:
    result = validate_password(password)
    if result is True:
        print(f"'{password}' - Валидный пароль ✅")
    else:
        print(f"'{password}' - Невалидный пароль ❌")
        for violation in result:
            print(f"  - {violation}")
    print()

# Запуск интерактивной проверки
# check_password_interactive()
```

### Задание 2: Анализатор текста

Создайте программу, которая анализирует текст и выводит следующую информацию:

1. Количество слов
2. Количество предложений
3. Частотный словарь слов
4. Топ-10 самых используемых слов
5. Среднюю длину слова
6. Среднюю длину предложения (в словах)

**Решение:**

```python
import re
import string
from collections import Counter

class TextAnalyzer:
    def __init__(self, text):
        """Инициализирует анализатор с заданным текстом"""
        self.text = text
        self.words = []
        self.sentences = []
        self.word_counts = Counter()
        
        # Анализируем текст при создании экземпляра
        self._analyze()
    
    def _analyze(self):
        """Проводит анализ текста"""
        # Разбиваем текст на предложения
        # Учитываем что предложение может заканчиваться точкой, восклицательным или вопросительным знаком
        self.sentences = re.findall(r'[^.!?]+[.!?]', self.text)
        
        # Очищаем предложения от лишних пробелов
        self.sentences = [s.strip() for s in self.sentences]
        
        # Извлекаем слова из текста (только буквы и цифры)
        self.words = re.findall(r'\b[a-zA-Zа-яА-Я0-9]+\b', self.text.lower())
        
        # Подсчитываем частоту слов
        self.word_counts = Counter(self.words)
    
    def get_word_count(self):
        """Возвращает количество слов в тексте"""
        return len(self.words)
    
    def get_sentence_count(self):
        """Возвращает количество предложений в тексте"""
        return len(self.sentences)
    
    def get_average_word_length(self):
        """Возвращает среднюю длину слова"""
        if not self.words:
            return 0
        return sum(len(word) for word in self.words) / len(self.words)
    
    def get_average_sentence_length(self):
        """Возвращает среднюю длину предложения в словах"""
        if not self.sentences:
            return 0
        
        sentence_lengths = []
        for sentence in self.sentences:
            words_in_sentence = re.findall(r'\b[a-zA-Zа-яА-Я0-9]+\b', sentence.lower())
            sentence_lengths.append(len(words_in_sentence))
        
        return sum(sentence_lengths) / len(self.sentences)
    
    def get_most_common_words(self, n=10):
        """Возвращает n самых часто используемых слов"""
        return self.word_counts.most_common(n)
    
    def get_word_frequency(self, word):
        """Возвращает частоту указанного слова"""
        return self.word_counts.get(word.lower(), 0)
    
    def generate_report(self):
        """Генерирует отчет об анализе текста"""
        report = []
        report.append("АНАЛИЗ ТЕКСТА")
        report.append("=" * 50)
        report.append(f"Количество слов: {self.get_word_count()}")
        report.append(f"Количество предложений: {self.get_sentence_count()}")
        report.append(f"Средняя длина слова: {self.get_average_word_length():.2f} символов")
        report.append(f"Средняя длина предложения: {self.get_average_sentence_length():.2f} слов")
        
        report.append("\nТоп-10 самых используемых слов:")
        for word, count in self.get_most_common_words(10):
            report.append(f"  {word}: {count}")
        
        return "\n".join(report)

# Тестирование анализатора текста
sample_text = """
Python - это высокоуровневый язык программирования, который был создан Гвидо ван Россумом в 1991 году. 
Python славится своей читаемостью и простотой синтаксиса, что делает его отличным выбором для начинающих программистов.
Однако, несмотря на простоту, Python является мощным языком, который используется в самых разных областях.

Веб-разработка, анализ данных, машинное обучение, научные расчеты - вот лишь некоторые из областей, где Python нашел широкое применение.
Такие крупные компании, как Google, Facebook, Netflix и NASA, активно используют Python в своих проектах.
Почему же Python стал таким популярным?

Во-первых, Python имеет огромное сообщество разработчиков, которые создают множество библиотек и инструментов.
Во-вторых, Python является кроссплатформенным языком и работает на различных операционных системах.
В-третьих, Python поддерживает различные парадигмы программирования, включая объектно-ориентированное, процедурное и функциональное программирование.

В последние годы Python стал особенно популярен в области искусственного интеллекта и машинного обучения благодаря таким библиотекам, как TensorFlow, PyTorch и scikit-learn.
"""

analyzer = TextAnalyzer(sample_text)
print(analyzer.generate_report())
```

### Задание 3: Парсер CSV-файлов с помощью регулярных выражений

Создайте парсер CSV-файлов, который:

1. Корректно обрабатывает поля в кавычках, включая запятые внутри полей
2. Обрабатывает экранированные символы внутри кавычек
3. Поддерживает разные разделители (запятая, точка с запятой, табуляция)
4. Возвращает результат в виде списка словарей, где ключи — заголовки столбцов

**Решение:**

```python
import re
import csv

class CSVParser:
    def __init__(self, delimiter=',', quotechar='"', escapechar='\\'):
        """
        Инициализирует парсер CSV с заданными параметрами
        
        Args:
            delimiter: Символ-разделитель полей
            quotechar: Символ кавычек для полей
            escapechar: Символ экранирования
        """
        self.delimiter = delimiter
        self.quotechar = quotechar
        self.escapechar = escapechar
    
    def parse_line(self, line):
        """
        Разбирает строку CSV на отдельные поля
        
        Args:
            line: Строка CSV для разбора
        
        Returns:
            Список полей из строки
        """
        # Создаем шаблон для поиска полей
        # Учитываем:
        # 1. Поля в кавычках, которые могут содержать разделители
        # 2. Поля без кавычек
        pattern = fr'''
            # Группа 1: Поле в кавычках
            {self.quotechar}((?:[^{self.quotechar}]|{self.escapechar}{self.quotechar})*){self.quotechar}
            # или
            |
            # Группа 2: Поле без кавычек
            ([^{self.delimiter}\n\r]*)
        '''
        
        # Находим все совпадения
        matches = re.finditer(pattern, line, re.VERBOSE)
        
        fields = []
        for match in matches:
            # Если поле в кавычках
            if match.group(1) is not None:
                # Заменяем экранированные кавычки на обычные
                field = match.group(1).replace(f'{self.escapechar}{self.quotechar}', self.quotechar)
                fields.append(field)
            # Если поле без кавычек
            elif match.group(2) is not None:
                fields.append(match.group(2))
        
        return fields
    
    def parse_file(self, file_path):
        """
        Разбирает CSV-файл
        
        Args:
            file_path: Путь к CSV-файлу
        
        Returns:
            Список словарей, где ключи — заголовки, а значения — данные
        """
        result = []
        headers = []
        
        with open(file_path, 'r', encoding='utf-8') as file:
            # Читаем первую строку (заголовки)
            header_line = file.readline().strip()
            headers = self.parse_line(header_line)
            
            # Читаем остальные строки
            for line in file:
                line = line.strip()
                if not line:  # Пропускаем пустые строки
                    continue
                
                fields = self.parse_line(line)
                
                # Создаем словарь для текущей строки
                row_dict = {}
                for i, field in enumerate(fields):
                    # Если полей больше, чем заголовков, используем индекс
                    if i < len(headers):
                        row_dict[headers[i]] = field
                    else:
                        row_dict[f'Column{i+1}'] = field
                
                result.append(row_dict)
        
        return result
    
    def parse_string(self, csv_string):
        """
        Разбирает строку, содержащую CSV-данные
        
        Args:
            csv_string: Строка с CSV-данными
        
        Returns:
            Список словарей, где ключи — заголовки, а значения — данные
        """
        result = []
        headers = []
        
        lines = csv_string.strip().split('\n')
        if not lines:
            return result
        
        # Читаем первую строку (заголовки)
        headers = self.parse_line(lines[0])
        
        # Читаем остальные строки
        for i in range(1, len(lines)):
            line = lines[i].strip()
            if not line:  # Пропускаем пустые строки
                continue
            
            fields = self.parse_line(line)
            
            # Создаем словарь для текущей строки
            row_dict = {}
            for i, field in enumerate(fields):
                # Если полей больше, чем заголовков, используем индекс
                if i < len(headers):
                    row_dict[headers[i]] = field
                else:
                    row_dict[f'Column{i+1}'] = field
            
            result.append(row_dict)
        
        return result
    
    def to_csv(self, data, file_path=None, include_headers=True):
        """
        Преобразует список словарей в CSV-формат
        
        Args:
            data: Список словарей для преобразования
            file_path: Путь к файлу для сохранения (если None, возвращает строку)
            include_headers: Включать ли заголовки в результат
        
        Returns:
            Строка в формате CSV или None, если результат сохранен в файл
        """
        if not data:
            return "" if file_path is None else None
        
        # Собираем все уникальные ключи в качестве заголовков
        headers = set()
        for row in data:
            headers.update(row.keys())
        headers = sorted(list(headers))
        
        # Формируем строки CSV
        csv_lines = []
        
        # Добавляем заголовки
        if include_headers:
            header_line = self.delimiter.join([
                f'{self.quotechar}{header.replace(self.quotechar, f"{self.escapechar}{self.quotechar}")}{self.quotechar}'
                for header in headers
            ])
            csv_lines.append(header_line)
        
        # Добавляем данные
        for row in data:
            fields = []
            for header in headers:
                value = row.get(header, "")
                # Экранируем кавычки
                value = str(value).replace(self.quotechar, f"{self.escapechar}{self.quotechar}")
                # Если значение содержит разделитель или перевод строки, заключаем в кавычки
                if self.delimiter in value or '\n' in value or '\r' in value:
                    value = f'{self.quotechar}{value}{self.quotechar}'
                fields.append(value)
            csv_lines.append(self.delimiter.join(fields))
        
        # Соединяем строки
        csv_string = '\n'.join(csv_lines)
        
        # Если указан файл, сохраняем в него
        if file_path:
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(csv_string)
            return None
        
        return csv_string

# Тестирование парсера
test_csv = '''name,age,city
"John Doe",30,"New York, USA"
"Jane Smith",25,"Los Angeles, CA"
"Bob Johnson",40,"Chicago, IL"
"Alice Brown",35,"Houston, TX"
"Test ""quoted""",20,"San Francisco, CA"
'''

parser = CSVParser(delimiter=',', quotechar='"')
parsed_data = parser.parse_string(test_csv)

print("Parsed CSV data:")
for row in parsed_data:
    print(row)

# Тестирование преобразования обратно в CSV
output_csv = parser.to_csv(parsed_data)
print("\nOutput CSV:")
print(output_csv)

# Пример изменения данных
for row in parsed_data:
    if 'age' in row:
        row['age'] = str(int(row['age']) + 5)  # Прибавляем 5 лет к возрасту

# Сохранение в новый файл
# parser.to_csv(parsed_data, "modified.csv")

# Тестирование с другим разделителем (точка с запятой)
test_csv_semicolon = '''name;age;city
"John Doe";30;"New York; USA"
"Jane Smith";25;"Los Angeles; CA"
'''

parser_semicolon = CSVParser(delimiter=';', quotechar='"')
parsed_data_semicolon = parser_semicolon.parse_string(test_csv_semicolon)

print("\nParsed CSV data with semicolon delimiter:")
for row in parsed_data_semicolon:
    print(row)
```

## Идеи для улучшения

Вот несколько идей для улучшения этих заданий:

1. Валидатор паролей:
   - Добавить проверку на наличие пароля в словаре распространенных паролей
   - Реализовать визуальный индикатор силы пароля
   - Добавить генератор надежных паролей
   - Проверять пароль на наличие распространенных последовательностей (12345, qwerty и т.д.)

2. Анализатор текста:
   - Добавить определение языка текста
   - Добавить анализ эмоциональной окраски текста (сентимент-анализ)
   - Реализовать визуализацию результатов (графики, облака слов)
   - Добавить определение частей речи и синтаксический анализ

3. Парсер CSV-файлов:
   - Добавить поддержку разных кодировок
   - Добавить проверку типов данных в столбцах
   - Реализовать конвертацию между разными форматами (CSV, JSON, XML)
   - Добавить валидацию и очистку данных

## Заключение

В этом уроке мы изучили регулярные выражения в Python и их применение для работы с текстом. Мы рассмотрели:

- Основные принципы и синтаксис регулярных выражений
- Специальные символы и метасимволы
- Функции модуля `re` для поиска, замены и разделения текста
- Группы и захваты для извлечения информации
- Флаги регулярных выражений для настройки поведения
- Жадные и ленивые квантификаторы
- Опережающие и ретроспективные проверки
- Практические примеры использования регулярных выражений

Регулярные выражения — это мощный инструмент, который значительно упрощает работу с текстом и строками. Они широко используются в различных задачах:

- Валидация данных (email, телефоны, пароли)
- Парсинг и извлечение информации из текста
- Поиск и замена по шаблону
- Анализ логов и других структурированных текстовых данных

Однако стоит помнить, что сложные регулярные выражения могут быть трудными для чтения и отладки. Поэтому важно разбивать сложные выражения на более простые части и добавлять комментарии, объясняющие их работу.

В следующем уроке мы рассмотрим многопоточность и многопроцессорность в Python, что позволит вам создавать более эффективные и быстрые программы.
