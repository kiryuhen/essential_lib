# SOLID принципы в Python

## Содержание
1. [Введение](#введение)
2. [Принцип единственной ответственности (Single Responsibility Principle)](#принцип-единственной-ответственности-single-responsibility-principle)
3. [Принцип открытости/закрытости (Open/Closed Principle)](#принцип-открытостизакрытости-openclosed-principle)
4. [Принцип подстановки Барбары Лисков (Liskov Substitution Principle)](#принцип-подстановки-барбары-лисков-liskov-substitution-principle)
5. [Принцип разделения интерфейса (Interface Segregation Principle)](#принцип-разделения-интерфейса-interface-segregation-principle)
6. [Принцип инверсии зависимостей (Dependency Inversion Principle)](#принцип-инверсии-зависимостей-dependency-inversion-principle)
7. [Комбинированное применение SOLID принципов](#комбинированное-применение-solid-принципов)
8. [Практические задания](#практические-задания)
9. [Проект](#проект)
10. [Дополнительные ресурсы](#дополнительные-ресурсы)

## Введение

SOLID — это акроним, объединяющий пять основных принципов объектно-ориентированного проектирования и программирования, сформулированных Робертом Мартином (известным как "Uncle Bob"). Эти принципы помогают создавать программное обеспечение, которое легче поддерживать, понимать, расширять и тестировать. SOLID принципы особенно актуальны при работе над крупными, долгосрочными проектами, где код будет развиваться и обслуживаться в течение длительного времени.

Акроним SOLID расшифровывается следующим образом:

- **S** — Single Responsibility Principle (Принцип единственной ответственности)
- **O** — Open/Closed Principle (Принцип открытости/закрытости)
- **L** — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
- **I** — Interface Segregation Principle (Принцип разделения интерфейса)
- **D** — Dependency Inversion Principle (Принцип инверсии зависимостей)

Хотя SOLID принципы изначально были разработаны для статически типизированных объектно-ориентированных языков (таких как Java или C++), они также полезны и в динамически типизированных языках, таких как Python. Однако их применение в Python имеет свои особенности из-за специфики языка:

1. **Динамическая типизация**: В Python отсутствуют явные интерфейсы и статическая проверка типов, но это не означает, что мы не можем следовать SOLID принципам. Можно использовать абстрактные базовые классы, протоколы, утиную типизацию.

2. **Акцент на простоте**: Python придерживается философии "лучше явное, чем неявное" и "простота лучше сложности". Иногда это может противоречить слишком строгому соблюдению SOLID, которое может добавить дополнительную сложность и абстракцию.

3. **Функциональные возможности**: Python поддерживает как объектно-ориентированную, так и функциональную парадигмы. Иногда решения в функциональном стиле могут быть проще и элегантнее, чем решения в строго объектно-ориентированном стиле.

### Зачем нужны SOLID принципы?

SOLID принципы решают ряд общих проблем в разработке программного обеспечения:

1. **Жесткость (Rigidity)**: Система, в которой небольшие изменения вызывают каскад последующих изменений в зависимых модулях.
2. **Хрупкость (Fragility)**: Система, в которой изменения могут привести к неожиданным ошибкам в не связанных с изменением модулях.
3. **Неподвижность (Immobility)**: Сложность повторного использования кода, потому что компоненты слишком тесно связаны с системой.
4. **Вязкость (Viscosity)**: Когда внесение изменений "правильным" способом сложнее, чем обходным путем.
5. **Ненужная сложность (Needless Complexity)**: Излишняя абстракция и проектирование "на будущее", которое, возможно, никогда не наступит.

Следование SOLID принципам помогает создавать код, который:

- **Удобен для тестирования**: Модули с одной ответственностью проще тестировать.
- **Расширяем**: Новые функции можно добавлять без изменения существующего кода.
- **Удобен для сопровождения**: Изменения влияют только на конкретные модули, а не на всю систему.
- **Понятен**: Код организован логично, соответствуя бизнес-домену.
- **Надежен**: Код менее подвержен ошибкам при изменениях.

Теперь рассмотрим каждый из SOLID принципов подробно, с примерами и рекомендациями по их применению в Python.

## Принцип единственной ответственности (Single Responsibility Principle)

### Определение

Принцип единственной ответственности (SRP) утверждает:

> Каждый класс должен иметь только одну ответственность (причину для изменения).

Другими словами, класс должен отвечать только за что-то одно. Если у класса есть несколько обязанностей, они должны быть разделены на отдельные классы.

### Почему это важно?

1. **Упрощается понимание**: Классы с одной ответственностью проще понять.
2. **Снижается связанность**: Изменения в одной части системы меньше влияют на другие.
3. **Улучшается поддерживаемость**: Проще поддерживать и изменять код, когда ответственности четко разделены.
4. **Облегчается тестирование**: Классы с одной ответственностью проще тестировать.

### Пример нарушения SRP

Рассмотрим класс `Employee`, который отвечает за несколько вещей:

```python
class Employee:
    def __init__(self, name, position, salary):
        self.name = name
        self.position = position
        self.salary = salary
    
    def get_employee_info(self):
        return f"{self.name}, {self.position}"
    
    def calculate_pay(self):
        # Расчет заработной платы
        return self.salary * 0.9  # за вычетом налогов
    
    def save_to_database(self):
        # SQL запрос для сохранения сотрудника в базу данных
        print(f"Saving {self.name} to database")
    
    def generate_employee_report(self):
        # Генерация отчета по сотруднику
        report = f"Employee Report for {self.name}\n"
        report += f"Position: {self.position}\n"
        report += f"Salary: {self.salary}\n"
        return report
```

В этом классе есть несколько ответственностей:
1. Управление данными сотрудника (имя, должность, зарплата)
2. Расчет заработной платы
3. Сохранение в базу данных
4. Формирование отчетов

Это нарушение SRP, потому что класс изменяется по нескольким причинам:
- Изменение логики хранения данных сотрудника
- Изменение способа расчета заработной платы
- Изменение взаимодействия с базой данных
- Изменение формата отчетов

### Refactoring для соблюдения SRP

Разделим ответственности на отдельные классы:

```python
# Класс для управления данными сотрудника
class Employee:
    def __init__(self, name, position, salary):
        self.name = name
        self.position = position
        self.salary = salary
    
    def get_employee_info(self):
        return f"{self.name}, {self.position}"

# Класс для расчета заработной платы
class PayrollCalculator:
    @staticmethod
    def calculate_pay(employee):
        # Расчет заработной платы
        return employee.salary * 0.9  # за вычетом налогов

# Класс для взаимодействия с базой данных
class EmployeeRepository:
    @staticmethod
    def save(employee):
        # SQL запрос для сохранения сотрудника в базу данных
        print(f"Saving {employee.name} to database")
    
    @staticmethod
    def find_by_name(name):
        # SQL запрос для поиска сотрудника по имени
        print(f"Finding employee with name {name}")

# Класс для формирования отчетов
class EmployeeReportGenerator:
    @staticmethod
    def generate_report(employee):
        # Генерация отчета по сотруднику
        report = f"Employee Report for {employee.name}\n"
        report += f"Position: {employee.position}\n"
        report += f"Salary: {employee.salary}\n"
        return report
```

Теперь каждый класс имеет только одну ответственность:
- `Employee` управляет данными сотрудника
- `PayrollCalculator` занимается расчетом заработной платы
- `EmployeeRepository` отвечает за взаимодействие с базой данных
- `EmployeeReportGenerator` формирует отчеты

### Как определить "одну ответственность"?

Определение "одной ответственности" может быть субъективным. Вот несколько критериев, которые могут помочь определить, имеет ли класс одну ответственность:

1. **По причине изменения**: Класс должен иметь только одну причину для изменения. Если у вас есть несколько причин изменить класс, возможно, у него несколько ответственностей.

2. **По функциональной области**: Класс должен относиться к одной функциональной области (например, "бизнес-логика", "доступ к данным", "представление").

3. **По стейкхолдерам**: Класс должен удовлетворять требования только одного "стейкхолдера" (заинтересованного лица или группы).

4. **По уровню абстракции**: Все методы класса должны работать на одном уровне абстракции.

### Особенности применения SRP в Python

1. **Модули как единицы ответственности**: В Python модули также могут быть единицами ответственности. Организуйте код так, чтобы каждый модуль имел одну ответственность.

2. **Функции вместо классов**: Иногда в Python лучше использовать простые функции вместо создания классов с одним методом. Например:

```python
# Вместо
class PayrollCalculator:
    @staticmethod
    def calculate_pay(employee):
        return employee.salary * 0.9

# Можно просто
def calculate_pay(employee):
    return employee.salary * 0.9
```

3. **Миксины для повторно используемой функциональности**: Если несколько классов должны иметь схожую функциональность, можно использовать миксины:

```python
class PrettyPrintMixin:
    def to_pretty_string(self):
        return "\n".join(f"{key}: {value}" for key, value in self.__dict__.items())

class Employee(PrettyPrintMixin):
    def __init__(self, name, position):
        self.name = name
        self.position = position

employee = Employee("John", "Developer")
print(employee.to_pretty_string())
```

4. **Декораторы для разделения ответственности**: Декораторы позволяют добавлять функциональность, не изменяя основной класс:

```python
def log_method_calls(cls):
    """Декоратор класса для логирования вызовов методов"""
    original_methods = {}
    
    for name, method in cls.__dict__.items():
        if callable(method) and not name.startswith('__'):
            original_methods[name] = method
            
            def make_logged_method(name, original):
                def logged_method(self, *args, **kwargs):
                    print(f"Calling {name} with args: {args}, kwargs: {kwargs}")
                    result = original(self, *args, **kwargs)
                    print(f"{name} returned: {result}")
                    return result
                return logged_method
            
            setattr(cls, name, make_logged_method(name, method))
    
    return cls

@log_method_calls
class Employee:
    def __init__(self, name, position):
        self.name = name
        self.position = position
    
    def get_info(self):
        return f"{self.name}, {self.position}"

employee = Employee("John", "Developer")
employee.get_info()  # Этот вызов будет логироваться
```

### Когда не следовать SRP слишком строго?

1. **Для маленьких проектов или прототипов**: Строгое соблюдение SRP может быть избыточным для небольших проектов или прототипов.
2. **Когда разделение увеличивает сложность**: Иногда разделение тесно связанных обязанностей на отдельные классы может увеличить сложность системы.
3. **Когда обязанности слишком маленькие**: Создание класса для очень маленькой обязанности может быть излишним.

## Принцип открытости/закрытости (Open/Closed Principle)

### Определение

Принцип открытости/закрытости (OCP) утверждает:

> Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.

Это означает, что поведение сущности можно расширить без изменения её исходного кода.

### Почему это важно?

1. **Снижение риска ошибок**: Изменение существующего, работающего кода может привести к новым ошибкам.
2. **Улучшение поддерживаемости**: Расширение функциональности без изменения существующего кода упрощает поддержку.
3. **Повышение гибкости**: Легче добавлять новые функции, не затрагивая существующие.
4. **Упрощение тестирования**: После расширения нужно тестировать только новую функциональность, а не всю систему.

### Пример нарушения OCP

Представим, что у нас есть класс для расчета налогов:

```python
class TaxCalculator:
    def calculate_tax(self, income, tax_type):
        if tax_type == "standard":
            return income * 0.2
        elif tax_type == "reduced":
            return income * 0.1
        elif tax_type == "zero":
            return 0
```

Проблема этого кода в том, что каждый раз, когда мы хотим добавить новый тип налога, нам нужно изменять класс `TaxCalculator`. Это нарушение OCP, потому что класс не закрыт для модификации.

### Refactoring для соблюдения OCP

Преобразуем код, чтобы соответствовать OCP:

```python
from abc import ABC, abstractmethod

class TaxStrategy(ABC):
    @abstractmethod
    def calculate_tax(self, income):
        pass

class StandardTaxStrategy(TaxStrategy):
    def calculate_tax(self, income):
        return income * 0.2

class ReducedTaxStrategy(TaxStrategy):
    def calculate_tax(self, income):
        return income * 0.1

class ZeroTaxStrategy(TaxStrategy):
    def calculate_tax(self, income):
        return 0

class TaxCalculator:
    def __init__(self, strategy=None):
        self.strategy = strategy
    
    def set_strategy(self, strategy):
        self.strategy = strategy
    
    def calculate_tax(self, income):
        if self.strategy is None:
            raise ValueError("Tax strategy not set")
        return self.strategy.calculate_tax(income)
```

Теперь, если мы хотим добавить новый тип налога, нам не нужно изменять существующие классы. Вместо этого мы создаем новый класс, реализующий интерфейс `TaxStrategy`:

```python
class ProgressiveTaxStrategy(TaxStrategy):
    def calculate_tax(self, income):
        if income <= 10000:
            return income * 0.1
        elif income <= 50000:
            return income * 0.2
        else:
            return income * 0.3
```

Использование:

```python
calculator = TaxCalculator()

# Использование разных стратегий
calculator.set_strategy(StandardTaxStrategy())
print(calculator.calculate_tax(1000))  # 200.0

calculator.set_strategy(ReducedTaxStrategy())
print(calculator.calculate_tax(1000))  # 100.0

calculator.set_strategy(ZeroTaxStrategy())
print(calculator.calculate_tax(1000))  # 0

calculator.set_strategy(ProgressiveTaxStrategy())
print(calculator.calculate_tax(1000))  # 100.0
print(calculator.calculate_tax(20000))  # 4000.0
print(calculator.calculate_tax(100000))  # 30000.0
```

### Способы соблюдения OCP в Python

1. **Использование абстрактных базовых классов**: Как показано в примере выше, мы можем использовать абстрактные базовые классы для определения интерфейсов.

2. **Использование наследования**: Наследование позволяет расширять поведение без изменения родительского класса:

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2
```

3. **Использование композиции и внедрения зависимостей**: Внедрение зависимостей через конструктор или сеттер:

```python
class FileStorage:
    def save(self, data):
        print(f"Saving {data} to file")

class DatabaseStorage:
    def save(self, data):
        print(f"Saving {data} to database")

class Report:
    def __init__(self, storage):
        self.storage = storage
    
    def generate_and_save(self, data):
        report = f"Report: {data}"
        self.storage.save(report)

# Использование разных типов хранилищ
report1 = Report(FileStorage())
report1.generate_and_save("Sales data")

report2 = Report(DatabaseStorage())
report2.generate_and_save("Sales data")
```

4. **Использование функций высшего порядка**: Python поддерживает функциональное программирование, что позволяет использовать функции как аргументы:

```python
def process_data(data, transform_func):
    return transform_func(data)

def double(x):
    return x * 2

def square(x):
    return x * x

# Разные трансформации без изменения process_data
print(process_data(5, double))  # 10
print(process_data(5, square))  # 25
print(process_data(5, lambda x: x + 1))  # 6
```

5. **Использование миксинов**: Миксины позволяют добавлять функциональность к классам без изменения их базовой реализации:

```python
class SerializableJSONMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class SerializableXMLMixin:
    def to_xml(self):
        xml = "<object>"
        for key, value in self.__dict__.items():
            xml += f"<{key}>{value}</{key}>"
        xml += "</object>"
        return xml

class Person(SerializableJSONMixin, SerializableXMLMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("John", 30)
print(person.to_json())  # {"name": "John", "age": 30}
print(person.to_xml())   # <object><name>John</name><age>30</age></object>
```

### Особенности применения OCP в Python

1. **Утиная типизация**: В Python мы можем использовать утиную типизацию вместо явных интерфейсов:

```python
class FileWriter:
    def write(self, data):
        print(f"Writing {data} to file")

class DatabaseWriter:
    def write(self, data):
        print(f"Writing {data} to database")

def save_data(data, writer):
    # Любой объект с методом write будет работать
    writer.write(data)

# Использование
save_data("hello", FileWriter())
save_data("world", DatabaseWriter())
```

2. **Функции как первоклассные объекты**: В Python функции можно передавать как аргументы, что упрощает стратегический паттерн:

```python
def standard_tax(income):
    return income * 0.2

def reduced_tax(income):
    return income * 0.1

class TaxCalculator:
    def __init__(self, strategy=standard_tax):
        self.strategy = strategy
    
    def calculate_tax(self, income):
        return self.strategy(income)

# Использование
calculator = TaxCalculator()
print(calculator.calculate_tax(1000))  # 200.0

calculator.strategy = reduced_tax
print(calculator.calculate_tax(1000))  # 100.0

# Лямбда-функция
calculator.strategy = lambda income: income * 0.3
print(calculator.calculate_tax(1000))  # 300.0
```

3. **Декораторы**: Декораторы позволяют расширять функциональность без изменения исходного кода:

```python
def log_calls(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned: {result}")
        return result
    return wrapper

@log_calls
def add(a, b):
    return a + b

# Использование
print(add(2, 3))  # Будет логировать вызов и результат
```

### Когда не следовать OCP слишком строго?

1. **Когда требования нестабильны**: Если требования часто меняются, предварительное проектирование для расширения может быть преждевременной оптимизацией.
2. **Для простых, одноразовых программ**: Для простых скриптов или одноразовых программ соблюдение OCP может быть излишним.
3. **Когда стоимость абстракции превышает выгоды**: Иногда абстракция добавляет сложность без значительных выгод.

## Принцип подстановки Барбары Лисков (Liskov Substitution Principle)

### Определение

Принцип подстановки Барбары Лисков (LSP) утверждает:

> Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения корректности программы.

Другими словами, подклассы должны дополнять, а не замещать поведение базового класса, чтобы код, работающий с базовым классом, мог без проблем работать и с его подклассами.

### Почему это важно?

1. **Предсказуемое поведение**: LSP обеспечивает предсказуемое поведение при использовании полиморфизма.
2. **Более надежный код**: Следование LSP делает код более надежным и менее подверженным ошибкам.
3. **Лучший дизайн иерархии классов**: LSP помогает проектировать более логичные и последовательные иерархии классов.
4. **Упрощение тестирования**: Следуя LSP, можно тестировать код с использованием мок-объектов или заменителей.

### Пример нарушения LSP

Рассмотрим классический пример с геометрическими фигурами:

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def set_width(self, width):
        self.width = width
    
    def set_height(self, height):
        self.height = height
    
    def area(self):
        return self.width * self.height

class Square(Rectangle):
    def __init__(self, side):
        super().__init__(side, side)
    
    def set_width(self, width):
        self.width = width
        self.height = width
    
    def set_height(self, height):
        self.width = height
        self.height = height
```

Проблема в том, что `Square` изменяет поведение `Rectangle`. Когда мы устанавливаем ширину или высоту квадрата, мы также изменяем другое измерение, чтобы сохранить его квадратную форму. Это нарушает LSP, потому что следующий код будет работать некорректно для `Square`:

```python
def print_area(rectangle):
    rectangle.set_width(4)
    rectangle.set_height(5)
    # Для Rectangle ожидаем 4 * 5 = 20
    # Для Square получим 5 * 5 = 25, что неправильно
    print(f"Area: {rectangle.area()}")

rectangle = Rectangle(3, 4)
print_area(rectangle)  # Area: 20

square = Square(3)
print_area(square)     # Area: 25 - не то, что ожидалось!
```

### Refactoring для соблюдения LSP

Вместо наследования лучше использовать композицию или создать общего предка:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def set_width(self, width):
        self.width = width
    
    def set_height(self, height):
        self.height = height
    
    def area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side
    
    def set_side(self, side):
        self.side = side
    
    def area(self):
        return self.side * self.side
```

Теперь `Square` и `Rectangle` имеют общего предка `Shape`, но не имеют отношения наследования между собой. Функцию `print_area` можно переписать так:

```python
def print_area(shape):
    print(f"Area: {shape.area()}")

rectangle = Rectangle(4, 5)
print_area(rectangle)  # Area: 20

square = Square(5)
print_area(square)     # Area: 25
```

### Основные правила LSP

1. **Предусловия не могут быть усилены в подтипе**: Подтип не должен требовать более строгих условий, чем базовый тип.
2. **Постусловия не могут быть ослаблены в подтипе**: Результаты методов подтипа должны соответствовать ожиданиям для базового типа.
3. **Инварианты базового типа должны сохраняться в подтипе**: Подтип должен поддерживать все свойства, гарантированные базовым типом.
4. **Правило истории (History Rule)**: Подтип не должен изменять значения, которые базовый тип не изменял бы.

### Признаки нарушения LSP

1. **Методы, выбрасывающие исключения**: Если метод подкласса выбрасывает исключение, которое не выбрасывает метод базового класса, это может быть нарушением LSP.

```python
class Bird:
    def fly(self):
        return "Flying"

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Penguins can't fly")  # Нарушение LSP
```

2. **Методы, возвращающие неожиданные типы**: Если метод подкласса возвращает тип, отличный от базового класса, это может нарушать LSP.

```python
class Report:
    def generate(self):
        return ["Line 1", "Line 2"]  # Возвращает список

class PDFReport(Report):
    def generate(self):
        return "PDF content"  # Возвращает строку, нарушение LSP
```

3. **Измененное поведение**: Если метод подкласса ведет себя иначе, чем метод базового класса, это может нарушать LSP.

```python
class Account:
    def withdraw(self, amount):
        # Позволяет снять любую сумму
        return f"Withdrawn ${amount}"

class SavingsAccount(Account):
    def withdraw(self, amount):
        if amount > 1000:
            raise ValueError("Cannot withdraw more than $1000")  # Нарушение LSP
        return f"Withdrawn ${amount}"
```

### Соблюдение LSP в Python

1. **Использование абстрактных базовых классов**: Абстрактные базовые классы помогают определить контракт, которому должны следовать подклассы:

```python
from abc import ABC, abstractmethod

class Bird(ABC):
    @abstractmethod
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        return "Flying"

class SwimmingBird(Bird):
    def move(self):
        return "Swimming"

class Penguin(SwimmingBird):
    pass

class Eagle(FlyingBird):
    pass
```

2. **Использование протоколов (в Python 3.8+)**: Протоколы позволяют определять интерфейсы структурно, без явного наследования:

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Drawable(Protocol):
    def draw(self) -> str:
        ...

class Circle:
    def draw(self) -> str:
        return "Drawing a circle"

class Square:
    def draw(self) -> str:
        return "Drawing a square"

def render(drawable: Drawable):
    print(drawable.draw())

render(Circle())  # Работает, хотя Circle не наследуется от Drawable
render(Square())  # Тоже работает
```

3. **Использование композиции вместо наследования**: Иногда лучше использовать композицию вместо наследования:

```python
class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self, engine):
        self.engine = engine
    
    def start(self):
        return self.engine.start()

class ElectricCar(Car):
    pass  # Использует тот же интерфейс, что и Car

class DieselCar(Car):
    pass  # Использует тот же интерфейс, что и Car
```

4. **Обеспечение согласованности поведения**: Методы в подклассах должны вести себя предсказуемо:

```python
class Animal:
    def make_sound(self):
        return "Some generic sound"

class Dog(Animal):
    def make_sound(self):
        return "Woof"  # Согласуется с ожиданиями для make_sound

class Cat(Animal):
    def make_sound(self):
        return "Meow"  # Согласуется с ожиданиями для make_sound
```

### Особенности применения LSP в Python

1. **Утиная типизация**: Python использует "утиную типизацию" (duck typing), что позволяет заменять объекты, если они имеют одинаковые методы:

```python
def swim(duck):
    return duck.swim()

class Duck:
    def swim(self):
        return "Duck swimming"

class Swan:
    def swim(self):
        return "Swan swimming"

print(swim(Duck()))  # Duck swimming
print(swim(Swan()))  # Swan swimming - работает из-за утиной типизации
```

2. **Множественное наследование**: Python поддерживает множественное наследование, что может усложнять соблюдение LSP:

```python
class A:
    def method(self):
        return "A.method"

class B:
    def method(self):
        return "B.method"

class C(A, B):
    pass  # Наследует метод А из-за порядка разрешения методов (MRO)

print(C().method())  # "A.method"

# Но это может вызвать проблемы, если код ожидает поведение B
def function_expecting_b(obj):
    assert obj.method() == "B.method"  # Эта проверка не пройдет для C

try:
    function_expecting_b(C())
except AssertionError:
    print("LSP нарушен!")
```

3. **Аннотации типов**: С Python 3.5+ можно использовать аннотации типов для обеспечения совместимости:

```python
from typing import List, Union

class Animal:
    def make_sound(self) -> str:
        return "Some sound"

class Dog(Animal):
    def make_sound(self) -> str:  # Совместимая сигнатура
        return "Woof"

def print_sound(animal: Animal) -> None:
    print(animal.make_sound())

print_sound(Dog())  # Работает корректно
```

### Когда не следовать LSP слишком строго?

1. **В небольших, простых приложениях**: Для небольших приложений строгое соблюдение LSP может быть излишним.
2. **Когда наследование используется только для повторного использования кода**: Если подклассы не используются полиморфно, LSP менее важен.
3. **В прототипах или в исследовательском коде**: На начальных этапах разработки LSP может ограничивать эксперименты.

## Принцип разделения интерфейса (Interface Segregation Principle)

### Определение

Принцип разделения интерфейса (ISP) утверждает:

> Клиенты не должны зависеть от интерфейсов, которые они не используют.

Другими словами, лучше иметь много специализированных интерфейсов, чем один универсальный.

### Почему это важно?

1. **Снижение связанности**: Клиенты зависят только от тех методов, которые они реально используют.
2. **Повышение модульности**: Мелкие, сфокусированные интерфейсы способствуют более модульному дизайну.
3. **Упрощение поддержки**: Изменения в одной части системы меньше влияют на другие.
4. **Облегчение тестирования**: Специализированные интерфейсы проще имитировать или макетировать при тестировании.

### Пример нарушения ISP

Рассмотрим интерфейс для работы с документами:

```python
from abc import ABC, abstractmethod

class Document(ABC):
    @abstractmethod
    def open(self):
        pass
    
    @abstractmethod
    def save(self):
        pass
    
    @abstractmethod
    def print(self):
        pass
    
    @abstractmethod
    def scan(self):
        pass

# Реализации
class PDFDocument(Document):
    def open(self):
        return "Opening PDF"
    
    def save(self):
        return "Saving PDF"
    
    def print(self):
        return "Printing PDF"
    
    def scan(self):
        # PDF не может сканировать, но мы вынуждены реализовать этот метод
        raise NotImplementedError("PDFs cannot be scanned")
```

Проблема в том, что `PDFDocument` вынужден реализовывать метод `scan`, который не имеет смысла для PDF-документов. Это нарушение ISP, потому что `PDFDocument` зависит от интерфейса, который он не использует полностью.

### Refactoring для соблюдения ISP

Разделим интерфейс на более мелкие, специализированные интерфейсы:

```python
from abc import ABC, abstractmethod

class Openable(ABC):
    @abstractmethod
    def open(self):
        pass

class Saveable(ABC):
    @abstractmethod
    def save(self):
        pass

class Printable(ABC):
    @abstractmethod
    def print(self):
        pass

class Scannable(ABC):
    @abstractmethod
    def scan(self):
        pass

# Реализации
class PDFDocument(Openable, Saveable, Printable):
    def open(self):
        return "Opening PDF"
    
    def save(self):
        return "Saving PDF"
    
    def print(self):
        return "Printing PDF"

class ScannerDocument(Openable, Saveable, Scannable):
    def open(self):
        return "Opening document for scanning"
    
    def save(self):
        return "Saving scanned document"
    
    def scan(self):
        return "Scanning document"

# Теперь клиенты могут работать только с нужными интерфейсами
def print_document(printable: Printable):
    print(printable.print())

def scan_document(scannable: Scannable):
    print(scannable.scan())

# Использование
pdf = PDFDocument()
print_document(pdf)  # Работает

try:
    scan_document(pdf)  # Ошибка - PDF не поддерживает интерфейс Scannable
except TypeError as e:
    print(f"Ошибка: {e}")

scanner_doc = ScannerDocument()
scan_document(scanner_doc)  # Работает
```

### Признаки нарушения ISP

1. **Неиспользуемые методы интерфейса**: Если класс реализует интерфейс, но некоторые методы выбрасывают исключения или имеют пустую реализацию.
2. **Реализации, не нуждающиеся в большинстве методов**: Если класс нуждается только в малой части методов интерфейса.
3. **Большие, монолитные интерфейсы**: Интерфейсы с большим количеством методов, особенно если эти методы логически относятся к разным аспектам.
4. **Клиенты, использующие только часть интерфейса**: Если разные клиенты используют разные подмножества методов интерфейса.

### Соблюдение ISP в Python

1. **Использование абстрактных базовых классов для определения интерфейсов**:

```python
from abc import ABC, abstractmethod

class Worker(ABC):
    @abstractmethod
    def work(self):
        pass

class Eater(ABC):
    @abstractmethod
    def eat(self):
        pass

class RestBreakTaker(ABC):
    @abstractmethod
    def take_rest_break(self):
        pass

# Человек может делать все
class Human(Worker, Eater, RestBreakTaker):
    def work(self):
        return "Human working"
    
    def eat(self):
        return "Human eating"
    
    def take_rest_break(self):
        return "Human taking a break"

# Робот может только работать
class Robot(Worker):
    def work(self):
        return "Robot working"
```

2. **Использование миксинов для добавления функциональности**:

```python
class PrintableMixin:
    def print(self):
        return f"Printing {self.__class__.__name__}"

class EmailableMixin:
    def email(self, recipient):
        return f"Emailing {self.__class__.__name__} to {recipient}"

class Document:
    def __init__(self, content):
        self.content = content

class Report(Document, PrintableMixin, EmailableMixin):
    pass

class Log(Document, EmailableMixin):
    pass

# Использование
report = Report("Sales figures")
print(report.print())  # Printing Report
print(report.email("boss@example.com"))  # Emailing Report to boss@example.com

log = Log("Error log")
print(log.email("admin@example.com"))  # Emailing Log to admin@example.com
```

3. **Использование протоколов (в Python 3.8+)**:

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Printable(Protocol):
    def print(self) -> str:
        ...

@runtime_checkable
class Emailable(Protocol):
    def email(self, recipient: str) -> str:
        ...

class Document:
    def __init__(self, content):
        self.content = content

class Report(Document):
    def print(self):
        return f"Printing report: {self.content}"
    
    def email(self, recipient):
        return f"Emailing report to {recipient}: {self.content}"

class Log(Document):
    def email(self, recipient):
        return f"Emailing log to {recipient}: {self.content}"

# Функции, работающие с интерфейсами
def print_document(doc: Printable):
    print(doc.print())

def email_document(doc: Emailable, recipient: str):
    print(doc.email(recipient))

# Использование
report = Report("Sales figures")
log = Log("Error log")

print_document(report)  # Работает
email_document(report, "boss@example.com")  # Работает
email_document(log, "admin@example.com")  # Работает

try:
    print_document(log)  # Ошибка - Log не поддерживает интерфейс Printable
except AttributeError as e:
    print(f"Ошибка: {e}")
```

4. **Использование утиной типизации**:

```python
def print_document(doc):
    if hasattr(doc, "print") and callable(doc.print):
        print(doc.print())
    else:
        raise TypeError("Object does not support printing")

def email_document(doc, recipient):
    if hasattr(doc, "email") and callable(doc.email):
        print(doc.email(recipient))
    else:
        raise TypeError("Object does not support emailing")
```

### Особенности применения ISP в Python

1. **Отсутствие явных интерфейсов**: Python не имеет явного синтаксиса для интерфейсов, как, например, Java. Вместо этого можно использовать абстрактные базовые классы, протоколы или полагаться на утиную типизацию.

2. **Множественное наследование**: Python поддерживает множественное наследование, что позволяет создавать классы, реализующие несколько интерфейсов:

```python
class A:
    def method_a(self):
        return "A"

class B:
    def method_b(self):
        return "B"

class C(A, B):  # Множественное наследование
    pass

c = C()
print(c.method_a())  # A
print(c.method_b())  # B
```

3. **Опциональные методы**: В Python иногда используются опциональные методы, которые могут быть реализованы, если нужна определенная функциональность:

```python
class Iterator:
    def __iter__(self):
        return self
    
    def __next__(self):
        raise StopIteration
    
    # Опциональный метод
    def __reversed__(self):
        # По умолчанию не поддерживается
        raise NotImplementedError("Reversed iteration not supported")
```

4. **Декораторы для расширения функциональности**: Можно использовать декораторы для добавления методов к классам:

```python
def add_printing(cls):
    def print_method(self):
        return f"Printing {self.__class__.__name__}"
    
    cls.print = print_method
    return cls

@add_printing
class Report:
    pass

report = Report()
print(report.print())  # Printing Report
```

### Когда не следовать ISP слишком строго?

1. **В небольших, простых приложениях**: Для небольших приложений разделение интерфейсов может быть излишним.
2. **Когда интерфейсы логически связаны**: Если методы интерфейса логически связаны между собой, их разделение может усложнить код.
3. **При использовании фреймворков или библиотек**: Иногда необходимо следовать интерфейсам, определенным фреймворком или библиотекой.

## Принцип инверсии зависимостей (Dependency Inversion Principle)

### Определение

Принцип инверсии зависимостей (DIP) утверждает:

> 1. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций.
> 2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Другими словами, код должен зависеть от абстракций, а не от конкретных реализаций.

### Почему это важно?

1. **Снижение связанности**: DIP уменьшает связанность между компонентами системы.
2. **Упрощение тестирования**: Абстракции легче имитировать, что упрощает юнит-тестирование.
3. **Повышение гибкости**: Легче заменять компоненты системы без изменения других частей.
4. **Улучшение поддерживаемости**: Изменения в одной части системы меньше влияют на другие.

### Пример нарушения DIP

Рассмотрим класс `OrderService`, который напрямую зависит от `MySQLOrderRepository`:

```python
class MySQLOrderRepository:
    def save(self, order):
        print(f"Saving order {order} to MySQL database")
    
    def find_by_id(self, order_id):
        print(f"Finding order with id {order_id} in MySQL database")
        return {"id": order_id, "items": ["item1", "item2"]}

class OrderService:
    def __init__(self):
        self.repository = MySQLOrderRepository()  # Жесткая зависимость
    
    def place_order(self, order):
        print("Placing order")
        self.repository.save(order)
    
    def get_order(self, order_id):
        return self.repository.find_by_id(order_id)
```

Проблема в том, что `OrderService` напрямую зависит от конкретной реализации `MySQLOrderRepository`. Если мы захотим использовать другое хранилище (например, MongoDB или PostgreSQL), нам придется изменить код `OrderService`.

### Refactoring для соблюдения DIP

Введем абстракцию для репозитория и сделаем `OrderService` зависимым от этой абстракции:

```python
from abc import ABC, abstractmethod

# Абстракция (интерфейс) для репозитория заказов
class OrderRepository(ABC):
    @abstractmethod
    def save(self, order):
        pass
    
    @abstractmethod
    def find_by_id(self, order_id):
        pass

# Конкретная реализация для MySQL
class MySQLOrderRepository(OrderRepository):
    def save(self, order):
        print(f"Saving order {order} to MySQL database")
    
    def find_by_id(self, order_id):
        print(f"Finding order with id {order_id} in MySQL database")
        return {"id": order_id, "items": ["item1", "item2"]}

# Конкретная реализация для MongoDB
class MongoDBOrderRepository(OrderRepository):
    def save(self, order):
        print(f"Saving order {order} to MongoDB")
    
    def find_by_id(self, order_id):
        print(f"Finding order with id {order_id} in MongoDB")
        return {"id": order_id, "items": ["item1", "item2"]}

# OrderService теперь зависит от абстракции OrderRepository
class OrderService:
    def __init__(self, repository: OrderRepository):
        self.repository = repository  # Внедрение зависимости через конструктор
    
    def place_order(self, order):
        print("Placing order")
        self.repository.save(order)
    
    def get_order(self, order_id):
        return self.repository.find_by_id(order_id)

# Использование
mysql_repository = MySQLOrderRepository()
mongo_repository = MongoDBOrderRepository()

# Создаем сервис с MySQL репозиторием
mysql_service = OrderService(mysql_repository)
mysql_service.place_order({"items": ["item1", "item2"]})

# Создаем сервис с MongoDB репозиторием
mongo_service = OrderService(mongo_repository)
mongo_service.place_order({"items": ["item1", "item2"]})
```

### Способы внедрения зависимостей

1. **Внедрение через конструктор**: Зависимости передаются через конструктор:

```python
class OrderService:
    def __init__(self, repository: OrderRepository, notification_service: NotificationService):
        self.repository = repository
        self.notification_service = notification_service
```

2. **Внедрение через сеттер**: Зависимости устанавливаются через методы-сеттеры:

```python
class OrderService:
    def __init__(self):
        self.repository = None
        self.notification_service = None
    
    def set_repository(self, repository: OrderRepository):
        self.repository = repository
    
    def set_notification_service(self, notification_service: NotificationService):
        self.notification_service = notification_service
```

3. **Внедрение через метод**: Зависимости передаются как аргументы методов:

```python
class OrderService:
    def place_order(self, order, repository: OrderRepository, notification_service: NotificationService):
        repository.save(order)
        notification_service.notify(f"Order {order} placed")
```

### Соблюдение DIP в Python

1. **Абстрактные базовые классы**: Для определения абстракций можно использовать абстрактные базовые классы:

```python
from abc import ABC, abstractmethod

class Logger(ABC):
    @abstractmethod
    def log(self, message):
        pass

class ConsoleLogger(Logger):
    def log(self, message):
        print(f"Console: {message}")

class FileLogger(Logger):
    def __init__(self, file_path):
        self.file_path = file_path
    
    def log(self, message):
        print(f"Writing to {self.file_path}: {message}")

class Service:
    def __init__(self, logger: Logger):
        self.logger = logger
    
    def do_something(self):
        self.logger.log("Doing something")
```

2. **Протоколы (в Python 3.8+)**: Для определения абстракций можно использовать протоколы:

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Logger(Protocol):
    def log(self, message: str) -> None:
        ...

class ConsoleLogger:
    def log(self, message: str) -> None:
        print(f"Console: {message}")

class FileLogger:
    def __init__(self, file_path: str):
        self.file_path = file_path
    
    def log(self, message: str) -> None:
        print(f"Writing to {self.file_path}: {message}")

class Service:
    def __init__(self, logger: Logger):
        self.logger = logger
    
    def do_something(self):
        self.logger.log("Doing something")
```

3. **Утиная типизация**: Python поддерживает утиную типизацию, поэтому абстракции могут быть неявными:

```python
class ConsoleLogger:
    def log(self, message):
        print(f"Console: {message}")

class FileLogger:
    def log(self, message):
        print(f"File: {message}")

class Service:
    def __init__(self, logger):
        # Любой объект с методом log будет работать
        self.logger = logger
    
    def do_something(self):
        self.logger.log("Doing something")
```

4. **Контейнеры внедрения зависимостей**: Для управления зависимостями можно использовать библиотеки, такие как `dependency_injector`:

```python
from dependency_injector import containers, providers

class Container(containers.DeclarativeContainer):
    config = providers.Configuration()
    
    logger = providers.Singleton(
        FileLogger,
        file_path=config.log_file_path
    )
    
    service = providers.Factory(
        Service,
        logger=logger
    )

# Использование
container = Container()
container.config.log_file_path.from_env("LOG_FILE_PATH", "app.log")

service = container.service()
service.do_something()
```

### Особенности применения DIP в Python

1. **Функции как зависимости**: В Python функции являются объектами первого класса, поэтому их можно передавать как зависимости:

```python
def console_log(message):
    print(f"Console: {message}")

def file_log(message, file_path="app.log"):
    print(f"Writing to {file_path}: {message}")

class Service:
    def __init__(self, log_func):
        self.log = log_func
    
    def do_something(self):
        self.log("Doing something")

# Использование
service1 = Service(console_log)
service1.do_something()

service2 = Service(lambda message: file_log(message, "errors.log"))
service2.do_something()
```

2. **Фабричные функции**: Фабричные функции могут создавать объекты с нужными зависимостями:

```python
def create_service(log_type="console", file_path=None):
    if log_type == "console":
        logger = ConsoleLogger()
    elif log_type == "file":
        logger = FileLogger(file_path or "app.log")
    else:
        raise ValueError(f"Unknown log type: {log_type}")
    
    return Service(logger)

# Использование
service1 = create_service()  # С ConsoleLogger
service2 = create_service("file", "errors.log")  # С FileLogger
```

3. **Декораторы**: Декораторы могут добавлять зависимости к классам или функциям:

```python
def with_logger(logger_type="console", file_path=None):
    def decorator(cls):
        original_init = cls.__init__
        
        def __init__(self, *args, **kwargs):
            if logger_type == "console":
                self.logger = ConsoleLogger()
            elif logger_type == "file":
                self.logger = FileLogger(file_path or "app.log")
            else:
                raise ValueError(f"Unknown logger type: {logger_type}")
            
            original_init(self, *args, **kwargs)
        
        cls.__init__ = __init__
        return cls
    
    return decorator

@with_logger("file", "service.log")
class Service:
    def do_something(self):
        self.logger.log("Doing something")
```

4. **Контекстные переменные**: Для глобальных зависимостей можно использовать контекстные переменные:

```python
import contextvars

current_logger = contextvars.ContextVar("current_logger")

class Service:
    def do_something(self):
        logger = current_logger.get()
        logger.log("Doing something")

# Установка зависимости
current_logger.set(ConsoleLogger())

# Использование
service = Service()
service.do_something()
```

### Когда не следовать DIP слишком строго?

1. **В небольших, простых приложениях**: Для небольших приложений абстрагирование всех зависимостей может быть излишним.
2. **Для стабильных зависимостей**: Если зависимость стабильна и вряд ли изменится, абстрагирование может быть избыточным.
3. **Когда производительность критична**: Прямые вызовы могут быть более эффективными, чем вызовы через абстракции.
4. **В прототипах или экспериментальном коде**: На начальных этапах разработки DIP может ограничивать эксперименты.

## Комбинированное применение SOLID принципов

SOLID принципы дополняют друг друга и часто применяются вместе. Рассмотрим пример, демонстрирующий применение всех пяти принципов:

```python
from abc import ABC, abstractmethod
from typing import List, Protocol, runtime_checkable

# SRP: Класс Order отвечает только за представление заказа
class Order:
    def __init__(self, order_id: str, items: List[str]):
        self.order_id = order_id
        self.items = items
        self.status = "new"
    
    def __str__(self):
        return f"Order {self.order_id} with items: {', '.join(self.items)}"

# OCP и ISP: Интерфейсы для различных функциональностей
@runtime_checkable
class OrderRepository(Protocol):
    def save(self, order: Order) -> None:
        ...
    
    def find_by_id(self, order_id: str) -> Order:
        ...

@runtime_checkable
class OrderProcessor(Protocol):
    def process(self, order: Order) -> None:
        ...

@runtime_checkable
class NotificationService(Protocol):
    def notify(self, message: str) -> None:
        ...

# LSP: Конкретные реализации, соответствующие интерфейсам
class MySQLOrderRepository:
    def save(self, order: Order) -> None:
        print(f"Saving {order} to MySQL")
    
    def find_by_id(self, order_id: str) -> Order:
        print(f"Finding order {order_id} in MySQL")
        return Order(order_id, ["item1", "item2"])

class MongoDBOrderRepository:
    def save(self, order: Order) -> None:
        print(f"Saving {order} to MongoDB")
    
    def find_by_id(self, order_id: str) -> Order:
        print(f"Finding order {order_id} in MongoDB")
        return Order(order_id, ["item1", "item2"])

class StandardOrderProcessor:
    def process(self, order: Order) -> None:
        print(f"Processing {order}")
        order.status = "processed"

class EmailNotificationService:
    def notify(self, message: str) -> None:
        print(f"Sending email: {message}")

class SMSNotificationService:
    def notify(self, message: str) -> None:
        print(f"Sending SMS: {message}")

# DIP: Сервис, зависящий от абстракций, а не от конкретных реализаций
class OrderService:
    def __init__(
        self,
        repository: OrderRepository,
        processor: OrderProcessor,
        notification_service: NotificationService
    ):
        self.repository = repository
        self.processor = processor
        self.notification_service = notification_service
    
    def place_order(self, order: Order) -> None:
        self.repository.save(order)
        self.processor.process(order)
        self.notification_service.notify(f"Order {order.order_id} has been placed")
    
    def get_order(self, order_id: str) -> Order:
        return self.repository.find_by_id(order_id)

# Использование
def main():
    # Создаем зависимости
    repository = MySQLOrderRepository()
    processor = StandardOrderProcessor()
    notification_service = EmailNotificationService()
    
    # Создаем сервис с внедрением зависимостей
    order_service = OrderService(repository, processor, notification_service)
    
    # Создаем и размещаем заказ
    order = Order("12345", ["book", "laptop", "coffee"])
    order_service.place_order(order)
    
    # Извлекаем заказ
    retrieved_order = order_service.get_order("12345")
    print(f"Retrieved: {retrieved_order}")
    
    # Легко заменить зависимости
    print("\nChanging dependencies:")
    repository = MongoDBOrderRepository()
    notification_service = SMSNotificationService()
    
    order_service = OrderService(repository, processor, notification_service)
    order_service.place_order(order)

if __name__ == "__main__":
    main()
```

### Как SOLID принципы работают вместе

1. **SRP** обеспечивает, что каждый класс имеет только одну ответственность, что упрощает поддержку и понимание кода.
2. **OCP** позволяет расширять функциональность без изменения существующего кода, что уменьшает риск введения ошибок.
3. **LSP** обеспечивает, что подклассы могут заменить свои базовые классы без нарушения корректности программы.
4. **ISP** гарантирует, что клиенты не зависят от интерфейсов, которые они не используют, что упрощает поддержку и изменение.
5. **DIP** инвертирует направление зависимостей, что делает код более гибким и тестируемым.

Вместе эти принципы обеспечивают:
- **Модульность**: Система состоит из слабо связанных компонентов.
- **Расширяемость**: Новые функциональности можно добавлять без изменения существующего кода.
- **Поддерживаемость**: Изменения в одной части системы не влияют на другие части.
- **Тестируемость**: Компоненты можно тестировать изолированно.
- **Гибкость**: Компоненты можно легко заменять или переконфигурировать.

## Распространенные ошибки и рекомендации

### Ошибки при применении принципов SOLID

1. **Overengineering (избыточное проектирование)**
   - Создание слишком большого числа маленьких классов и интерфейсов
   - Усложнение кода без необходимости

2. **Раннее абстрагирование**
   - Создание абстракций до появления реальной необходимости в них
   - Следуйте принципу "Не усложняйте, пока это явно не требуется" (YAGNI - You Ain't Gonna Need It)

3. **Слишком строгое следование принципам**
   - Принципы SOLID — это рекомендации, а не жесткие правила
   - Иногда оправдано нарушить принцип ради упрощения дизайна

4. **Игнорирование контекста**
   - Не все проекты требуют полного соблюдения SOLID
   - Для небольших скриптов или прототипов излишнее следование SOLID может замедлить разработку

### Рекомендации по применению SOLID

1. **Начинайте просто**
   - Создавайте абстракции только при наличии более одной реализации или ясной перспективы их появления
   - Рефакторите код по мере его развития

2. **Используйте зависимости извне**
   - Передавайте зависимости через конструктор или методы, а не создавайте их внутри класса
   - Это улучшает тестируемость и гибкость кода

3. **Предпочитайте композицию наследованию**
   - Наследование создает сильную связь между классами
   - Композиция позволяет использовать объекты более гибко

4. **Постепенно внедряйте принципы**
   - Не пытайтесь переписать весь код сразу
   - Начните с рефакторинга наиболее проблемных частей

5. **Используйте шаблоны проектирования**
   - Многие паттерны помогают соблюдать принципы SOLID
   - Например, паттерн "Стратегия" помогает соблюдать OCP, паттерн "Фабрика" помогает с DIP


## Практические задания

### Задание 1: Рефакторинг кода для соблюдения SRP

Вам дан класс `UserManager`, который нарушает принцип единственной ответственности. Выполните рефакторинг, чтобы разделить его на несколько классов, каждый с единственной ответственностью.

```python
class UserManager:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def register_user(self, username, password, email):
        # Проверка валидности данных
        if not self._validate_username(username):
            raise ValueError("Invalid username")
        if not self._validate_password(password):
            raise ValueError("Invalid password")
        if not self._validate_email(email):
            raise ValueError("Invalid email")
        
        # Хеширование пароля
        hashed_password = self._hash_password(password)
        
        # Сохранение в базу данных
        self.db.execute(
            "INSERT INTO users (username, password, email) VALUES (?, ?, ?)",
            (username, hashed_password, email)
        )
        
        # Отправка уведомления
        self._send_welcome_email(username, email)
    
    def _validate_username(self, username):
        return len(username) >= 4 and username.isalnum()
    
    def _validate_password(self, password):
        return len(password) >= 8
    
    def _validate_email(self, email):
        return "@" in email and "." in email
    
    def _hash_password(self, password):
        # Простое хеширование для примера
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()
    
    def _send_welcome_email(self, username, email):
        print(f"Sending welcome email to {email}")
        # Логика отправки email
        
    def reset_password(self, username, new_password):
        if not self._validate_password(new_password):
            raise ValueError("Invalid password")
        
        hashed_password = self._hash_password(new_password)
        self.db.execute(
            "UPDATE users SET password = ? WHERE username = ?",
            (hashed_password, username)
        )
        
        user = self.db.execute(
            "SELECT email FROM users WHERE username = ?",
            (username,)
        ).fetchone()
        
        if user:
            self._send_password_reset_confirmation(user[0])
    
    def _send_password_reset_confirmation(self, email):
        print(f"Sending password reset confirmation to {email}")
        # Логика отправки email
    
    def delete_user(self, username):
        self.db.execute(
            "DELETE FROM users WHERE username = ?",
            (username,)
        )
```

### Задание 2: Рефакторинг кода для соблюдения OCP

Вам дан класс `PaymentProcessor`, который нарушает принцип открытости/закрытости. Выполните рефакторинг, чтобы новые способы оплаты можно было добавлять без изменения существующего кода.

```python
class PaymentProcessor:
    def process_payment(self, payment_type, amount):
        if payment_type == "credit_card":
            print(f"Processing credit card payment of ${amount}")
            # Логика обработки оплаты кредитной картой
            return True
        elif payment_type == "paypal":
            print(f"Processing PayPal payment of ${amount}")
            # Логика обработки оплаты через PayPal
            return True
        elif payment_type == "bank_transfer":
            print(f"Processing bank transfer of ${amount}")
            # Логика обработки банковского перевода
            return True
        else:
            raise ValueError(f"Unsupported payment type: {payment_type}")
```

### Задание 3: Рефакторинг кода для соблюдения LSP

Вам дан код, который нарушает принцип подстановки Барбары Лисков. Выполните рефакторинг, чтобы подклассы можно было использовать вместо базового класса без нарушения корректности программы.

```python
class Bird:
    def fly(self):
        print("Flying high")

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Penguins can't fly")

class Duck(Bird):
    def fly(self):
        print("Duck flying")

def make_bird_fly(bird):
    bird.fly()

# Использование
duck = Duck()
make_bird_fly(duck)  # Работает

penguin = Penguin()
try:
    make_bird_fly(penguin)  # Вызывает ошибку
except NotImplementedError as e:
    print(e)
```

### Задание 4: Рефакторинг кода для соблюдения ISP

Вам дан код, который нарушает принцип разделения интерфейса. Выполните рефакторинг, чтобы клиенты не зависели от интерфейсов, которые они не используют.

```python
from abc import ABC, abstractmethod

class Machine(ABC):
    @abstractmethod
    def print(self, document):
        pass
    
    @abstractmethod
    def scan(self, document):
        pass
    
    @abstractmethod
    def fax(self, document):
        pass
    
    @abstractmethod
    def copy(self, document):
        pass

class MultiFunctionPrinter(Machine):
    def print(self, document):
        print(f"Printing {document}")
    
    def scan(self, document):
        print(f"Scanning {document}")
    
    def fax(self, document):
        print(f"Faxing {document}")
    
    def copy(self, document):
        print(f"Copying {document}")

class OldPrinter(Machine):
    def print(self, document):
        print(f"Printing {document}")
    
    def scan(self, document):
        raise NotImplementedError("Scanning not supported")
    
    def fax(self, document):
        raise NotImplementedError("Faxing not supported")
    
    def copy(self, document):
        raise NotImplementedError("Copying not supported")
```

### Задание 5: Рефакторинг кода для соблюдения DIP

Вам дан код, который нарушает принцип инверсии зависимостей. Выполните рефакторинг, чтобы высокоуровневые модули не зависели от низкоуровневых модулей.

```python
class MySQLDatabase:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        print(f"Connecting to MySQL: {connection_string}")
    
    def execute(self, query, parameters):
        print(f"Executing MySQL query: {query} with parameters: {parameters}")
        # Логика выполнения запроса
        return []

class UserRepository:
    def __init__(self, connection_string):
        self.db = MySQLDatabase(connection_string)
    
    def save(self, user):
        self.db.execute(
            "INSERT INTO users (username, email) VALUES (?, ?)",
            (user.username, user.email)
        )
    
    def find_by_username(self, username):
        return self.db.execute(
            "SELECT * FROM users WHERE username = ?",
            (username,)
        )

class UserService:
    def __init__(self, connection_string):
        self.repository = UserRepository(connection_string)
    
    def register_user(self, username, email):
        user = User(username, email)
        self.repository.save(user)
        return user

class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email
```

## Проект

### Разработка системы управления задачами (Task Management System)

В этом проекте вы создадите систему управления задачами, соблюдая принципы SOLID. Система должна позволять создавать, редактировать, удалять и просматривать задачи, а также управлять их статусами и назначенными исполнителями.

#### Требования:

1. **Задачи (Tasks)**:
   - Каждая задача имеет заголовок, описание, статус, приоритет, дату создания, дату выполнения и назначенного исполнителя
   - Задачи могут быть разных типов: обычные задачи, ошибки (bugs), функциональности (features), и т.д.
   - Каждый тип задачи может иметь специфические свойства и поведение

2. **Пользователи (Users)**:
   - Пользователи могут иметь разные роли: администратор, менеджер, разработчик, тестировщик
   - У каждой роли есть специфические права и возможности

3. **Хранение данных**:
   - Система должна поддерживать различные способы хранения данных: в памяти, в файле, в базе данных
   - Должна быть возможность легко добавлять новые способы хранения

4. **Уведомления**:
   - Система должна отправлять уведомления о событиях (создание задачи, изменение статуса, и т.д.)
   - Уведомления могут отправляться разными способами: email, SMS, push-уведомления
   - Должна быть возможность легко добавлять новые способы уведомления

5. **Представление**:
   - Система должна поддерживать различные представления данных: консольное, графическое, API
   - Должна быть возможность легко добавлять новые представления

#### Структура проекта:

```
task_management/
├── core/
│   ├── __init__.py
│   ├── task.py         # Базовые классы задач
│   ├── user.py         # Базовые классы пользователей
│   ├── repository.py   # Интерфейсы репозиториев
│   └── notification.py # Интерфейсы уведомлений
├── domain/
│   ├── __init__.py
│   ├── task_types.py   # Конкретные типы задач
│   └── user_roles.py   # Конкретные роли пользователей
├── infrastructure/
│   ├── __init__.py
│   ├── repositories/   # Реализации репозиториев
│   │   ├── __init__.py
│   │   ├── memory_repository.py
│   │   ├── file_repository.py
│   │   └── db_repository.py
│   └── notifications/  # Реализации уведомлений
│       ├── __init__.py
│       ├── email_notification.py
│       ├── sms_notification.py
│       └── push_notification.py
├── application/
│   ├── __init__.py
│   ├── task_service.py   # Сервисы для работы с задачами
│   └── user_service.py   # Сервисы для работы с пользователями
├── presentation/
│   ├── __init__.py
│   ├── console_ui.py     # Консольный интерфейс
│   └── api.py            # API интерфейс
└── main.py               # Точка входа
```

#### Задание:

1. Спроектируйте систему, соблюдая принципы SOLID.
2. Реализуйте базовые классы и интерфейсы.
3. Реализуйте хотя бы по одной конкретной реализации для каждого компонента.
4. Напишите простой клиентский код, демонстрирующий работу системы.
5. Напишите юнит-тесты для основных компонентов.

#### Рекомендации:

1. **SRP**: Каждый класс должен иметь только одну ответственность.
   - Разделите ответственности между классами
   - Используйте сервисы для бизнес-логики, репозитории для доступа к данным, и т.д.

2. **OCP**: Система должна быть открыта для расширения, но закрыта для модификации.
   - Используйте абстрактные классы и интерфейсы
   - Реализуйте паттерн Стратегия для различных алгоритмов

3. **LSP**: Подклассы должны быть заменяемы для их базовых классов.
   - Убедитесь, что подклассы не нарушают контракты базовых классов
   - Избегайте выбрасывания исключений в методах, которые не выбрасывают исключения в базовых классах

4. **ISP**: Клиенты не должны зависеть от интерфейсов, которые они не используют.
   - Разделите интерфейсы на более мелкие, специализированные
   - Используйте миксины для добавления функциональности

5. **DIP**: Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
   - Используйте внедрение зависимостей
   - Зависьте от абстракций, а не от конкретных реализаций

## Дополнительные ресурсы

### Книги

1. **"Чистая архитектура" (Clean Architecture)** - Роберт Мартин
   - Книга от автора принципов SOLID, описывающая, как применять эти принципы в архитектуре программного обеспечения.

2. **"Чистый код" (Clean Code)** - Роберт Мартин
   - Основополагающая книга о написании качественного, читаемого и поддерживаемого кода.

3. **"Рефакторинг. Улучшение существующего кода" (Refactoring: Improving the Design of Existing Code)** - Мартин Фаулер
   - Книга о методах улучшения структуры существующего кода без изменения его внешнего поведения.

4. **"Паттерны проектирования. Элементы повторно используемого объектно-ориентированного программного обеспечения" (Design Patterns: Elements of Reusable Object-Oriented Software)** - Банда четырех (Gang of Four)
   - Классическая книга о паттернах проектирования, многие из которых помогают соблюдать принципы SOLID.

### Онлайн-ресурсы

1. **[Python SOLID Principles: the Definitive Guide](https://stackify.com/solid-design-principles-python/)**
   - Подробное руководство по применению принципов SOLID в Python.

2. **[SOLID Principles In Python](https://www.pythontutorial.net/python-oop/python-solid-principles/)**
   - Туториал по SOLID принципам с примерами на Python.

3. **[Real Python - SOLID Principles in Python](https://realpython.com/solid-principles-python/)**
   - Подробная статья о SOLID принципах с примерами на Python.

4. **[Python Design Patterns](https://python-patterns.guide/)**
   - Руководство по паттернам проектирования в Python, включая паттерны, помогающие соблюдать SOLID.

### Видеокурсы

1. **"SOLID Principles of Object-Oriented Design" на Pluralsight**
   - Курс от Стива Смита, объясняющий принципы SOLID и их применение.

2. **"Clean Code: SOLID Principles" на Udemy**
   - Курс, фокусирующийся на применении принципов SOLID для написания чистого кода.

3. **"Design Patterns in Python" на Udemy**
   - Курс по паттернам проектирования в Python, многие из которых помогают соблюдать принципы SOLID.

### Инструменты

1. **[Pylint](https://www.pylint.org/)**
   - Статический анализатор кода Python, который может помочь обнаружить нарушения принципов SOLID.

2. **[Mypy](http://mypy-lang.org/)**
   - Статический анализатор типов для Python, который может помочь обнаружить нарушения LSP.

3. **[Dependency Injector](https://python-dependency-injector.ets-labs.org/)**
   - Библиотека для внедрения зависимостей в Python, помогающая соблюдать DIP.

4. **[PyConsistency](https://github.com/chadlagore/pyconsistency)**
   - Библиотека для проверки инвариантов и контрактов в Python, помогающая соблюдать LSP.
