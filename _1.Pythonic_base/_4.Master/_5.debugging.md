# Отладка кода (debugging) в Python

## Содержание
1. [Введение в отладку](#введение-в-отладку)
2. [Типы ошибок в Python](#типы-ошибок-в-python)
3. [Базовые методы отладки](#базовые-методы-отладки)
4. [Использование отладчика pdb](#использование-отладчика-pdb)
5. [Отладка в IDE](#отладка-в-ide)
6. [Логирование](#логирование)
7. [Отладка многопоточных программ](#отладка-многопоточных-программ)
8. [Практические задания](#практические-задания)
9. [Мини-проект: Создание отладчика](#мини-проект-создание-отладчика)

## Введение в отладку

Отладка (debugging) — это процесс поиска и устранения ошибок (багов) в программном коде. Это один из важнейших навыков разработчика, который существенно влияет на эффективность и качество программирования.

### Почему отладка важна?

1. **Выявление ошибок** — даже опытные программисты пишут код с ошибками. Умение их находить и исправлять критически важно.
2. **Понимание кода** — отладка помогает глубже понять, как работает программа.
3. **Улучшение кода** — в процессе отладки часто выявляются не только ошибки, но и слабые места в дизайне программы.
4. **Экономия времени** — систематический подход к отладке более эффективен, чем случайные изменения кода.
5. **Непрерывное улучшение** — навыки отладки помогают писать более качественный код изначально.

### Цикл отладки

Отладка обычно представляет собой итеративный процесс, состоящий из следующих шагов:

1. **Воспроизведение проблемы** — первый шаг к решению любой проблемы — научиться стабильно воспроизводить ее.
2. **Сбор информации** — анализ сообщений об ошибках, лог-файлов и состояния программы для определения возможных причин.
3. **Формирование гипотезы** — на основе имеющейся информации формируется предположение о причине проблемы.
4. **Тестирование гипотезы** — проверка предположения с помощью внесения изменений, анализа кода или использования отладчика.
5. **Исправление проблемы** — после подтверждения гипотезы вносятся необходимые исправления.
6. **Проверка решения** — проверка, что проблема действительно решена и не было внесено новых проблем.

## Типы ошибок в Python

Прежде чем перейти к методам отладки, важно понимать типы ошибок, которые могут возникать в Python-программах.

### 1. Синтаксические ошибки (SyntaxError)

Возникают, когда код нарушает правила языка Python. Интерпретатор не может выполнить такой код.

```python
# Пример синтаксической ошибки
if x == 5    # Отсутствует двоеточие в конце
    print("x равен 5")
```

### 2. Исключения времени выполнения (RuntimeError)

Возникают во время выполнения программы. В отличие от синтаксических ошибок, исключения могут возникать даже в синтаксически правильном коде.

```python
# Пример исключения времени выполнения (деление на ноль)
x = 10 / 0  # Вызывает ZeroDivisionError
```

Примеры распространенных исключений:
- `NameError` — попытка использования неопределенной переменной
- `TypeError` — операция с несовместимыми типами данных
- `IndexError` — обращение к несуществующему индексу в списке или кортеже
- `KeyError` — обращение к несуществующему ключу в словаре
- `ValueError` — функция получает аргумент правильного типа, но неправильного значения
- `AttributeError` — попытка доступа к несуществующему атрибуту объекта
- `ImportError` — ошибка при импорте модуля
- `FileNotFoundError` — попытка открыть несуществующий файл

### 3. Логические ошибки

Самый сложный тип ошибок. Программа выполняется без исключений, но работает неправильно. Такие ошибки могут не вызывать явных сообщений об ошибках и требуют глубокого понимания кода для диагностики.

```python
# Пример логической ошибки
def calculate_area(radius):
    # Ошибка: используется диаметр вместо радиуса
    return 3.14 * (2 * radius) ** 2
```

### 4. Ошибки производительности

Программа работает правильно, но слишком медленно или потребляет слишком много ресурсов.

```python
# Пример ошибки производительности
def find_primes(n):
    primes = []
    for i in range(2, n + 1):
        is_prime = True
        # Неэффективный алгоритм проверки простоты числа
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes
```

## Базовые методы отладки

### 1. Анализ сообщений об ошибках

Python предоставляет информативные сообщения об ошибках с указанием типа исключения, места в коде и трассировкой стека вызовов.

Пример сообщения об ошибке:
```
Traceback (most recent call last):
  File "example.py", line 5, in <module>
    result = divide(10, 0)
  File "example.py", line 2, in divide
    return a / b
ZeroDivisionError: division by zero
```

В этом сообщении:
- Тип исключения: `ZeroDivisionError`
- Сообщение: `division by zero`
- Трассировка стека (от последнего вызова к первому):
  1. Ошибка произошла в строке 2 функции `divide`
  2. Функция `divide` была вызвана в строке 5 модуля

Совет: всегда читайте сообщения об ошибках снизу вверх, начиная с самой ошибки и поднимаясь по стеку вызовов.

### 2. Использование print для отладки

Самый простой способ отладки — добавление `print` для проверки значений переменных в определенных точках программы.

```python
def calculate_discount(price, discount_rate):
    print(f"Input values: price={price}, discount_rate={discount_rate}")
    
    if discount_rate > 1.0:
        discount_rate = discount_rate / 100.0
        print(f"Adjusted discount_rate: {discount_rate}")
    
    discount = price * discount_rate
    print(f"Calculated discount: {discount}")
    
    final_price = price - discount
    print(f"Final price: {final_price}")
    
    return final_price
```

Плюсы:
- Простота использования
- Не требует специальных инструментов
- Наглядность для понимания потока выполнения

Минусы:
- Изменение кода для отладки
- Необходимость удаления отладочных `print` перед выпуском программы
- Малая эффективность для сложных проблем

### 3. Техника бинарного поиска

Бинарный поиск — эффективный метод для локализации ошибок в программе:

1. Разделите код пополам.
2. Проверьте, находится ли ошибка в первой или второй половине (с помощью `print` или других методов).
3. Повторите для половины, содержащей ошибку, пока не найдете проблемное место.

### 4. Изолирование проблемы

Создание минимального примера, воспроизводящего проблему:

1. Постепенно удаляйте части кода, которые не влияют на проблему.
2. Заменяйте сложные входные данные простыми.
3. Устраняйте внешние зависимости.

Преимущества минимального примера:
- Упрощает отладку
- Помогает точно выявить причину проблемы
- Удобен для публикации вопросов на форумах

### 5. Использование Python-консоли

Интерактивная консоль позволяет экспериментировать с небольшими фрагментами кода и быстро проверять гипотезы.

## Использование отладчика pdb

Python Debug (pdb) — это встроенный отладчик Python, предоставляющий возможности для пошагового выполнения кода, просмотра переменных и многое другое.

### Основные способы запуска pdb

1. **Запуск скрипта через pdb:**
```bash
python -m pdb myscript.py
```

2. **Вставка точки останова в код:**
```python
import pdb; pdb.set_trace()
# В Python 3.7+ можно использовать встроенную функцию:
# breakpoint()
```

### Основные команды pdb

| Команда | Сокращение | Описание |
|---------|------------|----------|
| `help` | `h` | Показать справку |
| `where` | `w` | Показать текущее положение в стеке вызовов |
| `list` | `l` | Показать исходный код вокруг текущей строки |
| `next` | `n` | Выполнить следующую строку (без входа в функции) |
| `step` | `s` | Выполнить следующую строку (с входом в функции) |
| `continue` | `c` | Продолжить выполнение до следующей точки останова |
| `return` | `r` | Продолжить выполнение до конца текущей функции |
| `break` | `b` | Установить точку останова (`break line_number` или `break file:line`) |
| `clear` | `cl` | Удалить точку останова |
| `print` | `p` | Вывести значение выражения |
| `pp` | | Вывести значение выражения с форматированием |
| `display` | | Вывести значение выражения каждый раз при остановке |
| `undisplay` | | Прекратить отображение выражения |
| `up` | | Перейти на кадр стека выше |
| `down` | | Перейти на кадр стека ниже |
| `args` | `a` | Показать аргументы текущей функции |
| `locals` | | Показать локальные переменные |
| `quit` | `q` | Выйти из отладчика |

### Пример использования pdb

Рассмотрим пример программы с ошибкой:

```python
# buggy_program.py
def calculate_total(items):
    total = 0
    for item in items:
        total += item['price'] * item['quantity']
    return total

def apply_discount(total, discount_percent):
    discount = total * (discount_percent / 100)
    return total - discount

def process_order(items, discount_percent=0):
    total = calculate_total(items)
    if discount_percent > 0:
        total = apply_discount(total, discount)  # Ошибка: передается discount вместо discount_percent
    return total

# Тестовые данные
order_items = [
    {'name': 'Книга', 'price': 500, 'quantity': 2},
    {'name': 'Ручка', 'price': 40, 'quantity': 5}
]

# Расчет заказа с ошибкой
final_price = process_order(order_items, 10)
print(f"Итоговая цена: {final_price}")
```

Отладка этой программы с pdb:

```python
# Добавим точку останова
def process_order(items, discount_percent=0):
    total = calculate_total(items)
    import pdb; pdb.set_trace()  # Точка останова
    if discount_percent > 0:
        total = apply_discount(total, discount)
    return total
```

При выполнении программы pdb остановится на точке останова, и мы сможем:
1. Проверить значения переменных `total` и `discount_percent`
2. Выполнить следующую строку и увидеть ошибку
3. Исследовать ошибку и исправить передачу неправильного аргумента

### Пример сессии отладки

```
> buggy_program.py(11)process_order()
-> if discount_percent > 0:
(Pdb) p total
1080
(Pdb) p discount_percent
10
(Pdb) n
> buggy_program.py(12)process_order()
-> total = apply_discount(total, discount)
(Pdb) p discount
*** NameError: name 'discount' is not defined
(Pdb) p locals()
{'items': [...], 'discount_percent': 10, 'total': 1080}
```

Теперь ясно, что проблема в том, что мы пытаемся использовать переменную `discount`, которая не определена. Правильный вызов должен быть:

```python
total = apply_discount(total, discount_percent)
```

## Отладка в IDE

Современные IDE (Integrated Development Environments) предоставляют мощные инструменты для отладки с графическим интерфейсом. Рассмотрим основные возможности на примере популярных IDE.

### PyCharm

PyCharm — одна из самых мощных IDE для Python с продвинутыми возможностями отладки.

#### Основные функции отладки в PyCharm:

1. **Установка точек останова:**
   - Кликните на поле рядом с номером строки или используйте `Ctrl+F8`
   - Настраиваемые условные точки останова

2. **Запуск отладки:**
   - Используйте `Shift+F9` или иконку отладки
   - Можно прикрепить отладчик к уже запущенному процессу

3. **Управление выполнением:**
   - Step Over (`F8`) — выполнить следующую строку без входа в функции
   - Step Into (`F7`) — выполнить следующую строку с входом в функции
   - Step Out (`Shift+F8`) — выполнить до конца текущей функции
   - Resume (`F9`) — продолжить выполнение до следующей точки останова

4. **Просмотр переменных:**
   - Панель Variables показывает все доступные переменные
   - Watches для отслеживания конкретных выражений
   - Инструменты для просмотра сложных структур данных

5. **Фреймы стека:**
   - Просмотр и переключение между различными уровнями стека вызовов

6. **Оценка выражений:**
   - Консоль для выполнения произвольного кода в текущем контексте

### Visual Studio Code

VS Code с расширением Python также предоставляет мощные возможности отладки.

#### Основные функции отладки в VS Code:

1. **Установка точек останова:**
   - Кликните на поле рядом с номером строки или используйте `F9`
   - Поддержка условных точек останова

2. **Запуск отладки:**
   - Используйте `F5` или панель отладки

3. **Управление выполнением:**
   - Аналогичные PyCharm команды с теми же клавишами

4. **Просмотр переменных:**
   - Панели Variables, Watch и Call Stack
   - Возможность интерактивно изменять переменные

5. **Интеграция с инструментами Python:**
   - Поддержка различных отладчиков (включая pdb)
   - Интеграция с линтерами и форматерами кода

### Типичный рабочий процесс отладки в IDE

1. Установите точку останова перед проблемным местом
2. Запустите программу в режиме отладки
3. Когда программа остановится на точке останова:
   - Изучите значения переменных
   - Выполняйте код пошагово
   - При необходимости измените переменные
4. Продолжайте выполнение или установите новые точки останова
5. Когда найдете ошибку, остановите отладку и внесите исправления

## Логирование

Логирование — более продвинутый и систематический подход к отладке, чем использование `print`. Python предоставляет стандартный модуль `logging` для этой цели.

### Преимущества логирования перед print:

1. **Уровни важности** — разделение сообщений на категории (DEBUG, INFO, WARNING, ERROR, CRITICAL)
2. **Настраиваемость** — можно включать/выключать логи без изменения кода
3. **Форматирование** — гибкое форматирование сообщений с датой, временем, файлом, строкой кода
4. **Направление вывода** — вывод в файл, консоль, сетевые сокеты и т.д.
5. **Потокобезопасность** — работает корректно в многопоточных программах

### Основы логирования в Python

```python
import logging

# Настройка логгера
logging.basicConfig(
    level=logging.DEBUG,  # Уровень логирования
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',  # Формат сообщений
    filename='app.log',  # Файл для записи логов
    filemode='w'  # Режим записи ('w' - перезапись, 'a' - добавление)
)

# Создание логгера для модуля
logger = logging.getLogger(__name__)

def calculate_discount(price, discount_rate):
    logger.debug(f"Starting calculate_discount with price={price}, discount_rate={discount_rate}")
    
    if discount_rate > 1.0:
        logger.info(f"Converting discount rate from percentage: {discount_rate}%")
        discount_rate = discount_rate / 100.0
    
    discount = price * discount_rate
    logger.debug(f"Calculated discount: {discount}")
    
    final_price = price - discount
    logger.debug(f"Final price: {final_price}")
    
    return final_price

# Пример использования
try:
    price = 1000
    discount = 15
    final_price = calculate_discount(price, discount)
    logger.info(f"Successfully calculated final price: {final_price}")
except Exception as e:
    logger.error(f"Error calculating discount: {e}", exc_info=True)
```

### Уровни логирования

| Уровень | Значение | Когда использовать |
|---------|----------|-------------------|
| DEBUG | 10 | Детальная информация для отладки |
| INFO | 20 | Подтверждение, что все работает как ожидалось |
| WARNING | 30 | Индикация потенциальных проблем |
| ERROR | 40 | Ошибки, из-за которых функция не может выполниться |
| CRITICAL | 50 | Серьезные ошибки, из-за которых программа не может продолжать работу |

### Настройка обработчиков и форматирования

Для более гибкой настройки логирования можно использовать обработчики (handlers):

```python
import logging

# Создаем логгер
logger = logging.getLogger('my_app')
logger.setLevel(logging.DEBUG)

# Обработчик для вывода в файл
file_handler = logging.FileHandler('app.log')
file_handler.setLevel(logging.DEBUG)

# Обработчик для вывода в консоль
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)  # В консоль только важные сообщения

# Создаем форматтер
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Добавляем обработчики к логгеру
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Использование логгера
logger.debug('Это отладочное сообщение')  # Только в файл
logger.info('Это информационное сообщение')  # В файл и консоль
logger.warning('Это предупреждение')  # В файл и консоль
logger.error('Это сообщение об ошибке')  # В файл и консоль
logger.critical('Это критическая ошибка')  # В файл и консоль
```

### Настройка логирования через конфигурационный файл

Для больших приложений удобно настраивать логирование через конфигурационный файл:

```python
import logging
import logging.config
import yaml

# Загрузка конфигурации из YAML-файла
with open('logging_config.yaml', 'rt') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)

# Получение логгера
logger = logging.getLogger(__name__)

# Использование логгера
logger.debug('Отладочное сообщение')
```

Пример файла `logging_config.yaml`:

```yaml
version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: INFO
    formatter: simple
    stream: ext://sys.stdout
  file:
    class: logging.FileHandler
    level: DEBUG
    formatter: simple
    filename: app.log
loggers:
  my_app:
    level: DEBUG
    handlers: [console, file]
    propagate: no
root:
  level: WARNING
  handlers: [console]
  propagate: no
```

### Использование логирования для отладки

1. **Стратегическое размещение логов** — добавляйте логи в ключевых точках программы и при входе/выходе из функций.
2. **Правильный уровень детализации** — слишком много логов так же вредно, как и слишком мало.
3. **Структурирование информации** — включайте контекст в сообщения (значения переменных, состояние программы).
4. **Ротация лог-файлов** — для долгоработающих программ используйте `RotatingFileHandler` или `TimedRotatingFileHandler`.
5. **Ведение отдельных логов для разных компонентов** — используйте иерархию логгеров.

## Отладка многопоточных программ

Отладка многопоточных программ представляет особые сложности из-за недетерминированного порядка выполнения и возможных состояний гонки.

### Общие проблемы многопоточных программ

1. **Состояния гонки (Race Conditions)** — результат зависит от порядка выполнения потоков.
2. **Взаимные блокировки (Deadlocks)** — два или более потоков ждут ресурсов, удерживаемых друг другом.
3. **Проблемы синхронизации** — потоки взаимодействуют неправильно.
4. **Проблемы с общими ресурсами** — неконтролируемый доступ к общим данным.

### Методы отладки многопоточных программ

1. **Логирование с указанием потока**

```python
import logging
import threading
import time

# Настройка логгера
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(threadName)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Функция, выполняемая в отдельном потоке
def worker(name, delay):
    logger.info(f"Поток {name} начал работу")
    count = 0
    while count < 3:
        time.sleep(delay)
        count += 1
        logger.debug(f"Поток {name}: счетчик = {count}")
    logger.info(f"Поток {name} завершил работу")

# Создание и запуск потоков
threads = []
for i in range(3):
    thread = threading.Thread(target=worker, args=(f"Worker-{i}", i+1))
    thread.name = f"Thread-{i}"  # Установка имени потока для логов
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

logger.info("Все потоки завершены")
```

2. **Использование thread-safe структур данных**

```python
import threading
import queue
import logging

# Создаем thread-safe очередь
q = queue.Queue()

# Функция-производитель
def producer():
    for i in range(10):
        q.put(i)
        logging.debug(f"Производитель: добавил {i}, размер очереди {q.qsize()}")

# Функция-потребитель
def consumer():
    while True:
        try:
            item = q.get(block=False)
            logging.debug(f"Потребитель: получил {item}, размер очереди {q.qsize()}")
            q.task_done()
        except queue.Empty:
            if producer_done:
                break

# Запуск потоков
producer_done = False
producer_thread = threading.Thread(target=producer)
consumer_thread = threading.Thread(target=consumer)

producer_thread.start()
consumer_thread.start()

producer_thread.join()
producer_done = True
consumer_thread.join()
```

3. **Использование блокировок и примитивов синхронизации**

```python
import threading
import logging
import time

# Общий ресурс
counter = 0

# Блокировка для защиты counter
counter_lock = threading.Lock()

def increment_counter(name, count):
    global counter
    for _ in range(count):
        # Приобретение блокировки
        with counter_lock:
            counter += 1
            logging.debug(f"Поток {name}: counter = {counter}")
        time.sleep(0.01)  # Небольшая задержка

# Создание потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=increment_counter, args=(f"Thread-{i}", 10))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

logging.info(f"Окончательное значение counter: {counter}")
```

4. **Использование атомарных операций**

```python
import threading
from threading import Thread
import time
import logging
import ctypes

# Атомарный счетчик
class AtomicCounter:
    def __init__(self, initial=0):
        self.value = initial
        self._lock = threading.Lock()

    def increment(self, num=1):
        with self._lock:
            self.value += num
            return self.value

    def decrement(self, num=1):
        with self._lock:
            self.value -= num
            return self.value

    def get_value(self):
        with self._lock:
            return self.value

# Использование атомарного счетчика
counter = AtomicCounter()

def worker(name, count):
    for _ in range(count):
        value = counter.increment()
        logging.debug(f"Поток {name}: counter = {value}")
        time.sleep(0.01)

# Создание потоков
threads = []
for i in range(5):
    thread = Thread(target=worker, args=(f"Thread-{i}", 10))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

logging.info(f"Окончательное значение counter: {counter.get_value()}")
```

5. **Инструменты для отладки многопоточных программ**

- **threading.enumerate()** — получение списка всех активных потоков
- **threading.current_thread()** — получение текущего потока
- **threading.active_count()** — получение количества активных потоков
- **threading.stack_size()** — установка/получение размера стека для новых потоков

```python
import threading
import time
import logging

def worker(name):
    logging.info(f"Поток {name} начал работу")
    time.sleep(2)
    logging.info(f"Поток {name} завершил работу")

# Создание потоков
threads = []
for i in range(3):
    thread = threading.Thread(target=worker, args=(f"Worker-{i}",))
    threads.append(thread)
    thread.start()

# Отображение информации о потоках
time.sleep(0.5)
logging.info(f"Активные потоки: {threading.active_count()}")
for thread in threading.enumerate():
    logging.info(f"Поток {thread.name} активен: {thread.is_alive()}")

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()
```

### Советы по отладке многопоточных программ

1. **Используйте детерминированные входы** — начинайте с входных данных, которые всегда должны давать одинаковый результат.
2. **Добавляйте задержки** — иногда добавление стратегических задержек может помочь воспроизвести проблему.
3. **Ограничивайте количество потоков** — начинайте с минимального количества потоков, необходимого для воспроизведения проблемы.
4. **Изолируйте проблему** — создайте минимальный пример, демонстрирующий проблему.
5. **Используйте отладчик с поддержкой потоков** — PyCharm и другие IDE позволяют переключаться между потоками при отладке.
6. **Рассмотрите альтернативы потокам** — для некоторых задач лучше подходят процессы, асинхронное программирование или очереди задач.

## Практические задания

### Задание 1: Отладка функции расчета факториала

Ниже приведена функция для расчета факториала числа. В ней содержится ошибка. Используйте различные методы отладки, чтобы найти и исправить ошибку.

```python
def factorial(n):
    """
    Рассчитывает факториал числа n.
    
    Args:
        n (int): Положительное целое число.
        
    Returns:
        int: Факториал числа n.
    """
    if n < 0:
        raise ValueError("Факториал определен только для неотрицательных чисел")
    
    result = 0  # Ошибка: начальное значение должно быть 1
    for i in range(1, n + 1):
        result *= i
    
    return result

# Тестирование функции
print(factorial(5))  # Должно вернуть 120
```

#### Решение

1. **Анализ кода:**
   - Функция должна рассчитывать факториал, который является произведением всех чисел от 1 до n.
   - Начальное значение установлено как 0, но при умножении на любое число результат всегда будет 0.
   - Правильное начальное значение должно быть 1 (нейтральный элемент для умножения).

2. **Использование print для отладки:**

```python
def factorial(n):
    if n < 0:
        raise ValueError("Факториал определен только для неотрицательных чисел")
    
    result = 0  # Подозрительная строка
    print(f"Начальное значение result: {result}")
    
    for i in range(1, n + 1):
        result *= i
        print(f"После умножения на {i}: result = {result}")
    
    return result

# Тестирование функции
print(factorial(5))
```

3. **Использование отладчика pdb:**

```python
def factorial(n):
    import pdb; pdb.set_trace()
    if n < 0:
        raise ValueError("Факториал определен только для неотрицательных чисел")
    
    result = 0
    for i in range(1, n + 1):
        result *= i
    
    return result

# Тестирование функции
print(factorial(5))
```

4. **Исправленная функция:**

```python
def factorial(n):
    """
    Рассчитывает факториал числа n.
    
    Args:
        n (int): Положительное целое число.
        
    Returns:
        int: Факториал числа n.
    """
    if n < 0:
        raise ValueError("Факториал определен только для неотрицательных чисел")
    
    result = 1  # Исправлено: начальное значение должно быть 1
    for i in range(1, n + 1):
        result *= i
    
    return result

# Тестирование функции
print(factorial(5))  # Теперь правильно вернет 120
```

### Задание 2: Отладка функции поиска в списке

Ниже приведена функция для поиска элемента в отсортированном списке. В ней содержится несколько ошибок. Используйте различные методы отладки, чтобы найти и исправить ошибки.

```python
def binary_search(arr, target):
    """
    Выполняет бинарный поиск элемента в отсортированном списке.
    
    Args:
        arr (list): Отсортированный список.
        target: Искомый элемент.
        
    Returns:
        int: Индекс элемента, если он найден, иначе -1.
    """
    left = 0
    right = len(arr)  # Ошибка 1: должно быть len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid  # Ошибка 2: должно быть mid + 1
        else:
            right = mid  # Ошибка 3: должно быть mid - 1
    
    return -1

# Тестирование функции
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(sorted_list, 7))  # Должно вернуть 3
print(binary_search(sorted_list, 6))  # Должно вернуть -1
```

#### Решение

1. **Анализ кода:**
   - Бинарный поиск работает путем сравнения искомого элемента с средним элементом отсортированного списка и сужения диапазона поиска.
   - Есть три потенциальные проблемы: инициализация правой границы, обновление левой границы и обновление правой границы.

2. **Использование логирования для отладки:**

```python
import logging

logging.basicConfig(level=logging.DEBUG, format='%(message)s')
logger = logging.getLogger(__name__)

def binary_search(arr, target):
    logger.debug(f"Ищем {target} в {arr}")
    
    left = 0
    right = len(arr)
    logger.debug(f"Начальные границы: left={left}, right={right}")
    
    while left <= right:
        mid = (left + right) // 2
        logger.debug(f"Середина: mid={mid}, значение={arr[mid] if mid < len(arr) else 'Индекс за пределами списка'}")
        
        # Проверка выхода за пределы списка
        if mid >= len(arr):
            logger.error(f"Индекс mid={mid} выходит за пределы списка длиной {len(arr)}")
            break
        
        if arr[mid] == target:
            logger.debug(f"Элемент найден по индексу {mid}")
            return mid
        elif arr[mid] < target:
            left = mid
            logger.debug(f"Элемент меньше целевого, новые границы: left={left}, right={right}")
        else:
            right = mid
            logger.debug(f"Элемент больше целевого, новые границы: left={left}, right={right}")
        
        # Проверка на бесконечный цикл
        if left == right - 1 and arr[left] != target and arr[right] != target:
            logger.debug(f"Возможный бесконечный цикл: left={left}, right={right}")
    
    logger.debug("Элемент не найден")
    return -1

# Тестирование функции
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(sorted_list, 7))
print(binary_search(sorted_list, 6))
```

3. **Исправленная функция:**

```python
def binary_search(arr, target):
    """
    Выполняет бинарный поиск элемента в отсортированном списке.
    
    Args:
        arr (list): Отсортированный список.
        target: Искомый элемент.
        
    Returns:
        int: Индекс элемента, если он найден, иначе -1.
    """
    left = 0
    right = len(arr) - 1  # Исправлено: правая граница - это последний индекс списка
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # Исправлено: нужно исключить середину из поиска
        else:
            right = mid - 1  # Исправлено: нужно исключить середину из поиска
    
    return -1

# Тестирование функции
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(sorted_list, 7))  # Теперь правильно вернет 3
print(binary_search(sorted_list, 6))  # Теперь правильно вернет -1
```

### Задание 3: Отладка многопоточной программы

Ниже приведена многопоточная программа, которая должна увеличивать счетчик с помощью нескольких потоков. В ней содержится проблема синхронизации. Используйте методы отладки, чтобы найти и исправить проблему.

```python
import threading
import time

# Общий счетчик
counter = 0

def increment_counter(count):
    """
    Увеличивает глобальный счетчик на указанное количество.
    
    Args:
        count (int): Количество итераций увеличения.
    """
    global counter
    local_counter = counter
    
    for _ in range(count):
        local_counter += 1
        time.sleep(0.01)  # Имитация некоторой работы
    
    counter = local_counter

# Создание и запуск потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=increment_counter, args=(10,))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

print(f"Окончательное значение счетчика: {counter}")
# Ожидаемое значение: 50 (5 потоков * 10 увеличений каждый)
# Фактическое значение: будет меньше из-за состояния гонки
```

#### Решение

1. **Анализ проблемы:**
   - Проблема заключается в том, что каждый поток считывает значение счетчика в начале работы и затем перезаписывает его в конце, игнорируя обновления от других потоков.
   - Это классическое состояние гонки (race condition), когда результат зависит от порядка выполнения потоков.

2. **Использование логирования для отладки:**

```python
import threading
import time
import logging

logging.basicConfig(level=logging.DEBUG, format='%(threadName)s: %(message)s')
logger = logging.getLogger(__name__)

# Общий счетчик
counter = 0

def increment_counter(count):
    global counter
    logger.debug(f"Начало работы. Текущее значение счетчика: {counter}")
    
    local_counter = counter
    logger.debug(f"Локальное значение: {local_counter}")
    
    for i in range(count):
        local_counter += 1
        logger.debug(f"Увеличение {i+1}: local_counter = {local_counter}")
        time.sleep(0.01)
    
    logger.debug(f"Обновление глобального счетчика с {counter} на {local_counter}")
    counter = local_counter
    logger.debug(f"Конец работы. Итоговое значение счетчика: {counter}")

# Создание и запуск потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=increment_counter, args=(10,), name=f"Thread-{i}")
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

print(f"Окончательное значение счетчика: {counter}")
```

3. **Исправленная функция с использованием блокировки:**

```python
import threading
import time

# Общий счетчик
counter = 0

# Создание блокировки
counter_lock = threading.Lock()

def increment_counter(count):
    """
    Увеличивает глобальный счетчик на указанное количество.
    
    Args:
        count (int): Количество итераций увеличения.
    """
    global counter
    
    for _ in range(count):
        # Приобретение блокировки перед обновлением счетчика
        with counter_lock:
            counter += 1
        
        time.sleep(0.01)  # Имитация некоторой работы

# Создание и запуск потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=increment_counter, args=(10,))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

print(f"Окончательное значение счетчика: {counter}")
# Теперь должно быть 50 (5 потоков * 10 увеличений каждый)
```

4. **Альтернативное решение с использованием атомарного счетчика:**

```python
import threading
import time

class AtomicCounter:
    def __init__(self, initial=0):
        self.value = initial
        self._lock = threading.Lock()
    
    def increment(self, num=1):
        with self._lock:
            self.value += num
            return self.value
    
    def get_value(self):
        with self._lock:
            return self.value

# Создание атомарного счетчика
counter = AtomicCounter()

def increment_counter(count):
    """
    Увеличивает атомарный счетчик на указанное количество.
    
    Args:
        count (int): Количество итераций увеличения.
    """
    for _ in range(count):
        counter.increment()
        time.sleep(0.01)  # Имитация некоторой работы

# Создание и запуск потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=increment_counter, args=(10,))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()

print(f"Окончательное значение счетчика: {counter.get_value()}")
# Теперь должно быть 50 (5 потоков * 10 увеличений каждый)
```

## Мини-проект: Создание отладчика

В этом мини-проекте мы создадим простой отладчик на Python, который сможет:
1. Выполнять код пошагово
2. Отображать значения переменных
3. Устанавливать точки останова
4. Отслеживать изменения в переменных

### Реализация простого отладчика

```python
import sys
import inspect
import ast
import traceback

class SimpleDebugger:
    def __init__(self, code_str):
        """
        Инициализирует отладчик с заданным кодом.
        
        Args:
            code_str (str): Строка с исходным кодом Python.
        """
        self.code_str = code_str
        self.lines = code_str.strip().split('\n')
        self.current_line = 0
        self.variables = {}
        self.breakpoints = set()
        self.parsed_ast = ast.parse(code_str)
        self.running = True
    
    def show_context(self, context_lines=2):
        """
        Показывает текущую строку с контекстом.
        
        Args:
            context_lines (int): Количество строк контекста до и после текущей строки.
        """
        start = max(0, self.current_line - context_lines)
        end = min(len(self.lines), self.current_line + context_lines + 1)
        
        for i in range(start, end):
            prefix = '-> ' if i == self.current_line else '   '
            breakpoint_mark = '[B] ' if i in self.breakpoints else '    '
            print(f"{breakpoint_mark}{prefix}{i+1}: {self.lines[i]}")
    
    def show_variables(self):
        """
        Показывает текущие значения переменных.
        """
        if not self.variables:
            print("Переменные не определены.")
            return
        
        print("Переменные:")
        for name, value in self.variables.items():
            print(f"  {name} = {repr(value)}")
    
    def set_breakpoint(self, line_number):
        """
        Устанавливает точку останова на указанной строке.
        
        Args:
            line_number (int): Номер строки (начиная с 1).
        """
        line_index = line_number - 1
        if 0 <= line_index < len(self.lines):
            self.breakpoints.add(line_index)
            print(f"Точка останова установлена на строке {line_number}.")
        else:
            print(f"Некорректный номер строки: {line_number}")
    
    def clear_breakpoint(self, line_number):
        """
        Удаляет точку останова с указанной строки.
        
        Args:
            line_number (int): Номер строки (начиная с 1).
        """
        line_index = line_number - 1
        if line_index in self.breakpoints:
            self.breakpoints.remove(line_index)
            print(f"Точка останова удалена со строки {line_number}.")
        else:
            print(f"Точка останова на строке {line_number} не найдена.")
    
    def step(self):
        """
        Выполняет одну строку кода.
        """
        if self.current_line >= len(self.lines):
            print("Достигнут конец программы.")
            self.running = False
            return
        
        # Получение текущей строки кода
        line = self.lines[self.current_line]
        
        try:
            # Выполнение строки кода
            old_variables = self.variables.copy()
            exec(line, globals(), self.variables)
            
            # Отслеживание изменений в переменных
            for name, value in self.variables.items():
                if name not in old_variables or old_variables[name] != value:
                    if name.startswith('__') and name.endswith('__'):
                        continue  # Пропускаем встроенные переменные
                    print(f"Переменная изменена: {name} = {repr(value)}")
            
            # Переход к следующей строке
            self.current_line += 1
        except Exception as e:
            print(f"Ошибка: {e}")
            traceback.print_exc()
    
    def continue_execution(self):
        """
        Продолжает выполнение до следующей точки останова или конца программы.
        """
        while self.running and self.current_line < len(self.lines):
            # Проверка, находимся ли мы на точке останова
            if self.current_line in self.breakpoints and self.current_line > 0:
                print(f"Остановка на точке останова (строка {self.current_line + 1}).")
                break
            
            self.step()
    
    def run(self):
        """
        Запускает интерактивный отладчик.
        """
        print("Простой отладчик Python")
        print("Команды:")
        print("  s - шаг (step)")
        print("  c - продолжить до точки останова (continue)")
        print("  v - показать переменные (variables)")
        print("  b <номер строки> - установить точку останова (breakpoint)")
        print("  d <номер строки> - удалить точку останова (delete breakpoint)")
        print("  q - выход (quit)")
        print()
        
        self.show_context()
        
        while self.running:
            cmd = input("(отладчик) > ").strip()
            
            if cmd == 's':
                self.step()
                self.show_context()
            elif cmd == 'c':
                self.continue_execution()
                if self.running:
                    self.show_context()
            elif cmd == 'v':
                self.show_variables()
            elif cmd.startswith('b '):
                try:
                    line_number = int(cmd[2:])
                    self.set_breakpoint(line_number)
                except ValueError:
                    print("Ошибка: введите номер строки в формате 'b <номер строки>'")
            elif cmd.startswith('d '):
                try:
                    line_number = int(cmd[2:])
                    self.clear_breakpoint(line_number)
                except ValueError:
                    print("Ошибка: введите номер строки в формате 'd <номер строки>'")
            elif cmd == 'q':
                print("Выход из отладчика.")
                self.running = False
            else:
                print("Неизвестная команда. Введите 's', 'c', 'v', 'b <номер строки>', 'd <номер строки>' или 'q'.")

# Пример использования отладчика
sample_code = """
x = 10
y = 20
z = x + y
for i in range(5):
    x += i
    y -= i
print(f"x = {x}, y = {y}, z = {z}")
"""

debugger = SimpleDebugger(sample_code)
debugger.run()
```

### Улучшения для мини-проекта

1. **Поддержка выполнения функций**
   - Добавить возможность шагать внутрь функций (step into)
   - Добавить возможность пропускать функции (step over)
   - Добавить возможность выйти из функции (step out)

2. **Улучшенный анализ кода**
   - Использовать AST (Abstract Syntax Tree) для более точного анализа кода
   - Добавить возможность отображать кадры стека вызовов

3. **Более продвинутые точки останова**
   - Условные точки останова
   - Временные точки останова (на определенное количество проходов)
   - Точки останова при изменении переменных

4. **Визуализация**
   - Добавить простой графический интерфейс
   - Подсветка синтаксиса
   - Визуальное отображение стека вызовов

5. **Интеграция с другими инструментами**
   - Поддержка импорта модулей и пакетов
   - Интеграция с профилировщиком
   - Экспорт логов отладки

## Заключение

Отладка — это неотъемлемая часть процесса разработки, требующая методического подхода и терпения. В этом материале мы рассмотрели различные типы ошибок в Python, а также инструменты и методы их обнаружения и исправления.

Ключевые выводы:
1. **Понимание типов ошибок** — разные ошибки требуют разных подходов к отладке.
2. **Систематичность** — следуйте методическому подходу, а не пытайтесь угадать решение.
3. **Использование подходящих инструментов** — от простых `print` до продвинутых отладчиков и логирования.
4. **Изоляция проблем** — создавайте минимальные примеры, которые воспроизводят ошибку.
5. **Документирование процесса** — записывайте, что вы пробовали и какие результаты получили.

Отладка — это навык, который улучшается с практикой. Каждая ошибка, которую вы исправляете, делает вас лучшим программистом и помогает избегать подобных ошибок в будущем.

Для дальнейшего развития навыков отладки рекомендуется:
- Изучить дополнительные инструменты, такие как профилировщики и статические анализаторы кода.
- Практиковаться в отладке чужого кода для развития навыков понимания и анализа.
- Знакомиться с паттернами ошибок и их решениями в различных контекстах.
- Расширять знания о внутренней работе Python для лучшего понимания происходящего "под капотом".

Помните, что умение эффективно отлаживать код — это одно из ключевых отличий между начинающим и опытным программистом.
