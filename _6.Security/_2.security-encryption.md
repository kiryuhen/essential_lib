# Шифрование и хеширование

## Введение

Шифрование и хеширование — это фундаментальные методы защиты информации, которые используются для обеспечения конфиденциальности, целостности и аутентичности данных. Хотя оба метода трансформируют данные в нечитаемый формат, они служат разным целям и имеют различные свойства.

## Шифрование

**Шифрование** — это процесс преобразования данных в зашифрованный текст с помощью криптографического алгоритма и ключа, с целью сделать эти данные недоступными для чтения без соответствующего ключа для расшифровки.

### Основные свойства шифрования

1. **Обратимость** — зашифрованные данные могут быть преобразованы обратно в исходную форму при наличии правильного ключа.
2. **Конфиденциальность** — защита данных от несанкционированного чтения.
3. **Использование ключей** — для шифрования и расшифрования используются криптографические ключи.

### Типы шифрования

#### Симметричное шифрование

При симметричном шифровании для шифрования и расшифрования данных используется один и тот же ключ.

**Преимущества**:
- Высокая скорость шифрования/расшифрования
- Эффективность для больших объемов данных

**Недостатки**:
- Необходимость безопасного обмена ключами
- Сложность управления большим количеством ключей

**Популярные алгоритмы**:
- AES (Advanced Encryption Standard)
- DES (Data Encryption Standard) и 3DES
- Blowfish
- ChaCha20

**Пример симметричного шифрования с использованием AES в Python**:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import base64

def encrypt_aes(plaintext, key):
    """
    Шифрует текст с использованием AES-GCM.
    
    Args:
        plaintext (bytes): Данные для шифрования
        key (bytes): 32-байтовый ключ (для AES-256)
    
    Returns:
        bytes: iv + ciphertext + tag (закодированные в base64)
    """
    if len(key) != 32:
        raise ValueError("Ключ должен быть 32 байта (AES-256)")
    
    # Создаем случайный вектор инициализации
    iv = os.urandom(12)
    
    # Создаем шифр
    cipher = Cipher(
        algorithms.AES(key),
        modes.GCM(iv),
        backend=default_backend()
    )
    
    encryptor = cipher.encryptor()
    
    # Шифруем
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    
    # Получаем тег аутентификации
    tag = encryptor.tag
    
    # Объединяем все части и кодируем в base64
    result = base64.b64encode(iv + ciphertext + tag)
    return result

def decrypt_aes(ciphertext_base64, key):
    """
    Расшифровывает текст, зашифрованный с использованием AES-GCM.
    
    Args:
        ciphertext_base64 (bytes): Закодированные в base64 данные (iv + ciphertext + tag)
        key (bytes): 32-байтовый ключ (для AES-256)
    
    Returns:
        bytes: Расшифрованные данные
    """
    if len(key) != 32:
        raise ValueError("Ключ должен быть 32 байта (AES-256)")
    
    # Декодируем из base64
    ciphertext_full = base64.b64decode(ciphertext_base64)
    
    # Извлекаем части: iv (12 байт), tag (16 байт), остальное - шифротекст
    iv = ciphertext_full[:12]
    tag = ciphertext_full[-16:]
    ciphertext = ciphertext_full[12:-16]
    
    # Создаем шифр
    cipher = Cipher(
        algorithms.AES(key),
        modes.GCM(iv, tag),
        backend=default_backend()
    )
    
    decryptor = cipher.decryptor()
    
    # Расшифровываем
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext

# Пример использования
if __name__ == "__main__":
    key = os.urandom(32)  # 256 бит
    plaintext = b"Секретное сообщение, которое нужно зашифровать"
    
    # Шифрование
    encrypted = encrypt_aes(plaintext, key)
    print(f"Зашифрованный текст: {encrypted}")
    
    # Расшифрование
    decrypted = decrypt_aes(encrypted, key)
    print(f"Расшифрованный текст: {decrypted.decode('utf-8')}")
```

#### Асимметричное шифрование (шифрование с открытым ключом)

При асимметричном шифровании используется пара ключей: открытый (публичный) ключ для шифрования и закрытый (приватный) ключ для расшифрования.

**Преимущества**:
- Нет необходимости в безопасной передаче ключей
- Позволяет реализовать цифровые подписи

**Недостатки**:
- Медленнее симметричного шифрования
- Не подходит для шифрования больших объемов данных

**Популярные алгоритмы**:
- RSA (Rivest–Shamir–Adleman)
- ECC (Elliptic Curve Cryptography)
- DSA (Digital Signature Algorithm)
- ElGamal

**Пример асимметричного шифрования с использованием RSA в Python**:

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import base64

def generate_rsa_keys():
    """
    Генерирует пару RSA ключей.
    
    Returns:
        (private_key, public_key): Кортеж, содержащий приватный и публичный ключи
    """
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    public_key = private_key.public_key()
    
    return private_key, public_key

def encrypt_rsa(public_key, plaintext):
    """
    Шифрует данные с использованием RSA.
    
    Args:
        public_key: Публичный ключ RSA
        plaintext (bytes): Данные для шифрования
    
    Returns:
        bytes: Зашифрованные данные в кодировке base64
    """
    ciphertext = public_key.encrypt(
        plaintext,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    
    return base64.b64encode(ciphertext)

def decrypt_rsa(private_key, ciphertext_base64):
    """
    Расшифровывает данные с использованием RSA.
    
    Args:
        private_key: Приватный ключ RSA
        ciphertext_base64 (bytes): Зашифрованные данные в кодировке base64
    
    Returns:
        bytes: Расшифрованные данные
    """
    ciphertext = base64.b64decode(ciphertext_base64)
    
    plaintext = private_key.decrypt(
        ciphertext,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    
    return plaintext

# Пример использования
if __name__ == "__main__":
    # Генерация ключей
    private_key, public_key = generate_rsa_keys()
    
    # Исходные данные
    plaintext = b"Секретное сообщение, которое нужно зашифровать"
    
    # Шифрование
    encrypted = encrypt_rsa(public_key, plaintext)
    print(f"Зашифрованный текст: {encrypted}")
    
    # Расшифрование
    decrypted = decrypt_rsa(private_key, encrypted)
    print(f"Расшифрованный текст: {decrypted.decode('utf-8')}")
```

#### Гибридное шифрование

Гибридное шифрование сочетает в себе преимущества симметричного и асимметричного шифрования. Данные шифруются с помощью быстрого симметричного алгоритма, а симметричный ключ шифруется асимметричным алгоритмом.

**Преимущества**:
- Высокая скорость шифрования больших объемов данных
- Безопасный обмен ключами

**Пример гибридного шифрования в Python**:

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import os
import base64

def generate_rsa_keys():
    """Генерирует пару RSA ключей."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    public_key = private_key.public_key()
    
    return private_key, public_key

def hybrid_encrypt(public_key, plaintext):
    """
    Гибридное шифрование: AES + RSA.
    
    Args:
        public_key: RSA публичный ключ
        plaintext (bytes): Данные для шифрования
    
    Returns:
        dict: Словарь, содержащий зашифрованный ключ и зашифрованные данные
    """
    # Генерируем случайный AES ключ
    aes_key = os.urandom(32)  # 256 бит
    
    # Шифруем данные с помощью AES
    iv = os.urandom(12)
    cipher = Cipher(algorithms.AES(aes_key), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    tag = encryptor.tag
    
    # Шифруем AES ключ с помощью RSA
    encrypted_key = public_key.encrypt(
        aes_key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    
    return {
        'encrypted_key': base64.b64encode(encrypted_key),
        'iv': base64.b64encode(iv),
        'ciphertext': base64.b64encode(ciphertext),
        'tag': base64.b64encode(tag)
    }

def hybrid_decrypt(private_key, encrypted_data):
    """
    Гибридное расшифрование: AES + RSA.
    
    Args:
        private_key: RSA приватный ключ
        encrypted_data (dict): Словарь с зашифрованными данными
    
    Returns:
        bytes: Расшифрованные данные
    """
    # Расшифровываем AES ключ с помощью RSA
    encrypted_key = base64.b64decode(encrypted_data['encrypted_key'])
    aes_key = private_key.decrypt(
        encrypted_key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    
    # Расшифровываем данные с помощью AES
    iv = base64.b64decode(encrypted_data['iv'])
    ciphertext = base64.b64decode(encrypted_data['ciphertext'])
    tag = base64.b64decode(encrypted_data['tag'])
    
    cipher = Cipher(algorithms.AES(aes_key), modes.GCM(iv, tag), backend=default_backend())
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    
    return plaintext

# Пример использования
if __name__ == "__main__":
    # Генерация ключей
    private_key, public_key = generate_rsa_keys()
    
    # Исходные данные
    plaintext = b"Большой объем данных, который нужно зашифровать с высокой скоростью и безопасностью"
    
    # Гибридное шифрование
    encrypted_data = hybrid_encrypt(public_key, plaintext)
    print("Зашифрованные данные:")
    for key, value in encrypted_data.items():
        print(f"{key}: {value}")
    
    # Гибридное расшифрование
    decrypted = hybrid_decrypt(private_key, encrypted_data)
    print(f"\nРасшифрованный текст: {decrypted.decode('utf-8')}")
```

### Режимы шифрования блочных шифров

Блочные шифры (например, AES) работают с блоками данных фиксированной длины. Режимы шифрования определяют, как алгоритм обрабатывает блоки данных.

#### Основные режимы шифрования

1. **ECB (Electronic Codebook)**
   - Каждый блок шифруется независимо
   - Наименее безопасный режим, не рекомендуется для большинства приложений

2. **CBC (Cipher Block Chaining)**
   - Каждый блок перед шифрованием XOR-ится с предыдущим зашифрованным блоком
   - Требует вектор инициализации (IV)
   - Более безопасен, чем ECB

3. **CTR (Counter)**
   - Превращает блочный шифр в потоковый, шифруя последовательные значения счетчика
   - Параллелизуемый и простой в реализации

4. **GCM (Galois/Counter Mode)**
   - Обеспечивает аутентификационные данные (тег) для проверки целостности
   - Обеспечивает шифрование с аутентификацией
   - Высокопроизводительный и широко рекомендуемый

5. **OFB (Output Feedback)**
   - Преобразует блочный шифр в потоковый
   - Ошибки в шифротексте не распространяются

6. **CFB (Cipher Feedback)**
   - Похож на CBC, но может работать как потоковый шифр
   - Ошибки в шифротексте распространяются

**Пример использования разных режимов шифрования AES в Python**:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

def generate_key():
    """Генерирует случайный 256-битный ключ для AES."""
    return os.urandom(32)

def generate_iv(size=16):
    """Генерирует случайный вектор инициализации."""
    return os.urandom(size)

def encrypt_aes_cbc(key, plaintext):
    """Шифрует данные с использованием AES в режиме CBC."""
    iv = generate_iv()
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    
    # Выравнивание данных до размера блока (16 байт для AES)
    padder = padding.PKCS7(algorithms.AES.block_size).padder()
    padded_data = padder.update(plaintext) + padder.finalize()
    
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return {'iv': iv, 'ciphertext': ciphertext}

def decrypt_aes_cbc(key, iv, ciphertext):
    """Расшифровывает данные с использованием AES в режиме CBC."""
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    
    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    
    # Удаление выравнивания
    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    
    return plaintext

def encrypt_aes_ctr(key, plaintext):
    """Шифрует данные с использованием AES в режиме CTR."""
    nonce = os.urandom(16)  # 16-байтовый счетчик
    cipher = Cipher(algorithms.AES(key), modes.CTR(nonce), backend=default_backend())
    encryptor = cipher.encryptor()
    
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    return {'nonce': nonce, 'ciphertext': ciphertext}

def decrypt_aes_ctr(key, nonce, ciphertext):
    """Расшифровывает данные с использованием AES в режиме CTR."""
    cipher = Cipher(algorithms.AES(key), modes.CTR(nonce), backend=default_backend())
    decryptor = cipher.decryptor()
    
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext

def encrypt_aes_gcm(key, plaintext, associated_data=None):
    """
    Шифрует данные с использованием AES в режиме GCM.
    
    Args:
        key (bytes): 32-байтовый ключ
        plaintext (bytes): Данные для шифрования
        associated_data (bytes, optional): Дополнительные данные для аутентификации
    
    Returns:
        dict: Содержит iv, ciphertext и tag
    """
    iv = os.urandom(12)  # Рекомендуемый размер для GCM
    cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    
    # Если есть аутентификационные данные, добавляем их
    if associated_data:
        encryptor.authenticate_additional_data(associated_data)
    
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    
    return {
        'iv': iv,
        'ciphertext': ciphertext,
        'tag': encryptor.tag  # 16-байтовый тег аутентификации
    }

def decrypt_aes_gcm(key, iv, ciphertext, tag, associated_data=None):
    """
    Расшифровывает данные с использованием AES в режиме GCM.
    
    Args:
        key (bytes): 32-байтовый ключ
        iv (bytes): 12-байтовый вектор инициализации
        ciphertext (bytes): Зашифрованные данные
        tag (bytes): 16-байтовый тег аутентификации
        associated_data (bytes, optional): Дополнительные данные для аутентификации
    
    Returns:
        bytes: Расшифрованные данные
    """
    cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend())
    decryptor = cipher.decryptor()
    
    # Если есть аутентификационные данные, добавляем их
    if associated_data:
        decryptor.authenticate_additional_data(associated_data)
    
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext

# Пример использования
if __name__ == "__main__":
    key = generate_key()
    plaintext = b"Секретное сообщение, которое нужно зашифровать"
    
    # AES-GCM с аутентификационными данными
    associated_data = b"Дополнительные данные для аутентификации"
    
    encrypted_gcm = encrypt_aes_gcm(key, plaintext, associated_data)
    print(f"GCM Шифротекст: {encrypted_gcm['ciphertext']}")
    print(f"GCM Тег: {encrypted_gcm['tag']}")
    
    decrypted_gcm = decrypt_aes_gcm(
        key, 
        encrypted_gcm['iv'], 
        encrypted_gcm['ciphertext'], 
        encrypted_gcm['tag'], 
        associated_data
    )
    print(f"GCM Расшифрованный текст: {decrypted_gcm.decode('utf-8')}")
```

### Защита ключей шифрования

Безопасность шифрования в значительной степени зависит от того, насколько хорошо защищены ключи.

#### Основные принципы управления ключами

1. **Генерация ключей**
   - Используйте криптографически стойкие генераторы случайных чисел
   - Обеспечьте достаточную длину и энтропию ключей

2. **Хранение ключей**
   - Никогда не хардкодите ключи в коде
   - Используйте хранилища ключей (KeyStore, HSM)
   - Шифруйте ключи шифрования при хранении (KEK - Key Encryption Keys)

3. **Распределение ключей**
   - Используйте безопасные каналы для передачи ключей
   - Для симметричного шифрования рассмотрите использование асимметричных алгоритмов для обмена ключами

4. **Ротация ключей**
   - Периодически обновляйте ключи
   - Разработайте процедуры для безопасной смены ключей

**Пример управления ключами с использованием мастер-ключа**:

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import base64
import json
import getpass

class KeyManager:
    def __init__(self, key_file="keys.json"):
        self.key_file = key_file
        self.master_key = None
        self.keys = {}
        
        # Загрузка ключей, если файл существует
        if os.path.exists(key_file):
            self.load_keys()
    
    def set_master_key(self, password):
        """Устанавливает мастер-ключ на основе пароля."""
        salt = os.urandom(16)
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        self.master_key = {
            'key': base64.b64encode(kdf.derive(password.encode())),
            'salt': base64.b64encode(salt)
        }
    
    def load_master_key(self, password):
        """Загружает мастер-ключ на основе пароля."""
        if os.path.exists(self.key_file):
            with open(self.key_file, 'r') as f:
                data = json.load(f)
                
            salt = base64.b64decode(data['master_key']['salt'])
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
                backend=default_backend()
            )
            self.master_key = {
                'key': base64.b64encode(kdf.derive(password.encode())),
                'salt': data['master_key']['salt']
            }
            
            # Расшифровка ключей
            for key_id, encrypted_key in data['keys'].items():
                self.keys[key_id] = self._decrypt_key(encrypted_key)
    
    def generate_key(self, key_id, key_length=32):
        """Генерирует новый ключ и сохраняет его под указанным ID."""
        if not self.master_key:
            raise ValueError("Сначала необходимо установить мастер-ключ")
        
        key = os.urandom(key_length)
        self.keys[key_id] = key
        self.save_keys()
        return key
    
    def get_key(self, key_id):
        """Возвращает ключ по его ID."""
        return self.keys.get(key_id)
    
    def save_keys(self):
        """Сохраняет зашифрованные ключи в файл."""
        if not self.master_key:
            raise ValueError("Сначала необходимо установить мастер-ключ")
        
        encrypted_keys = {}
        for key_id, key in self.keys.items():
            encrypted_keys[key_id] = self._encrypt_key(key)
        
        data = {
            'master_key': {
                'salt': self.master_key['salt'].decode()
            },
            'keys': encrypted_keys
        }
        
        with open(self.key_file, 'w') as f:
            json.dump(data, f)
    
    def load_keys(self):
        """Загружает ключи из файла (требует предварительной загрузки мастер-ключа)."""
        if not self.master_key:
            raise ValueError("Сначала необходимо загрузить мастер-ключ")
        
        with open(self.key_file, 'r') as f:
            data = json.load(f)
        
        for key_id, encrypted_key in data['keys'].items():
            self.keys[key_id] = self._decrypt_key(encrypted_key)
    
    def _encrypt_key(self, key):
        """Шифрует ключ с помощью мастер-ключа."""
        iv = os.urandom(12)
        cipher = Cipher(
            algorithms.AES(base64.b64decode(self.master_key['key'])),
            modes.GCM(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(key) + encryptor.finalize()
        
        return {
            'iv': base64.b64encode(iv).decode(),
            'ciphertext': base64.b64encode(ciphertext).decode(),
            'tag': base64.b64encode(encryptor.tag).decode()
        }
    
    def _decrypt_key(self, encrypted_key):
        """Расшифровывает ключ с помощью мастер-ключа."""
        iv = base64.b64decode(encrypted_key['iv'])
        ciphertext = base64.b64decode(encrypted_key['ciphertext'])
        tag = base64.b64decode(encrypted_key['tag'])
        
        cipher = Cipher(
            algorithms.AES(base64.b64decode(self.master_key['key'])),
            modes.GCM(iv, tag),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        
        return decryptor.update(ciphertext) + decryptor.finalize()

# Пример использования
if __name__ == "__main__":
    # Создание менеджера ключей
    key_manager = KeyManager()
    
    # Сценарий первого использования
    if not os.path.exists(key_manager.key_file):
        print("Первичная настройка:")
        master_password = getpass.getpass("Создайте мастер-пароль: ")
        key_manager.set_master_key(master_password)
        
        # Генерация ключей для разных целей
        key_manager.generate_key("database_key")
        key_manager.generate_key("api_key")
        key_manager.generate_key("jwt_key")
        
        print(f"Ключи созданы и сохранены в {key_manager.key_file}")
    else:
        # Сценарий повторного использования
        print("Загрузка существующих ключей:")
        master_password = getpass.getpass("Введите мастер-пароль: ")
        
        try:
            key_manager.load_master_key(master_password)
            print("Загруженные ключи:")
            for key_id in key_manager.keys:
                print(f" - {key_id}")
        except Exception as e:
            print(f"Ошибка загрузки ключей: {e}")
```

## Хеширование

**Хеширование** — это процесс преобразования данных произвольной длины в строку фиксированной длины (хеш), который не может быть обращен обратно для получения исходных данных.

### Основные свойства хеширования

1. **Необратимость** — из хеша (теоретически) невозможно восстановить исходные данные.
2. **Детерминированность** — одни и те же входные данные всегда дают одинаковый хеш.
3. **Лавинный эффект** — небольшое изменение во входных данных приводит к значительному изменению в хеше.
4. **Устойчивость к коллизиям** — сложно найти два разных входных значения, дающих одинаковый хеш.

### Применение хеширования

1. **Проверка целостности данных** — для проверки, что данные не были изменены.
2. **Хранение паролей** — вместо хранения реальных паролей, хранят их хеши.
3. **Поиск дубликатов** — использование хешей для быстрого сравнения больших объемов данных.
4. **Структуры данных** — хеш-таблицы, блокчейн и т.д.

### Популярные алгоритмы хеширования

#### MD5
- 128-битный хеш
- Считается устаревшим и небезопасным для криптографических целей
- Всё ещё используется для проверки целостности данных и быстрых хеш-таблиц

#### SHA-1
- 160-битный хеш
- Также считается устаревшим для криптографических целей
- В 2017 году было продемонстрировано практическое создание коллизий

#### SHA-2
- Семейство, включающее SHA-224, SHA-256, SHA-384, SHA-512
- Широко используется и считается безопасным
- SHA-256 часто используется в блокчейн-технологиях и TLS

#### SHA-3
- Новейшее семейство хеш-функций, не связанное с SHA-2
- Разработано как альтернатива SHA-2
- Высокая устойчивость к атакам

#### BLAKE2
- Более быстрая альтернатива SHA-3
- Оптимизирована для 64-битных платформ

**Пример использования различных алгоритмов хеширования в Python**:

```python
import hashlib
import binascii
import time

def compare_hash_algorithms(data):
    """Сравнивает различные алгоритмы хеширования."""
    algorithms = [
        'md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
        'blake2b', 'blake2s', 'sha3_224', 'sha3_256', 'sha3_384', 'sha3_512'
    ]
    
    result = {}
    
    for algorithm in algorithms:
        start_time = time.time()
        hash_obj = hashlib.new(algorithm)
        hash_obj.update(data)
        digest = hash_obj.digest()
        end_time = time.time()
        
        result[algorithm] = {
            'hex': binascii.hexlify(digest).decode('utf-8'),
            'length_bits': len(digest) * 8,
            'time_ms': (end_time - start_time) * 1000
        }
    
    return result

# Пример использования
if __name__ == "__main__":
    test_data = b"Пример данных для хеширования"
    large_data = b"X" * 1000000  # 1 МБ данных
    
    print("Хеширование короткой строки:")
    short_results = compare_hash_algorithms(test_data)
    
    for algo, info in short_results.items():
        print(f"{algo.ljust(10)} | {info['length_bits']} бит | {info['time_ms']:.2f} мс | {info['hex'][:16]}...")
    
    print("\nХеширование 1 МБ данных:")
    large_results = compare_hash_algorithms(large_data)
    
    for algo, info in large_results.items():
        print(f"{algo.ljust(10)} | {info['length_bits']} бит | {info['time_ms']:.2f} мс | {info['hex'][:16]}...")
```

### Хеширование паролей

Для хеширования паролей требуются специальные алгоритмы, которые добавляют случайную "соль" и требуют значительных вычислительных ресурсов для противодействия атакам перебором и атакам по словарю.

#### Основные алгоритмы хеширования паролей

1. **PBKDF2 (Password-Based Key Derivation Function 2)**
   - Применяет хеш-функцию многократно
   - Использует соль для защиты от атак с помощью радужных таблиц
   - Количество итераций может быть увеличено для увеличения вычислительной сложности

2. **bcrypt**
   - Использует алгоритм шифрования Blowfish
   - Имеет встроенную соль
   - Фактор стоимости (cost factor) для управления временем вычисления

3. **scrypt**
   - Разработан для противодействия атакам с использованием специального оборудования (ASIC)
   - Требует большого объема памяти
   - Более устойчив к атакам на параллельном оборудовании, чем PBKDF2

4. **Argon2**
   - Победитель конкурса Password Hashing Competition (2015)
   - Разработан для максимальной устойчивости к атакам методом перебора
   - Имеет три варианта: Argon2d, Argon2i и Argon2id

**Пример хеширования паролей с использованием различных алгоритмов**:

```python
import hashlib
import os
import base64
import bcrypt
import argon2
import binascii
from passlib.hash import pbkdf2_sha256, argon2, bcrypt_sha256

def hash_password_pbkdf2(password, salt=None, iterations=100000):
    """
    Хеширует пароль с использованием PBKDF2-HMAC-SHA256.
    
    Args:
        password (str): Пароль для хеширования
        salt (bytes, optional): Соль. Если None, генерируется случайная соль.
        iterations (int): Количество итераций
    
    Returns:
        dict: Словарь, содержащий соль, количество итераций и хеш
    """
    if salt is None:
        salt = os.urandom(16)
    
    # Преобразуем пароль в байты, если это строка
    if isinstance(password, str):
        password = password.encode('utf-8')
    
    # Вычисляем хеш
    dk = hashlib.pbkdf2_hmac('sha256', password, salt, iterations)
    
    return {
        'algorithm': 'pbkdf2_sha256',
        'hash': base64.b64encode(dk).decode('ascii'),
        'salt': base64.b64encode(salt).decode('ascii'),
        'iterations': iterations
    }

def verify_password_pbkdf2(password, hash_dict):
    """
    Проверяет, соответствует ли пароль хешу.
    
    Args:
        password (str): Пароль для проверки
        hash_dict (dict): Словарь, содержащий соль, итерации и хеш
    
    Returns:
        bool: True, если пароль соответствует хешу, иначе False
    """
    if isinstance(password, str):
        password = password.encode('utf-8')
    
    salt = base64.b64decode(hash_dict['salt'])
    iterations = hash_dict['iterations']
    
    # Вычисляем хеш для введенного пароля
    dk = hashlib.pbkdf2_hmac('sha256', password, salt, iterations)
    computed_hash = base64.b64encode(dk).decode('ascii')
    
    # Сравниваем с сохраненным хешем
    return computed_hash == hash_dict['hash']

def hash_password_bcrypt(password, rounds=12):
    """
    Хеширует пароль с использованием bcrypt.
    
    Args:
        password (str): Пароль для хеширования
        rounds (int): Фактор стоимости (10-14 рекомендуется)
    
    Returns:
        str: Хеш пароля с включенной солью
    """
    if isinstance(password, str):
        password = password.encode('utf-8')
    
    # bcrypt автоматически генерирует соль
    hashed = bcrypt.hashpw(password, bcrypt.gensalt(rounds=rounds))
    return hashed.decode('ascii')

def verify_password_bcrypt(password, hashed):
    """
    Проверяет, соответствует ли пароль хешу bcrypt.
    
    Args:
        password (str): Пароль для проверки
        hashed (str): Хеш пароля
    
    Returns:
        bool: True, если пароль соответствует хешу, иначе False
    """
    if isinstance(password, str):
        password = password.encode('utf-8')
    
    if isinstance(hashed, str):
        hashed = hashed.encode('ascii')
    
    return bcrypt.checkpw(password, hashed)

def hash_password_argon2(password):
    """
    Хеширует пароль с использованием Argon2.
    
    Args:
        password (str): Пароль для хеширования
    
    Returns:
        str: Хеш пароля
    """
    # Используем passlib для простого интерфейса с Argon2
    return argon2.hash(password)

def verify_password_argon2(password, hash_str):
    """
    Проверяет, соответствует ли пароль хешу Argon2.
    
    Args:
        password (str): Пароль для проверки
        hash_str (str): Хеш пароля
    
    Returns:
        bool: True, если пароль соответствует хешу, иначе False
    """
    return argon2.verify(password, hash_str)

# Пример использования с passlib для удобства
def compare_password_hashing():
    password = "Секретный пароль 123!"
    
    # Хеширование с PBKDF2
    pbkdf2_hash = pbkdf2_sha256.hash(password)
    pbkdf2_verify = pbkdf2_sha256.verify(password, pbkdf2_hash)
    
    # Хеширование с bcrypt
    bcrypt_hash = bcrypt_sha256.hash(password)
    bcrypt_verify = bcrypt_sha256.verify(password, bcrypt_hash)
    
    # Хеширование с Argon2
    argon2_hash = argon2.hash(password)
    argon2_verify = argon2.verify(password, argon2_hash)
    
    print("PBKDF2-SHA256:")
    print(f"  Хеш: {pbkdf2_hash}")
    print(f"  Проверка: {pbkdf2_verify}")
    
    print("\nbcrypt-sha256:")
    print(f"  Хеш: {bcrypt_hash}")
    print(f"  Проверка: {bcrypt_verify}")
    
    print("\nArgon2:")
    print(f"  Хеш: {argon2_hash}")
    print(f"  Проверка: {argon2_verify}")

# Пример использования
if __name__ == "__main__":
    compare_password_hashing()
```

### Соль и перец

Для повышения безопасности хеширования паролей используются дополнительные методы:

#### Соль (Salt)

Соль — это случайные данные, которые добавляются к паролю перед хешированием. Каждый пароль должен иметь уникальную соль, которая хранится вместе с хешем.

**Преимущества использования соли**:
- Защита от атак с использованием радужных таблиц
- Защита от определения одинаковых паролей (один и тот же пароль у разных пользователей дает разные хеши)

#### Перец (Pepper)

Перец — это секретное значение, которое добавляется к паролю перед хешированием, но, в отличие от соли, не хранится в базе данных.

**Преимущества использования перца**:
- Даже при компрометации базы данных злоумышленнику потребуется дополнительно получить доступ к серверу для доступа к перцу
- Добавляет дополнительный уровень защиты для паролей

**Пример реализации хеширования паролей с солью и перцем**:

```python
import os
import hashlib
import hmac
import base64
from passlib.hash import pbkdf2_sha256

class PasswordHasher:
    def __init__(self, pepper=None, iterations=100000):
        """
        Инициализирует хешер паролей.
        
        Args:
            pepper (bytes, optional): Секретное значение, не хранящееся в базе данных
            iterations (int): Количество итераций для PBKDF2
        """
        # Если перец не предоставлен, используем значение из переменной окружения или дефолтное
        if pepper is None:
            self.pepper = os.environ.get('PASSWORD_PEPPER', 'default-pepper-value').encode('utf-8')
        else:
            self.pepper = pepper
            
        self.iterations = iterations
    
    def hash_password(self, password):
        """
        Хеширует пароль с использованием соли и перца.
        
        Args:
            password (str): Пароль для хеширования
        
        Returns:
            dict: Словарь с хешем и солью
        """
        # Генерируем случайную соль
        salt = os.urandom(16)
        salt_b64 = base64.b64encode(salt).decode('ascii')
        
        # Применяем перец с помощью HMAC
        peppered_password = self._apply_pepper(password)
        
        # Хешируем пароль с солью и перцем
        hash_b64 = self._hash_with_salt(peppered_password, salt)
        
        return {
            'hash': hash_b64,
            'salt': salt_b64,
            'iterations': self.iterations
        }
    
    def verify_password(self, password, hash_dict):
        """
        Проверяет, соответствует ли пароль хешу.
        
        Args:
            password (str): Пароль для проверки
            hash_dict (dict): Словарь с хешем и солью
        
        Returns:
            bool: True, если пароль соответствует хешу, иначе False
        """
        # Применяем перец к паролю
        peppered_password = self._apply_pepper(password)
        
        # Получаем соль из хеша
        salt = base64.b64decode(hash_dict['salt'])
        
        # Хешируем введенный пароль с той же солью
        computed_hash = self._hash_with_salt(peppered_password, salt)
        
        # Сравниваем хеши
        return computed_hash == hash_dict['hash']
    
    def _apply_pepper(self, password):
        """
        Применяет перец к паролю с помощью HMAC.
        
        Args:
            password (str): Пароль
        
        Returns:
            bytes: Пароль с примененным перцем
        """
        if isinstance(password, str):
            password = password.encode('utf-8')
            
        return hmac.new(self.pepper, password, hashlib.sha256).digest()
    
    def _hash_with_salt(self, peppered_password, salt):
        """
        Хеширует пароль с перцем и солью с помощью PBKDF2.
        
        Args:
            peppered_password (bytes): Пароль с примененным перцем
            salt (bytes): Соль
        
        Returns:
            str: Хеш в формате base64
        """
        dk = hashlib.pbkdf2_hmac('sha256', peppered_password, salt, self.iterations)
        return base64.b64encode(dk).decode('ascii')

# Пример более простой реализации с использованием passlib
class SimplePasswordHasher:
    def __init__(self, pepper=None):
        """
        Инициализирует хешер паролей с использованием passlib.
        
        Args:
            pepper (str, optional): Секретное значение, не хранящееся в базе данных
        """
        # Если перец не предоставлен, используем значение из переменной окружения или дефолтное
        self.pepper = pepper or os.environ.get('PASSWORD_PEPPER', 'default-pepper-value')
    
    def hash_password(self, password):
        """
        Хеширует пароль с использованием перца и соли.
        
        Args:
            password (str): Пароль для хеширования
        
        Returns:
            str: Хеш пароля
        """
        # Комбинируем пароль с перцем
        peppered_password = password + self.pepper
        
        # Хешируем с помощью passlib (автоматически добавляет соль)
        return pbkdf2_sha256.hash(peppered_password)
    
    def verify_password(self, password, hash_str):
        """
        Проверяет, соответствует ли пароль хешу.
        
        Args:
            password (str): Пароль для проверки
            hash_str (str): Хеш пароля
        
        Returns:
            bool: True, если пароль соответствует хешу, иначе False
        """
        # Комбинируем пароль с перцем
        peppered_password = password + self.pepper
        
        # Проверяем с помощью passlib
        return pbkdf2_sha256.verify(peppered_password, hash_str)

# Пример использования
if __name__ == "__main__":
    # Создаем хешер с перцем из переменных окружения
    # (для реального использования сохраните перец в безопасном месте)
    os.environ['PASSWORD_PEPPER'] = 'my-super-secret-pepper-value'
    
    # Полная реализация с ручным управлением
    hasher = PasswordHasher(iterations=150000)
    
    password = "Мой секретный пароль!"
    
    # Хеширование
    hash_data = hasher.hash_password(password)
    print(f"Хеш: {hash_data['hash']}")
    print(f"Соль: {hash_data['salt']}")
    print(f"Итерации: {hash_data['iterations']}")
    
    # Проверка
    is_valid = hasher.verify_password(password, hash_data)
    print(f"Правильный пароль: {is_valid}")
    
    is_invalid = hasher.verify_password("Неправильный пароль", hash_data)
    print(f"Неправильный пароль: {is_invalid}")
    
    # Простая реализация с passlib
    simple_hasher = SimplePasswordHasher()
    
    # Хеширование
    hash_str = simple_hasher.hash_password(password)
    print(f"\nОбъединенный хеш passlib: {hash_str}")
    
    # Проверка
    is_valid_simple = simple_hasher.verify_password(password, hash_str)
    print(f"Правильный пароль: {is_valid_simple}")
    
    is_invalid_simple = simple_hasher.verify_password("Неправильный пароль", hash_str)
    print(f"Неправильный пароль: {is_invalid_simple}")
```

## Цифровые подписи

Цифровые подписи используются для проверки подлинности и целостности данных. Они основаны на асимметричной криптографии.

### Процесс создания и проверки цифровой подписи

1. **Создание подписи**:
   - Генерация хеша сообщения
   - Шифрование хеша с помощью закрытого ключа отправителя

2. **Проверка подписи**:
   - Расшифровка подписи с помощью открытого ключа отправителя
   - Генерация хеша исходного сообщения
   - Сравнение двух хешей

### Популярные алгоритмы цифровой подписи

1. **RSA-PSS** — версия RSA с улучшенной безопасностью
2. **DSA (Digital Signature Algorithm)** — стандарт цифровой подписи
3. **ECDSA (Elliptic Curve Digital Signature Algorithm)** — версия DSA, использующая эллиптические кривые
4. **EdDSA (Edwards-curve Digital Signature Algorithm)** — более новая альтернатива, использующая кривые Эдвардса (Ed25519)

**Пример создания и проверки цифровой подписи с использованием RSA**:

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import base64

def generate_rsa_keys():
    """
    Генерирует пару RSA ключей.
    
    Returns:
        tuple: (private_key, public_key)
    """
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    public_key = private_key.public_key()
    
    return private_key, public_key

def sign_message(private_key, message):
    """
    Создает цифровую подпись для сообщения.
    
    Args:
        private_key: RSA приватный ключ
        message (bytes): Сообщение для подписи
    
    Returns:
        bytes: Цифровая подпись в формате base64
    """
    # Преобразуем сообщение в байты, если это строка
    if isinstance(message, str):
        message = message.encode('utf-8')
    
    # Создаем подпись
    signature = private_key.sign(
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    
    # Кодируем в base64 для удобства передачи
    return base64.b64encode(signature)

def verify_signature(public_key, message, signature_base64):
    """
    Проверяет цифровую подпись.
    
    Args:
        public_key: RSA публичный ключ
        message (bytes or str): Исходное сообщение
        signature_base64 (bytes): Подпись в формате base64
    
    Returns:
        bool: True, если подпись действительна, иначе False
    """
    # Преобразуем сообщение в байты, если это строка
    if isinstance(message, str):
        message = message.encode('utf-8')
    
    # Декодируем подпись из base64
    signature = base64.b64decode(signature_base64)
    
    try:
        # Проверяем подпись
        public_key.verify(
            signature,
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    except Exception:
        # Если возникла ошибка, подпись недействительна
        return False

# Пример использования
if __name__ == "__main__":
    # Генерация ключей
    private_key, public_key = generate_rsa_keys()
    
    # Сообщение для подписи
    message = "Это важное сообщение, которое необходимо подписать"
    
    # Создание подписи
    signature = sign_message(private_key, message)
    print(f"Подпись: {signature.decode('ascii')}")
    
    # Проверка подписи с правильным сообщением
    is_valid = verify_signature(public_key, message, signature)
    print(f"Подпись действительна: {is_valid}")
    
    # Проверка подписи с измененным сообщением
    altered_message = "Это измененное сообщение"
    is_valid_altered = verify_signature(public_key, altered_message, signature)
    print(f"Подпись для измененного сообщения действительна: {is_valid_altered}")
```

### Подпись файлов и данных

Цифровые подписи часто используются для подтверждения подлинности файлов, программного обеспечения и других данных.

```python
import os
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend
import base64

def generate_and_save_rsa_keys(private_key_path, public_key_path, password=None):
    """
    Генерирует и сохраняет пару RSA ключей.
    
    Args:
        private_key_path (str): Путь для сохранения приватного ключа
        public_key_path (str): Путь для сохранения публичного ключа
        password (str, optional): Пароль для защиты приватного ключа
    """
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )
    
    # Преобразуем пароль в байты, если он указан
    password_bytes = None
    if password:
        password_bytes = password.encode('utf-8')
    
    # Сериализуем и сохраняем приватный ключ
    with open(private_key_path, 'wb') as f:
        f.write(private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.BestAvailableEncryption(password_bytes) if password_bytes else serialization.NoEncryption()
        ))
    
    # Сериализуем и сохраняем публичный ключ
    public_key = private_key.public_key()
    with open(public_key_path, 'wb') as f:
        f.write(public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ))

def load_private_key(private_key_path, password=None):
    """
    Загружает приватный ключ из файла.
    
    Args:
        private_key_path (str): Путь к файлу приватного ключа
        password (str, optional): Пароль для расшифровки ключа
    
    Returns:
        RSAPrivateKey: Загруженный приватный ключ
    """
    with open(private_key_path, 'rb') as f:
        private_key_data = f.read()
    
    password_bytes = None
    if password:
        password_bytes = password.encode('utf-8')
    
    return serialization.load_pem_private_key(
        private_key_data,
        password=password_bytes,
        backend=default_backend()
    )

def load_public_key(public_key_path):
    """
    Загружает публичный ключ из файла.
    
    Args:
        public_key_path (str): Путь к файлу публичного ключа
    
    Returns:
        RSAPublicKey: Загруженный публичный ключ
    """
    with open(public_key_path, 'rb') as f:
        public_key_data = f.read()
    
    return serialization.load_pem_public_key(
        public_key_data,
        backend=default_backend()
    )

def sign_file(private_key, file_path, signature_path):
    """
    Создает цифровую подпись для файла.
    
    Args:
        private_key: RSA приватный ключ
        file_path (str): Путь к файлу для подписи
        signature_path (str): Путь для сохранения подписи
    """
    # Вычисляем хеш файла
    hasher = hashes.Hash(hashes.SHA256(), default_backend())
    
    with open(file_path, 'rb') as f:
        # Читаем файл по частям для эффективной обработки больших файлов
        chunk = f.read(8192)
        while chunk:
            hasher.update(chunk)
            chunk = f.read(8192)
    
    file_hash = hasher.finalize()
    
    # Создаем подпись
    signature = private_key.sign(
        file_hash,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    
    # Сохраняем подпись в файл
    with open(signature_path, 'wb') as f:
        f.write(base64.b64encode(signature))

def verify_file_signature(public_key, file_path, signature_path):
    """
    Проверяет цифровую подпись файла.
    
    Args:
        public_key: RSA публичный ключ
        file_path (str): Путь к файлу
        signature_path (str): Путь к файлу подписи
    
    Returns:
        bool: True, если подпись действительна, иначе False
    """
    # Загружаем подпись
    with open(signature_path, 'rb') as f:
        signature = base64.b64decode(f.read())
    
    # Вычисляем хеш файла
    hasher = hashes.Hash(hashes.SHA256(), default_backend())
    
    with open(file_path, 'rb') as f:
        chunk = f.read(8192)
        while chunk:
            hasher.update(chunk)
            chunk = f.read(8192)
    
    file_hash = hasher.finalize()
    
    try:
        # Проверяем подпись
        public_key.verify(
            signature,
            file_hash,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    except Exception:
        return False

# Пример использования
if __name__ == "__main__":
    # Пути для ключей и тестового файла
    private_key_path = "private_key.pem"
    public_key_path = "public_key.pem"
    test_file_path = "test_file.txt"
    signature_path = "test_file.sig"
    
    # Создаем тестовый файл, если он не существует
    if not os.path.exists(test_file_path):
        with open(test_file_path, 'w') as f:
            f.write("Это тестовый файл, который будет подписан и проверен.")
    
    # Генерируем ключи, если они не существуют
    if not (os.path.exists(private_key_path) and os.path.exists(public_key_path)):
        print("Генерация новых ключей...")
        generate_and_save_rsa_keys(private_key_path, public_key_path, password="secret")
    
    # Загружаем ключи
    private_key = load_private_key(private_key_path, password="secret")
    public_key = load_public_key(public_key_path)
    
    # Подписываем файл
    print(f"Подписываем файл {test_file_path}...")
    sign_file(private_key, test_file_path, signature_path)
    
    # Проверяем подпись
    print(f"Проверяем подпись...")
    is_valid = verify_file_signature(public_key, test_file_path, signature_path)
    print(f"Подпись действительна: {is_valid}")
    
    # Модифицируем файл и проверяем подпись снова
    print(f"Модифицируем файл и проверяем подпись снова...")
    with open(test_file_path, 'a') as f:
        f.write("\nЭта строка была добавлена позже и нарушает целостность файла.")
    
    is_valid_after_modification = verify_file_signature(public_key, test_file_path, signature_path)
    print(f"Подпись после модификации действительна: {is_valid_after_modification}")
```

## HMAC (Hash-based Message Authentication Code)

HMAC — это механизм для проверки целостности и аутентичности сообщения с использованием криптографической хеш-функции и секретного ключа.

### Преимущества HMAC

1. **Аутентификация и целостность** — HMAC обеспечивает и аутентификацию источника, и целостность данных.
2. **Простота** — HMAC прост в реализации и использовании.
3. **Использование существующих хеш-функций** — HMAC может использовать любую криптографическую хеш-функцию.

### Применение HMAC

1. **Аутентификация API-запросов**
2. **Подпись cookie и токенов**
3. **Проверка целостности файлов или данных**
4. **Защита от атак типа "человек посередине" (MITM)**

**Пример реализации HMAC в Python**:

```python
import hmac
import hashlib
import base64
import time
import json

def generate_api_signature(api_key, api_secret, method, endpoint, params=None, body=None, timestamp=None):
    """
    Генерирует подпись для API-запроса.
    
    Args:
        api_key (str): Ключ API для идентификации клиента
        api_secret (str): Секрет API для создания подписи
        method (str): HTTP-метод (GET, POST, и т.д.)
        endpoint (str): Эндпоинт API (часть URL после базового URL)
        params (dict, optional): Параметры запроса
        body (dict, optional): Тело запроса
        timestamp (int, optional): Временная метка запроса (Unix timestamp)
    
    Returns:
        dict: Словарь с подписью и информацией для запроса
    """
    # Если временная метка не указана, используем текущее время
    if timestamp is None:
        timestamp = int(time.time())
    
    # Преобразуем тело запроса в JSON, если оно указано
    body_str = ''
    if body:
        body_str = json.dumps(body, separators=(',', ':'))
    
    # Создаем строку для подписи
    signature_string = f"{method.upper()}\n{endpoint}\n{timestamp}\n"
    
    # Добавляем параметры запроса, если они указаны
    if params:
        # Сортируем параметры по ключу для обеспечения детерминированности
        params_str = '&'.join(f"{key}={params[key]}" for key in sorted(params.keys()))
        signature_string += f"{params_str}\n"
    
    # Добавляем тело запроса, если оно указано
    if body_str:
        signature_string += body_str
    
    # Создаем HMAC-подпись
    signature = hmac.new(
        api_secret.encode('utf-8'),
        signature_string.encode('utf-8'),
        hashlib.sha256
    ).digest()
    
    # Кодируем подпись в base64
    signature_b64 = base64.b64encode(signature).decode('ascii')
    
    return {
        'signature': signature_b64,
        'timestamp': timestamp,
        'api_key': api_key
    }

def verify_api_signature(api_key, api_secret, method, endpoint, timestamp, signature, params=None, body=None):
    """
    Проверяет подпись API-запроса.
    
    Args:
        api_key (str): Ключ API клиента
        api_secret (str): Секрет API для проверки подписи
        method (str): HTTP-метод запроса
        endpoint (str): Эндпоинт API
        timestamp (int): Временная метка запроса
        signature (str): Подпись в формате base64
        params (dict, optional): Параметры запроса
        body (dict, optional): Тело запроса
    
    Returns:
        bool: True, если подпись действительна, иначе False
    """
    # Проверяем, не устарел ли запрос
    current_time = int(time.time())
    if current_time - timestamp > 300:  # 5 минут
        print("Запрос устарел")
        return False
    
    # Создаем ожидаемую подпись
    expected_signature_data = generate_api_signature(
        api_key, api_secret, method, endpoint, params, body, timestamp
    )
    
    # Сравниваем подписи
    expected_signature = expected_signature_data['signature']
    return hmac.compare_digest(expected_signature, signature)

# Пример использования для защиты API
def secured_api_example():
    # Ключи API (в реальной системе эти ключи хранились бы в безопасном месте)
    api_key = "client_12345"
    api_secret = "976a5725cd294a088149f5acdf8b2c471f9e487c"
    
    # Данные запроса
    method = "POST"
    endpoint = "/api/v1/orders"
    params = {"market": "BTC-USD"}
    body = {
        "side": "buy",
        "price": 50000,
        "amount": 0.01
    }
    
    # Клиент: создание запроса с подписью
    signature_data = generate_api_signature(api_key, api_secret, method, endpoint, params, body)
    print("Клиент сгенерировал подпись:")
    print(f"API Key: {signature_data['api_key']}")
    print(f"Timestamp: {signature_data['timestamp']}")
    print(f"Signature: {signature_data['signature']}")
    
    # Сервер: проверка подписи запроса
    print("\nСервер проверяет подпись...")
    is_valid = verify_api_signature(
        api_key,
        api_secret,
        method,
        endpoint,
        signature_data['timestamp'],
        signature_data['signature'],
        params,
        body
    )
    
    if is_valid:
        print("Подпись действительна, запрос обрабатывается.")
    else:
        print("Недействительная подпись, запрос отклонен.")
    
    # Пример атаки: изменение данных запроса
    print("\nЗлоумышленник пытается изменить данные запроса...")
    modified_body = body.copy()
    modified_body["amount"] = 1.0  # Изменение суммы заказа
    
    is_valid_after_modification = verify_api_signature(
        api_key,
        api_secret,
        method,
        endpoint,
        signature_data['timestamp'],
        signature_data['signature'],
        params,
        modified_body
    )
    
    if is_valid_after_modification:
        print("Подпись действительна после модификации (это плохо!).")
    else:
        print("Подпись недействительна после модификации, атака обнаружена.")

# Пример использования HMAC для защиты cookie
def secure_cookie_example():
    print("\nПример защиты cookie с помощью HMAC:")
    
    # Секретный ключ для подписи cookie
    cookie_secret = "this_is_a_secret_cookie_key_123"
    
    # Данные cookie
    user_id = 12345
    username = "john_doe"
    role = "user"
    
    # Создаем данные cookie
    cookie_data = {
        "user_id": user_id,
        "username": username,
        "role": role,
        "expires": int(time.time()) + 3600  # 1 час
    }
    
    # Сериализуем данные в JSON
    cookie_json = json.dumps(cookie_data, separators=(',', ':'))
    
    # Кодируем в base64
    cookie_b64 = base64.b64encode(cookie_json.encode('utf-8')).decode('ascii')
    
    # Создаем HMAC-подпись
    signature = hmac.new(
        cookie_secret.encode('utf-8'),
        cookie_b64.encode('utf-8'),
        hashlib.sha256
    ).digest()
    
    # Кодируем подпись в base64
    signature_b64 = base64.b64encode(signature).decode('ascii')
    
    # Создаем окончательное значение cookie (данные.подпись)
    cookie_value = f"{cookie_b64}.{signature_b64}"
    print(f"Значение cookie: {cookie_value}")
    
    # На стороне сервера: проверка cookie
    print("\nСервер проверяет cookie...")
    
    # Разделяем данные и подпись
    try:
        received_data, received_signature = cookie_value.split('.')
        
        # Вычисляем ожидаемую подпись
        expected_signature = hmac.new(
            cookie_secret.encode('utf-8'),
            received_data.encode('utf-8'),
            hashlib.sha256
        ).digest()
        expected_signature_b64 = base64.b64encode(expected_signature).decode('ascii')
        
        # Проверяем подпись
        if hmac.compare_digest(expected_signature_b64, received_signature):
            # Декодируем данные
            decoded_json = base64.b64decode(received_data).decode('utf-8')
            decoded_data = json.loads(decoded_json)
            
            # Проверяем срок действия
            if decoded_data['expires'] > time.time():
                print(f"Cookie действительно. Пользователь: {decoded_data['username']}, роль: {decoded_data['role']}")
            else:
                print("Cookie истекло.")
        else:
            print("Недействительная подпись cookie.")
    except Exception as e:
        print(f"Ошибка при проверке cookie: {e}")
    
    # Пример попытки подделки cookie
    print("\nЗлоумышленник пытается подделать cookie...")
    
    # Изменяем роль пользователя на "admin"
    malicious_data = cookie_data.copy()
    malicious_data["role"] = "admin"
    
    # Сериализуем данные
    malicious_json = json.dumps(malicious_data, separators=(',', ':'))
    malicious_b64 = base64.b64encode(malicious_json.encode('utf-8')).decode('ascii')
    
    # Пробуем использовать оригинальную подпись с измененными данными
    malicious_cookie = f"{malicious_b64}.{signature_b64}"
    
    print("Сервер проверяет поддельное cookie...")
    
    # Разделяем данные и подпись
    try:
        received_data, received_signature = malicious_cookie.split('.')
        
        # Вычисляем ожидаемую подпись
        expected_signature = hmac.new(
            cookie_secret.encode('utf-8'),
            received_data.encode('utf-8'),
            hashlib.sha256
        ).digest()
        expected_signature_b64 = base64.b64encode(expected_signature).decode('ascii')
        
        # Проверяем подпись
        if hmac.compare_digest(expected_signature_b64, received_signature):
            print("Cookie подтверждено (это плохо!).")
        else:
            print("Недействительная подпись cookie, атака обнаружена.")
    except Exception as e:
        print(f"Ошибка при проверке cookie: {e}")

# Запускаем примеры
if __name__ == "__main__":
    secured_api_example()
    secure_cookie_example()
```

## Заключение

Шифрование и хеширование — это критически важные инструменты для обеспечения безопасности данных в современных приложениях. Правильное понимание и применение этих методов помогает защитить конфиденциальность и целостность данных пользователей, а также обеспечить аутентичность источника информации.

### Ключевые рекомендации

1. **Используйте современные алгоритмы**
   - Для шифрования: AES-256-GCM, ChaCha20-Poly1305
   - Для хеширования паролей: bcrypt, Argon2, PBKDF2
   - Для цифровых подписей: RSA-PSS, EdDSA (Ed25519)

2. **Управляйте ключами безопасно**
   - Никогда не храните ключи в коде
   - Используйте системы управления ключами (KMS)
   - Регулярно ротируйте ключи

3. **Следите за уязвимостями и обновлениями**
   - Регулярно обновляйте криптографические библиотеки
   - Следите за новостями о криптографических уязвимостях

4. **Придерживайтесь принципа Керкхоффса**
   - Безопасность системы должна зависеть только от ключа, а не от секретности алгоритма
   - Не создавайте свои собственные криптографические алгоритмы

5. **Используйте проверенные библиотеки вместо собственных реализаций**
   - В Python: cryptography, pyca/cryptography, pynacl
   - В других языках: libsodium, OpenSSL, BouncyCastle и т.д.

Помните, что безопасность — это процесс, а не продукт. Регулярно обновляйте свои знания и практики в области криптографии и безопасности данных.
