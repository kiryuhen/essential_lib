# Обработка исключений в Python

## Содержание
1. [Введение в обработку исключений](#введение-в-обработку-исключений)
2. [Оператор try-except](#оператор-try-except)
3. [Блок else](#блок-else)
4. [Блок finally](#блок-finally)
5. [Типы исключений](#типы-исключений)
6. [Создание собственных исключений](#создание-собственных-исключений)
7. [Повторное возбуждение исключений](#повторное-возбуждение-исключений)
8. [Проверка условий с помощью assert](#проверка-условий-с-помощью-assert)
9. [Менеджеры контекста (with)](#менеджеры-контекста-with)
10. [Лучшие практики обработки исключений](#лучшие-практики-обработки-исключений)
11. [Практические задания](#практические-задания)
12. [Решения практических заданий](#решения-практических-заданий)

## Введение в обработку исключений

Во время выполнения программы могут возникать различные ошибки: неправильный ввод пользователя, отсутствие файла, недостаточно памяти и т.д. Обработка исключений позволяет элегантно справляться с такими ситуациями, предотвращая аварийное завершение программы.

### Что такое исключение?

**Исключение** — это событие, которое происходит во время выполнения программы и нарушает нормальный ход выполнения инструкций. Когда Python встречает ошибку, он создает объект исключения. Если программа не обрабатывает это исключение, она аварийно завершается и выводит сообщение об ошибке.

### Примеры распространенных исключений:

```python
# ZeroDivisionError: деление на ноль
result = 10 / 0

# TypeError: операции с несовместимыми типами данных
result = '2' + 2

# ValueError: неверное значение
number = int('abc')

# FileNotFoundError: файл не найден
file = open('несуществующий_файл.txt')

# IndexError: индекс за пределами списка
my_list = [1, 2, 3]
print(my_list[10])
```

### Важность обработки исключений:

1. **Предотвращение сбоев программы** — программа может продолжить работу даже при возникновении ошибок
2. **Улучшение пользовательского опыта** — вместо непонятного сообщения об ошибке можно показать понятное сообщение
3. **Более надежный код** — правильная обработка исключительных ситуаций делает код более устойчивым
4. **Упрощение отладки** — можно получить информацию о контексте ошибки

## Оператор try-except

Базовая структура обработки исключений в Python состоит из блоков `try` и `except`:

```python
try:
    # Код, который может вызвать исключение
    result = 10 / 0
except ZeroDivisionError:
    # Код обработки исключения
    print("Ошибка: деление на ноль")
```

В этом примере:
1. Код внутри блока `try` выполняется как обычно.
2. Если в блоке `try` возникает исключение, Python ищет блок `except`, который может его обработать.
3. Если соответствующий блок `except` найден, выполняется код в этом блоке, после чего программа продолжает выполнение.
4. Если соответствующий блок `except` не найден, исключение передается "выше" в стек вызовов.

### Обработка нескольких исключений:

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
    print(f"Результат: {result}")
except ValueError:
    print("Ошибка: введено не число")
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
```

### Обработка нескольких исключений одним блоком:

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
    print(f"Результат: {result}")
except (ValueError, ZeroDivisionError):
    print("Ошибка: введено не число или ноль")
```

### Получение информации об исключении:

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
    print(f"Результат: {result}")
except Exception as e:
    print(f"Произошла ошибка: {e}")
    print(f"Тип ошибки: {type(e).__name__}")
```

### Перехват всех исключений:

```python
try:
    # Потенциально опасный код
    pass
except Exception as e:
    # Обработка любого исключения, кроме SystemExit, KeyboardInterrupt и GeneratorExit
    print(f"Поймано исключение: {e}")
except:
    # Перехватывает абсолютно все исключения (не рекомендуется)
    print("Произошла непредвиденная ошибка")
```

Важно: перехват всех исключений с помощью `except:` без указания типа считается плохой практикой, так как может скрыть серьезные проблемы и усложнить отладку.

## Блок else

Блок `else` после блоков `try` и `except` выполняется только если в блоке `try` не возникло исключений.

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ValueError:
    print("Введено не число")
except ZeroDivisionError:
    print("Деление на ноль")
else:
    # Выполняется только если исключений не было
    print(f"Результат: {result}")
    print("Операция выполнена успешно")
```

Когда использовать `else`:
- Код в блоке `else` не выполнится, если произойдет исключение в блоке `try`
- Подходит для кода, который должен выполниться только при успешном выполнении блока `try`
- Позволяет отделить код, который может вызвать исключение, от кода, который выполняется после успешного выполнения

## Блок finally

Блок `finally` выполняется всегда, независимо от того, возникло исключение или нет. Он используется для освобождения ресурсов, закрытия файлов и т.д.

```python
try:
    file = open("example.txt", "r")
    content = file.read()
    # Обработка содержимого файла
except FileNotFoundError:
    print("Файл не найден")
except IOError as e:
    print(f"Ошибка ввода-вывода: {e}")
else:
    print(f"Файл успешно прочитан, его размер: {len(content)} символов")
finally:
    # Этот блок выполняется в любом случае
    if 'file' in locals() and not file.closed:
        file.close()
        print("Файл закрыт")
```

Когда использовать `finally`:
- Для кода, который должен выполниться в любом случае (при исключении или без него)
- Для закрытия файлов, сетевых соединений, освобождения ресурсов
- Для завершающих операций, которые должны быть выполнены всегда

## Типы исключений

Python предоставляет множество встроенных типов исключений, организованных в иерархию. Все они наследуются от базового класса `BaseException`.

### Основные типы исключений:

1. **Синтаксические ошибки** (`SyntaxError`, `IndentationError`) — ошибки в синтаксисе Python
2. **Ошибки выполнения** — возникают во время выполнения программы:
   - `TypeError` — операции с несовместимыми типами данных
   - `ValueError` — функция получает аргумент правильного типа, но с недопустимым значением
   - `NameError` — обращение к несуществующей переменной
   - `IndexError` — индекс за пределами последовательности
   - `KeyError` — несуществующий ключ словаря
   - `AttributeError` — обращение к несуществующему атрибуту
   - `ImportError` — ошибка импорта модуля
   - `IOError` / `FileNotFoundError` — ошибки ввода-вывода
   - `ZeroDivisionError` — деление на ноль
   - `RuntimeError` — ошибка выполнения, не попадающая в другие категории

3. **Предупреждения** (`Warning`) — не прерывают выполнение программы, а только предупреждают

### Иерархия исключений:

```
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```

### Пример использования иерархии исключений:

```python
try:
    # Код, который может вызвать различные исключения
    pass
except ValueError:
    # Обработка ValueError
    pass
except LookupError:
    # Обработка IndexError и KeyError, так как они наследуются от LookupError
    pass
except ArithmeticError:
    # Обработка ZeroDivisionError, OverflowError и других арифметических ошибок
    pass
except Exception:
    # Обработка всех других исключений
    pass
```

## Создание собственных исключений

Вы можете создавать собственные исключения, определяя новые классы, наследующиеся от существующих классов исключений (обычно от `Exception`).

```python
class CustomError(Exception):
    """Базовое исключение для нашего приложения"""
    pass

class ValueTooSmallError(CustomError):
    """Вызывается, когда значение слишком маленькое"""
    def __init__(self, value, min_value, message="Значение слишком маленькое"):
        self.value = value
        self.min_value = min_value
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message}: {self.value} < {self.min_value}"

class ValueTooLargeError(CustomError):
    """Вызывается, когда значение слишком большое"""
    def __init__(self, value, max_value, message="Значение слишком большое"):
        self.value = value
        self.max_value = max_value
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message}: {self.value} > {self.max_value}"


def validate_value(value, min_value=0, max_value=100):
    """Проверяет, что значение находится в допустимом диапазоне"""
    if value < min_value:
        raise ValueTooSmallError(value, min_value)
    if value > max_value:
        raise ValueTooLargeError(value, max_value)
    return value

# Использование
try:
    user_value = int(input("Введите число от 0 до 100: "))
    validated_value = validate_value(user_value, 0, 100)
    print(f"Значение {validated_value} допустимо")
except ValueTooSmallError as e:
    print(f"Ошибка: {e}")
    print("Пожалуйста, введите большее число")
except ValueTooLargeError as e:
    print(f"Ошибка: {e}")
    print("Пожалуйста, введите меньшее число")
except ValueError:
    print("Ошибка: введите целое число")
```

## Повторное возбуждение исключений

Иногда требуется перехватить исключение, выполнить определенные действия, а затем снова возбудить его или другое исключение.

### Повторное возбуждение того же исключения:

```python
try:
    file = open("example.txt", "r")
    # Обработка файла
except FileNotFoundError as e:
    print("Файл не найден, будет использован файл по умолчанию")
    try:
        file = open("default.txt", "r")
    except FileNotFoundError:
        print("Файл по умолчанию тоже не найден!")
        raise  # Повторно возбуждает последнее исключение
```

### Возбуждение другого исключения с сохранением стека:

```python
try:
    value = int(input("Введите число: "))
    result = 100 / value
except ValueError:
    # Преобразуем ValueError в более конкретное исключение
    raise CustomError("Введено не число") from ValueError
except ZeroDivisionError as e:
    # Сохраняем информацию о причине
    raise CustomError("Операция не может быть выполнена") from e
```

### Подавление предыдущего исключения:

```python
try:
    # Потенциально опасный код
    pass
except SomeError as e:
    raise AnotherError("Другая ошибка") from None  # Подавляет связывание с оригинальным исключением
```

## Проверка условий с помощью assert

Оператор `assert` используется для проверки условий во время разработки и отладки. Он вызывает исключение `AssertionError`, если условие не выполняется.

```python
def calculate_average(numbers):
    assert len(numbers) > 0, "Список чисел не может быть пустым"
    return sum(numbers) / len(numbers)

# Использование
try:
    avg = calculate_average([])
except AssertionError as e:
    print(f"Ошибка: {e}")
```

Важно: в рабочей версии программы утверждения могут быть отключены для оптимизации (с помощью ключа `-O` при запуске Python). Поэтому не используйте `assert` для проверок, важных для безопасности или правильной работы программы.

## Менеджеры контекста (with)

Менеджеры контекста (`with`) — удобный способ управления ресурсами, который автоматически обрабатывает исключения и освобождает ресурсы.

### Использование with для файлов:

```python
# Без менеджера контекста
try:
    file = open("example.txt", "r")
    content = file.read()
    # Обработка содержимого
finally:
    file.close()

# С менеджером контекста
with open("example.txt", "r") as file:
    content = file.read()
    # Обработка содержимого
# Файл автоматически закрывается, даже если возникло исключение
```

### Создание собственного менеджера контекста:

```python
class DatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
    
    def __enter__(self):
        print("Открытие соединения с базой данных")
        self.connection = self._connect()
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Закрытие соединения с базой данных")
        if self.connection:
            self.connection.close()
        # Если возвращаем True, то исключение будет подавлено
        # Если возвращаем False или None, то исключение будет пробрасываться дальше
        return False
    
    def _connect(self):
        # Здесь был бы реальный код подключения к базе данных
        class Connection:
            def execute(self, query):
                print(f"Выполнение запроса: {query}")
            def close(self):
                print("Соединение закрыто")
        return Connection()

# Использование
try:
    with DatabaseConnection("database://localhost:5432") as conn:
        conn.execute("SELECT * FROM users")
        # Если здесь возникнет исключение, __exit__ все равно будет вызван
        # для закрытия соединения с базой данных
except Exception as e:
    print(f"Произошла ошибка: {e}")
```

### Использование contextlib для создания менеджеров контекста:

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    try:
        file = open(filename, mode)
        yield file
    finally:
        file.close()

# Использование
with file_manager("example.txt", "r") as file:
    content = file.read()
    print(content)
```

## Лучшие практики обработки исключений

1. **Не используйте пустые блоки except** — всегда указывайте конкретный тип исключения.
   ```python
   # Плохо:
   try:
       # код
   except:
       pass  # игнорирует все ошибки
   
   # Хорошо:
   try:
       # код
   except ValueError as e:
       logging.error(f"Ошибка значения: {e}")
   ```

2. **Перехватывайте только те исключения, которые вы ожидаете** — это делает код более понятным и безопасным.
   ```python
   try:
       num = int(input("Введите число: "))
   except ValueError:
       print("Это не число")
   ```

3. **Используйте блок finally для освобождения ресурсов** — даже если произойдет исключение, ресурсы будут освобождены.
   ```python
   lock = threading.Lock()
   try:
       lock.acquire()
       # критическая секция
   finally:
       lock.release()  # освобождение замка в любом случае
   ```

4. **Предпочитайте менеджеры контекста (with)** — они автоматически обрабатывают исключения и освобождают ресурсы.
   ```python
   # Вместо:
   file = open("file.txt", "r")
   try:
       data = file.read()
   finally:
       file.close()
   
   # Используйте:
   with open("file.txt", "r") as file:
       data = file.read()
   ```

5. **Создавайте специфические исключения** — они делают код более понятным и позволяют точнее обрабатывать ошибки.
   ```python
   class ConfigError(Exception):
       pass
   
   class ConfigParseError(ConfigError):
       pass
   
   class ConfigMissingError(ConfigError):
       pass
   ```

6. **Логируйте исключения** — это помогает при отладке и мониторинге.
   ```python
   import logging
   
   try:
       # код
   except Exception as e:
       logging.error(f"Произошла ошибка: {e}", exc_info=True)
   ```

7. **Не используйте исключения для управления потоком выполнения** — это делает код менее понятным и снижает производительность.
   ```python
   # Плохо:
   try:
       result = values[key]
   except KeyError:
       result = default_value
   
   # Хорошо:
   result = values.get(key, default_value)
   ```

8. **Не перехватывайте исключения слишком широко** — это может скрыть неожиданные проблемы.
   ```python
   # Плохо:
   try:
       # много кода с разными возможными исключениями
   except Exception:
       # обработка всех исключений одинаково
   
   # Хорошо:
   try:
       # минимально необходимый код
   except SpecificException:
       # обработка конкретного исключения
   ```

9. **Документируйте возможные исключения** — это помогает пользователям вашего кода.
   ```python
   def process_file(filename):
       """
       Обрабатывает файл.
       
       Args:
           filename (str): Путь к файлу
           
       Raises:
           FileNotFoundError: Если файл не существует
           PermissionError: Если нет прав на чтение файла
       """
       # код
   ```

10. **Используйте цепочки исключений** — они сохраняют контекст ошибки.
    ```python
    try:
        # код
    except ValueError as e:
        raise CustomError("Что-то пошло не так") from e
    ```

## Практические задания

### Задание 1: Калькулятор с обработкой исключений

Создайте простой калькулятор, который будет выполнять базовые арифметические операции (+, -, *, /). Калькулятор должен корректно обрабатывать следующие исключительные ситуации:
- Деление на ноль
- Ввод некорректных чисел (буквы вместо цифр)
- Ввод некорректной операции
- Переполнение результата

Калькулятор должен повторять запрос ввода, если возникла ошибка, и завершать работу только по команде пользователя.

### Задание 2: Работа с файлами и обработка исключений

Напишите программу, которая:
1. Запрашивает у пользователя имя файла для чтения
2. Пытается открыть файл и прочитать его содержимое
3. Обрабатывает различные исключения, которые могут возникнуть при работе с файлом
4. В случае успеха, считает количество строк, слов и символов в файле
5. Записывает эту статистику в новый файл с префиксом "stats_" перед именем исходного файла

Обработайте следующие исключения:
- Файл не найден
- Ошибка доступа к файлу
- Файл слишком большой для загрузки в память
- Ошибки ввода-вывода

### Задание 3: Библиотека с пользовательскими исключениями

Реализуйте систему управления библиотекой с пользовательскими исключениями:

1. Создайте иерархию пользовательских исключений:
   - `LibraryException` — базовое исключение для библиотеки
   - `BookNotFoundException` — книга не найдена
   - `BookAlreadyExistsException` — книга уже существует
   - `BookUnavailableException` — книга недоступна для выдачи
   - `UserNotFoundException` — пользователь не найден
   - `LimitExceededException` — превышен лимит книг на руках

2. Реализуйте класс `Library` с методами:
   - `add_book(book)` — добавить книгу в библиотеку
   - `remove_book(book_id)` — удалить книгу из библиотеки
   - `lend_book(book_id, user_id)` — выдать книгу пользователю
   - `return_book(book_id)` — принять книгу от пользователя
   - `find_book(query)` — найти книгу по названию или автору

3. Реализуйте корректную обработку исключений в каждом методе.

4. Создайте простой интерфейс командной строки для взаимодействия с библиотекой.

### Задание 4: Безопасный менеджер ресурсов

Создайте класс `ResourceManager`, который будет имитировать работу с ресурсом (например, файлом, сетевым соединением или базой данных). Класс должен:

1. Реализовать менеджер контекста для безопасной работы с ресурсом
2. Корректно обрабатывать возможные исключения при открытии, использовании и закрытии ресурса
3. Иметь возможность повторных попыток подключения при неудаче
4. Логировать все операции и ошибки

Пример использования:

```python
with ResourceManager("resource_name") as resource:
    resource.perform_operation()
    resource.another_operation()
```

### Задание 5: Валидация данных с исключениями

Создайте систему валидации данных, которая:

1. Проверяет данные пользователя (имя, email, телефон и т.д.) с помощью пользовательских исключений
2. Имеет иерархию исключений для различных типов ошибок валидации
3. Реализует несколько методов валидации (длина строки, формат email, диапазон чисел и т.д.)
4. Предоставляет понятные сообщения об ошибках

Создайте простую форму регистрации, которая использует эту систему валидации и корректно обрабатывает все исключения.

## Решения практических заданий

### Решение задания 1: Калькулятор с обработкой исключений

```python
def calculator():
    """Простой калькулятор с обработкой исключений"""
    
    # Максимальное и минимальное значение для результатов
    MAX_VALUE = 1e100
    MIN_VALUE = -1e100
    
    class CalculatorError(Exception):
        """Базовое исключение для калькулятора"""
        pass
    
    class InvalidOperationError(CalculatorError):
        """Исключение для некорректной операции"""
        pass
    
    class OverflowError(CalculatorError):
        """Исключение для переполнения результата"""
        pass
    
    def perform_operation(a, b, operation):
        """Выполняет арифметическую операцию и возвращает результат"""
        if operation == '+':
            result = a + b
        elif operation == '-':
            result = a - b
        elif operation == '*':
            result = a * b
        elif operation == '/':
            if b == 0:
                raise ZeroDivisionError("Деление на ноль недопустимо")
            result = a / b
        else:
            raise InvalidOperationError(f"Неизвестная операция: {operation}")
        
        # Проверка на переполнение
        if result > MAX_VALUE or result < MIN_VALUE:
            raise OverflowError("Результат слишком большой или слишком маленький")
        
        return result
    
    print("Добро пожаловать в калькулятор!")
    print("Поддерживаемые операции: +, -, *, /")
    print("Введите 'q' для выхода")
    
    while True:
        try:
            # Ввод первого числа
            input1 = input("\nВведите первое число: ")
            if input1.lower() == 'q':
                print("Выход из калькулятора.")
                break
            
            num1 = float(input1)
            
            # Ввод операции
            operation = input("Введите операцию (+, -, *, /): ")
            if operation.lower() == 'q':
                print("Выход из калькулятора.")
                break
            
            # Ввод второго числа
            input2 = input("Введите второе число: ")
            if input2.lower() == 'q':
                print("Выход из калькулятора.")
                break
            
            num2 = float(input2)
            
            # Выполнение операции
            result = perform_operation(num1, num2, operation)
            
            # Вывод результата
            print(f"Результат: {num1} {operation} {num2} = {result}")
            
        except ValueError as e:
            print(f"Ошибка: Введено некорректное число. {e}")
        except ZeroDivisionError as e:
            print(f"Ошибка: {e}")
        except InvalidOperationError as e:
            print(f"Ошибка: {e}")
        except OverflowError as e:
            print(f"Ошибка: {e}")
        except Exception as e:
            print(f"Непредвиденная ошибка: {e}")

if __name__ == "__main__":
    calculator()
```

### Решение задания 2: Работа с файлами и обработка исключений

```python
import os
import sys

def analyze_file(filename):
    """
    Анализирует файл и возвращает статистику (строки, слова, символы).
    
    Args:
        filename (str): Имя файла для анализа
        
    Returns:
        tuple: (строки, слова, символы) или None при ошибке
        
    Raises:
        FileNotFoundError: Если файл не найден
        PermissionError: Если нет прав на чтение файла
        MemoryError: Если файл слишком большой для загрузки в память
        IOError: При ошибке ввода-вывода
    """
    try:
        # Проверка размера файла
        file_size = os.path.getsize(filename)
        if file_size > 100 * 1024 * 1024:  # 100 МБ - условное ограничение
            raise MemoryError(f"Файл слишком большой: {file_size / (1024 * 1024):.2f} МБ")
        
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
        
        # Подсчет статистики
        lines = content.count('\n') + (0 if content == "" else 1)
        words = len(content.split())
        chars = len(content)
        
        return (lines, words, chars)
    
    except FileNotFoundError:
        print(f"Ошибка: Файл '{filename}' не найден.")
        return None
    except PermissionError:
        print(f"Ошибка: Нет прав на чтение файла '{filename}'.")
        return None
    except MemoryError as e:
        print(f"Ошибка: {e}")
        return None
    except IOError as e:
        print(f"Ошибка ввода-вывода: {e}")
        return None
    except Exception as e:
        print(f"Непредвиденная ошибка: {e}")
        return None

def save_statistics(original_filename, stats):
    """
    Сохраняет статистику в новый файл.
    
    Args:
        original_filename (str): Имя исходного файла
        stats (tuple): Статистика (строки, слова, символы)
        
    Returns:
        bool: True при успешном сохранении, False при ошибке
    """
    try:
        # Формируем имя нового файла
        directory = os.path.dirname(original_filename)
        basename = os.path.basename(original_filename)
        stats_filename = os.path.join(directory, f"stats_{basename}")
        
        # Записываем статистику в новый файл
        with open(stats_filename, 'w', encoding='utf-8') as file:
            file.write(f"Статистика для файла '{original_filename}':\n")
            file.write(f"Количество строк: {stats[0]}\n")
            file.write(f"Количество слов: {stats[1]}\n")
            file.write(f"Количество символов: {stats[2]}\n")
        
        print(f"Статистика сохранена в файл '{stats_filename}'")
        return True
    
    except PermissionError:
        print(f"Ошибка: Нет прав на запись в файл '{stats_filename}'.")
        return False
    except IOError as e:
        print(f"Ошибка при записи статистики: {e}")
        return False
    except Exception as e:
        print(f"Непредвиденная ошибка при сохранении статистики: {e}")
        return False

def main():
    """Основная функция программы"""
    print("Анализатор файлов")
    print("Введите 'q' для выхода")
    
    while True:
        # Запрашиваем имя файла у пользователя
        filename = input("\nВведите имя файла для анализа: ")
        
        if filename.lower() == 'q':
            print("Выход из программы.")
            break
        
        # Анализируем файл
        stats = analyze_file(filename)
        
        # Если анализ успешен, сохраняем статистику
        if stats:
            print(f"Анализ файла '{filename}' завершен.")
            print(f"Строк: {stats[0]}")
            print(f"Слов: {stats[1]}")
            print(f"Символов: {stats[2]}")
            
            save_statistics(filename, stats)

if __name__ == "__main__":
    main()
```

### Решение задания 3: Библиотека с пользовательскими исключениями

```python
class LibraryException(Exception):
    """Базовое исключение для библиотеки"""
    pass

class BookNotFoundException(LibraryException):
    """Исключение, возникающее когда книга не найдена"""
    def __init__(self, book_id, message="Книга не найдена"):
        self.book_id = book_id
        self.message = f"{message} (ID: {book_id})"
        super().__init__(self.message)

class BookAlreadyExistsException(LibraryException):
    """Исключение, возникающее когда добавляемая книга уже существует"""
    def __init__(self, book_id, message="Книга уже существует"):
        self.book_id = book_id
        self.message = f"{message} (ID: {book_id})"
        super().__init__(self.message)

class BookUnavailableException(LibraryException):
    """Исключение, возникающее когда книга недоступна для выдачи"""
    def __init__(self, book_id, user_id=None, message="Книга недоступна"):
        self.book_id = book_id
        self.user_id = user_id
        user_info = f", выдана пользователю {user_id}" if user_id else ""
        self.message = f"{message} (ID: {book_id}{user_info})"
        super().__init__(self.message)

class UserNotFoundException(LibraryException):
    """Исключение, возникающее когда пользователь не найден"""
    def __init__(self, user_id, message="Пользователь не найден"):
        self.user_id = user_id
        self.message = f"{message} (ID: {user_id})"
        super().__init__(self.message)

class LimitExceededException(LibraryException):
    """Исключение, возникающее когда превышен лимит книг на руках"""
    def __init__(self, user_id, limit, message="Превышен лимит книг на руках"):
        self.user_id = user_id
        self.limit = limit
        self.message = f"{message} (ID: {user_id}, лимит: {limit})"
        super().__init__(self.message)


class Book:
    """Класс для представления книги"""
    def __init__(self, book_id, title, author, year):
        self.book_id = book_id
        self.title = title
        self.author = author
        self.year = year
        self.available = True
        self.user_id = None
    
    def __str__(self):
        status = "доступна" if self.available else f"выдана пользователю {self.user_id}"
        return f"[{self.book_id}] {self.title} ({self.author}, {self.year}) - {status}"


class User:
    """Класс для представления пользователя библиотеки"""
    def __init__(self, user_id, name, email, max_books=3):
        self.user_id = user_id
        self.name = name
        self.email = email
        self.max_books = max_books
        self.books = []  # Список ID книг на руках
    
    def __str__(self):
        return f"[{self.user_id}] {self.name} (email: {self.email}) - книг на руках: {len(self.books)}/{self.max_books}"


class Library:
    """Класс для управления библиотекой"""
    def __init__(self):
        self.books = {}  # Словарь книг по ID
        self.users = {}  # Словарь пользователей по ID
    
    def add_book(self, book):
        """Добавляет книгу в библиотеку"""
        if book.book_id in self.books:
            raise BookAlreadyExistsException(book.book_id)
        
        self.books[book.book_id] = book
        return f"Книга '{book.title}' успешно добавлена в библиотеку."
    
    def remove_book(self, book_id):
        """Удаляет книгу из библиотеки"""
        if book_id not in self.books:
            raise BookNotFoundException(book_id)
        
        book = self.books[book_id]
        if not book.available:
            raise BookUnavailableException(book_id, book.user_id, "Книга не может быть удалена, так как она выдана")
        
        del self.books[book_id]
        return f"Книга '{book.title}' успешно удалена из библиотеки."
    
    def add_user(self, user):
        """Добавляет пользователя в библиотеку"""
        if user.user_id in self.users:
            raise LibraryException(f"Пользователь с ID {user.user_id} уже существует.")
        
        self.users[user.user_id] = user
        return f"Пользователь '{user.name}' успешно добавлен."
    
    def lend_book(self, book_id, user_id):
        """Выдает книгу пользователю"""
        # Проверяем наличие книги
        if book_id not in self.books:
            raise BookNotFoundException(book_id)
        
        # Проверяем наличие пользователя
        if user_id not in self.users:
            raise UserNotFoundException(user_id)
        
        book = self.books[book_id]
        user = self.users[user_id]
        
        # Проверяем доступность книги
        if not book.available:
            raise BookUnavailableException(book_id, book.user_id)
        
        # Проверяем лимит книг у пользователя
        if len(user.books) >= user.max_books:
            raise LimitExceededException(user_id, user.max_books)
        
        # Выдаем книгу
        book.available = False
        book.user_id = user_id
        user.books.append(book_id)
        
        return f"Книга '{book.title}' выдана пользователю {user.name}."
    
    def return_book(self, book_id):
        """Принимает книгу от пользователя"""
        # Проверяем наличие книги
        if book_id not in self.books:
            raise BookNotFoundException(book_id)
        
        book = self.books[book_id]
        
        # Проверяем, выдана ли книга
        if book.available:
            raise LibraryException(f"Книга '{book.title}' не была выдана.")
        
        # Получаем пользователя
        user_id = book.user_id
        if user_id not in self.users:
            # Если пользователя больше нет, просто освобождаем книгу
            book.available = True
            book.user_id = None
            return f"Книга '{book.title}' возвращена в библиотеку."
        
        user = self.users[user_id]
        
        # Возвращаем книгу
        book.available = True
        book.user_id = None
        user.books.remove(book_id)
        
        return f"Книга '{book.title}' возвращена пользователем {user.name}."
    
    def find_book(self, query):
        """Ищет книгу по названию или автору"""
        query = query.lower()
        found_books = []
        
        for book in self.books.values():
            if query in book.title.lower() or query in book.author.lower():
                found_books.append(book)
        
        return found_books
    
    def get_user_books(self, user_id):
        """Возвращает список книг, взятых пользователем"""
        if user_id not in self.users:
            raise UserNotFoundException(user_id)
        
        user = self.users[user_id]
        user_books = []
        
        for book_id in user.books:
            if book_id in self.books:  # Защита от ошибок
                user_books.append(self.books[book_id])
        
        return user_books
    
    def list_all_books(self):
        """Возвращает список всех книг в библиотеке"""
        return list(self.books.values())
    
    def list_all_users(self):
        """Возвращает список всех пользователей библиотеки"""
        return list(self.users.values())


def run_library_cli():
    """Запускает интерфейс командной строки для библиотеки"""
    library = Library()
    
    # Добавляем несколько книг для примера
    try:
        library.add_book(Book(1, "Война и мир", "Лев Толстой", 1869))
        library.add_book(Book(2, "Преступление и наказание", "Федор Достоевский", 1866))
        library.add_book(Book(3, "Мастер и Маргарита", "Михаил Булгаков", 1967))
        library.add_book(Book(4, "1984", "Джордж Оруэлл", 1949))
        library.add_book(Book(5, "Гарри Поттер и философский камень", "Дж.К. Роулинг", 1997))
        
        # Добавляем пользователей
        library.add_user(User(1, "Иван Иванов", "ivan@example.com"))
        library.add_user(User(2, "Анна Петрова", "anna@example.com"))
        library.add_user(User(3, "Сергей Сидоров", "sergey@example.com"))
    except LibraryException as e:
        print(f"Ошибка при инициализации библиотеки: {e}")
    
    print("Добро пожаловать в систему управления библиотекой!")
    
    while True:
        print("\nДоступные команды:")
        print("1. Показать все книги")
        print("2. Показать всех пользователей")
        print("3. Добавить книгу")
        print("4. Добавить пользователя")
        print("5. Выдать книгу")
        print("6. Принять книгу")
        print("7. Найти книгу")
        print("8. Показать книги пользователя")
        print("9. Удалить книгу")
        print("0. Выход")
        
        choice = input("\nВыберите команду (0-9): ")
        
        try:
            if choice == "1":
                # Показать все книги
                books = library.list_all_books()
                if not books:
                    print("В библиотеке нет книг.")
                else:
                    print("\nСписок всех книг:")
                    for book in books:
                        print(book)
            
            elif choice == "2":
                # Показать всех пользователей
                users = library.list_all_users()
                if not users:
                    print("В библиотеке нет зарегистрированных пользователей.")
                else:
                    print("\nСписок всех пользователей:")
                    for user in users:
                        print(user)
            
            elif choice == "3":
                # Добавить книгу
                try:
                    book_id = int(input("Введите ID книги: "))
                    title = input("Введите название книги: ")
                    author = input("Введите автора книги: ")
                    year = int(input("Введите год издания: "))
                    
                    book = Book(book_id, title, author, year)
                    result = library.add_book(book)
                    print(result)
                except ValueError:
                    print("Ошибка: ID и год должны быть целыми числами.")
            
            elif choice == "4":
                # Добавить пользователя
                try:
                    user_id = int(input("Введите ID пользователя: "))
                    name = input("Введите имя пользователя: ")
                    email = input("Введите email пользователя: ")
                    max_books = int(input("Введите максимальное количество книг (по умолчанию 3): ") or "3")
                    
                    user = User(user_id, name, email, max_books)
                    result = library.add_user(user)
                    print(result)
                except ValueError:
                    print("Ошибка: ID и максимальное количество книг должны быть целыми числами.")
            
            elif choice == "5":
                # Выдать книгу
                try:
                    book_id = int(input("Введите ID книги: "))
                    user_id = int(input("Введите ID пользователя: "))
                    
                    result = library.lend_book(book_id, user_id)
                    print(result)
                except ValueError:
                    print("Ошибка: ID должны быть целыми числами.")
            
            elif choice == "6":
                # Принять книгу
                try:
                    book_id = int(input("Введите ID книги: "))
                    
                    result = library.return_book(book_id)
                    print(result)
                except ValueError:
                    print("Ошибка: ID должен быть целым числом.")
            
            elif choice == "7":
                # Найти книгу
                query = input("Введите запрос для поиска (название или автор): ")
                
                found_books = library.find_book(query)
                if not found_books:
                    print("По вашему запросу книги не найдены.")
                else:
                    print(f"\nНайдено книг: {len(found_books)}")
                    for book in found_books:
                        print(book)
            
            elif choice == "8":
                # Показать книги пользователя
                try:
                    user_id = int(input("Введите ID пользователя: "))
                    
                    user_books = library.get_user_books(user_id)
                    user = library.users[user_id]
                    
                    if not user_books:
                        print(f"У пользователя {user.name} нет книг на руках.")
                    else:
                        print(f"\nКниги пользователя {user.name}:")
                        for book in user_books:
                            print(book)
                except ValueError:
                    print("Ошибка: ID должен быть целым числом.")
            
            elif choice == "9":
                # Удалить книгу
                try:
                    book_id = int(input("Введите ID книги для удаления: "))
                    
                    result = library.remove_book(book_id)
                    print(result)
                except ValueError:
                    print("Ошибка: ID должен быть целым числом.")
            
            elif choice == "0":
                # Выход
                print("Выход из программы. До свидания!")
                break
            
            else:
                print("Неверная команда. Пожалуйста, выберите от 0 до 9.")
        
        except LibraryException as e:
            print(f"Ошибка: {e}")
        except Exception as e:
            print(f"Непредвиденная ошибка: {e}")


if __name__ == "__main__":
    run_library_cli()
```

### Решение задания 4: Безопасный менеджер ресурсов

```python
import time
import logging
import random

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("resource_manager.log"),
        logging.StreamHandler()
    ]
)

class ResourceError(Exception):
    """Базовый класс для исключений, связанных с ресурсами"""
    pass

class ResourceConnectionError(ResourceError):
    """Исключение при ошибке подключения к ресурсу"""
    pass

class ResourceTimeoutError(ResourceError):
    """Исключение при превышении времени ожидания"""
    pass

class ResourceUnavailableError(ResourceError):
    """Исключение, когда ресурс недоступен"""
    pass

class ResourceManager:
    """Класс для безопасного управления ресурсами"""
    
    def __init__(self, resource_name, max_retries=3, retry_delay=1):
        """
        Инициализирует менеджер ресурсов.
        
        Args:
            resource_name (str): Имя ресурса
            max_retries (int): Максимальное количество попыток подключения
            retry_delay (int): Задержка между попытками в секундах
        """
        self.resource_name = resource_name
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.resource = None
        self.connected = False
    
    def __enter__(self):
        """Метод для входа в контекстный блок"""
        self.connect()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Метод для выхода из контекстного блока"""
        self.disconnect()
        
        # Если произошло исключение, логируем его
        if exc_type is not None:
            logging.error(f"Произошла ошибка при работе с ресурсом: {exc_val}")
            # Возвращаем False, чтобы исключение было передано выше
            return False
        
        return True
    
    def simulate_connection(self):
        """
        Имитирует подключение к ресурсу.
        В реальном приложении здесь был бы код подключения к реальному ресурсу.
        
        Raises:
            ResourceConnectionError: Если не удалось подключиться
            ResourceTimeoutError: Если превышено время ожидания
            ResourceUnavailableError: Если ресурс недоступен
        """
        # Имитируем случайные проблемы с подключением
        error_chance = random.random()
        
        if error_chance < 0.2:
            raise ResourceConnectionError(f"Не удалось подключиться к ресурсу '{self.resource_name}'")
        elif error_chance < 0.3:
            raise ResourceTimeoutError(f"Превышено время ожидания подключения к ресурсу '{self.resource_name}'")
        elif error_chance < 0.4:
            raise ResourceUnavailableError(f"Ресурс '{self.resource_name}' недоступен")
        
        # Имитируем задержку подключения
        time.sleep(0.5)
        
        # Подключение успешно, создаем объект ресурса
        class Resource:
            """Простой класс для имитации ресурса"""
            def __init__(self, name):
                self.name = name
            
            def perform_operation(self):
                # Имитируем случайный сбой операции
                if random.random() < 0.1:
                    raise ResourceError("Ошибка при выполнении операции")
                logging.info(f"Операция на ресурсе '{self.name}' выполнена успешно")
                return f"Результат операции с ресурсом '{self.name}'"
            
            def another_operation(self, param=None):
                # Имитируем еще одну операцию
                if random.random() < 0.1:
                    raise ResourceError("Ошибка при выполнении другой операции")
                logging.info(f"Другая операция на ресурсе '{self.name}' выполнена успешно")
                return f"Результат другой операции с ресурсом '{self.name}'"
        
        return Resource(self.resource_name)
    
    def connect(self):
        """
        Подключается к ресурсу с возможностью повторных попыток.
        
        Raises:
            ResourceError: Если не удалось подключиться после всех попыток
        """
        if self.connected:
            return
        
        for attempt in range(1, self.max_retries + 1):
            try:
                logging.info(f"Попытка подключения к ресурсу '{self.resource_name}' ({attempt}/{self.max_retries})")
                self.resource = self.simulate_connection()
                self.connected = True
                logging.info(f"Успешное подключение к ресурсу '{self.resource_name}'")
                return
            except ResourceError as e:
                logging.warning(f"Попытка {attempt}/{self.max_retries} не удалась: {e}")
                if attempt < self.max_retries:
                    logging.info(f"Повторная попытка через {self.retry_delay} сек...")
                    time.sleep(self.retry_delay)
                else:
                    logging.error(f"Не удалось подключиться к ресурсу '{self.resource_name}' после {self.max_retries} попыток")
                    raise
    
    def disconnect(self):
        """Отключается от ресурса"""
        if self.connected:
            logging.info(f"Отключение от ресурса '{self.resource_name}'")
            # В реальном приложении здесь был бы код отключения от ресурса
            self.resource = None
            self.connected = False
    
    def perform_operation(self):
        """
        Выполняет операцию на ресурсе.
        
        Returns:
            str: Результат операции
            
        Raises:
            ResourceError: Если ресурс не подключен или произошла ошибка
        """
        if not self.connected or not self.resource:
            raise ResourceError("Ресурс не подключен")
        
        try:
            return self.resource.perform_operation()
        except ResourceError as e:
            logging.error(f"Ошибка при выполнении операции: {e}")
            raise
    
    def another_operation(self):
        """
        Выполняет другую операцию на ресурсе.
        
        Returns:
            str: Результат операции
            
        Raises:
            ResourceError: Если ресурс не подключен или произошла ошибка
        """
        if not self.connected or not self.resource:
            raise ResourceError("Ресурс не подключен")
        
        try:
            return self.resource.another_operation()
        except ResourceError as e:
            logging.error(f"Ошибка при выполнении другой операции: {e}")
            raise


def demonstrate_resource_manager():
    """Функция для демонстрации работы ResourceManager"""
    print("Демонстрация безопасного менеджера ресурсов")
    
    # Пример успешного использования
    try:
        print("\n1. Обычное использование:")
        with ResourceManager("database") as resource:
            result1 = resource.perform_operation()
            print(f"Результат первой операции: {result1}")
            
            result2 = resource.another_operation()
            print(f"Результат второй операции: {result2}")
    except ResourceError as e:
        print(f"Перехвачена ошибка ресурса: {e}")
    
    # Пример с ошибкой подключения
    try:
        print("\n2. Ситуация с ошибкой подключения:")
        with ResourceManager("unstable_service", max_retries=2, retry_delay=0.5) as resource:
            result = resource.perform_operation()
            print(f"Результат операции: {result}")
    except ResourceError as e:
        print(f"Перехвачена ошибка ресурса: {e}")
    
    # Пример с ошибкой во время операции
    try:
        print("\n3. Ситуация с ошибкой во время операции:")
        with ResourceManager("risky_service") as resource:
            # Выполняем несколько операций, чтобы увеличить шанс ошибки
            for i in range(5):
                try:
                    result = resource.perform_operation()
                    print(f"Результат операции {i+1}: {result}")
                except ResourceError as e:
                    print(f"Ошибка при операции {i+1}: {e}")
    except ResourceError as e:
        print(f"Перехвачена ошибка ресурса: {e}")
    
    print("\nДемонстрация завершена. Проверьте лог-файл для подробной информации.")


if __name__ == "__main__":
    demonstrate_resource_manager()
```

### Решение задания 5: Валидация данных с исключениями

```python
import re
import datetime

class ValidationError(Exception):
    """Базовый класс для исключений валидации"""
    pass

class RequiredFieldError(ValidationError):
    """Исключение для отсутствующих обязательных полей"""
    pass

class TypeValidationError(ValidationError):
    """Исключение для ошибок типа данных"""
    pass

class FormatValidationError(ValidationError):
    """Исключение для ошибок формата"""
    pass

class LengthValidationError(ValidationError):
    """Исключение для ошибок длины"""
    pass

class RangeValidationError(ValidationError):
    """Исключение для ошибок диапазона"""
    pass

class ComplexValidationError(ValidationError):
    """Исключение для сложных ошибок валидации (требующих нескольких проверок)"""
    