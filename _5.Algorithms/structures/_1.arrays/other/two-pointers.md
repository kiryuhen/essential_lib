# Два указателя (Two Pointers)

## Определение и концепция

**Два указателя** — это алгоритмический паттерн, который использует два указателя (индекса) для прохождения по массиву или другой линейной структуре данных. Эти указатели могут двигаться с разной скоростью, в одном или противоположных направлениях.

Основная идея заключается в эффективном решении задач, которые в наивной реализации требовали бы вложенных циклов (и, следовательно, квадратичной сложности), за счет сокращения количества итераций до линейной сложности O(n).

## Типы паттерна "два указателя"

### 1. Противоположно направленные указатели

В этом варианте один указатель начинает движение с начала массива, а другой — с конца. Указатели движутся навстречу друг другу до тех пор, пока не встретятся или не будет найдено решение.

### 2. Однонаправленные указатели с разной скоростью

Оба указателя начинают с одного конца (обычно с начала) и двигаются в одном направлении, но с разной скоростью или в соответствии с различными условиями.

### 3. Однонаправленные указатели с общим направлением

Оба указателя двигаются в одном направлении, но один может опережать другой, создавая "окно" между ними. Это подтип часто пересекается с паттерном скользящего окна.

## Примеры задач и их решения

### Пример 1: Поиск пары с заданной суммой в отсортированном массиве

**Задача:** Дан отсортированный массив целых чисел и целевое значение target, найти индексы двух чисел, сумма которых равна target.

**Решение с использованием противоположно направленных указателей:**

```python
def two_sum(arr, target):
    # Инициализируем указатели: left в начале массива, right в конце
    left = 0
    right = len(arr) - 1
    
    while left < right:
        # Вычисляем текущую сумму
        current_sum = arr[left] + arr[right]
        
        # Если сумма равна целевому значению, возвращаем индексы
        if current_sum == target:
            return [left, right]
        # Если сумма меньше target, увеличиваем левый указатель
        elif current_sum < target:
            left += 1
        # Если сумма больше target, уменьшаем правый указатель
        else:
            right -= 1
    
    # Если пара не найдена
    return [-1, -1]
```

Временная сложность: O(n), где n — размер массива.
Пространственная сложность: O(1), используется постоянное количество дополнительной памяти.

### Пример 2: Удаление дубликатов из отсортированного массива

**Задача:** Дан отсортированный массив, удалить дубликаты "на месте" и вернуть новую длину массива.

**Решение с использованием однонаправленных указателей:**

```python
def remove_duplicates(nums):
    # Обработка краевого случая пустого массива
    if not nums:
        return 0
    
    # Указатель для записи уникальных элементов
    write_pointer = 1
    
    # Проходим по массиву с 1-го элемента
    for read_pointer in range(1, len(nums)):
        # Если текущий элемент отличается от предыдущего
        if nums[read_pointer] != nums[read_pointer - 1]:
            # Записываем этот уникальный элемент
            nums[write_pointer] = nums[read_pointer]
            # Перемещаем указатель записи
            write_pointer += 1
    
    # Возвращаем новую длину массива (без дубликатов)
    return write_pointer
```

Временная сложность: O(n).
Пространственная сложность: O(1).

### Пример 3: Проверка палиндрома

**Задача:** Дана строка, определить, является ли она палиндромом (читается одинаково слева направо и справа налево).

**Решение с использованием противоположно направленных указателей:**

```python
def is_palindrome(s):
    # Приводим к нижнему регистру и удаляем все символы, кроме букв и цифр
    s = ''.join(c.lower() for c in s if c.isalnum())
    
    # Инициализируем указатели
    left = 0
    right = len(s) - 1
    
    # Проверяем символы с обоих концов
    while left < right:
        # Если символы не совпадают, строка не является палиндромом
        if s[left] != s[right]:
            return False
        # Перемещаем указатели к центру
        left += 1
        right -= 1
    
    # Если мы прошли всю проверку, строка является палиндромом
    return True
```

Временная сложность: O(n).
Пространственная сложность: O(n) из-за создания новой отфильтрованной строки.

### Пример 4: Сортировка массива из трех значений (Задача "Сортировка цветов")

**Задача:** Дан массив, содержащий только 0, 1 и 2, отсортировать его на месте так, чтобы все 0 были в начале, затем все 1, и все 2 в конце.

**Решение с использованием трех указателей (вариант двух указателей):**

```python
def sort_colors(nums):
    # Инициализируем три указателя:
    # low - для хранения 0, mid - для хранения 1, high - для хранения 2
    low = 0
    mid = 0
    high = len(nums) - 1
    
    while mid <= high:
        if nums[mid] == 0:
            # Если текущий элемент 0, меняем его с элементом на позиции low
            nums[low], nums[mid] = nums[mid], nums[low]
            # Перемещаем оба указателя вперед
            low += 1
            mid += 1
        elif nums[mid] == 1:
            # Если текущий элемент 1, он уже на правильном месте
            # Просто перемещаем mid вперед
            mid += 1
        else:  # nums[mid] == 2
            # Если текущий элемент 2, меняем его с элементом на позиции high
            nums[mid], nums[high] = nums[high], nums[mid]
            # Перемещаем только high назад
            # mid не увеличиваем, так как нужно проверить новый элемент на этой позиции
            high -= 1
```

Временная сложность: O(n).
Пространственная сложность: O(1).

## Когда использовать паттерн двух указателей

Паттерн двух указателей особенно полезен в следующих ситуациях:

1. **Поиск пар**: Когда нужно найти пары элементов, удовлетворяющих определенным условиям (например, с заданной суммой).

2. **Работа с отсортированными массивами**: Многие задачи с отсортированными массивами можно эффективно решить с помощью двух указателей.

3. **Задачи на палиндромы и обратный порядок**: Проверка палиндромов, обращение строк и т.д.

4. **Удаление элементов**: Удаление дубликатов или элементов, удовлетворяющих определенным условиям.

5. **Слияние отсортированных структур**: Объединение двух отсортированных массивов.

6. **Поиск подмассивов с определенными свойствами**: Часто используется вместе с паттерном скользящего окна.

## Советы по применению на собеседованиях

1. **Распознавание паттерна**: Если задача связана с поиском пар, работой с отсортированными массивами или требует оптимизации с O(n²) до O(n), подумайте о применении паттерна двух указателей.

2. **Обработка краевых случаев**: Всегда проверяйте пустые массивы, массивы из одного элемента, и другие краевые случаи.

3. **Проверка условий окончания**: Убедитесь, что ваши условия окончания цикла корректны, особенно когда указатели должны встретиться или пересечься.

4. **Отсортированность**: Многие решения с двумя указателями работают только с отсортированными данными. Если массив не отсортирован, возможно, его сначала нужно отсортировать.

5. **Оптимизация пространства**: Одно из главных преимуществ этого паттерна — возможность решить задачу с O(1) дополнительной памяти.

## Заключение

Паттерн двух указателей — это элегантный и эффективный способ решения многих задач, особенно тех, которые иначе потребовали бы квадратичного времени. Он особенно полезен при работе с отсортированными массивами и при поиске пар или подмассивов с определенными свойствами.

Овладение этим паттерном позволит вам эффективно решать широкий спектр задач не только на собеседованиях, но и в реальной разработке программного обеспечения.