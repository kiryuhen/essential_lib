# Шаблон Reactor (Реактор)

## Описание
Reactor — это паттерн событийно-ориентированной обработки, где один или несколько циклов демультиплексируют события I/O и передают их зарегистрированным обработчикам.

## Проблема
При обработке множества одновременных запросов I/O (сокеты, файлы) создание отдельного потока на каждое соединение неэффективно: затраты на контекстные переключения и память возрастают.

## Решение
Reactor использует цикл событий (event loop): он ждёт уведомления от демультиплексора (`select`, `epoll`, `kqueue`), затем вызывает соответствующий обработчик для каждого готового ресурса.

## Структура
1. **Демультиплексор (Demultiplexer)** — абстракция «select/epoll», уведомляющая о событиях на дескрипторах.
2. **Регистратор (Registration API)** — интерфейс для регистрации и удаления обработчиков.
3. **Диспетчер (Dispatcher)** — сопоставляет события с обработчиками.
4. **Обработчики событий (Event Handlers)** — функции или объекты, выполняющие конкретную логику.

## Пример на Python
```python
import selectors, socket

sel = selectors.DefaultSelector()

def accept(sock):
    conn, _ = sock.accept()
    conn.setblocking(False)
    sel.register(conn, selectors.EVENT_READ, read)

def read(conn):
    data = conn.recv(1024)
    if data:
        conn.sendall(data)
    else:
        sel.unregister(conn)
        conn.close()

server = socket.socket()
server.bind(('localhost', 9000))
server.listen()
server.setblocking(False)
sel.register(server, selectors.EVENT_READ, accept)

while True:
    for key, _ in sel.select():
        handler = key.data
        handler(key.fileobj)
```

## Применение
- Высоконагруженные сетевые серверы (Nginx, Netty)
- Асинхронные фреймворки (asyncio, Twisted)
- Обработка аппаратного и файлового I/O
- GUI и event-driven приложения

## Плюсы
1. Высокая масштабируемость при I/O-bound нагрузке
2. Низкое потребление потоков
3. Централизация логики обработки событий
4. Гибкость в регистрации новых источников

## Минусы
1. Колбэки усложняют читаемость и отладку
2. Один цикл может стать узким местом
3. Неэффективен для CPU-bound задач без дополнительных потоков

## Когда использовать
- Когда требуется обслуживать множество соединений в одном потоке
- В сетевых и event-driven системах
- При необходимости минимизировать количество потоков

