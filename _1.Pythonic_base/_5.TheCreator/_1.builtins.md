# Python: Встроенные функции (без импорта)

В этом документе подробно рассмотрены все встроенные функции Python, доступные без импорта дополнительных модулей. Документация ориентирована на Python 3.8+.

## Содержание

- [Функции преобразования типов](#функции-преобразования-типов)
- [Числовые функции](#числовые-функции)
- [Функции-итераторы](#функции-итераторы)
- [Функции для последовательностей](#функции-для-последовательностей)
- [Функции для работы с объектами](#функции-для-работы-с-объектами)
- [Функции ввода-вывода](#функции-ввода-вывода)
- [Функции для работы с переменными и областями видимости](#функции-для-работы-с-переменными-и-областями-видимости)
- [Рефлексия и метапрограммирование](#рефлексия-и-метапрограммирование)

## Функции преобразования типов

### `int(x=0, base=10)`

**Описание:** Преобразует значение в целое число.

**Внутреннее устройство:** 
- Для строк вызывает метод `__int__()` объекта.
- Использует указанную систему счисления (base) для преобразования строк.
- При преобразовании чисел с плавающей точкой отбрасывает дробную часть.

**Примеры:**
```python
# Базовое преобразование
int("42")  # 42

# Преобразование из других систем счисления
int("1010", 2)  # 10 (двоичная в десятичную)
int("ff", 16)  # 255 (шестнадцатеричная в десятичную)

# Преобразование float в int (отбрасывание дробной части)
int(3.9)  # 3 (не округляет, а отбрасывает)
```

**Особенности для senior-разработчиков:**
- Не использует округление для float, а именно отбрасывает дробную часть, что эквивалентно `math.floor()` для положительных и `math.ceil()` для отрицательных чисел.
- При работе с большими числами не имеет ограничений по размеру (в отличие от многих других языков программирования).
- Кастомные типы могут определять своё поведение через `__int__()`.

### `float(x=0.0)`

**Описание:** Преобразует значение в число с плавающей точкой.

**Внутреннее устройство:**
- Вызывает метод `__float__()` объекта.
- Реализован на основе стандарта IEEE 754 (обычно двойная точность).
- Поддерживает специальные значения: `inf`, `-inf`, `nan`.

**Примеры:**
```python
# Базовое преобразование
float("3.14")  # 3.14

# Научная нотация
float("1.23e-4")  # 0.000123

# Специальные значения
float("inf")  # бесконечность
float("nan")  # не-число (NaN)
```

**Особенности для senior-разработчиков:**
- Имеет ограниченную точность (обычно 15-17 значащих цифр).
- Подвержен проблемам округления при работе с десятичными дробями (например, `0.1 + 0.2 != 0.3`).
- Для финансовых расчётов вместо `float` лучше использовать `decimal.Decimal`.

### `str(object='')`

**Описание:** Преобразует объект в строковое представление.

**Внутреннее устройство:**
- Вызывает метод `__str__()` объекта.
- Если `__str__()` не определён, использует `__repr__()`.
- Строки в Python 3 хранятся в Unicode.

**Примеры:**
```python
# Преобразование чисел в строки
str(42)  # "42"
str(3.14)  # "3.14"

# Преобразование списка
str([1, 2, 3])  # "[1, 2, 3]"

# Кастомный класс с переопределением __str__
class Person:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"Person: {self.name}"
        
str(Person("John"))  # "Person: John"
```

**Особенности для senior-разработчиков:**
- Разница между `str()` и `repr()`: `str()` предназначен для "читаемого" представления, а `repr()` - для "технического".
- При конкатенации большого количества строк предпочитайте `str.join()` или `io.StringIO` вместо оператора `+`.
- Строки в Python неизменяемы (immutable), что влияет на производительность при множественных операциях.

### `bool(x=False)`

**Описание:** Преобразует значение в булево (`True` или `False`).

**Внутреннее устройство:**
- Вызывает метод `__bool__()` объекта.
- Если `__bool__()` не определён, вызывает `__len__()` и возвращает `False`, если длина равна 0.
- Если ни один из методов не определён, всегда возвращает `True`.
- Технически `bool` является подклассом `int`, где `True` имеет значение 1, а `False` - 0.

**Примеры:**
```python
# Числа
bool(0)  # False (только 0 - False)
bool(42)  # True (любое ненулевое число - True)

# Последовательности
bool([])  # False (пустые последовательности - False)
bool([1, 2])  # True

# Объекты
bool(None)  # False
```

**Особенности для senior-разработчиков:**
- Избегайте явного сравнения с `True`/`False` (`if x is True`). Используйте непосредственно значение (`if x`).
- В условиях операторов `and`/`or` возвращается именно операнд, а не его булево значение: `0 or "hello"` вернёт `"hello"`.
- Переопределение `__bool__()` в кастомных классах может существенно повлиять на логику условий.

### `list([iterable])`

**Описание:** Создаёт список из итерируемого объекта (или пустой список).

**Внутреннее устройство:**
- Списки реализованы как динамические массивы.
- При расширении списка выделяется больше памяти, чем требуется на данный момент (амортизированная сложность добавления O(1)).
- Внутренне хранит массив указателей на объекты.

**Примеры:**
```python
# Создание списка из разных итерируемых
list("abc")  # ['a', 'b', 'c']
list(range(3))  # [0, 1, 2]

# Копирование существующего списка
original = [1, 2, 3]
copy = list(original)  # [1, 2, 3] (новый список)
```

**Особенности для senior-разработчиков:**
- Создание списка с `list()` создаёт **поверхностную** копию, вложенные изменяемые объекты останутся общими.
- Для обработки больших наборов данных рассмотрите `array.array` (одного типа) или `numpy.ndarray` для лучшей производительности.
- Сложность операций: доступ по индексу O(1), добавление в конец (амортизированная) O(1), вставка/удаление O(n).

### `tuple([iterable])`

**Описание:** Создаёт кортеж из итерируемого объекта (или пустой кортеж).

**Внутреннее устройство:**
- Кортежи неизменяемы (immutable).
- Имеют меньший размер в памяти по сравнению со списками аналогичного содержания.
- Как и списки, хранят указатели на объекты.

**Примеры:**
```python
# Создание кортежа из разных итерируемых
tuple("abc")  # ('a', 'b', 'c')
tuple([1, 2, 3])  # (1, 2, 3)

# Пустой кортеж и кортеж с одним элементом
empty = tuple()  # ()
single = (1,)  # Обратите внимание на запятую
```

**Особенности для senior-разработчиков:**
- Кортежи как ключи словарей: используйте только если все элементы хэшируемы.
- Более эффективны для фиксированных коллекций, используйте вместо списков, когда не требуется изменение.
- Распаковка кортежей работает быстрее, чем обращение по индексу: `x, y = get_point()` вместо `point = get_point(); x = point[0]; y = point[1]`.

### `set([iterable])`

**Описание:** Создаёт множество из итерируемого объекта (или пустое множество).

**Внутреннее устройство:**
- Реализовано как хэш-таблица.
- Элементы должны быть хэшируемыми.
- Неупорядоченная коллекция уникальных элементов.

**Примеры:**
```python
# Создание множества
set([1, 2, 2, 3, 3, 3])  # {1, 2, 3} (дубликаты удаляются)

# Операции с множествами
a = set([1, 2, 3])
b = set([3, 4, 5])
a.intersection(b)  # {3}
a | b  # {1, 2, 3, 4, 5} (объединение)

# Проверка включения
3 in set([1, 2, 3])  # True (быстрая операция O(1))
```

**Особенности для senior-разработчиков:**
- Сложность операций: включение, добавление, удаление - в среднем O(1).
- Используйте для удаления дубликатов с сохранением порядка: `list(dict.fromkeys(items))`.
- Для тяжелых операций с множествами используйте генераторы для создания множеств: `{x for x in range(1000000) if isPrime(x)}`.

### `dict(mapping=None, **kwargs)`

**Описание:** Создаёт словарь из маппинга или итерируемых пар ключ-значение.

**Внутреннее устройство:**
- Реализован как хэш-таблица с открытой адресацией.
- Начиная с Python 3.6 (гарантировано с 3.7), словари сохраняют порядок вставки.
- Ключи должны быть хэшируемыми (неизменяемыми).

**Примеры:**
```python
# Создание словаря разными способами
dict(a=1, b=2)  # {'a': 1, 'b': 2}
dict([('a', 1), ('b', 2)])  # {'a': 1, 'b': 2}
dict(zip(['a', 'b'], [1, 2]))  # {'a': 1, 'b': 2}

# Словарное включение
{x: x**2 for x in range(3)}  # {0: 0, 1: 1, 2: 4}
```

**Особенности для senior-разработчиков:**
- Сложность операций: получение/установка/удаление - в среднем O(1).
- Для хранения большого количества словарей с идентичными ключами рассмотрите `__slots__` или `namedtuple`.
- Используйте `collections.defaultdict` чтобы избежать проверок существования ключей.
- С Python 3.9 можно использовать оператор `|` для объединения словарей: `dict1 | dict2`.

## Числовые функции

### `abs(x)`

**Описание:** Возвращает абсолютное значение числа.

**Внутреннее устройство:**
- Вызывает метод `__abs__()` объекта.
- Для комплексных чисел возвращает модуль (sqrt(a²+b²)).

**Примеры:**
```python
abs(-5)  # 5
abs(3.14)  # 3.14
abs(complex(3, 4))  # 5.0 (модуль комплексного числа)
```

**Особенности для senior-разработчиков:**
- Для массовых вычислений используйте `numpy.abs()` вместо применения `abs()` в цикле.
- Математически безопаснее использовать `abs(a - b) < epsilon` для сравнения float-чисел вместо прямого `a == b`.

### `pow(base, exp[, mod])`

**Описание:** Возводит base в степень exp, опционально по модулю mod.

**Внутреннее устройство:**
- Вызывает метод `__pow__()` объекта.
- При указании модуля использует эффективный алгоритм возведения в степень по модулю.
- Версия с модулем работает только с целыми числами.

**Примеры:**
```python
pow(2, 3)  # 8
pow(2, -1)  # 0.5 (1/2)

# Модульная арифметика (гораздо эффективнее, чем (a ** b) % mod)
pow(2, 1000, 10)  # 6 (остаток от деления 2^1000 на 10)
```

**Особенности для senior-разработчиков:**
- `pow(a, b, m)` вычисляется эффективнее, чем `(a ** b) % m`, особенно для больших значений.
- Используется в криптографии для быстрого возведения в степень по модулю.
- Для матричных операций используйте `numpy.power()`.

### `round(number[, ndigits])`

**Описание:** Округляет число до указанного количества десятичных знаков.

**Внутреннее устройство:**
- Использует "банковское округление" (округление до ближайшего чётного при равной удалённости).
- Если ndigits опущен, округляет до целого числа.
- Если ndigits отрицательный, округляет до соответствующего разряда до запятой.

**Примеры:**
```python
round(3.14159, 2)  # 3.14
round(1.5)  # 2
round(2.5)  # 2 (банковское округление!)
round(123, -1)  # 120 (округление до десятков)
```

**Особенности для senior-разработчиков:**
- Банковское округление может быть неинтуитивным: `round(2.5) == 2`, а не 3!
- Из-за ограничений представления float, `round(2.675, 2)` может дать 2.67 вместо ожидаемого 2.68.
- Для строгого десятичного округления используйте `decimal.Decimal`.

### `min(*args, key=None, default=NotImplemented)`

**Описание:** Возвращает наименьший элемент из args или итерируемого объекта.

**Внутреннее устройство:**
- Использует оператор < для сравнения.
- Если указан key, сравнивает результаты применения key к каждому элементу.
- Параметр default (добавлен в Python 3.4) используется, когда последовательность пуста.

**Примеры:**
```python
min(5, 3, 8, 1)  # 1
min([5, 3, 8, 1])  # 1

# Использование ключевой функции
min(["apple", "banana", "cherry"], key=len)  # "apple" (самое короткое)

# Использование default
min([], default=0)  # 0 (вместо исключения ValueError)
```

**Особенности для senior-разработчиков:**
- Не использует стабильную сортировку, первый встреченный минимальный элемент будет возвращен.
- Для сложных объектов производительнее использовать key-функцию вместо переопределения `__lt__`.
- Для нахождения минимума в больших наборах данных эффективнее использовать `min` с генератором, чем сначала создавать полный список.

### `max(*args, key=None, default=NotImplemented)`

**Описание:** Возвращает наибольший элемент из args или итерируемого объекта.

**Внутреннее устройство:**
- Действует аналогично `min()`, но использует оператор > для сравнения.
- Если указан key, сравнивает результаты применения key к каждому элементу.

**Примеры:**
```python
max(5, 3, 8, 1)  # 8
max([5, 3, 8, 1])  # 8

# Использование ключевой функции
max(["apple", "banana", "cherry"], key=len)  # "banana" (самое длинное из равных)

# Поиск самого распространенного элемента
data = [1, 2, 2, 3, 3, 3, 4]
max(set(data), key=data.count)  # 3
```

**Особенности для senior-разработчиков:**
- Для сложных задач поиска максимума рассмотрите использование `heapq.nlargest()`.
- При необходимости сохранить порядок равнозначных максимумов используйте сортировку.
- При работе с большими объемами данных используйте генераторную версию для экономии памяти.

### `sum(iterable, start=0)`

**Описание:** Суммирует элементы итерируемого объекта, начиная с start.

**Внутреннее устройство:**
- Последовательно применяет оператор + к элементам.
- Для оптимизации использует специализированные алгоритмы для стандартных числовых типов.

**Примеры:**
```python
sum([1, 2, 3, 4])  # 10
sum([1, 2, 3], 10)  # 16 (10 + 1 + 2 + 3)

# Работа с генераторами
sum(x*x for x in range(5))  # 30 (0² + 1² + 2² + 3² + 4²)
```

**Особенности для senior-разработчиков:**
- **Не используйте** для конкатенации строк! `sum(['a', 'b', 'c'], '')` менее эффективно, чем `''.join(['a', 'b', 'c'])`.
- Для улучшения точности при суммировании float используйте `math.fsum()`.
- При необходимости более сложной агрегации (например, одновременного расчёта суммы и суммы квадратов) рассмотрите `statistics.NormalDist` или написание кастомного агрегатора.

## Функции-итераторы

### `iter(object[, sentinel])`

**Описание:** Возвращает итератор для объекта. Если указан sentinel, создаёт итератор, вызывающий object до получения sentinel.

**Внутреннее устройство:**
- Вызывает метод `__iter__()` объекта, или использует `__getitem__()` для последовательностей.
- Формат с sentinel преобразует вызываемый объект в итератор, останавливающийся при получении значения, равного sentinel.

**Примеры:**
```python
# Базовое использование
it = iter([1, 2, 3])
next(it)  # 1
next(it)  # 2

# Использование с sentinel
from random import randint
random_until_5 = iter(lambda: randint(1, 10), 5)
for num in random_until_5:
    print(num)  # Выводит случайные числа, пока не выпадет 5
```

**Особенности для senior-разработчиков:**
- Форма с sentinel полезна для разбора файлов строка-за-строкой: `iter(f.readline, '')`.
- Итераторы одноразовые - повторное использование требует повторного вызова `iter()`.
- Использование `iter` с функциями без аргументов (`iter(func, sentinel)`) может быть полезно для бесконечных итераторов с условием остановки.

### `next(iterator[, default])`

**Описание:** Возвращает следующий элемент из итератора. Если элементы закончились и указан default, возвращает его; иначе вызывает StopIteration.

**Внутреннее устройство:**
- Вызывает метод `__next__()` итератора.
- Обрабатывает исключение StopIteration и возвращает default, если он указан.

**Примеры:**
```python
it = iter([1, 2])
next(it)  # 1
next(it)  # 2
next(it, 'end')  # 'end' (вместо StopIteration)
```

**Особенности для senior-разработчиков:**
- Используйте параметр default для обработки конца итератора без try/except.
- Комбинирование `iter` и `next` полезно для получения первого элемента из итерируемого объекта: `next(iter(sequence), default)`.
- Для пропуска n элементов эффективнее использовать `itertools.islice` вместо вызова `next` в цикле.

### `range([start], stop[, step])`

**Описание:** Создаёт последовательность целых чисел от start до stop с шагом step.

**Внутреннее устройство:**
- В Python 3 возвращает итерируемый объект, а не список (в отличие от Python 2).
- Вычисляет значения "на лету", что экономит память.
- Хранит только start, stop, step и текущее значение.

**Примеры:**
```python
list(range(5))  # [0, 1, 2, 3, 4]
list(range(1, 6))  # [1, 2, 3, 4, 5]
list(range(0, 10, 2))  # [0, 2, 4, 6, 8]
list(range(5, 0, -1))  # [5, 4, 3, 2, 1]
```

**Особенности для senior-разработчиков:**
- Объект range поддерживает индексацию и содержит `__contains__` для эффективной проверки вхождения: `5 in range(10)` - O(1).
- При работе с большими диапазонами `range` гораздо эффективнее, чем явное создание списка.
- Для генерации не-целых чисел или более сложных последовательностей используйте `numpy.arange/linspace` или генераторные выражения.

### `enumerate(iterable, start=0)`

**Описание:** Создаёт итератор, возвращающий пары (индекс, элемент) для элементов итерируемого объекта.

**Внутреннее устройство:**
- Хранит счётчик и итератор объекта.
- Эффективно использует память, не создавая полную последовательность пар.

**Примеры:**
```python
# Получение индексов в цикле
for i, value in enumerate(['a', 'b', 'c']):
    print(f"{i}: {value}")  # "0: a", "1: b", "2: c"

# Смещение нумерации
list(enumerate(['a', 'b', 'c'], 1))  # [(1, 'a'), (2, 'b'), (3, 'c')]
```

**Особенности для senior-разработчиков:**
- Полезно для генерации индексированных структур данных: `dict(enumerate(items))`.
- Позволяет избежать изменяемого счётчика вне цикла и связанных с этим ошибок.
- Для обратной нумерации комбинируйте с `reversed`: `enumerate(reversed(items))`.

### `zip(*iterables)`

**Описание:** Создаёт итератор, возвращающий кортежи из соответствующих элементов переданных итерируемых объектов.

**Внутреннее устройство:**
- Останавливается, когда самый короткий итерируемый объект исчерпан.
- Использует память пропорционально количеству итерируемых объектов, а не их длине.

**Примеры:**
```python
list(zip([1, 2, 3], ['a', 'b', 'c']))  # [(1, 'a'), (2, 'b'), (3, 'c')]

# Ранняя остановка при итерируемых разной длины
list(zip([1, 2], ['a', 'b', 'c']))  # [(1, 'a'), (2, 'b')]

# Распаковка транспонированной матрицы
matrix = [(1, 2, 3), (4, 5, 6)]
list(zip(*matrix))  # [(1, 4), (2, 5), (3, 6)]
```

**Особенности для senior-разработчиков:**
- Для сохранения всех элементов используйте `itertools.zip_longest()`.
- В Python 3.10 добавлен `zip(..., strict=True)`, вызывающий ошибку при итерируемых разной длины.
- Эффективно для "вертикального" объединения данных из разных источников для последующей обработки.

### `map(function, *iterables)`

**Описание:** Применяет функцию к каждому элементу итерируемого объекта и возвращает итератор результатов.

**Внутреннее устройство:**
- Работает "лениво", не вычисляя всех результатов сразу.
- При передаче нескольких итерируемых объектов, функция получает соответствующие элементы в качестве аргументов (как zip).

**Примеры:**
```python
# Применение функции к каждому элементу
list(map(lambda x: x * 2, [1, 2, 3]))  # [2, 4, 6]

# Многоаргументная функция и несколько итерируемых
list(map(lambda x, y: x + y, [1, 2, 3], [10, 20, 30]))  # [11, 22, 33]

# Преобразование типов
list(map(int, ['1', '2', '3']))  # [1, 2, 3]
```

**Особенности для senior-разработчиков:**
- Часто `.map()` можно заменить генераторным выражением: `(func(x) for x in items)`.
- Для сохранения исходных элементов вместе с результатами используйте `zip`: `zip(items, map(func, items))`.
- При работе с большими объёмами данных `map` эффективнее списковых включений из-за меньших накладных расходов интерпретатора.

### `filter(function, iterable)`

**Описание:** Создаёт итератор, содержащий элементы, для которых функция возвращает True.

**Внутреннее устройство:**
- Работает "лениво", проверяя условия по мере запроса.
- Если function равно None, фильтрует на "истинность".

**Примеры:**
```python
# Фильтрация по предикату
list(filter(lambda x: x > 5, [1, 6, 3, 8, 2]))  # [6, 8]

# Фильтрация пустых строк
list(filter(None, ['a', '', 'b', None, 'c', 0]))  # ['a', 'b', 'c']

# Нахождение простых чисел
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

list(filter(is_prime, range(10)))  # [2, 3, 5, 7]
```

**Особенности для senior-разработчиков:**
- Как и `map`, часто может быть заменено генераторным выражением: `(x for x in items if predicate(x))`.
- Комбинирование `filter` и `map` может быть неэффективным; рассмотрите использование генераторных выражений для объединения обоих шагов.
- Для сложной фильтрации и преобразований рассмотрите использование `itertools` или `pandas` для более читабельного кода.

## Функции для последовательностей

### `sorted(iterable, *, key=None, reverse=False)`

**Описание:** Возвращает новый отсортированный список из элементов итерируемого объекта.

**Внутреннее устройство:**
- Использует Timsort - гибридный алгоритм сортировки, объединяющий merge sort и insertion sort.
- Сортировка стабильная (сохраняет относительный порядок элементов с одинаковыми ключами).
- Если указан key, сортирует по результатам применения key к элементам.

**Примеры:**
```python
# Базовая сортировка
sorted([3, 1, 4, 1, 5, 9, 2])  # [1, 1, 2, 3, 4, 5, 9]

# Сортировка с ключом и в обратном порядке
sorted(['apple', 'banana', 'kiwi'], key=len, reverse=True)  # ['banana', 'apple', 'kiwi']

# Сортировка объектов по нескольким атрибутам
data = [('John', 30), ('Alice', 25), ('Bob', 25)]
sorted(data, key=lambda x: (x[1], x[0]))  # [('Alice', 25), ('Bob', 25), ('John', 30)]
```

**Особенности для senior-разработчиков:**
- Сложность O(n log n) во всех случаях.
- Timsort оптимизирован для частично-отсортированных данных и имеет лучшую производительность на них.
- Использование `key=functools.cmp_to_key(cmp_func)` позволяет использовать функции сравнения в стиле Python 2, но это менее эффективно.
- Для частичной сортировки (top-N) используйте `heapq.nsmallest()/nlargest()`.

### `reversed(seq)`

**Описание:** Возвращает итератор, проходящий последовательность в обратном порядке.

**Внутреннее устройство:**
- Вызывает метод `__reversed__()` объекта, если он определён.
- В противном случае, создаёт новый итератор, проходящий от последнего к первому элементу.
- Не создаёт копию всей последовательности в памяти.

**Примеры:**
```python
# Обратный проход по списку
list(reversed([1, 2, 3]))  # [3, 2, 1]

# Обратная итерация по строке
''.join(reversed("hello"))  # "olleh"

# Обратный диапазон
list(reversed(range(5)))  # [4, 3, 2, 1, 0]
```

**Особенности для senior-разработчиков:**
- Предпочтительнее `reversed(x)`, чем `x[::-1]` для итерации, так как не создаёт копии.
- Комбинирование с другими итерационными функциями: `map(func, reversed(seq))`.
- Многие встроенные типы (list, str, tuple, range) имеют оптимизированную реализацию `__reversed__()`.

### `len(obj)`

**Описание:** Возвращает количество элементов в объекте.

**Внутреннее устройство:**
- Вызывает метод `__len__()` объекта.
- Для большинства встроенных типов работает за O(1), так как длина кэшируется.

**Примеры:**
```python
len([1, 2, 3])  # 3
len("hello")  # 5
len({"a": 1, "b": 2})  # 2 (количество пар ключ-значение)
```

**Особенности для senior-разработчиков:**
- Для пользовательских классов `__len__()` должен возвращать целое неотрицательное число.
- Избегайте кодирования `if len(x) == 0:` вместо `if not x:`, так как многие объекты реализуют `__bool__()` эффективнее.
- Для определения размера объекта в байтах используйте `sys.getsizeof()`.

### `all(iterable)`

**Описание:** Возвращает True, если все элементы итерируемого объекта истинны (или если объект пуст).

**Внутреннее устройство:**
- Использует короткое замыкание (прекращает проверку при первом False).
- Эквивалентно `bool(x) and bool(y) and ...`.

**Примеры:**
```python
all([True, True, True])  # True
all([True, False, True])  # False
all([])  # True (вакуумная истина)

# Проверка всех чисел на чётность
all(x % 2 == 0 for x in [2, 4, 6, 8])  # True
```

**Особенности для senior-разработчиков:**
- Для больших наборов данных преимущество перед явным циклом в коротком замыкании.
- Полезно для валидации данных: `all(key in data for key in required_keys)`.
- При оценке сложных условий учитывайте, что вычисление генератора может быть затратным.

### `any(iterable)`

**Описание:** Возвращает True, если хотя бы один элемент итерируемого объекта истинен (False для пустого объекта).

**Внутреннее устройство:**
- Использует короткое замыкание (прекращает проверку при первом True).
- Эквивалентно `bool(x) or bool(y) or ...`.

**Примеры:**
```python
any([False, False, True])  # True
any([False, False, False])  # False
any([])  # False (вакуумная ложь)

# Проверка наличия хотя бы одного нечётного числа
any(x % 2 == 1 for x in [2, 4, 5, 8])  # True
```

**Особенности для senior-разработчиков:**
- Используйте в комбинации с map для элегантной проверки условий: `any(map(predicate, items))`.
- Предпочтительнее `if any(...)` вместо флагов и циклов `found = False; for ...: if ...: found = True; break`.
- Для проверки "A содержит хотя бы один элемент из B" используйте `any(x in A for x in B)`.

## Функции для работы с объектами

### `type(object)` или `type(name, bases, dict)`

**Описание:** В одноаргументной форме возвращает тип объекта. В трёхаргументной форме создаёт новый тип (метапрограммирование).

**Внутреннее устройство:**
- Трёхаргументная форма является низкоуровневым эквивалентом определения класса.
- Ядро метапрограммирования в Python, создаёт новый объект типа.

**Примеры:**
```python
# Определение типа
type(42)  # <class 'int'>
type([])  # <class 'list'>

# Динамическое создание класса
MyClass = type('MyClass', (object,), {'x': 42, 'say_hello': lambda self: 'Hello'})
obj = MyClass()
obj.x  # 42
obj.say_hello()  # 'Hello'
```

**Особенности для senior-разработчиков:**
- Предпочитайте `isinstance()` вместо сравнения `type(obj) == some_type` для проверки типа.
- Трёхаргументная форма полезна для создания динамических интерфейсов и DSL.
- Основа метаклассов - `type` это метакласс для всех классов.

### `isinstance(object, classinfo)`

**Описание:** Проверяет, является ли объект экземпляром указанного класса или его подклассов.

**Внутреннее устройство:**
- Проверяет весь граф наследования объекта.
- Поддерживает проверку на несколько типов через кортеж: `isinstance(obj, (type1, type2))`.
- Использует метод `__instancecheck__()` метакласса.

**Примеры:**
```python
# Базовая проверка типа
isinstance(42, int)  # True
isinstance("hello", (int, str))  # True

# Проверка наследования
class Base: pass
class Child(Base): pass
obj = Child()
isinstance(obj, Base)  # True
```

**Особенности для senior-разработчиков:**
- Предпочтительнее прямого сравнения типов, так как учитывает наследование и абстрактные базовые классы.
- Для проверки "является ли duck-typing совместимым" используйте `hasattr()` вместо `isinstance()`.
- Для проверки на стандартные протоколы (например, на итерируемость) используйте `collections.abc`.

### `issubclass(class, classinfo)`

**Описание:** Проверяет, является ли класс подклассом указанного класса (или классов).

**Внутреннее устройство:**
- Подобно `isinstance()`, но работает только с классами, не с экземплярами.
- Класс считается подклассом самого себя.

**Примеры:**
```python
# Базовые проверки
issubclass(bool, int)  # True (bool наследуется от int)
issubclass(list, dict)  # False

# Множественная проверка
issubclass(bool, (float, int))  # True
```

**Особенности для senior-разработчиков:**
- Полезно для проверки совместимости типов в полиморфных функциях.
- Для кастомных проверок типов можно переопределить `__subclasscheck__` в метаклассе.
- Будьте осторожны с абстрактными базовыми классами - они могут считаться подклассами даже без явного наследования.

### `callable(object)`

**Описание:** Проверяет, является ли объект вызываемым (функцией, методом, классом и т.д.).

**Внутреннее устройство:**
- Проверяет наличие метода `__call__()` у объекта.
- Классы всегда считаются вызываемыми (вызов создаёт экземпляр).

**Примеры:**
```python
# Разные вызываемые объекты
callable(len)  # True (функция)
callable(lambda x: x)  # True (лямбда)
callable(str)  # True (класс)
callable([].append)  # True (метод)

# Невызываемые объекты
callable([])  # False (список)
callable(None)  # False

# Кастомный вызываемый объект
class Adder:
    def __call__(self, a, b):
        return a + b

add = Adder()
callable(add)  # True
add(2, 3)  # 5
```

**Особенности для senior-разработчиков:**
- Используйте перед вызовом неизвестного объекта для предотвращения ошибок.
- Классы с `__call__` могут использоваться как функции с состоянием.
- Полезно для создания фабрик и стратегий.

### `hasattr(object, name)`

**Описание:** Проверяет, имеет ли объект атрибут с указанным именем.

**Внутреннее устройство:**
- Пытается получить атрибут через `getattr()` и перехватывает исключение `AttributeError`.
- Работает с динамическими атрибутами (`__getattr__`).

**Примеры:**
```python
# Проверка наличия атрибутов
hasattr([], 'append')  # True
hasattr([], 'push')  # False

# Использование для проверки совместимости
def safe_process(obj):
    if hasattr(obj, 'process'):
        return obj.process()
    return None
```

**Особенности для senior-разработчиков:**
- Часто лучше использовать EAFP (Easier to Ask Forgiveness than Permission) с try/except вместо проверки `hasattr`.
- `hasattr(obj, attr)` может вызвать выполнение кода в `__getattr__` или `__getattribute__`, что может иметь побочные эффекты.
- Хорошо подходит для проверки совместимости duck-typing.

### `getattr(object, name[, default])`

**Описание:** Возвращает значение атрибута объекта или default, если атрибут не существует.

**Внутреннее устройство:**
- Обращается к объекту через имя атрибута `object.name`.
- Если атрибут не найден и default не указан, вызывает AttributeError.
- Обрабатывает `__getattr__` и `__getattribute__` для динамических атрибутов.

**Примеры:**
```python
# Базовое получение атрибута
getattr([], 'append')  # <method 'append' of 'list'>

# Использование значения по умолчанию
getattr([], 'push', lambda x: None)  # <function <lambda>>

# Динамический доступ к атрибутам
attrs = ['__class__', '__len__', 'append']
methods = [getattr([], attr) for attr in attrs]
```

**Особенности для senior-разработчиков:**
- Полезно для рефлексии и метапрограммирования.
- Комбинируйте с `hasattr` для безопасного доступа без использования значения по умолчанию.
- Для глубокого доступа к вложенным атрибутам можно использовать функциональный подход: `functools.reduce(getattr, path.split('.'), obj)`.

### `setattr(object, name, value)`

**Описание:** Устанавливает значение атрибута объекта.

**Внутреннее устройство:**
- Эквивалентно `object.name = value`.
- Может вызывать `__setattr__` объекта для кастомной логики.

**Примеры:**
```python
# Установка атрибута
obj = type('MyObject', (), {})()
setattr(obj, 'x', 42)
obj.x  # 42

# Динамическое создание атрибутов
data = {'name': 'John', 'age': 30}
user = type('User', (), {})()
for key, value in data.items():
    setattr(user, key, value)
```

**Особенности для senior-разработчиков:**
- Позволяет модифицировать объекты динамически, что полезно для ORM и сериализации.
- Может нарушать инкапсуляцию при неправильном использовании.
- Будьте осторожны с специальными именами атрибутов (`__xxx__`).

### `delattr(object, name)`

**Описание:** Удаляет атрибут объекта.

**Внутреннее устройство:**
- Эквивалентно `del object.name`.
- Вызывает `__delattr__` объекта для кастомной логики.

**Примеры:**
```python
# Удаление атрибута
class MyClass:
    x = 42
    y = 24

obj = MyClass()
delattr(obj, 'x')
hasattr(obj, 'x')  # False (x удалён из экземпляра)
hasattr(MyClass, 'x')  # True (x всё ещё существует в классе)

# Динамическое управление атрибутами
for attr in ['x', 'y']:
    if getattr(obj, attr, None) == 24:
        delattr(obj, attr)
```

**Особенности для senior-разработчиков:**
- Удаление атрибута экземпляра не влияет на атрибут класса.
- Может быть полезно для очистки ресурсов и временных атрибутов.
- Будьте осторожны с удалением обязательных атрибутов.

## Функции ввода-вывода

### `print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`

**Описание:** Выводит объекты в текстовый поток.

**Внутреннее устройство:**
- Преобразует объекты в строки с помощью `str()`.
- Разделяет их строкой sep и добавляет end в конце.
- Записывает в указанный file (по умолчанию sys.stdout).
- Если flush=True, принудительно сбрасывает буфер потока.

**Примеры:**
```python
# Базовый вывод
print("Hello", "World")  # "Hello World"

# Настройка разделителя и окончания
print("Hello", "World", sep=", ", end="!")  # "Hello, World!"

# Вывод в файл
with open('output.txt', 'w') as f:
    print("Logging to file", file=f)

# Вывод без буферизации
import time
for i in range(5):
    print(i, end=' ', flush=True)
    time.sleep(1)  # Вывод происходит немедленно после каждой итерации
```

**Особенности для senior-разработчиков:**
- Для форматированного вывода используйте f-строки или `str.format()` перед `print()`.
- Для вывода бинарных данных используйте прямую запись в поток (`sys.stdout.buffer.write()`).
- `print()` автоматически преобразует любой объект в строку, что может быть затратно для больших структур.

### `input([prompt])`

**Описание:** Считывает строку с клавиатуры после вывода приглашения prompt.

**Внутреннее устройство:**
- Выводит prompt в sys.stdout без завершающего перевода строки.
- Считывает строку из sys.stdin до перевода строки.
- Возвращает строку без завершающего символа перевода строки.

**Примеры:**
```python
# Базовый ввод
name = input("Enter your name: ")

# Преобразование ввода
age = int(input("Enter your age: "))

# Обработка ввода с валидацией
while True:
    try:
        number = float(input("Enter a positive number: "))
        if number > 0:
            break
        print("The number must be positive.")
    except ValueError:
        print("Invalid input. Please enter a number.")
```

**Особенности для senior-разработчиков:**
- Всегда возвращает строку, необходимо явное преобразование в нужный тип.
- Для сложного ввода (например, паролей) используйте `getpass` модуль.
- Для интерактивных приложений с расширенными возможностями используйте библиотеки `prompt_toolkit` или `cmd`.

### `open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`

**Описание:** Открывает файл и возвращает соответствующий объект файла.

**Внутреннее устройство:**
- Создаёт объект-дескриптор файла, абстрагирующий операции чтения/записи.
- Управляет буферизацией и кодировкой.
- Может работать как с текстовыми, так и с бинарными файлами.

**Примеры:**
```python
# Чтение текстового файла
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()

# Запись в файл с автоматическим закрытием
with open('output.txt', 'w', encoding='utf-8') as f:
    f.write("Hello, world!")

# Построчное чтение больших файлов
with open('large_file.txt', 'r') as f:
    for line in f:
        process_line(line.strip())

# Работа с бинарными файлами
with open('image.png', 'rb') as f_in, open('copy.png', 'wb') as f_out:
    f_out.write(f_in.read())
```

**Особенности для senior-разработчиков:**
- Всегда используйте контекстный менеджер (`with`) для автоматического закрытия файла.
- Для больших файлов используйте построчное чтение или `chunked` подход вместо `read()`.
- Режимы файла: 'r' (чтение), 'w' (перезапись), 'a' (добавление), 'x' (эксклюзивное создание), 'b' (бинарный), 't' (текстовый), '+' (чтение и запись).
- Для временных файлов предпочтительнее модуль `tempfile`.

## Функции для работы с переменными и областями видимости

### `globals()`

**Описание:** Возвращает словарь текущих глобальных переменных.

**Внутреннее устройство:**
- Непосредственно возвращает ссылку на словарь глобальных переменных текущего модуля.
- Изменения в этом словаре влияют на глобальные переменные.

**Примеры:**
```python
# Просмотр глобальных переменных
x = 42
globals()['x']  # 42

# Динамическое создание переменных
globals()['dynamic_var'] = "I'm dynamically created"
print(dynamic_var)  # "I'm dynamically created"

# Функция, добавляющая глобальные переменные
def register_vars(**kwargs):
    globals().update(kwargs)

register_vars(PI=3.14159, G=9.8)
print(PI, G)  # 3.14159 9.8
```

**Особенности для senior-разработчиков:**
- Позволяет динамически создавать и модифицировать переменные.
- Полезно для метапрограммирования и динамической загрузки модулей.
- Избегайте чрезмерного использования, так как это затрудняет отслеживание состояния программы.

### `locals()`

**Описание:** Возвращает словарь текущих локальных переменных.

**Внутреннее устройство:**
- В отличие от `globals()`, возвращает копию словаря локальных переменных.
- Изменения в этом словаре могут не влиять на локальные переменные (зависит от контекста).

**Примеры:**
```python
# Просмотр локальных переменных в функции
def func():
    x = 42
    print(locals())  # {'x': 42}

# Различие между globals() и locals() на верхнем уровне
x = 1
print(globals()['x'], locals()['x'])  # 1 1
globals()['x'] = 2
print(x)  # 2 (изменения видны)
```

**Особенности для senior-разработчиков:**
- В отличие от `globals()`, изменения словаря `locals()` внутри функции обычно не влияют на локальные переменные.
- Полезно для отладки и интроспекции.
- На верхнем уровне модуля `locals()` и `globals()` возвращают один и тот же словарь.

### `vars([object])`

**Описание:** Возвращает `__dict__` объекта или текущие локальные переменные, если объект не указан.

**Внутреннее устройство:**
- Для объектов возвращает `object.__dict__`.
- Без аргументов эквивалентно `locals()`.

**Примеры:**
```python
# Просмотр атрибутов объекта
class Person:
    def __init__(self, name):
        self.name = name

p = Person("John")
vars(p)  # {'name': 'John'}

# Эквивалентность vars() и locals()
def func():
    x = 42
    print(vars() == locals())  # True
```

**Особенности для senior-разработчиков:**
- Полезно для интроспекции объектов и сериализации.
- Не все объекты имеют `__dict__` (например, slots-классы, встроенные типы).
- Изменения, внесённые через `vars(obj)`, напрямую влияют на атрибуты объекта.

### `dir([object])`

**Описание:** Возвращает список имён в пространстве имён объекта или список имён в текущей области видимости.

**Внутреннее устройство:**
- Без аргументов возвращает имена в текущей области видимости.
- Для объекта возвращает атрибуты, полученные через `__dir__()` или из `__dict__` и MRO.
- Включает встроенные атрибуты и методы.

**Примеры:**
```python
# Просмотр доступных атрибутов и методов
dir(list)  # ['__add__', '__class__', 'append', 'clear', ...]

# Просмотр текущей области видимости
x = 42
'x' in dir()  # True

# Кастомизация dir() для объекта
class CustomDir:
    def __dir__(self):
        return ['custom_attr_1', 'custom_attr_2']

dir(CustomDir())  # ['custom_attr_1', 'custom_attr_2']
```

**Особенности для senior-разработчиков:**
- В отличие от `vars()`, `dir()` работает для всех объектов, включая те, что используют `__slots__`.
- Полезно для интерактивного исследования объектов и автодополнения.
- Для кастомных объектов можно переопределить `__dir__()` для управления выводом.

## Рефлексия и метапрограммирование

### `__import__(name, globals=None, locals=None, fromlist=(), level=0)`

**Описание:** Низкоуровневая функция для импорта модуля, используемая оператором `import`.

**Внутреннее устройство:**
- Динамически загружает модуль по имени.
- Используется интерпретатором для реализации оператора `import`.

**Примеры:**
```python
# Базовый импорт
math = __import__('math')
math.sqrt(16)  # 4.0

# Эквивалент from X import Y
module = __import__('os.path', fromlist=['basename'])
basename = module.basename
basename('/path/to/file.txt')  # 'file.txt'

# Относительный импорт (level > 0)
submodule = __import__('..submodule', globals(), level=2)  # Импорт из родительского пакета
```

**Особенности для senior-разработчиков:**
- Предпочитайте использование `importlib.import_module()` вместо `__import__()`.
- Полезно для динамического импорта модулей во время выполнения.
- Параметр `fromlist` влияет на то, какой объект возвращается - модуль верхнего уровня или подмодуль.

### `eval(expression, globals=None, locals=None)`

**Описание:** Вычисляет строковое выражение как выражение Python.

**Внутреннее устройство:**
- Парсит строку и вычисляет её как выражение.
- Использует указанные globals/locals или текущие области видимости.

**Примеры:**
```python
# Вычисление математического выражения
eval('2 + 2')  # 4

# Использование переменных из окружения
x = 10
eval('x * 5')  # 50

# Использование с кастомными областями видимости
scope = {'x': 20, 'y': 30}
eval('x + y', scope)  # 50
```

**Особенности для senior-разработчиков:**
- **Опасность безопасности**: Никогда не использовать с недоверенным вводом!
- Для безопасной оценки математических выражений используйте специализированные парсеры или `ast.literal_eval()`.
- Полезно для конфигурационных файлов и метапрограммирования в контролируемой среде.

### `exec(object, globals=None, locals=None)`

**Описание:** Выполняет строку или объект кода как программу Python.

**Внутреннее устройство:**
- В отличие от `eval()`, может выполнять несколько операторов.
- Не возвращает значение (возвращает None).

**Примеры:**
```python
# Выполнение блока кода
exec('x = 5\ny = 10\nprint(x + y)')  # Выводит 15

# Компиляция и выполнение
code = compile('result = [x**2 for x in range(10)]', '<string>', 'exec')
namespace = {}
exec(code, namespace)
namespace['result']  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

**Особенности для senior-разработчиков:**
- Как и `eval()`, представляет угрозу безопасности при использовании с недоверенным вводом.
- Используйте для динамической генерации и выполнения кода во время выполнения.
- Полезно для метапрограммирования, но сложно отлаживать.

### `compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)`

**Описание:** Компилирует строку в объект кода, который можно выполнить через `exec()` или `eval()`.

**Внутреннее устройство:**
- Преобразует исходный код в байт-код.
- Параметр mode определяет тип компиляции: 'exec' (блок кода), 'eval' (выражение) или 'single' (одиночный оператор).

**Примеры:**
```python
# Компиляция выражения для многократного использования
expr = compile('x**2 + y**2', '<string>', 'eval')
for x, y in [(3, 4), (5, 12), (8, 15)]:
    result = eval(expr, {'x': x, 'y': y})
    print(f"({x}, {y}) -> {result}")  # (3, 4) -> 25, (5, 12) -> 169, (8, 15) -> 289

# Компиляция блока кода
code = compile('''
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n-1)
result = factorial(5)
''', '<string>', 'exec')

namespace = {}
exec(code, namespace)
namespace['result']  # 120
```

**Особенности для senior-разработчиков:**
- Позволяет предварительно скомпилировать код для повышения производительности при многократном выполнении.
- Параметр flags позволяет контролировать поведение компилятора (например, future statements).
- Параметр optimize влияет на оптимизацию байт-кода (аналогично опции -O интерпретатора).

### `repr(object)`

**Описание:** Возвращает строковое представление объекта, которое может быть использовано для воссоздания объекта.

**Внутреннее устройство:**
- Вызывает метод `__repr__()` объекта.
- Предназначен для разработчиков и отладки, в отличие от `str()`.

**Примеры:**
```python
# Представления разных типов
repr(42)  # '42'
repr("Hello")  # "'Hello'"
repr([1, 2, 3])  # '[1, 2, 3]'

# Кастомное представление
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

p = Point(3, 4)
repr(p)  # 'Point(3, 4)'
eval(repr(p))  # Создаёт новый объект Point(3, 4)
```

**Особенности для senior-разработчиков:**
- Хорошая реализация `__repr__` должна возвращать строку, которую можно использовать с `eval()` для воссоздания объекта.
- Полезно для отладки и логирования.
- В интерактивной консоли Python автоматически вызывает `repr()` для отображения результата.

### `id(object)`

**Описание:** Возвращает уникальный идентификатор объекта (целое число).

**Внутреннее устройство:**
- В CPython возвращает адрес объекта в памяти.
- Гарантируется, что значение будет уникальным и постоянным для объекта в течение его жизни.

**Примеры:**
```python
# Проверка идентичности объектов
a = [1, 2, 3]
b = a
c = [1, 2, 3]

id(a) == id(b)  # True (a и b ссылаются на один объект)
id(a) == id(c)  # False (c - другой список с тем же содержимым)

# Идентификация объектов в условиях
def is_same_object(a, b):
    return id(a) == id(b)
```

**Особенности для senior-разработчиков:**
- Предпочитайте оператор `is` вместо сравнения `id()` для проверки идентичности объектов.
- Иногда полезно для отладки проблем с неожиданным поведением изменяемых объектов.
- В CPython маленькие целые числа и некоторые строки кэшируются, поэтому могут иметь одинаковый id, даже если созданы отдельно.

### `property(fget=None, fset=None, fdel=None, doc=None)` или `@property`

**Описание:** Создаёт дескриптор свойства, позволяющий управлять доступом к атрибутам.

**Внутреннее устройство:**
- Реализует протокол дескриптора через методы `__get__`, `__set__` и `__delete__`.
- Позволяет определить логику для чтения, записи и удаления атрибута.

**Примеры:**
```python
# Функциональная форма
class Circle:
    def __init__(self, radius):
        self._radius = radius
        
    def get_radius(self):
        return self._radius
        
    def set_radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value
        
    def del_radius(self):
        del self._radius
        
    radius = property(get_radius, set_radius, del_radius, 
                     "Circle radius")

# Декораторная форма (более распространённая)
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
        
    @property
    def width(self):
        return self._width
        
    @width.setter
    def width(self, value):
        if value < 0:
            raise ValueError("Width cannot be negative")
        self._width = value
        
    @property
    def area(self):
        return self._width * self._height
```

**Особенности для senior-разработчиков:**
- Позволяет создавать вычисляемые свойства и валидировать ввод без изменения интерфейса.
- Только для чтения: определите только `@property` без сеттера.
- Свойства кэшируются как дескрипторы класса, а не для каждого экземпляра.
- Для определения свойств с одинаковой логикой для множества атрибутов рассмотрите кастомные дескрипторы.

### `super([type[, object-or-type]])`

**Описание:** Возвращает прокси-объект, делегирующий вызовы методов родительскому или родственному классу.

**Внутреннее устройство:**
- Без аргументов (в методе класса) использует текущий класс и экземпляр.
- Разрешает методы с использованием MRO (Method Resolution Order).
- Поддерживает множественное наследование.

**Примеры:**
```python
# Базовый вызов метода родителя
class Animal:
    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return super().speak() + " and bark"

# Множественное наследование с super()
class A:
    def method(self):
        print("A.method called")

class B(A):
    def method(self):
        print("B.method called")
        super().method()

class C(A):
    def method(self):
        print("C.method called")
        super().method()

class D(B, C):
    def method(self):
        print("D.method called")
        super().method()

# При вызове D().method() будет порядок: D, B, C, A
```

**Особенности для senior-разработчиков:**
- `super()` следует MRO, а не просто обращается к прямому родителю.
- При множественном наследовании критически важно вызывать `super()` в каждом методе, чтобы все классы в иерархии выполнялись.
- Можно использовать с указанием конкретного класса: `super(MyClass, self).method()`.
- Паттерн "алмазного" наследования будет работать корректно только при правильном использовании `super()`.

### `classmethod(function)`

**Описание:** Преобразует метод в метод класса, который принимает класс, а не экземпляр, в качестве первого аргумента.

**Внутреннее устройство:**
- Создаёт дескриптор, преобразующий обычный метод в метод класса.
- Передаёт класс (а не экземпляр) в первый параметр.

**Примеры:**
```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)
    
    @classmethod
    def today(cls):
        import datetime
        now = datetime.datetime.now()
        return cls(now.year, now.month, now.day)

# Использование методов класса
date1 = Date.from_string('2023-01-15')
date2 = Date.today()
```

**Особенности для senior-разработчиков:**
- Полезно для определения альтернативных конструкторов.
- В отличие от статических методов, методы класса наследуются и работают с подклассами (`cls` будет подклассом).
- Позволяет определять фабричные методы, которые вернут экземпляр соответствующего класса или подкласса.
- Может быть использован для отслеживания всех экземпляров класса.

### `staticmethod(function)`

**Описание:** Преобразует метод в статический метод, который не принимает неявный первый аргумент.

**Внутреннее устройство:**
- Создаёт дескриптор, не передающий экземпляр или класс в функцию.
- Статические методы являются обычными функциями, привязанными к пространству имён класса.

**Примеры:**
```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
    
    @staticmethod
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

# Использование без создания экземпляра
MathUtils.add(5, 3)  # 8
MathUtils.is_prime(17)  # True
```

**Особенности для senior-разработчиков:**
- Используйте для методов, не зависящих от состояния класса или экземпляра.
- В отличие от методов класса, статические методы не получают ссылку на класс.
- Полезно для вспомогательных функций, связанных с классом логически, но не требующих доступа к его данным.
- Наследуется подклассами, но не может быть переопределено с изменением поведения для разных классов (в отличие от `@classmethod`).

## Итоги и советы

- Встроенные функции Python предоставляют мощные инструменты для работы с различными аспектами языка.
- Senior-разработчикам стоит знать не только базовый синтаксис, но и внутреннее устройство и особенности производительности.
- Предпочитайте использование встроенных функций вместо самостоятельной реализации эквивалентной функциональности.
- Используйте `dir()`, `help()` и `type()` для изучения объектов и их возможностей во время разработки.
- Изучите модули `itertools`, `functools` и `collections` для расширения функциональности встроенных функций.
- Будьте осторожны с функциями для динамического выполнения кода (`eval`, `exec`) из-за потенциальных проблем с безопасностью.
