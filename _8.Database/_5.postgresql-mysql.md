# Подключение к PostgreSQL и MySQL в Python

## Введение

В предыдущем уроке мы рассмотрели работу с SQLite - легковесной встраиваемой базой данных, которая отлично подходит для небольших приложений. Однако для более серьезных проектов часто требуются полнофункциональные серверные системы управления базами данных (СУБД), такие как PostgreSQL и MySQL. Эти системы обеспечивают:

- Более высокую производительность при работе с большими объемами данных
- Лучшую поддержку одновременного доступа многих пользователей
- Расширенные функции для обеспечения целостности данных
- Более богатые возможности SQL, включая хранимые процедуры, триггеры и т.д.
- Полную поддержку транзакций и восстановления после сбоев

В этом уроке мы рассмотрим, как подключаться к PostgreSQL и MySQL из Python и как работать с этими базами данных.

## PostgreSQL и Python

### О PostgreSQL

PostgreSQL - это мощная объектно-реляционная СУБД с открытым исходным кодом. Она известна своей надежностью, расширяемостью и строгим соблюдением стандартов SQL. PostgreSQL предлагает множество продвинутых функций, таких как:

- Сложные запросы и индексирование
- Транзакции с полной поддержкой ACID
- Многоверсионное управление конкурентным доступом (MVCC)
- Наследование таблиц
- Поддержка JSON и других NoSQL функций
- Расширяемость с помощью собственных типов данных, операторов и функций

### Установка драйвера psycopg2

Для работы с PostgreSQL из Python обычно используется библиотека `psycopg2`. Она обеспечивает полную поддержку стандарта DB-API 2.0 и дополнительные возможности, специфичные для PostgreSQL.

Установка psycopg2:

```bash
pip install psycopg2
```

Если у вас возникают проблемы с компиляцией библиотеки из исходников, вы можете установить предварительно скомпилированную версию:

```bash
pip install psycopg2-binary
```

### Подключение к PostgreSQL

После установки драйвера вы можете подключиться к базе данных PostgreSQL:

```python
import psycopg2

# Параметры подключения
params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password",
    "port": 5432  # Стандартный порт PostgreSQL
}

# Установка соединения
conn = psycopg2.connect(**params)

# Создание курсора
cursor = conn.cursor()

# Выполнение SQL-запроса
cursor.execute("SELECT version();")

# Получение результата
version = cursor.fetchone()
print(f"PostgreSQL version: {version[0]}")

# Закрытие соединения
cursor.close()
conn.close()
```

Вы также можете использовать строку подключения:

```python
conn = psycopg2.connect("host=localhost dbname=mydb user=postgres password=password port=5432")
```

Как и в случае с SQLite, рекомендуется использовать контекстный менеджер для автоматического закрытия соединения:

```python
import psycopg2

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    with conn.cursor() as cursor:
        cursor.execute("SELECT version();")
        version = cursor.fetchone()
        print(f"PostgreSQL version: {version[0]}")
```

### Создание таблиц в PostgreSQL

Создание таблиц в PostgreSQL очень похоже на SQLite, но с некоторыми дополнительными возможностями:

```python
import psycopg2

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    with conn.cursor() as cursor:
        # Создаем таблицу (если она не существует)
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            age INTEGER CHECK (age >= 0),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # Создаем дополнительную таблицу с внешним ключом
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS orders (
            order_id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            product_name VARCHAR(100) NOT NULL,
            quantity INTEGER NOT NULL CHECK (quantity > 0),
            order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        )
        ''')
        
        # Фиксируем изменения
        conn.commit()
        
        print("Таблицы созданы успешно")
```

В этом примере:
- `SERIAL` - автоинкрементное целое число (аналог `INTEGER PRIMARY KEY AUTOINCREMENT` в SQLite)
- `VARCHAR` - строка переменной длины с ограничением максимальной длины
- `CHECK` - ограничение проверки для обеспечения целостности данных
- `DEFAULT CURRENT_TIMESTAMP` - установка текущей даты и времени по умолчанию
- `ON DELETE CASCADE` - автоматическое удаление связанных записей

### Вставка данных

Вставка данных также выполняется с помощью SQL-запроса `INSERT INTO`:

```python
import psycopg2

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    with conn.cursor() as cursor:
        # Вставка одной записи
        cursor.execute('''
        INSERT INTO users (name, email, age)
        VALUES (%s, %s, %s)
        RETURNING id
        ''', ('John Doe', 'john@example.com', 30))
        
        # Получаем ID вставленной записи
        user_id = cursor.fetchone()[0]
        print(f"Вставлена запись с ID: {user_id}")
        
        # Вставка нескольких записей
        users = [
            ('Alice Smith', 'alice@example.com', 25),
            ('Bob Johnson', 'bob@example.com', 35),
            ('Charlie Brown', 'charlie@example.com', 40)
        ]
        
        cursor.executemany('''
        INSERT INTO users (name, email, age)
        VALUES (%s, %s, %s)
        ''', users)
        
        # Вставляем заказы для пользователя
        orders = [
            (user_id, 'Phone', 1),
            (user_id, 'Headphones', 2),
            (user_id, 'Charger', 3)
        ]
        
        cursor.executemany('''
        INSERT INTO orders (user_id, product_name, quantity)
        VALUES (%s, %s, %s)
        ''', orders)
        
        # Фиксируем изменения
        conn.commit()
        
        print(f"Вставлено {len(users)} пользователей и {len(orders)} заказов")
```

Обратите внимание на несколько важных моментов:
1. В PostgreSQL используется `%s` для параметров запросов (в отличие от `?` в SQLite)
2. Инструкция `RETURNING` позволяет получить значения из вставленной записи
3. Как и в SQLite, в `psycopg2` поддерживается выполнение множественных запросов через `executemany`

### Выполнение запросов и получение данных

Для выборки данных используется SQL-запрос `SELECT`:

```python
import psycopg2
import psycopg2.extras

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    # Использование DictCursor для получения результатов в виде словарей
    with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
        # Выборка всех пользователей
        cursor.execute("SELECT * FROM users")
        
        # Получение всех записей
        users = cursor.fetchall()
        for user in users:
            # Доступ по имени поля
            print(f"User: {user['name']}, Email: {user['email']}, Age: {user['age']}")
        
        # Выборка с условием и JOIN
        cursor.execute('''
        SELECT u.name, o.product_name, o.quantity, o.order_date
        FROM users u
        JOIN orders o ON u.id = o.user_id
        WHERE u.id = %s
        ORDER BY o.order_date
        ''', (users[0]['id'],))
        
        # Получение результатов
        orders = cursor.fetchall()
        print(f"\nЗаказы пользователя {users[0]['name']}:")
        for order in orders:
            print(f"  Продукт: {order['product_name']}, "
                  f"Количество: {order['quantity']}, "
                  f"Дата: {order['order_date']}")
        
        # Получение агрегированных данных
        cursor.execute('''
        SELECT 
            u.name, 
            COUNT(o.order_id) as order_count, 
            SUM(o.quantity) as total_items
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.id, u.name
        ORDER BY total_items DESC NULLS LAST
        ''')
        
        # Вывод результатов
        print("\nСтатистика заказов:")
        for row in cursor.fetchall():
            print(f"Пользователь: {row['name']}, "
                  f"Количество заказов: {row['order_count']}, "
                  f"Всего товаров: {row['total_items'] or 0}")
```

В этом примере:
1. Мы используем `psycopg2.extras.DictCursor`, который позволяет получать результаты в виде словарей с доступом по имени поля
2. Демонстрируется использование JOIN для связывания таблиц
3. Показано использование GROUP BY для получения агрегированных данных
4. Используется сортировка с учетом NULL-значений (NULLS LAST)

### Обновление и удаление данных

Для обновления и удаления данных используются SQL-запросы `UPDATE` и `DELETE`:

```python
import psycopg2

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    with conn.cursor() as cursor:
        # Обновление данных
        cursor.execute('''
        UPDATE users
        SET age = age + 1
        WHERE name = %s
        RETURNING id, name, age
        ''', ('John Doe',))
        
        # Получение обновленных данных
        updated_user = cursor.fetchone()
        if updated_user:
            print(f"Обновлен пользователь: ID: {updated_user[0]}, "
                  f"Имя: {updated_user[1]}, Новый возраст: {updated_user[2]}")
        
        # Удаление данных
        cursor.execute('''
        DELETE FROM users
        WHERE email = %s
        RETURNING id, name
        ''', ('charlie@example.com',))
        
        # Проверка результата удаления
        deleted_user = cursor.fetchone()
        if deleted_user:
            print(f"Удален пользователь: ID: {deleted_user[0]}, Имя: {deleted_user[1]}")
        else:
            print("Пользователь не найден")
        
        # Фиксируем изменения
        conn.commit()
```

### Транзакции в PostgreSQL

PostgreSQL полностью поддерживает транзакции с соблюдением принципов ACID. Работа с транзакциями аналогична SQLite:

```python
import psycopg2

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

conn = psycopg2.connect(**params)
cursor = conn.cursor()

try:
    # Начало транзакции (начинается автоматически при первом запросе)
    
    # Вставка пользователя
    cursor.execute('''
    INSERT INTO users (name, email, age)
    VALUES (%s, %s, %s)
    RETURNING id
    ''', ('Dave Wilson', 'dave@example.com', 45))
    
    user_id = cursor.fetchone()[0]
    
    # Вставка заказа
    cursor.execute('''
    INSERT INTO orders (user_id, product_name, quantity)
    VALUES (%s, %s, %s)
    ''', (user_id, 'Laptop', 1))
    
    # Имитация ошибки
    if user_id % 2 == 0:  # Для демонстрации
        raise Exception("Симуляция сбоя для четных ID")
    
    # Если все операции успешны, фиксируем транзакцию
    conn.commit()
    print(f"Транзакция успешно выполнена для пользователя ID: {user_id}")

except Exception as e:
    # В случае ошибки откатываем транзакцию
    conn.rollback()
    print(f"Транзакция отменена: {e}")

finally:
    # Закрытие курсора и соединения
    cursor.close()
    conn.close()
```

### Дополнительные возможности psycopg2

#### Работа с JSON данными

PostgreSQL имеет отличную поддержку JSON. Вот пример работы с JSON-данными:

```python
import psycopg2
import psycopg2.extras
import json

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    # Создаем таблицу с JSON-полем
    with conn.cursor() as cursor:
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            properties JSONB  -- JSONB - бинарный JSON с индексированием
        )
        ''')
        conn.commit()
    
    # Вставляем данные с JSON
    with conn.cursor() as cursor:
        product_data = {
            'color': 'red',
            'weight': 150,
            'dimensions': {
                'width': 10,
                'height': 20,
                'depth': 5
            },
            'tags': ['electronics', 'gadget', 'new']
        }
        
        cursor.execute('''
        INSERT INTO products (name, properties)
        VALUES (%s, %s)
        RETURNING id
        ''', ('Smartphone', json.dumps(product_data)))
        
        product_id = cursor.fetchone()[0]
        conn.commit()
    
    # Запросы к JSON-данным
    with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
        # Получение всего JSON-объекта
        cursor.execute('SELECT properties FROM products WHERE id = %s', (product_id,))
        result = cursor.fetchone()
        properties = result['properties']
        print(f"Все свойства: {properties}")
        
        # Извлечение конкретного поля из JSON
        cursor.execute('''
        SELECT properties->>'color' as color, 
               (properties->>'weight')::int as weight
        FROM products
        WHERE id = %s
        ''', (product_id,))
        
        result = cursor.fetchone()
        print(f"Цвет: {result['color']}, Вес: {result['weight']}")
        
        # Поиск по значению внутри JSON
        cursor.execute('''
        SELECT name, properties 
        FROM products 
        WHERE properties->>'color' = %s
        ''', ('red',))
        
        matches = cursor.fetchall()
        for product in matches:
            print(f"Найден продукт: {product['name']}")
        
        # Поиск по вложенному значению
        cursor.execute('''
        SELECT name
        FROM products
        WHERE properties->'dimensions'->>'width' = %s
        ''', ('10',))  # Обратите внимание, что сравнение строковое
        
        for product in cursor.fetchall():
            print(f"Продукт с шириной 10: {product['name']}")
        
        # Поиск по элементу массива
        cursor.execute('''
        SELECT name
        FROM products
        WHERE %s = ANY(SELECT jsonb_array_elements_text(properties->'tags'))
        ''', ('gadget',))
        
        for product in cursor.fetchall():
            print(f"Продукт с тегом 'gadget': {product['name']}")
```

#### Типы данных PostgreSQL

`psycopg2` автоматически преобразует между типами данных Python и PostgreSQL:

| Python тип | PostgreSQL тип |
|------------|----------------|
| None       | NULL           |
| bool       | boolean        |
| int        | integer, bigint|
| float      | real, double   |
| str        | varchar, text  |
| bytes      | bytea          |
| date       | date           |
| time       | time           |
| datetime   | timestamp      |
| list       | array          |
| dict       | jsonb, json    |

Для работы с более сложными типами данных, такими как массивы или диапазоны, используются специальные адаптеры и преобразователи:

```python
import psycopg2
from psycopg2.extras import Json, register_default_jsonb

params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

with psycopg2.connect(**params) as conn:
    # Регистрация обработчика JSONB
    register_default_jsonb(conn)
    
    with conn.cursor() as cursor:
        # Создание таблицы с массивом
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS posts (
            id SERIAL PRIMARY KEY,
            title VARCHAR(100) NOT NULL,
            tags TEXT[],  -- Массив строк
            data JSONB    -- JSONB данные
        )
        ''')
        
        # Вставка с массивом и JSONB
        cursor.execute('''
        INSERT INTO posts (title, tags, data)
        VALUES (%s, %s, %s)
        ''', (
            'My First Post',
            ['python', 'database', 'postgresql'],  # Автоматически преобразуется в массив
            {'author': 'John', 'comments': 5}      # Автоматически преобразуется в JSONB
        ))
        
        conn.commit()
```

#### Обработка уведомлений (LISTEN/NOTIFY)

PostgreSQL поддерживает механизм асинхронных уведомлений, который можно использовать для реализации простой системы публикации/подписки:

```python
import psycopg2
import select

# Функция для обработки уведомлений
def process_notifications(conn):
    while True:
        # Проверяем, есть ли уведомления (без блокировки)
        if select.select([conn], [], [], 5) == ([], [], []):
            print("Нет уведомлений...")
        else:
            # Получаем все уведомления
            conn.poll()
            while conn.notifies:
                notify = conn.notifies.pop(0)
                print(f"Получено уведомление: pid={notify.pid}, канал={notify.channel}, "
                      f"данные={notify.payload}")

# Пример использования
params = {
    "host": "localhost",
    "database": "mydb",
    "user": "postgres",
    "password": "password"
}

# Соединение для прослушивания уведомлений
listener_conn = psycopg2.connect(**params)
listener_conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)

with listener_conn.cursor() as cursor:
    # Подписываемся на канал уведомлений
    cursor.execute("LISTEN events;")
    print("Ожидание уведомлений на канале 'events'...")

    # В другом соединении отправляем уведомление
    with psycopg2.connect(**params) as sender_conn:
        with sender_conn.cursor() as sender_cursor:
            # Отправляем уведомление
            sender_cursor.execute("NOTIFY events, 'Hello from PostgreSQL!';")
            sender_conn.commit()
    
    # Обрабатываем уведомления
    process_notifications(listener_conn)

listener_conn.close()
```

Этот механизм может быть полезен для реализации обновлений в реальном времени, координации между процессами и других сценариев, требующих асинхронной связи.

## MySQL и Python

### О MySQL

MySQL - это одна из самых популярных реляционных СУБД с открытым исходным кодом. Она известна своей скоростью, надежностью и простотой использования. MySQL используется во множестве проектов, от небольших сайтов до крупных веб-приложений.

Основные особенности MySQL:
- Высокая производительность и масштабируемость
- Поддержка транзакций (с движками InnoDB, NDB)
- Полнотекстовый поиск
- Репликация
- Триггеры, хранимые процедуры и функции
- Поддержка различных механизмов хранения с разными характеристиками

### Установка драйвера mysql-connector-python

Для работы с MySQL из Python мы будем использовать официальный коннектор MySQL:

```bash
pip install mysql-connector-python
```

### Подключение к MySQL

После установки драйвера вы можете подключиться к базе данных MySQL:

```python
import mysql.connector

# Параметры подключения
config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb",
    "port": 3306  # Стандартный порт MySQL
}

# Установка соединения
conn = mysql.connector.connect(**config)

# Создание курсора
cursor = conn.cursor()

# Выполнение SQL-запроса
cursor.execute("SELECT VERSION()")

# Получение результата
version = cursor.fetchone()
print(f"MySQL version: {version[0]}")

# Закрытие соединения
cursor.close()
conn.close()
```

Для использования контекстного менеджера:

```python
import mysql.connector

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor() as cursor:
        cursor.execute("SELECT VERSION()")
        version = cursor.fetchone()
        print(f"MySQL version: {version[0]}")
```

### Создание таблиц в MySQL

Создание таблиц в MySQL похоже на другие СУБД, но с некоторыми особенностями синтаксиса:

```python
import mysql.connector

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor() as cursor:
        # Создаем таблицу пользователей
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            age INT CHECK (age >= 0),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB
        ''')
        
        # Создаем таблицу заказов
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS orders (
            order_id INT AUTO_INCREMENT PRIMARY KEY,
            user_id INT NOT NULL,
            product_name VARCHAR(100) NOT NULL,
            quantity INT NOT NULL CHECK (quantity > 0),
            order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        ) ENGINE=InnoDB
        ''')
        
        # Фиксируем изменения
        conn.commit()
        
        print("Таблицы созданы успешно")
```

В этом примере:
- `AUTO_INCREMENT` - автоинкрементное целое число (аналог `SERIAL` в PostgreSQL)
- `ENGINE=InnoDB` - указывает тип таблицы, InnoDB поддерживает транзакции и внешние ключи

### Вставка данных

Вставка данных в MySQL аналогична другим СУБД:

```python
import mysql.connector

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor() as cursor:
        # Вставка одной записи
        cursor.execute('''
        INSERT INTO users (name, email, age)
        VALUES (%s, %s, %s)
        ''', ('John Doe', 'john@example.com', 30))
        
        # Получаем ID вставленной записи
        user_id = cursor.lastrowid
        print(f"Вставлена запись с ID: {user_id}")
        
        # Вставка нескольких записей
        users = [
            ('Alice Smith', 'alice@example.com', 25),
            ('Bob Johnson', 'bob@example.com', 35),
            ('Charlie Brown', 'charlie@example.com', 40)
        ]
        
        cursor.executemany('''
        INSERT INTO users (name, email, age)
        VALUES (%s, %s, %s)
        ''', users)
        
        # Вставляем заказы для пользователя
        orders = [
            (user_id, 'Phone', 1),
            (user_id, 'Headphones', 2),
            (user_id, 'Charger', 3)
        ]
        
        cursor.executemany('''
        INSERT INTO orders (user_id, product_name, quantity)
        VALUES (%s, %s, %s)
        ''', orders)
        
        # Фиксируем изменения
        conn.commit()
        
        print(f"Вставлено {cursor.rowcount} записей")
```

Обратите внимание, что в MySQL также используется `%s` для параметров запросов.

### Выборка данных с помощью курсора словаря

По умолчанию `mysql.connector` возвращает данные в виде кортежей. Для получения результатов в виде словарей нужно использовать специальный тип курсора:

```python
import mysql.connector
from mysql.connector import Error

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

try:
    # Подключение к базе данных
    conn = mysql.connector.connect(**config)
    
    # Создание курсора словаря
    cursor = conn.cursor(dictionary=True)
    
    # Выборка всех пользователей
    cursor.execute("SELECT * FROM users")
    
    # Получение всех записей
    users = cursor.fetchall()
    for user in users:
        # Доступ по имени поля
        print(f"User: {user['name']}, Email: {user['email']}, Age: {user['age']}")
    
    # Выборка с условием и JOIN
    cursor.execute('''
    SELECT u.name, o.product_name, o.quantity, o.order_date
    FROM users u
    JOIN orders o ON u.id = o.user_id
    WHERE u.id = %s
    ORDER BY o.order_date
    ''', (users[0]['id'],))
    
    # Получение результатов
    orders = cursor.fetchall()
    print(f"\nЗаказы пользователя {users[0]['name']}:")
    for order in orders:
        print(f"  Продукт: {order['product_name']}, "
              f"Количество: {order['quantity']}, "
              f"Дата: {order['order_date']}")
    
    # Агрегатные функции
    cursor.execute('''
    SELECT 
        u.name, 
        COUNT(o.order_id) as order_count, 
        SUM(o.quantity) as total_items
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.id, u.name
    ORDER BY total_items DESC
    ''')
    
    # Вывод результатов
    print("\nСтатистика заказов:")
    for row in cursor.fetchall():
        total_items = row['total_items'] if row['total_items'] is not None else 0
        print(f"Пользователь: {row['name']}, "
              f"Количество заказов: {row['order_count']}, "
              f"Всего товаров: {total_items}")

except Error as e:
    print(f"Ошибка при работе с MySQL: {e}")

finally:
    # Закрытие соединения
    if conn.is_connected():
        cursor.close()
        conn.close()
        print("Соединение с MySQL закрыто")
```

### Обновление и удаление данных

Обновление и удаление данных в MySQL:

```python
import mysql.connector

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor() as cursor:
        # Обновление данных
        cursor.execute('''
        UPDATE users
        SET age = age + 1
        WHERE name = %s
        ''', ('John Doe',))
        
        # Получение количества обновленных строк
        updated_rows = cursor.rowcount
        print(f"Обновлено строк: {updated_rows}")
        
        # Удаление данных
        cursor.execute('''
        DELETE FROM users
        WHERE email = %s
        ''', ('charlie@example.com',))
        
        # Получение количества удаленных строк
        deleted_rows = cursor.rowcount
        print(f"Удалено строк: {deleted_rows}")
        
        # Фиксируем изменения
        conn.commit()
```

### Транзакции в MySQL

MySQL с движком InnoDB поддерживает транзакции:

```python
import mysql.connector
from mysql.connector import Error

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

try:
    # Подключение к базе данных
    conn = mysql.connector.connect(**config)
    cursor = conn.cursor()
    
    # Отключаем автокоммит
    conn.autocommit = False
    
    # Начало транзакции
    conn.start_transaction()
    
    # Вставка пользователя
    cursor.execute('''
    INSERT INTO users (name, email, age)
    VALUES (%s, %s, %s)
    ''', ('Dave Wilson', 'dave@example.com', 45))
    
    user_id = cursor.lastrowid
    
    # Вставка заказа
    cursor.execute('''
    INSERT INTO orders (user_id, product_name, quantity)
    VALUES (%s, %s, %s)
    ''', (user_id, 'Laptop', 1))
    
    # Имитация ошибки
    if user_id % 2 == 0:  # Для демонстрации
        raise Exception("Симуляция сбоя для четных ID")
    
    # Если все операции успешны, фиксируем транзакцию
    conn.commit()
    print(f"Транзакция успешно выполнена для пользователя ID: {user_id}")

except Error as e:
    # В случае ошибки откатываем транзакцию
    if conn.is_connected():
        conn.rollback()
    print(f"Транзакция отменена: {e}")

finally:
    # Закрытие курсора и соединения
    if conn.is_connected():
        cursor.close()
        conn.close()
        print("Соединение с MySQL закрыто")
```

### Особенности работы с MySQL

#### Использование хранимых процедур

MySQL поддерживает хранимые процедуры, которые можно вызывать из Python:

```python
import mysql.connector

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor() as cursor:
        # Создание хранимой процедуры
        cursor.execute('''
        CREATE PROCEDURE get_user_orders(IN user_id INT)
        BEGIN
            SELECT u.name, o.product_name, o.quantity, o.order_date
            FROM users u
            JOIN orders o ON u.id = o.user_id
            WHERE u.id = user_id
            ORDER BY o.order_date;
        END
        ''')
        
        conn.commit()
        
        # Вызов хранимой процедуры
        cursor.callproc('get_user_orders', [1])  # ID пользователя
        
        # Получение результатов
        for result in cursor.stored_results():
            for row in result.fetchall():
                print(f"User: {row[0]}, Product: {row[1]}, Quantity: {row[2]}, Date: {row[3]}")
```

#### Обработка ошибок и исключений

MySQL может генерировать различные исключения, которые следует обрабатывать:

```python
import mysql.connector
from mysql.connector import Error, IntegrityError, ProgrammingError

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

try:
    conn = mysql.connector.connect(**config)
    cursor = conn.cursor()
    
    # Попытка вставить дубликат (нарушение уникальности)
    try:
        cursor.execute('''
        INSERT INTO users (name, email, age)
        VALUES (%s, %s, %s)
        ''', ('John Doe', 'john@example.com', 30))  # Уже существует
        
        conn.commit()
    
    except IntegrityError as ie:
        print(f"Ошибка целостности данных: {ie}")
    
    # Попытка выполнить неверный SQL-запрос
    try:
        cursor.execute("SELECT * FROM non_existent_table")
    
    except ProgrammingError as pe:
        print(f"Ошибка в SQL-запросе: {pe}")

except Error as e:
    print(f"Ошибка при подключении: {e}")

finally:
    if 'conn' in locals() and conn.is_connected():
        cursor.close()
        conn.close()
        print("Соединение с MySQL закрыто")
```

#### Работа с датами и временем

MySQL имеет несколько типов данных для хранения дат и времени. Вот как с ними работать:

```python
import mysql.connector
import datetime

config = {
    "host": "localhost",
    "user": "root",
    "password": "password",
    "database": "mydb"
}

with mysql.connector.connect(**config) as conn:
    with conn.cursor(dictionary=True) as cursor:
        # Создание таблицы с различными типами дат
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS events (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            event_date DATE,              -- Только дата
            event_time TIME,              -- Только время
            event_datetime DATETIME,      -- Дата и время
            created TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- Автоматическая метка времени
        )
        ''')
        
        conn.commit()
        
        # Текущие дата и время
        now = datetime.datetime.now()
        today = datetime.date.today()
        current_time = datetime.time(now.hour, now.minute, now.second)
        
        # Вставка события
        cursor.execute('''
        INSERT INTO events (name, event_date, event_time, event_datetime)
        VALUES (%s, %s, %s, %s)
        ''', ('Meeting', today, current_time, now))
        
        conn.commit()
        
        # Вставка с датой в строковом формате
        cursor.execute('''
        INSERT INTO events (name, event_date, event_time, event_datetime)
        VALUES (%s, %s, %s, %s)
        ''', ('Conference', '2023-12-15', '09:30:00', '2023-12-15 09:30:00'))
        
        conn.commit()
        
        # Выборка с фильтрацией по дате
        cursor.execute('''
        SELECT * FROM events 
        WHERE event_date > %s
        ''', (datetime.date(2023, 1, 1),))
        
        future_events = cursor.fetchall()
        for event in future_events:
            print(f"Событие: {event['name']}, "
                  f"Дата: {event['event_date']}, "
                  f"Время: {event['event_time']}, "
                  f"Дата и время: {event['event_datetime']}")
        
        # Получение событий за текущий месяц
        cursor.execute('''
        SELECT * FROM events 
        WHERE MONTH(event_date) = MONTH(CURRENT_DATE()) 
          AND YEAR(event_date) = YEAR(CURRENT_DATE())
        ''')
        
        this_month_events = cursor.fetchall()
        print(f"\nСобытия в текущем месяце: {len(this_month_events)}")
```

### Сравнение MySQL и PostgreSQL

| Характеристика | MySQL | PostgreSQL |
|----------------|-------|------------|
| Синтаксис | Близок к стандарту SQL, с некоторыми расширениями | Строго следует стандарту SQL с расширениями |
| Типы данных | Базовые типы, JSON (с 5.7.8) | Расширенная поддержка типов, включая JSON, массивы, геометрические типы |
| Транзакции | Поддерживаются с InnoDB | Полная поддержка ACID |
| Производительность | Высокая для чтения, оптимизирована для веб-приложений | Высокая для сложных запросов и записи |
| Репликация | Master-Slave, Group Replication | Streaming Replication, Logical Replication |
| Индексирование | B-Tree, Hash, Full-text | B-Tree, Hash, GiST, GIN, SP-GiST, BRIN |
| Расширяемость | Ограниченная | Высокая (собственные типы данных, операторы, функции) |
| Соответствие ACID | Зависит от движка хранения | Полное соответствие |
| Хранимые процедуры | Ограниченная поддержка | Расширенная поддержка с PL/pgSQL, PL/Python и др. |

## Объектно-реляционные преобразователи (ORM)

Для упрощения работы с базами данных в Python часто используются ORM (Object-Relational Mappers). Они позволяют работать с базами данных через объекты Python, избегая необходимости писать SQL-запросы вручную.

### SQLAlchemy

SQLAlchemy - самая популярная ORM-библиотека для Python. Она поддерживает множество СУБД, включая PostgreSQL, MySQL, SQLite и другие.

Установка:

```bash
pip install sqlalchemy
```

Для использования с PostgreSQL:

```bash
pip install psycopg2-binary
```

Для использования с MySQL:

```bash
pip install mysql-connector-python
```

#### Пример использования SQLAlchemy с PostgreSQL

```python
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
import datetime

# Создание движка базы данных
engine = create_engine('postgresql://postgres:password@localhost/mydb')

# Создание базового класса моделей
Base = declarative_base()

# Определение моделей
class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    age = Column(Integer)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Отношение один-ко-многим с заказами
    orders = relationship("Order", back_populates="user", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<User(name='{self.name}', email='{self.email}', age={self.age})>"

class Order(Base):
    __tablename__ = 'orders'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    product_name = Column(String(100), nullable=False)
    quantity = Column(Integer, nullable=False)
    price = Column(Float, nullable=False)
    order_date = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Обратное отношение
    user = relationship("User", back_populates="orders")
    
    def __repr__(self):
        return f"<Order(product='{self.product_name}', quantity={self.quantity}, price={self.price})>"

# Создание таблиц в базе данных
Base.metadata.create_all(engine)

# Создание сессии
Session = sessionmaker(bind=engine)
session = Session()

# Добавление данных
try:
    # Создание пользователя
    new_user = User(name="John Doe", email="john@example.com", age=30)
    session.add(new_user)
    session.flush()  # Чтобы получить ID пользователя
    
    # Создание заказов для пользователя
    orders = [
        Order(user_id=new_user.id, product_name="Phone", quantity=1, price=999.99),
        Order(user_id=new_user.id, product_name="Headphones", quantity=2, price=59.99),
        Order(user_id=new_user.id, product_name="Charger", quantity=3, price=19.99)
    ]
    session.add_all(orders)
    
    # Фиксируем изменения
    session.commit()
    print(f"Пользователь и заказы успешно добавлены.")

except Exception as e:
    # Откатываем изменения в случае ошибки
    session.rollback()
    print(f"Ошибка: {e}")

finally:
    # Закрываем сессию
    session.close()

# Запросы через ORM
session = Session()

try:
    # Выборка всех пользователей
    users = session.query(User).all()
    for user in users:
        print(f"Пользователь: {user.name}, Email: {user.email}")
        
        # Выборка заказов пользователя
        for order in user.orders:
            print(f"  Заказ: {order.product_name}, Количество: {order.quantity}, Цена: {order.price}")
    
    # Сложный запрос с условиями
    expensive_orders = session.query(Order).filter(
        Order.price > 50,
        Order.quantity > 1
    ).order_by(Order.price.desc()).all()
    
    print("\nДорогие заказы:")
    for order in expensive_orders:
        print(f"{order.product_name}: ${order.price} x {order.quantity}")
    
    # Запрос с JOIN
    user_orders = session.query(
        User.name,
        User.email,
        Order.product_name,
        Order.price,
        Order.quantity
    ).join(Order, User.id == Order.user_id).filter(
        Order.price > 20
    ).all()
    
    print("\nЗаказы пользователей:")
    for name, email, product, price, quantity in user_orders:
        print(f"{name} ({email}): {product}, ${price} x {quantity}")
    
    # Агрегатные функции
    from sqlalchemy import func
    
    total_spent = session.query(
        User.name,
        func.sum(Order.price * Order.quantity).label('total')
    ).join(Order).group_by(User.id).order_by(func.sum(Order.price * Order.quantity).desc()).all()
    
    print("\nОбщая сумма заказов по пользователям:")
    for name, total in total_spent:
        print(f"{name}: ${total:.2f}")

except Exception as e:
    print(f"Ошибка при выполнении запросов: {e}")

finally:
    session.close()
```

## Практические примеры

### Пример 1: Система управления библиотекой с PostgreSQL

```python
import psycopg2
import psycopg2.extras
import datetime

class LibraryManager:
    def __init__(self, host='localhost', database='library_db', user='postgres', password='password'):
        """Инициализация менеджера библиотеки"""
        self.connection_params = {
            'host': host,
            'database': database,
            'user': user,
            'password': password
        }
        self.create_tables()
    
    def create_tables(self):
        """Создание необходимых таблиц"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor() as cursor:
                # Таблица авторов
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS authors (
                    author_id SERIAL PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    birth_year INTEGER,
                    nationality VARCHAR(50)
                )
                ''')
                
                # Таблица категорий
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS categories (
                    category_id SERIAL PRIMARY KEY,
                    name VARCHAR(50) NOT NULL UNIQUE
                )
                ''')
                
                # Таблица книг
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS books (
                    book_id SERIAL PRIMARY KEY,
                    title VARCHAR(200) NOT NULL,
                    author_id INTEGER REFERENCES authors(author_id),
                    category_id INTEGER REFERENCES categories(category_id),
                    isbn VARCHAR(20) UNIQUE,
                    publication_year INTEGER,
                    description TEXT,
                    available BOOLEAN DEFAULT TRUE
                )
                ''')
                
                # Таблица читателей
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS members (
                    member_id SERIAL PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    email VARCHAR(100) UNIQUE NOT NULL,
                    phone VARCHAR(20),
                    join_date DATE DEFAULT CURRENT_DATE
                )
                ''')
                
                # Таблица выдачи книг
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS loans (
                    loan_id SERIAL PRIMARY KEY,
                    book_id INTEGER REFERENCES books(book_id),
                    member_id INTEGER REFERENCES members(member_id),
                    loan_date DATE NOT NULL DEFAULT CURRENT_DATE,
                    due_date DATE NOT NULL,
                    return_date DATE,
                    CONSTRAINT check_dates CHECK (return_date IS NULL OR return_date >= loan_date)
                )
                ''')
                
                conn.commit()
                print("Таблицы успешно созданы")
    
    def add_sample_data(self):
        """Добавление тестовых данных"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor() as cursor:
                # Добавление авторов
                cursor.execute('''
                INSERT INTO authors (name, birth_year, nationality)
                VALUES 
                    ('Лев Толстой', 1828, 'Россия'),
                    ('Джордж Оруэлл', 1903, 'Великобритания'),
                    ('Харпер Ли', 1926, 'США')
                ON CONFLICT (author_id) DO NOTHING
                RETURNING author_id
                ''')
                
                # Добавление категорий
                cursor.execute('''
                INSERT INTO categories (name)
                VALUES 
                    ('Роман'),
                    ('Научная фантастика'),
                    ('Детектив'),
                    ('Классическая литература')
                ON CONFLICT (name) DO NOTHING
                RETURNING category_id
                ''')
                
                # Добавление книг
                cursor.execute('''
                INSERT INTO books (title, author_id, category_id, isbn, publication_year, description)
                VALUES 
                    ('Война и мир', 1, 4, '9780198800545', 1869, 'Эпический роман о России в эпоху наполеоновских войн'),
                    ('1984', 2, 2, '9780451524935', 1949, 'Антиутопический роман о тоталитарном обществе'),
                    ('Убить пересмешника', 3, 1, '9780061120084', 1960, 'Роман о расовой несправедливости в США')
                ON CONFLICT (isbn) DO NOTHING
                RETURNING book_id
                ''')
                
                # Добавление читателей
                cursor.execute('''
                INSERT INTO members (name, email, phone)
                VALUES 
                    ('Иван Иванов', 'ivan@example.com', '+7-900-123-4567'),
                    ('Анна Петрова', 'anna@example.com', '+7-900-765-4321'),
                    ('Сергей Сидоров', 'sergey@example.com', '+7-900-555-5555')
                ON CONFLICT (email) DO NOTHING
                RETURNING member_id
                ''')
                
                conn.commit()
                print("Тестовые данные успешно добавлены")
    
    def add_book(self, title, author_id, category_id, isbn=None, publication_year=None, description=None):
        """Добавление новой книги"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor() as cursor:
                try:
                    cursor.execute('''
                    INSERT INTO books (title, author_id, category_id, isbn, publication_year, description)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    RETURNING book_id
                    ''', (title, author_id, category_id, isbn, publication_year, description))
                    
                    book_id = cursor.fetchone()[0]
                    conn.commit()
                    print(f"Книга '{title}' успешно добавлена с ID {book_id}")
                    return book_id
                except psycopg2.IntegrityError as e:
                    conn.rollback()
                    if "duplicate key value violates unique constraint" in str(e):
                        print(f"Ошибка: Книга с ISBN {isbn} уже существует")
                    else:
                        print(f"Ошибка при добавлении книги: {e}")
                    return None
    
    def list_books(self, available_only=False):
        """Список книг с информацией об авторе и категории"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                query = '''
                SELECT 
                    b.book_id,
                    b.title,
                    b.isbn,
                    b.publication_year,
                    b.available,
                    a.name AS author_name,
                    c.name AS category_name
                FROM books b
                JOIN authors a ON b.author_id = a.author_id
                JOIN categories c ON b.category_id = c.category_id
                '''
                
                if available_only:
                    query += ' WHERE b.available = TRUE'
                
                query += ' ORDER BY b.title'
                
                cursor.execute(query)
                books = cursor.fetchall()
                
                if not books:
                    print("Книги не найдены")
                else:
                    print(f"Найдено {len(books)} книг:")
                    for book in books:
                        status = "доступна" if book['available'] else "выдана"
                        print(f"{book['book_id']}: '{book['title']}' "
                              f"({book['publication_year'] or 'Год не указан'}) "
                              f"- {book['author_name']} [{book['category_name']}] - {status}")
                
                return books
    
    def search_books(self, search_term):
        """Поиск книг по названию или автору"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute('''
                SELECT 
                    b.book_id,
                    b.title,
                    b.isbn,
                    b.publication_year,
                    b.available,
                    a.name AS author_name,
                    c.name AS category_name
                FROM books b
                JOIN authors a ON b.author_id = a.author_id
                JOIN categories c ON b.category_id = c.category_id
                WHERE b.title ILIKE %s OR a.name ILIKE %s
                ORDER BY b.title
                ''', (f'%{search_term}%', f'%{search_term}%'))
                
                books = cursor.fetchall()
                
                if not books:
                    print(f"Книги по запросу '{search_term}' не найдены")
                else:
                    print(f"Найдено {len(books)} книг по запросу '{search_term}':")
                    for book in books:
                        status = "доступна" if book['available'] else "выдана"
                        print(f"{book['book_id']}: '{book['title']}' "
                              f"- {book['author_name']} [{book['category_name']}] - {status}")
                
                return books
    
    def loan_book(self, book_id, member_id, loan_days=14):
        """Выдача книги читателю"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                try:
                    # Проверяем доступность книги
                    cursor.execute('''
                    SELECT title, available FROM books WHERE book_id = %s
                    ''', (book_id,))
                    
                    book = cursor.fetchone()
                    if not book:
                        print(f"Ошибка: Книга с ID {book_id} не найдена")
                        return False
                    
                    if not book['available']:
                        print(f"Ошибка: Книга '{book['title']}' уже выдана")
                        return False
                    
                    # Проверяем существование читателя
                    cursor.execute('''
                    SELECT name FROM members WHERE member_id = %s
                    ''', (member_id,))
                    
                    member = cursor.fetchone()
                    if not member:
                        print(f"Ошибка: Читатель с ID {member_id} не найден")
                        return False
                    
                    # Определяем даты
                    loan_date = datetime.date.today()
                    due_date = loan_date + datetime.timedelta(days=loan_days)
                    
                    # Начинаем транзакцию
                    # Создаем запись о выдаче
                    cursor.execute('''
                    INSERT INTO loans (book_id, member_id, loan_date, due_date)
                    VALUES (%s, %s, %s, %s)
                    RETURNING loan_id
                    ''', (book_id, member_id, loan_date, due_date))
                    
                    loan_id = cursor.fetchone()[0]
                    
                    # Обновляем статус книги
                    cursor.execute('''
                    UPDATE books SET available = FALSE WHERE book_id = %s
                    ''', (book_id,))
                    
                    conn.commit()
                    print(f"Книга '{book['title']}' выдана читателю {member['name']} до {due_date}")
                    return loan_id
                
                except Exception as e:
                    conn.rollback()
                    print(f"Ошибка при выдаче книги: {e}")
                    return None
    
    def return_book(self, book_id):
        """Возврат книги"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                try:
                    # Проверяем существование книги
                    cursor.execute('''
                    SELECT title, available FROM books WHERE book_id = %s
                    ''', (book_id,))
                    
                    book = cursor.fetchone()
                    if not book:
                        print(f"Ошибка: Книга с ID {book_id} не найдена")
                        return False
                    
                    if book['available']:
                        print(f"Ошибка: Книга '{book['title']}' не числится как выданная")
                        return False
                    
                    # Находим активную выдачу
                    cursor.execute('''
                    SELECT l.loan_id, l.loan_date, l.due_date, m.name as member_name
                    FROM loans l
                    JOIN members m ON l.member_id = m.member_id
                    WHERE l.book_id = %s AND l.return_date IS NULL
                    ''', (book_id,))
                    
                    loan = cursor.fetchone()
                    if not loan:
                        print(f"Ошибка: Активная выдача для книги с ID {book_id} не найдена")
                        return False
                    
                    # Обновляем запись о выдаче
                    return_date = datetime.date.today()
                    cursor.execute('''
                    UPDATE loans SET return_date = %s WHERE loan_id = %s
                    ''', (return_date, loan['loan_id']))
                    
                    # Обновляем статус книги
                    cursor.execute('''
                    UPDATE books SET available = TRUE WHERE book_id = %s
                    ''', (book_id,))
                    
                    conn.commit()
                    
                    # Проверяем, просрочена ли книга
                    is_overdue = return_date > loan['due_date']
                    status = "просрочена" if is_overdue else "возвращена вовремя"
                    
                    print(f"Книга '{book['title']}' возвращена читателем {loan['member_name']} ({status})")
                    return True
                
                except Exception as e:
                    conn.rollback()
                    print(f"Ошибка при возврате книги: {e}")
                    return False
    
    def get_overdue_loans(self):
        """Получение списка просроченных книг"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                today = datetime.date.today()
                
                cursor.execute('''
                SELECT 
                    l.loan_id,
                    l.loan_date,
                    l.due_date,
                    b.book_id,
                    b.title,
                    m.member_id,
                    m.name AS member_name,
                    m.email,
                    m.phone
                FROM loans l
                JOIN books b ON l.book_id = b.book_id
                JOIN members m ON l.member_id = m.member_id
                WHERE l.return_date IS NULL AND l.due_date < %s
                ORDER BY l.due_date
                ''', (today,))
                
                overdue_loans = cursor.fetchall()
                
                if not overdue_loans:
                    print("Просроченных книг нет")
                else:
                    print(f"Найдено {len(overdue_loans)} просроченных книг:")
                    for loan in overdue_loans:
                        days_overdue = (today - loan['due_date']).days
                        print(f"Книга: '{loan['title']}', Читатель: {loan['member_name']}, "
                              f"Срок: {loan['due_date']}, Просрочено на {days_overdue} дней")
                
                return overdue_loans
    
    def get_library_stats(self):
        """Получение статистики библиотеки"""
        with psycopg2.connect(**self.connection_params) as conn:
            with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                stats = {}
                
                # Общее количество книг
                cursor.execute("SELECT COUNT(*) FROM books")
                stats['total_books'] = cursor.fetchone()[0]
                
                # Количество доступных книг
                cursor.execute("SELECT COUNT(*) FROM books WHERE available = TRUE")
                stats['available_books'] = cursor.fetchone()[0]
                
                # Количество выданных книг
                cursor.execute("SELECT COUNT(*) FROM books WHERE available = FALSE")
                stats['loaned_books'] = cursor.fetchone()[0]
                
                # Количество читателей
                cursor.execute("SELECT COUNT(*) FROM members")
                stats['total_members'] = cursor.fetchone()[0]
                
                # Количество активных выдач
                cursor.execute("SELECT COUNT(*) FROM loans WHERE return_date IS NULL")
                stats['active_loans'] = cursor.fetchone()[0]
                
                # Количество просроченных книг
                cursor.execute('''
                SELECT COUNT(*) FROM loans 
                WHERE return_date IS NULL AND due_date < CURRENT_DATE
                ''')
                stats['overdue_loans'] = cursor.fetchone()[0]
                
                # Самые популярные книги
                cursor.execute('''
                SELECT 
                    b.title,
                    a.name AS author_name,
                    COUNT(l.loan_id) AS loan_count
                FROM books b
                JOIN authors a ON b.author_id = a.author_id
                JOIN loans l ON b.book_id = l.book_id
                GROUP BY b.book_id, b.title, a.name
                ORDER BY loan_count DESC
                LIMIT 5
                ''')
                stats['popular_books'] = cursor.fetchall()
                
                # Самые активные читатели
                cursor.execute('''
                SELECT 
                    m.name,
                    COUNT(l.loan_id) AS loan_count
                FROM members m
                JOIN loans l ON m.member_id = l.member_id
                GROUP BY m.member_id, m.name
                ORDER BY loan_count DESC
                LIMIT 5
                ''')
                stats['active_members'] = cursor.fetchall()
                
                # Количество книг по категориям
                cursor.execute('''
                SELECT 
                    c.name,
                    COUNT(b.book_id) AS book_count
                FROM categories c
                JOIN books b ON c.category_id = b.category_id
                GROUP BY c.category_id, c.name
                ORDER BY book_count DESC
                ''')
                stats['books_by_category'] = cursor.fetchall()
                
                # Вывод статистики
                print("\n=== Статистика библиотеки ===")
                print(f"Всего книг: {stats['total_books']}")
                print(f"Доступных книг: {stats['available_books']}")
                print(f"Выданных книг: {stats['loaned_books']}")
                print(f"Всего читателей: {stats['total_members']}")
                print(f"Активных выдач: {stats['active_loans']}")
                print(f"Просроченных книг: {stats['overdue_loans']}")
                
                if stats['popular_books']:
                    print("\nСамые популярные книги:")
                    for book in stats['popular_books']:
                        print(f"- '{book['title']}' ({book['author_name']}) - {book['loan_count']} выдач")
                
                if stats['active_members']:
                    print("\nСамые активные читатели:")
                    for member in stats['active_members']:
                        print(f"- {member['name']} - {member['loan_count']} книг")
                
                if stats['books_by_category']:
                    print("\nКниги по категориям:")
                    for category in stats['books_by_category']:
                        print(f"- {category['name']}: {category['book_count']} книг")
                
                return stats

# Пример использования
if __name__ == "__main__":
    # Подключение к PostgreSQL
    library = LibraryManager(database='library_db', user='postgres', password='password')
    
    # Добавление тестовых данных
    library.add_sample_data()
    
    # Список всех книг
    print("\n=== Список всех книг ===")
    library.list_books()
    
    # Поиск книг
    print("\n=== Поиск книг ===")
    library.search_books("Война")
    
    # Выдача книги
    print("\n=== Выдача книги ===")
    library.loan_book(1, 1, loan_days=7)
    
    # Список доступных книг
    print("\n=== Список доступных книг ===")
    library.list_books(available_only=True)
    
    # Просроченные книги
    print("\n=== Просроченные книги ===")
    library.get_overdue_loans()
    
    # Возврат книги
    print("\n=== Возврат книги ===")
    library.return_book(1)
    
    # Получение статистики
    library.get_library_stats()
```

### Пример 2: Система отслеживания расходов с MySQL

```python
import mysql.connector
from mysql.connector import Error
import datetime
from decimal import Decimal

class ExpenseTracker:
    def __init__(self, host='localhost', database='expense_db', user='root', password='password'):
        """Инициализация трекера расходов"""
        self.config = {
            'host': host,
            'database': database,
            'user': user,
            'password': password,
            'autocommit': False
        }
        self.create_database()
        self.create_tables()
    
    def create_database(self):
        """Создание базы данных, если она не существует"""
        try:
            # Подключение без указания базы данных
            conn = mysql.connector.connect(
                host=self.config['host'],
                user=self.config['user'],
                password=self.config['password']
            )
            
            with conn.cursor() as cursor:
                # Создание базы данных
                cursor.execute(f"CREATE DATABASE IF NOT EXISTS {self.config['database']}")
                print(f"База данных {self.config['database']} создана или уже существует")
            
            conn.close()
        
        except Error as e:
            print(f"Ошибка при создании базы данных: {e}")
    
    def create_tables(self):
        """Создание необходимых таблиц"""
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    # Таблица категорий
                    cursor.execute('''
                    CREATE TABLE IF NOT EXISTS categories (
                        category_id INT AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(50) NOT NULL UNIQUE,
                        description VARCHAR(255)
                    ) ENGINE=InnoDB
                    ''')
                    
                    # Таблица расходов
                    cursor.execute('''
                    CREATE TABLE IF NOT EXISTS expenses (
                        expense_id INT AUTO_INCREMENT PRIMARY KEY,
                        amount DECIMAL(10, 2) NOT NULL,
                        description VARCHAR(255),
                        date DATE NOT NULL,
                        category_id INT,
                        payment_method VARCHAR(50),
                        FOREIGN KEY (category_id) REFERENCES categories(category_id)
                    ) ENGINE=InnoDB
                    ''')
                    
                    # Таблица доходов
                    cursor.execute('''
                    CREATE TABLE IF NOT EXISTS income (
                        income_id INT AUTO_INCREMENT PRIMARY KEY,
                        amount DECIMAL(10, 2) NOT NULL,
                        description VARCHAR(255),
                        date DATE NOT NULL,
                        source VARCHAR(100) NOT NULL
                    ) ENGINE=InnoDB
                    ''')
                    
                    # Таблица бюджетов
                    cursor.execute('''
                    CREATE TABLE IF NOT EXISTS budgets (
                        budget_id INT AUTO_INCREMENT PRIMARY KEY,
                        category_id INT,
                        amount DECIMAL(10, 2) NOT NULL,
                        start_date DATE NOT NULL,
                        end_date DATE NOT NULL,
                        FOREIGN KEY (category_id) REFERENCES categories(category_id),
                        CHECK (end_date >= start_date)
                    ) ENGINE=InnoDB
                    ''')
                    
                    conn.commit()
                    print("Таблицы успешно созданы")
        
        except Error as e:
            print(f"Ошибка при создании таблиц: {e}")
    
    def add_default_categories(self):
        """Добавление стандартных категорий расходов"""
        categories = [
            ("Продукты", "Продукты питания и напитки"),
            ("Жилье", "Аренда, коммунальные платежи, ремонт"),
            ("Транспорт", "Общественный транспорт, такси, бензин"),
            ("Развлечения", "Кино, концерты, мероприятия"),
            ("Здоровье", "Лекарства, визиты к врачу, страховка"),
            ("Одежда", "Одежда, обувь, аксессуары"),
            ("Рестораны", "Кафе, рестораны, доставка еды"),
            ("Образование", "Курсы, книги, обучение"),
            ("Путешествия", "Отели, билеты, экскурсии")
        ]
        
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    for name, description in categories:
                        try:
                            cursor.execute('''
                            INSERT INTO categories (name, description)
                            VALUES (%s, %s)
                            ''', (name, description))
                        except mysql.connector.IntegrityError:
                            # Категория уже существует, пропускаем
                            pass
                    
                    conn.commit()
                    print("Стандартные категории добавлены")
        
        except Error as e:
            print(f"Ошибка при добавлении категорий: {e}")
    
    def add_expense(self, amount, description, date, category_id, payment_method=None):
        """Добавление нового расхода"""
        try:
            if isinstance(amount, str):
                amount = Decimal(amount.replace(',', '.'))
            
            if isinstance(date, str):
                date = datetime.datetime.strptime(date, "%Y-%m-%d").date()
            
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    cursor.execute('''
                    INSERT INTO expenses (amount, description, date, category_id, payment_method)
                    VALUES (%s, %s, %s, %s, %s)
                    ''', (amount, description, date, category_id, payment_method))
                    
                    conn.commit()
                    expense_id = cursor.lastrowid
                    print(f"Расход добавлен с ID {expense_id}")
                    return expense_id
        
        except Error as e:
            print(f"Ошибка при добавлении расхода: {e}")
            return None
    
    def add_income(self, amount, description, date, source):
        """Добавление нового дохода"""
        try:
            if isinstance(amount, str):
                amount = Decimal(amount.replace(',', '.'))
            
            if isinstance(date, str):
                date = datetime.datetime.strptime(date, "%Y-%m-%d").date()
            
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    cursor.execute('''
                    INSERT INTO income (amount, description, date, source)
                    VALUES (%s, %s, %s, %s)
                    ''', (amount, description, date, source))
                    
                    conn.commit()
                    income_id = cursor.lastrowid
                    print(f"Доход добавлен с ID {income_id}")
                    return income_id
        
        except Error as e:
            print(f"Ошибка при добавлении дохода: {e}")
            return None
    
    def create_budget(self, category_id, amount, start_date, end_date):
        """Создание бюджета для категории на период"""
        try:
            if isinstance(amount, str):
                amount = Decimal(amount.replace(',', '.'))
            
            if isinstance(start_date, str):
                start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
            
            if isinstance(end_date, str):
                end_date = datetime.datetime.strptime(end_date, "%Y-%m-%d").date()
            
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    # Проверяем существование категории
                    cursor.execute("SELECT name FROM categories WHERE category_id = %s", (category_id,))
                    category = cursor.fetchone()
                    
                    if not category:
                        print(f"Ошибка: Категория с ID {category_id} не найдена")
                        return None
                    
                    # Создаем бюджет
                    cursor.execute('''
                    INSERT INTO budgets (category_id, amount, start_date, end_date)
                    VALUES (%s, %s, %s, %s)
                    ''', (category_id, amount, start_date, end_date))
                    
                    conn.commit()
                    budget_id = cursor.lastrowid
                    print(f"Бюджет создан с ID {budget_id} для категории '{category[0]}'")
                    return budget_id
        
        except Error as e:
            print(f"Ошибка при создании бюджета: {e}")
            return None
    
    def get_expenses(self, start_date=None, end_date=None, category_id=None):
        """Получение списка расходов с возможностью фильтрации"""
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor(dictionary=True) as cursor:
                    query = '''
                    SELECT 
                        e.expense_id,
                        e.amount,
                        e.description,
                        e.date,
                        e.payment_method,
                        c.category_id,
                        c.name AS category_name
                    FROM expenses e
                    LEFT JOIN categories c ON e.category_id = c.category_id
                    WHERE 1=1
                    '''
                    
                    params = []
                    
                    if start_date:
                        if isinstance(start_date, str):
                            start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                        query += " AND e.date >= %s"
                        params.append(start_date)
                    
                    if end_date:
                        if isinstance(end_date, str):
                            end_date = datetime.datetime.strptime(end_date, "%Y-%m-%d").date()
                        query += " AND e.date <= %s"
                        params.append(end_date)
                    
                    if category_id:
                        query += " AND e.category_id = %s"
                        params.append(category_id)
                    
                    query += " ORDER BY e.date DESC, e.expense_id DESC"
                    
                    cursor.execute(query, params)
                    expenses = cursor.fetchall()
                    
                    return expenses
        
        except Error as e:
            print(f"Ошибка при получении расходов: {e}")
            return []
    
    def get_income(self, start_date=None, end_date=None):
        """Получение списка доходов с возможностью фильтрации"""
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor(dictionary=True) as cursor:
                    query = '''
                    SELECT 
                        income_id,
                        amount,
                        description,
                        date,
                        source
                    FROM income
                    WHERE 1=1
                    '''
                    
                    params = []
                    
                    if start_date:
                        if isinstance(start_date, str):
                            start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                        query += " AND date >= %s"
                        params.append(start_date)
                    
                    if end_date:
                        if isinstance(end_date, str):
                            end_date = datetime.datetime.strptime(end_date, "%Y-%m-%d").date()
                        query += " AND date <= %s"
                        params.append(end_date)
                    
                    query += " ORDER BY date DESC, income_id DESC"
                    
                    cursor.execute(query, params)
                    income = cursor.fetchall()
                    
                    return income
        
        except Error as e:
            print(f"Ошибка при получении доходов: {e}")
            return []
    
    def get_expenses_by_category(self, start_date=None, end_date=None):
        """Анализ расходов по категориям"""
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor(dictionary=True) as cursor:
                    query = '''
                    SELECT 
                        c.category_id,
                        c.name AS category_name,
                        SUM(e.amount) AS total_amount,
                        COUNT(e.expense_id) AS expense_count
                    FROM categories c
                    LEFT JOIN expenses e ON c.category_id = e.category_id
                    '''
                    
                    params = []
                    where_clause = []
                    
                    if start_date:
                        if isinstance(start_date, str):
                            start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                        where_clause.append("e.date >= %s")
                        params.append(start_date)
                    
                    if end_date:
                        if isinstance(end_date, str):
                            end_date = datetime.datetime.strptime(end_date, "%Y-%m-%d").date()
                        where_clause.append("e.date <= %s")
                        params.append(end_date)
                    
                    if where_clause:
                        query += " WHERE " + " AND ".join(where_clause)
                    
                    query += " GROUP BY c.category_id, c.name ORDER BY total_amount DESC"
                    
                    cursor.execute(query, params)
                    categories = cursor.fetchall()
                    
                    return categories
        
        except Error as e:
            print(f"Ошибка при анализе расходов по категориям: {e}")
            return []
    
    def get_budget_status(self, start_date=None, end_date=None):
        """Получение статуса бюджетов с фактическими расходами"""
        # Если даты не указаны, используем текущий месяц
        if not start_date and not end_date:
            today = datetime.date.today()
            start_date = datetime.date(today.year, today.month, 1)
            # Последний день месяца
            if today.month == 12:
                end_date = datetime.date(today.year, 12, 31)
            else:
                end_date = datetime.date(today.year, today.month + 1, 1) - datetime.timedelta(days=1)
        
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor(dictionary=True) as cursor:
                    query = '''
                    SELECT 
                        b.budget_id,
                        c.category_id,
                        c.name AS category_name,
                        b.amount AS budget_amount,
                        b.start_date,
                        b.end_date,
                        COALESCE(SUM(e.amount), 0) AS spent_amount
                    FROM budgets b
                    JOIN categories c ON b.category_id = c.category_id
                    LEFT JOIN expenses e ON e.category_id = c.category_id 
                        AND e.date BETWEEN b.start_date AND b.end_date
                    WHERE b.start_date <= %s AND b.end_date >= %s
                    GROUP BY b.budget_id, c.category_id, c.name, b.amount, b.start_date, b.end_date
                    ORDER BY (COALESCE(SUM(e.amount), 0) / b.amount) DESC
                    '''
                    
                    cursor.execute(query, (end_date, start_date))
                    budgets = cursor.fetchall()
                    
                    # Вычисляем дополнительные поля
                    for budget in budgets:
                        budget['remaining'] = budget['budget_amount'] - budget['spent_amount']
                        if budget['budget_amount'] > 0:
                            budget['percentage'] = (budget['spent_amount'] / budget['budget_amount']) * 100
                        else:
                            budget['percentage'] = 0
                    
                    return budgets
        
        except Error as e:
            print(f"Ошибка при получении статуса бюджетов: {e}")
            return []
    
    def get_monthly_summary(self, year=None, month=None):
        """Получение ежемесячной сводки доходов и расходов"""
        # Если год и месяц не указаны, используем текущий месяц
        if not year or not month:
            today = datetime.date.today()
            year = today.year
            month = today.month
        
        # Определение начала и конца месяца
        start_date = datetime.date(year, month, 1)
        # Последний день месяца
        if month == 12:
            end_date = datetime.date(year, 12, 31)
        else:
            end_date = datetime.date(year, month + 1, 1) - datetime.timedelta(days=1)
        
        try:
            with mysql.connector.connect(**self.config) as conn:
                with conn.cursor() as cursor:
                    # Общая сумма расходов
                    cursor.execute('''
                    SELECT COALESCE(SUM(amount), 0) FROM expenses
                    WHERE date BETWEEN %s AND %s
                    ''', (start_date, end_date))
                    total_expenses = cursor.fetchone()[0]
                    
                    # Общая сумма доходов
                    cursor.execute('''
                    SELECT COALESCE(SUM(amount), 0) FROM income
                    WHERE date BETWEEN %s AND %s
                    ''', (start_date, end_date))
                    total_income = cursor.fetchone()[0]
                    
                    # Баланс
                    balance = total_income - total_expenses
                    
                    # Расходы по категориям
                    expenses_by_category = self.get_expenses_by_category(start_date, end_date)
                    
                    # Статус бюджетов
                    budget_status = self.get_budget_status(start_date, end_date)
                    
                    # Формируем сводку
                    summary = {
                        'year': year,
                        'month': month,
                        'start_date': start_date,
                        'end_date': end_date,
                        'total_income': float(total_income),
                        'total_expenses': float(total_expenses),
                        'balance': float(balance),
                        'expenses_by_category': expenses_by_category,
                        'budget_status': budget_status
                    }
                    
                    return summary
        
        except Error as e:
            print(f"Ошибка при получении ежемесячной сводки: {e}")
            return None
    
    def display_monthly_summary(self, summary):
        """Отображение ежемесячной сводки в консоли"""
        if not summary:
            print("Данные для сводки отсутствуют")
            return
        
        month_name = summary['start_date'].strftime('%B')
        
        print(f"\n=== Финансовая сводка за {month_name} {summary['year']} ===")
        print(f"Период: {summary['start_date']} - {summary['end_date']}")
        print(f"Общий доход: {summary['total_income']:.2f}")
        print(f"Общие расходы: {summary['total_expenses']:.2f}")
        print(f"Баланс: {summary['balance']:.2f}")
        
        if summary['expenses_by_category']:
            print("\nРасходы по категориям:")
            for category in summary['expenses_by_category']:
                if category['expense_count'] > 0:
                    print(f"- {category['category_name']}: {float(category['total_amount']):.2f} "
                          f"({category['expense_count']} {self._pluralize(category['expense_count'], 'расход', 'расхода', 'расходов')})")
        
        if summary['budget_status']:
            print("\nСтатус бюджетов:")
            for budget in summary['budget_status']:
                status = "Превышен" if budget['remaining'] < 0 else "В норме"
                print(f"- {budget['category_name']}: {float(budget['spent_amount']):.2f} из {float(budget['budget_amount']):.2f} "
                      f"({budget['percentage']:.1f}%) - {status}")
                
                # Визуализация прогресса