# 2.1. Объектно-ориентированное программирование в Python

## Содержание
- [Основные концепции ООП](#основные-концепции-ооп)
- [Классы и объекты](#классы-и-объекты)
- [Наследование](#наследование)
- [Инкапсуляция](#инкапсуляция)
- [Полиморфизм](#полиморфизм)
- [Специальные методы](#специальные-методы)
- [Атрибуты класса и экземпляра](#атрибуты-класса-и-экземпляра)
- [Методы класса и статические методы](#методы-класса-и-статические-методы)
- [Абстрактные классы и интерфейсы](#абстрактные-классы-и-интерфейсы)
- [Множественное наследование и MRO](#множественное-наследование-и-mro)
- [Миксины](#миксины)
- [Метаклассы](#метаклассы)
- [Принципы SOLID в Python](#принципы-solid-в-python)
- [Практические задачи](#практические-задачи)
- [Полезные ресурсы](#полезные-ресурсы)

## Основные концепции ООП

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые содержат данные (атрибуты) и код (методы). Python является полноценным объектно-ориентированным языком.

### Основные принципы ООП:

1. **Инкапсуляция** — объединение данных и методов, которые работают с этими данными, в одной единице (классе) и ограничение доступа к внутреннему устройству объекта.

2. **Наследование** — механизм, позволяющий создавать новые классы на основе существующих, перенимая и расширяя их функциональность.

3. **Полиморфизм** — возможность использовать один и тот же интерфейс для объектов разных типов.

4. **Абстракция** — выделение существенных характеристик объекта и игнорирование несущественных.

### Особенности ООП в Python:

- Python использует **динамическую типизацию**, что делает ООП более гибким, но менее строгим по сравнению с языками со статической типизацией.
- В Python "всё является объектом", даже примитивные типы данных, функции и классы.
- Python поддерживает **множественное наследование**.
- В Python нет явного объявления **private** или **protected** членов класса, вместо этого используются соглашения об именовании.

## Классы и объекты

### Определение класса

Класс — это шаблон для создания объектов. Он определяет атрибуты и методы, которые будут иметь все объекты этого класса.

```python
class Person:
    """Класс для представления человека."""
    
    def __init__(self, name, age):
        """Инициализация нового экземпляра Person."""
        self.name = name  # Атрибут экземпляра
        self.age = age    # Атрибут экземпляра
    
    def greet(self):
        """Метод для приветствия."""
        return f"Привет! Меня зовут {self.name}, мне {self.age} лет."
    
    def have_birthday(self):
        """Метод для увеличения возраста на 1 год."""
        self.age += 1
        return f"{self.name} теперь {self.age} лет."
```

### Создание и использование объектов

Объект (экземпляр класса) — это конкретная реализация класса с собственными значениями атрибутов.

```python
# Создание экземпляров класса Person
person1 = Person("Алиса", 30)
person2 = Person("Боб", 25)

# Использование методов
print(person1.greet())    # "Привет! Меня зовут Алиса, мне 30 лет."
print(person2.greet())    # "Привет! Меня зовут Боб, мне 25 лет."

# Изменение атрибутов
person1.age = 31
print(person1.age)        # 31

# Вызов метода
print(person2.have_birthday())  # "Боб теперь 26 лет."
print(person2.age)        # 26
```

### Метод `__init__`

Метод `__init__` — это специальный метод, который вызывается при создании нового экземпляра класса. Он используется для инициализации атрибутов объекта.

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.area = width * height  # Вычисляемый атрибут
```

### Параметр `self`

Параметр `self` — ссылка на текущий экземпляр класса. Он обязательно должен быть первым параметром в методах экземпляра.

```python
class Counter:
    def __init__(self, initial_value=0):
        self.value = initial_value
    
    def increment(self):
        self.value += 1
        return self.value
    
    def reset(self):
        self.value = 0
        return self.value
    
    def current_value(self):
        return self.value
```

### Документирование классов и методов

Хорошей практикой является добавление документации к классам и методам с помощью строк документации (docstrings).

```python
class BankAccount:
    """
    Класс для представления банковского счета.
    
    Attributes:
        owner (str): Владелец счета
        balance (float): Текущий баланс
        currency (str): Валюта счета
    """
    
    def __init__(self, owner, balance=0, currency="USD"):
        """
        Инициализирует новый банковский счет.
        
        Args:
            owner (str): Имя владельца счета
            balance (float, optional): Начальный баланс. По умолчанию 0.
            currency (str, optional): Валюта счета. По умолчанию "USD".
        """
        self.owner = owner
        self.balance = balance
        self.currency = currency
    
    def deposit(self, amount):
        """
        Пополняет счет на указанную сумму.
        
        Args:
            amount (float): Сумма для внесения на счет
            
        Returns:
            float: Новый баланс
            
        Raises:
            ValueError: Если сумма отрицательная
        """
        if amount <= 0:
            raise ValueError("Сумма депозита должна быть положительной")
        self.balance += amount
        return self.balance
```

## Наследование

Наследование позволяет создавать новые классы на основе существующих, перенимая и расширяя их функциональность.

### Базовое наследование

```python
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        return "Некоторый звук"
    
    def info(self):
        return f"{self.name} - это {self.species}"

# Подкласс, наследующий от Animal
class Dog(Animal):
    def __init__(self, name, breed):
        # Вызов конструктора родительского класса
        super().__init__(name, species="собака")
        self.breed = breed
    
    # Переопределение метода родительского класса
    def make_sound(self):
        return "Гав!"
    
    # Добавление нового метода
    def wag_tail(self):
        return f"{self.name} виляет хвостом"

# Создание экземпляра подкласса
my_dog = Dog("Барон", "лабрадор")
print(my_dog.info())       # "Барон - это собака"
print(my_dog.make_sound()) # "Гав!"
print(my_dog.wag_tail())   # "Барон виляет хвостом"
```

### Функция `super()`

Функция `super()` используется для вызова методов родительского класса. Это особенно полезно при переопределении методов.

```python
class ElectricCar(Car):
    def __init__(self, make, model, year, battery_capacity):
        # Вызов конструктора родительского класса
        super().__init__(make, model, year)
        self.battery_capacity = battery_capacity
    
    def describe_battery(self):
        return f"У этого автомобиля батарея ёмкостью {self.battery_capacity} кВт⋅ч."
    
    # Переопределение метода родительского класса с расширением
    def get_info(self):
        # Получение базовой информации от родительского класса
        base_info = super().get_info()
        # Добавление дополнительной информации
        return f"{base_info} Это электромобиль с батареей {self.battery_capacity} кВт⋅ч."
```

### Проверка наследования

```python
# Проверка является ли объект экземпляром класса
my_dog = Dog("Барон", "лабрадор")
print(isinstance(my_dog, Dog))     # True
print(isinstance(my_dog, Animal))  # True

# Проверка является ли класс подклассом другого класса
print(issubclass(Dog, Animal))     # True
print(issubclass(Animal, Dog))     # False
```

## Инкапсуляция

Инкапсуляция — это механизм, который связывает данные и методы, которые работают с этими данными, в единое целое (класс) и защищает внутреннее состояние объекта от непосредственного доступа извне.

### Соглашения об именовании в Python

В Python нет строгого механизма защиты атрибутов, вместо этого используются соглашения об именовании:

1. **Публичные** атрибуты и методы (без префикса): доступны для всех.
2. **Защищенные** (_protected_, с одним подчеркиванием `_`): считаются внутренними, но доступны для подклассов.
3. **Приватные** (_private_, с двумя подчеркиваниями `__`): имена преобразуются интерпретатором, чтобы затруднить доступ извне.

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner              # Публичный атрибут
        self._balance = balance         # "Защищенный" атрибут
        self.__account_number = "12345" # "Приватный" атрибут
    
    def deposit(self, amount):
        self._balance += amount
        return self._balance
    
    def withdraw(self, amount):
        if amount > self._balance:
            raise ValueError("Недостаточно средств")
        self._balance -= amount
        return self._balance
    
    def get_balance(self):
        return self._balance
    
    def _calculate_interest(self):
        # "Защищенный" метод
        return self._balance * 0.05
    
    def __generate_statement(self):
        # "Приватный" метод
        return f"Account: {self.__account_number}, Balance: {self._balance}"
    
    def print_statement(self):
        # Публичный метод, использующий приватный метод
        print(self.__generate_statement())

# Создание экземпляра
account = BankAccount("Алиса", 1000)

# Доступ к атрибутам
print(account.owner)            # "Алиса"
print(account._balance)         # 1000 (доступно, но не рекомендуется)
# print(account.__account_number)  # AttributeError: 'BankAccount' object has no attribute '__account_number'

# На самом деле, приватные атрибуты всё ещё доступны через манглинг имени:
print(account._BankAccount__account_number)  # "12345"
```

### Свойства (Properties)

Свойства (properties) — это специальный механизм в Python, который позволяет контролировать доступ к атрибутам класса через методы getter, setter и deleter.

```python
class Person:
    def __init__(self, first_name, last_name):
        self._first_name = first_name
        self._last_name = last_name
        self._full_name = f"{first_name} {last_name}"
    
    # Геттер - для получения значения
    @property
    def full_name(self):
        return self._full_name
    
    # Сеттер - для установки значения
    @full_name.setter
    def full_name(self, value):
        if not isinstance(value, str):
            raise TypeError("Полное имя должно быть строкой")
        parts = value.split()
        if len(parts) != 2:
            raise ValueError("Полное имя должно состоять из имени и фамилии")
        self._first_name, self._last_name = parts
        self._full_name = value
    
    # Делитер - для удаления значения
    @full_name.deleter
    def full_name(self):
        self._first_name = None
        self._last_name = None
        self._full_name = None
        print("Полное имя удалено")
    
    # Еще одно свойство (только для чтения)
    @property
    def initials(self):
        return f"{self._first_name[0]}.{self._last_name[0]}."

# Использование свойств
person = Person("Анна", "Смирнова")
print(person.full_name)  # "Анна Смирнова"
print(person.initials)   # "А.С."

# Изменение свойства
person.full_name = "Петр Иванов"
print(person.full_name)  # "Петр Иванов"
print(person.initials)   # "П.И."

# Удаление свойства
del person.full_name     # "Полное имя удалено"
print(person.full_name)  # None
```

### Дескрипторы

Дескрипторы — это объекты, которые определяют, как атрибуты будут обрабатываться при доступе, установке или удалении.

```python
class Validator:
    def __init__(self, min_value=None, max_value=None):
        self.min_value = min_value
        self.max_value = max_value
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__[self.name]
    
    def __set__(self, instance, value):
        if not isinstance(value, (int, float)):
            raise TypeError(f"{self.name} должен быть числом")
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{self.name} должен быть не меньше {self.min_value}")
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{self.name} должен быть не больше {self.max_value}")
        instance.__dict__[self.name] = value

class Person:
    age = Validator(min_value=0, max_value=120)
    height = Validator(min_value=0, max_value=300)
    weight = Validator(min_value=0, max_value=500)
    
    def __init__(self, name, age, height, weight):
        self.name = name
        self.age = age
        self.height = height
        self.weight = weight

# Использование
person = Person("Иван", 25, 180, 75)
print(person.age)  # 25

try:
    person.age = -5  # ValueError: age должен быть не меньше 0
except ValueError as e:
    print(e)

try:
    person.height = "высокий"  # TypeError: height должен быть числом
except TypeError as e:
    print(e)
```

## Полиморфизм

Полиморфизм позволяет объектам разных классов реагировать по-разному на одинаковые методы или операции.

### Перегрузка операторов

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __add__(self, other):
        """Оператор + (сложение векторов)"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __sub__(self, other):
        """Оператор - (вычитание векторов)"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    def __mul__(self, scalar):
        """Оператор * (умножение вектора на скаляр)"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __eq__(self, other):
        """Оператор == (сравнение векторов)"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return NotImplemented

# Использование
v1 = Vector(1, 2)
v2 = Vector(3, 4)

v3 = v1 + v2
print(v3)  # "Vector(4, 6)"

v4 = v1 * 2
print(v4)  # "Vector(2, 4)"

print(v1 == Vector(1, 2))  # True
print(v1 == v2)           # False
```

### Утиная типизация

"Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка."

Python использует динамическую типизацию и утиную типизацию, что означает, что тип объекта определяется его поведением (методами и атрибутами), а не наследованием от определенного класса.

```python
class Duck:
    def quack(self):
        return "Кря!"
    
    def swim(self):
        return "Плаваю как утка"

class Person:
    def quack(self):
        return "Я имитирую утку!"
    
    def swim(self):
        return "Я плаваю, но не как утка"

def make_it_quack_and_swim(thing):
    # Мы не проверяем тип объекта, только наличие нужных методов
    print(thing.quack())
    print(thing.swim())

# Использование
duck = Duck()
person = Person()

make_it_quack_and_swim(duck)
# "Кря!"
# "Плаваю как утка"

make_it_quack_and_swim(person)
# "Я имитирую утку!"
# "Я плаваю, но не как утка"
```

### Абстрактные базовые классы (ABC)

В отличие от утиной типизации, абстрактные базовые классы обеспечивают более строгое соответствие интерфейсу.

```python
from abc import ABC, abstractmethod

class Drawable(ABC):
    @abstractmethod
    def draw(self):
        pass

class Circle(Drawable):
    def __init__(self, radius):
        self.radius = radius
    
    def draw(self):
        return f"Рисую круг с радиусом {self.radius}"

class Square(Drawable):
    def __init__(self, side):
        self.side = side
    
    def draw(self):
        return f"Рисую квадрат со стороной {self.side}"

# Нельзя создать экземпляр абстрактного класса
try:
    drawable = Drawable()  # TypeError: Can't instantiate abstract class Drawable with abstract method draw
except TypeError as e:
    print(e)

# Но можно использовать его для проверки типа
circle = Circle(5)
square = Square(4)

def render(drawable):
    if isinstance(drawable, Drawable):
        print(drawable.draw())
    else:
        print("Объект не является отрисовываемым")

render(circle)  # "Рисую круг с радиусом 5"
render(square)  # "Рисую квадрат со стороной 4"
render("не отрисовываемый объект")  # "Объект не является отрисовываемым"
```

## Специальные методы

Python использует специальные методы (также называемые "магическими" или "dunder-методами" от "double underscore") для определения поведения классов в различных ситуациях.

### Основные специальные методы

```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
        self.current_page = 0
    
    def __str__(self):
        """Строковое представление для пользователя"""
        return f'"{self.title}" by {self.author}'
    
    def __repr__(self):
        """Строковое представление для отладки/разработки"""
        return f'Book(title="{self.title}", author="{self.author}", pages={self.pages})'
    
    def __len__(self):
        """Возвращает количество страниц в книге"""
        return self.pages
    
    def __getitem__(self, page):
        """Позволяет получить доступ к странице через индекс"""
        if not isinstance(page, int):
            raise TypeError("Индекс страницы должен быть целым числом")
        if page < 0 or page >= self.pages:
            raise IndexError("Страница не существует")
        return f"Содержимое страницы {page}"
    
    def __call__(self, page):
        """Позволяет вызывать экземпляр как функцию"""
        self.current_page = page
        return f"Переход на страницу {page}"
    
    def __bool__(self):
        """Определяет, как объект преобразуется в булево значение"""
        return self.pages > 0

# Использование
book = Book("Война и мир", "Лев Толстой", 1225)

# __str__
print(str(book))  # "Война и мир" by Лев Толстой
print(book)       # То же самое, неявно вызывает __str__

# __repr__
print(repr(book))  # Book(title="Война и мир", author="Лев Толстой", pages=1225)

# __len__
print(len(book))   # 1225

# __getitem__
print(book[10])    # "Содержимое страницы 10"

# __call__
print(book(42))    # "Переход на страницу 42"

# __bool__
if book:
    print("Книга существует")  # Выполнится, т.к. book.__bool__() вернет True
```

### Методы сравнения

```python
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __eq__(self, other):
        """Равенство (==)"""
        if isinstance(other, Temperature):
            return self.celsius == other.celsius
        elif isinstance(other, (int, float)):
            return self.celsius == other
        return NotImplemented
    
    def __lt__(self, other):
        """Меньше чем (<)"""
        if isinstance(other, Temperature):
            return self.celsius < other.celsius
        elif isinstance(other, (int, float)):
            return self.celsius < other
        return NotImplemented
    
    def __le__(self, other):
        """Меньше или равно (<=)"""
        if isinstance(other, Temperature):
            return self.celsius <= other.celsius
        elif isinstance(other, (int, float)):
            return self.celsius <= other
        return NotImplemented
    
    # Python автоматически определит __gt__, __ge__ и __ne__ на основе __lt__, __le__ и __eq__

# Использование
t1 = Temperature(20)
t2 = Temperature(25)
t3 = Temperature(20)

print(t1 == t3)  # True
print(t1 != t2)  # True
print(t1 < t2)   # True
print(t1 <= t3)  # True
print(t2 > t1)   # True
print(t2 >= t3)  # True

# Сравнение с числами
print(t1 == 20)  # True
print(t2 > 20)   # True
```

### Методы для управления атрибутами

```python
class Person:
    def __init__(self, name):
        self._name = name
        self._attributes = {}
    
    def __getattr__(self, name):
        """Вызывается, когда атрибут не найден обычным способом"""
        if name in self._attributes:
            return self._attributes[name]
        raise AttributeError(f"У объекта {self.__class__.__name__} нет атрибута {name}")
    
    def __setattr__(self, name, value):
        """Вызывается при любой попытке присвоить значение атрибуту"""
        if name.startswith('_'):
            # Для внутренних атрибутов используем стандартное поведение
            super().__setattr__(name, value)
        else:
            # Пользовательские атрибуты сохраняем в словаре
            self._attributes[name] = value
    
    def __delattr__(self, name):
        """Вызывается при удалении атрибута"""
        if name.startswith('_'):
            super().__delattr__(name)
        elif name in self._attributes:
            del self._attributes[name]
        else:
            raise AttributeError(f"У объекта {self.__class__.__name__} нет атрибута {name}")
    
    def __dir__(self):
        """Возвращает список атрибутов объекта"""
        standard_attrs = super().__dir__()
        return sorted(list(self._attributes.keys()) + standard_attrs)

# Использование
person = Person("Анна")
person.age = 30
person.city = "Москва"

print(person.age)  # 30
print(person.city)  # "Москва"

# Вызовет __getattr__
try:
    print(person.email)  # AttributeError: У объекта Person нет атрибута email
except AttributeError as e:
    print(e)

# Удаление атрибута
del person.age
try:
    print(person.age)  # AttributeError: У объекта Person нет атрибута age
except AttributeError as e:
    print(e)

# Список атрибутов
print(dir(person))  # Включает 'city' и стандартные атрибуты
```

### Методы для контроля создания экземпляров

```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Вызывается при создании экземпляра для выделения памяти"""
        if cls._instance is None:
            # Создаем экземпляр только если он еще не существует
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, name=None):
        # Инициализация выполняется при каждом вызове конструктора
        # Будьте осторожны с изменением атрибутов в __init__ для синглтона
        if not hasattr(self, 'name') or name is not None:
            self.name = name

# Использование
s1 = Singleton("Первый")
s2 = Singleton("Второй")

print(s1 is s2)  # True - это один и тот же объект
print(s1.name)   # "Второй" - имя было перезаписано
```

## Атрибуты класса и экземпляра

### Атрибуты класса

Атрибуты класса принадлежат классу и являются общими для всех экземпляров. Они определяются на уровне класса, вне методов.

```python
class Student:
    # Атрибуты класса
    school_name = "Школа №1"
    total_students = 0
    
    def __init__(self, name, grade):
        # Атрибуты экземпляра
        self.name = name
        self.grade = grade
        Student.total_students += 1
    
    def get_info(self):
        return f"{self.name}, {self.grade} класс, {self.school_name}"

# Доступ к атрибутам класса через класс
print(Student.school_name)    # "Школа №1"
print(Student.total_students)  # 0 (пока нет экземпляров)

# Создание экземпляров
student1 = Student("Анна", 10)
student2 = Student("Иван", 11)

print(Student.total_students)  # 2

# Доступ к атрибутам класса через экземпляр
print(student1.school_name)   # "Школа №1"

# Изменение атрибута класса
Student.school_name = "Гимназия №2"
print(student1.school_name)   # "Гимназия №2"
print(student2.school_name)   # "Гимназия №2"

# Изменение атрибута через экземпляр создает новый атрибут экземпляра, затеняющий атрибут класса
student1.school_name = "Частная школа"
print(student1.school_name)   # "Частная школа"
print(student2.school_name)   # "Гимназия №2"
print(Student.school_name)    # "Гимназия №2"
```

### Атрибуты экземпляра

Атрибуты экземпляра уникальны для каждого экземпляра класса. Они обычно определяются внутри метода `__init__`.

```python
class BankAccount:
    # Атрибут класса
    interest_rate = 0.05
    
    def __init__(self, account_number, balance=0):
        # Атрибуты экземпляра
        self.account_number = account_number
        self.balance = balance
        self.transactions = []  # Список для хранения истории транзакций
    
    def deposit(self, amount):
        self.balance += amount
        self.transactions.append(f"Депозит: +{amount}")
        return self.balance
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise ValueError("Недостаточно средств")
        self.balance -= amount
        self.transactions.append(f"Снятие: -{amount}")
        return self.balance
    
    def add_interest(self):
        interest = self.balance * self.interest_rate
        self.balance += interest
        self.transactions.append(f"Проценты: +{interest}")
        return self.balance
    
    def get_statement(self):
        statement = f"Выписка по счету {self.account_number}\n"
        statement += f"Текущий баланс: {self.balance}\n"
        statement += "История транзакций:\n"
        for transaction in self.transactions:
            statement += f"- {transaction}\n"
        return statement

# Создание экземпляров
account1 = BankAccount("12345", 1000)
account2 = BankAccount("67890", 5000)

# Операции с аккаунтами
account1.deposit(500)
account1.withdraw(200)
account1.add_interest()

account2.withdraw(1000)
account2.add_interest()

# Получение выписки
print(account1.get_statement())
print(account2.get_statement())

# Изменение процентной ставки для всех аккаунтов
BankAccount.interest_rate = 0.06

# Следующее начисление процентов будет по новой ставке
account1.add_interest()
account2.add_interest()
```

## Методы класса и статические методы

### Методы класса (@classmethod)

Методы класса связаны с классом, а не с его экземплярами. Они получают в качестве первого параметра класс, а не экземпляр.

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
    
    def __str__(self):
        return f"{self.day:02d}/{self.month:02d}/{self.year}"
    
    @classmethod
    def from_string(cls, date_string):
        """Создает экземпляр Date из строки в формате DD-MM-YYYY"""
        day, month, year = map(int, date_string.split('-'))
        return cls(day, month, year)
    
    @classmethod
    def today(cls):
        """Создает экземпляр Date с текущей датой"""
        import datetime
        today = datetime.date.today()
        return cls(today.day, today.month, today.year)
    
    def is_leap_year(self):
        """Проверяет, является ли год високосным"""
        return (self.year % 4 == 0 and self.year % 100 != 0) or (self.year % 400 == 0)

# Использование методов класса для создания экземпляров
date1 = Date(15, 10, 2023)
date2 = Date.from_string("25-12-2023")
date3 = Date.today()

print(date1)  # "15/10/2023"
print(date2)  # "25/12/2023"
print(date3)  # Текущая дата

# Использование методов экземпляра
print(date1.is_leap_year())  # False
```

### Статические методы (@staticmethod)

Статические методы не привязаны ни к классу, ни к его экземплярам. Они группируются в классе только для логической организации кода.

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
    
    @staticmethod
    def subtract(a, b):
        return a - b
    
    @staticmethod
    def multiply(a, b):
        return a * b
    
    @staticmethod
    def divide(a, b):
        if b == 0:
            raise ValueError("Деление на ноль недопустимо")
        return a / b
    
    @staticmethod
    def is_prime(n):
        """Проверяет, является ли число простым"""
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

# Использование статических методов
print(MathUtils.add(5, 3))      # 8
print(MathUtils.multiply(4, 2))  # 8
print(MathUtils.is_prime(17))    # True
print(MathUtils.is_prime(4))     # False

# Статические методы можно вызывать и через экземпляр
math_obj = MathUtils()
print(math_obj.add(10, 20))  # 30 (но это менее идиоматично)
```

# Декоратор `@property` в Python

## Введение

В Python декоратор `@property` используется для создания управляемых атрибутов в классах. Он позволяет обращаться к методам как к полям объекта, сохраняя при этом возможность выполнять дополнительную логику при чтении, записи и удалении значений.

Основные преимущества использования `@property`:

- **Инкапсуляция**: скрытие реализации и защита внутреннего состояния.
- **Вычисляемые атрибуты**: получение значения, вычисленного «на лету».
- **Валидация и логирование**: проверка или фиксирование изменений.
- **Обратная совместимость**: переход от открытых полей к методам без изменения интерфейса.

---

## Основная идея

Декоратор `@property` делает из метода класса
`getter` — функцию, вызываемую при чтении атрибута. После этого к нему можно добавить методы для записи (`@<имя>.setter`) и удаления (`@<имя>.deleter`).

Под капотом:

```python
prop = property(fget, fset=None, fdel=None, doc=None)
```

- `fget(self)` — вызывается при `obj.attr`
- `fset(self, value)` — при `obj.attr = value`
- `fdel(self)` — при `del obj.attr`
- `doc` — строка документации, доступная в `prop.__doc__`

---

## Пример: класс `Circle` с валидацией и вычислением площади

```python
import math

class Circle:
    def __init__(self, radius):
        # Используем «приватное» поле для хранения
        self._radius = radius

    @property
    def radius(self):
        """Геттер: возвращает значение радиуса"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Сеттер: проверяет корректность и устанавливает новый радиус"""
        if not isinstance(value, (int, float)):
            raise TypeError("Радиус должен быть числом")
        if value < 0:
            raise ValueError("Радиус не может быть отрицательным")
        self._radius = value

    @radius.deleter
    def radius(self):
        """Делетер: удаляет внутренний радиус"""
        del self._radius

    @property
    def area(self):
        """Вычисляемая площадь круга"""
        return math.pi * self._radius ** 2
```

**Разбор примера**:

1. **Чтение**:
   ```python
   c = Circle(5)
   print(c.radius)  # вызывает Circle.radius.fget -> 5
   ```
2. **Запись и валидация**:
   ```python
   c.radius = 10    # вызывает Circle.radius.fset -> устанавливает 10
   c.radius = -1    # ValueError: Радиус не может быть отрицательным
   ```
3. **Удаление**:
   ```python
   del c.radius     # вызывает Circle.radius.fdel -> удаляет _radius
   ```
4. **Вычисляемый атрибут**:
   ```python
   print(c.area)    # вычисляет площадь: math.pi * radius**2
   ```

---

## Расширенное использование

### Ленивые вычисления (Lazy Evaluation)
Иногда атрибуты требуются вычислять один раз и кешировать:

```python
class DataFetcher:
    def __init__(self, source):
        self.source = source
        self._data = None

    @property
    def data(self):
        if self._data is None:
            # тяжелая операция загрузки
            self._data = self._load_from_source()
        return self._data

    def _load_from_source(self):
        print("Загрузка данных...")
        return [1, 2, 3]
```

### Ручное создание через `property()`

```python
class Person:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, value):
        if not value:
            raise ValueError("Имя не может быть пустым")
        self._name = value

    def del_name(self):
        del self._name

    name = property(get_name, set_name, del_name, "Имя пользователя")
```

---

## Внутренние атрибуты `property` объекта

- `property.fget` — метод-геттер
- `property.fset` — метод-сеттер (или `None`)
- `property.fdel` — метод-удаления (или `None`)
- `property.__doc__` — документация

Эти атрибуты помогают при отладке и рефлексии.

---

## Когда применять `@property`

- Замена публичного поля на метод без изменения API.
- Необходима валидация при изменении атрибута.
- Требуется ленивое вычисление или кеширование.
- Желание предоставить только чтение к внутренним данным.

---

### Сравнение методов экземпляра, класса и статических методов

```python
class Example:
    value = "класс"
    
    def __init__(self):
        self.value = "экземпляр"
    
    def instance_method(self):
        """
        Метод экземпляра имеет доступ к атрибутам экземпляра и класса.
        Первый параметр: self (экземпляр)
        """
        return f"Метод экземпляра: {self.value}"
    
    @classmethod
    def class_method(cls):
        """
        Метод класса имеет доступ к атрибутам класса, но не к атрибутам экземпляра.
        Первый параметр: cls (класс)
        """
        return f"Метод класса: {cls.value}"
    
    @staticmethod
    def static_method():
        """
        Статический метод не имеет доступа к атрибутам экземпляра или класса.
        Нет автоматически передаваемых параметров.
        """
        return "Статический метод (без доступа к self или cls)"

# Создание экземпляра
example = Example()

# Вызов методов через экземпляр
print(example.instance_method())  # "Метод экземпляра: экземпляр"
print(example.class_method())     # "Метод класса: класс"
print(example.static_method())    # "Статический метод (без доступа к self или cls)"

# Вызов методов через класс
# print(Example.instance_method())  # TypeError: необходим аргумент self
print(Example.class_method())     # "Метод класса: класс"
print(Example.static_method())    # "Статический метод (без доступа к self или cls)"
```

## Абстрактные классы и интерфейсы

Абстрактные классы — это классы, которые содержат один или несколько абстрактных методов (методов без реализации). Они не могут быть инстанцированы напрямую, а служат шаблоном для создания подклассов.

### Создание абстрактного класса

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        """Вычисляет площадь фигуры"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """Вычисляет периметр фигуры"""
        pass
    
    def describe(self):
        """Обычный метод (не абстрактный) с реализацией"""
        return f"Это фигура с площадью {self.area()} и периметром {self.perimeter()}"

# Нельзя создать экземпляр абстрактного класса
try:
    shape = Shape()  # TypeError
except TypeError as e:
    print(e)

# Создание подкласса с реализацией абстрактных методов
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius

# Создание экземпляра подкласса
circle = Circle(5)
print(circle.area())       # ~78.54
print(circle.perimeter())  # ~31.42
print(circle.describe())   # "Это фигура с площадью ... и периметром ..."
```

### Интерфейсы

В Python нет отдельного понятия "интерфейс", как в некоторых других языках (например, Java). Вместо этого используются абстрактные базовые классы с абстрактными методами.

```python
from abc import ABC, abstractmethod

# Определение интерфейса
class Drawable(ABC):
    @abstractmethod
    def draw(self):
        """Отрисовывает объект"""
        pass

class Resizable(ABC):
    @abstractmethod
    def resize(self, width, height):
        """Изменяет размер объекта"""
        pass

# Класс, реализующий несколько интерфейсов
class Rectangle(Drawable, Resizable):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def draw(self):
        return f"Рисую прямоугольник {self.width}x{self.height}"
    
    def resize(self, width, height):
        self.width = width
        self.height = height
        return f"Прямоугольник изменен до {self.width}x{self.height}"

# Использование
rect = Rectangle(10, 20)
print(rect.draw())       # "Рисую прямоугольник 10x20"
print(rect.resize(15, 25))  # "Прямоугольник изменен до 15x25"

# Проверка реализации интерфейсов
print(isinstance(rect, Drawable))   # True
print(isinstance(rect, Resizable))  # True
```

### Абстрактные свойства и атрибуты класса

```python
from abc import ABC, abstractmethod, abstractproperty

class Document(ABC):
    @property
    @abstractmethod
    def title(self):
        """Заголовок документа (абстрактное свойство)"""
        pass
    
    @abstractmethod
    def save(self, filename):
        """Сохраняет документ"""
        pass
    
    @classmethod
    @abstractmethod
    def create_empty(cls):
        """Создает пустой документ (абстрактный метод класса)"""
        pass

class TextDocument(Document):
    def __init__(self, title, content=""):
        self._title = title
        self.content = content
    
    @property
    def title(self):
        return self._title
    
    @title.setter
    def title(self, value):
        self._title = value
    
    def save(self, filename):
        with open(filename, 'w') as f:
            f.write(f"TITLE: {self.title}\n\n")
            f.write(self.content)
        return f"Документ сохранен в {filename}"
    
    @classmethod
    def create_empty(cls):
        return cls("Untitled")

# Использование
doc = TextDocument("Мой документ", "Это содержимое моего документа.")
print(doc.title)  # "Мой документ"

empty_doc = TextDocument.create_empty()
print(empty_doc.title)  # "Untitled"
```

## Множественное наследование и MRO

Python поддерживает множественное наследование, что позволяет классу наследовать атрибуты и методы от нескольких родительских классов.

### Базовое множественное наследование

```python
class A:
    def method(self):
        return "Метод из класса A"

class B:
    def method(self):
        return "Метод из класса B"
    
    def another_method(self):
        return "Другой метод из класса B"

class C(A, B):
    pass

# Использование
c = C()
print(c.method())         # "Метод из класса A" (A указан первым в списке наследования)
print(c.another_method())  # "Другой метод из класса B"
```

### Method Resolution Order (MRO)

MRO (порядок разрешения методов) — это алгоритм, который Python использует для определения порядка поиска методов при множественном наследовании.

```python
class A:
    def method(self):
        return "Метод из класса A"

class B(A):
    def method(self):
        return "Метод из класса B"

class C(A):
    def method(self):
        return "Метод из класса C"

class D(B, C):
    pass

# Просмотр MRO
print(D.__mro__)  # (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)

# Использование
d = D()
print(d.method())  # "Метод из класса B" (B имеет приоритет над C в MRO)
```

### `super()` при множественном наследовании

```python
class A:
    def method(self):
        return "A"

class B(A):
    def method(self):
        return f"B -> {super().method()}"

class C(A):
    def method(self):
        return f"C -> {super().method()}"

class D(B, C):
    def method(self):
        return f"D -> {super().method()}"

# Использование
d = D()
print(d.method())  # "D -> B -> C -> A"
print(D.__mro__)   # Показывает порядок вызова методов
```

### Проблема "ромбовидного" наследования

"Ромбовидное" наследование — это ситуация, когда класс наследует от двух классов, которые имеют общего предка.

```python
class Base:
    def __init__(self):
        print("Base.__init__")
        self.value = "Base"
    
    def method(self):
        return f"Base.method: {self.value}"

class A(Base):
    def __init__(self):
        super().__init__()
        print("A.__init__")
        self.value = "A"
    
    def method(self):
        return f"A.method: {self.value}"

class B(Base):
    def __init__(self):
        super().__init__()
        print("B.__init__")
        self.value = "B"
    
    def method(self):
        return f"B.method: {self.value}"

class C(A, B):
    def __init__(self):
        super().__init__()  # Вызывает только A.__init__, который вызывает Base.__init__
        print("C.__init__")
        self.value = "C"
    
    def method(self):
        return f"C.method -> {super().method()}"

# Вывод MRO
print(C.__mro__)  # (<class 'C'>, <class 'A'>, <class 'B'>, <class 'Base'>, <class 'object'>)

# Создание экземпляра
c = C()
# Вывод:
# Base.__init__
# A.__init__
# C.__init__

print(c.value)    # "C"
print(c.method())  # "C.method -> A.method: C"
```

## Миксины

Миксины — это классы, которые предназначены для предоставления дополнительной функциональности другим классам путем множественного наследования, но не предназначены для создания собственных экземпляров.

### Примеры миксинов

```python
# Миксин для сериализации в JSON
class JSONSerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)
    
    @classmethod
    def from_json(cls, json_str):
        import json
        data = json.loads(json_str)
        return cls(**data)

# Миксин для форматированного вывода
class PrettyPrintMixin:
    def pretty_print(self):
        output = f"{self.__class__.__name__}:\n"
        for key, value in self.__dict__.items():
            output += f"  {key}: {value}\n"
        return output

# Использование миксинов
class Person(JSONSerializableMixin, PrettyPrintMixin):
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city

# Создание экземпляра
person = Person("Иван", 30, "Москва")

# Использование функциональности миксинов
print(person.pretty_print())

json_data = person.to_json()
print(json_data)

# Десериализация
recovered_person = Person.from_json(json_data)
print(recovered_person.pretty_print())
```

### Соглашения по именованию для миксинов

Обычно миксины имеют суффикс `Mixin` или `Mixable` в имени класса и должны предоставлять конкретную функциональность.

```python
class LoggableMixin:
    """Миксин для добавления возможностей логирования."""
    
    def log(self, message, level="INFO"):
        print(f"[{level}] {self.__class__.__name__}: {message}")

class ValidatableMixin:
    """Миксин для добавления валидации данных."""
    
    def validate(self, data, schema):
        for key, validator in schema.items():
            if key in data:
                if not validator(data[key]):
                    raise ValueError(f"Неверное значение для {key}: {data[key]}")

# Использование миксинов
class UserForm(LoggableMixin, ValidatableMixin):
    def __init__(self, data):
        self.data = data
        self.validate_data()
    
    def validate_data(self):
        schema = {
            "name": lambda x: isinstance(x, str) and 2 <= len(x) <= 50,
            "age": lambda x: isinstance(x, int) and 0 <= x <= 120
        }
        
        try:
            self.validate(self.data, schema)
            self.log("Данные валидны")
        except ValueError as e:
            self.log(str(e), "ERROR")
            raise

# Использование
try:
    form = UserForm({"name": "Иван", "age": 30})
    print("Форма создана успешно")
except ValueError as e:
    print(f"Ошибка: {e}")

try:
    form = UserForm({"name": "И", "age": 150})
    print("Форма создана успешно")
except ValueError as e:
    print(f"Ошибка: {e}")
```

## Метаклассы

Метаклассы — это "классы классов", которые используются для создания классов. Они позволяют программисту управлять процессом создания и инициализации класса.

### Базовое использование метаклассов

```python
# Простой метакласс
class Meta(type):
    def __new__(mcs, name, bases, attrs):
        # name: имя создаваемого класса
        # bases: кортеж родительских классов
        # attrs: словарь атрибутов и методов класса
        
        print(f"Создаем класс {name}")
        
        # Добавляем атрибут всем создаваемым классам
        attrs['created_by_meta'] = True
        
        # Модифицируем методы
        for attr_name, attr_value in attrs.items():
            if callable(attr_value) and not attr_name.startswith('__'):
                attrs[attr_name] = mcs.log_calls(attr_value)
        
        # Создаем и возвращаем класс
        return super().__new__(mcs, name, bases, attrs)
    
    @staticmethod
    def log_calls(method):
        """Декоратор для логирования вызовов методов"""
        def wrapper(*args, **kwargs):
            print(f"Вызываем метод {method.__name__}")
            return method(*args, **kwargs)
        return wrapper

# Использование метакласса
class MyClass(metaclass=Meta):
    def method1(self):
        return "Это метод 1"
    
    def method2(self, arg):
        return f"Это метод 2 с аргументом {arg}"

# Создание экземпляра
obj = MyClass()
print(obj.created_by_meta)  # True
print(obj.method1())        # Логирование, затем "Это метод 1"
print(obj.method2("test"))  # Логирование, затем "Это метод 2 с аргументом test"
```

### Регистрация классов и синглтоны

```python
# Метакласс для регистрации классов
class RegistryMeta(type):
    _registry = {}
    
    def __new__(mcs, name, bases, attrs):
        cls = super().__new__(mcs, name, bases, attrs)
        if name != 'Registrable':  # Не регистрируем базовый класс
            mcs._registry[name] = cls
        return cls
    
    @classmethod
    def get_registry(mcs):
        return dict(mcs._registry)
    
    @classmethod
    def get_class(mcs, name):
        return mcs._registry.get(name)

# Базовый класс для регистрируемых классов
class Registrable(metaclass=RegistryMeta):
    pass

# Создание классов, которые автоматически регистрируются
class ServiceA(Registrable):
    def process(self):
        return "Обработка в ServiceA"

class ServiceB(Registrable):
    def process(self):
        return "Обработка в ServiceB"

# Использование реестра
registry = RegistryMeta.get_registry()
print(registry)  # {'ServiceA': <class 'ServiceA'>, 'ServiceB': <class 'ServiceB'>}

service_class = RegistryMeta.get_class("ServiceA")
service = service_class()
print(service.process())  # "Обработка в ServiceA"

# Метакласс для синглтонов
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

# Использование метакласса синглтона
class Logger(metaclass=SingletonMeta):
    def __init__(self, file_name=None):
        self.file_name = file_name or "app.log"
        print(f"Создан логгер с файлом {self.file_name}")
    
    def log(self, message):
        print(f"Запись в {self.file_name}: {message}")

# Проверка, что создается только один экземпляр
logger1 = Logger("log1.log")
logger2 = Logger("log2.log")  # Этот аргумент игнорируется, так как экземпляр уже существует

print(logger1 is logger2)  # True
logger1.log("Тестовое сообщение")
logger2.log("Другое сообщение")  # Используется тот же экземпляр, что и logger1
```

### Применение метаклассов

```python
# Метакласс для автоматического добавления свойств
class AutoPropertyMeta(type):
    def __new__(mcs, name, bases, attrs):
        # Создаем свойства для всех атрибутов, начинающихся с '_'
        for key, value in list(attrs.items()):
            if key.startswith('_') and not key.startswith('__') and isinstance(value, (int, float, str, bool, list, dict, tuple)):
                prop_name = key[1:]  # Имя свойства без '_'
                
                # Создаем геттер
                def get_property(name):
                    def getter(self):
                        return getattr(self, name)
                    return getter
                
                # Создаем сеттер
                def set_property(name):
                    def setter(self, value):
                        setattr(self, name, value)
                    return setter
                
                # Создаем свойство
                attrs[prop_name] = property(get_property(key), set_property(key))
        
        return super().__new__(mcs, name, bases, attrs)

# Использование метакласса
class Person(metaclass=AutoPropertyMeta):
    def __init__(self, name, age):
        self._name = name
        self._age = age
        self.__private = "private"  # Этот атрибут не будет автоматически преобразован в свойство

# Проверка автоматически созданных свойств
person = Person("Иван", 30)
print(person.name)  # "Иван" (автоматически созданное свойство)
print(person.age)   # 30 (автоматически созданное свойство)

person.name = "Петр"
person.age = 35
print(person._name)  # "Петр" (доступ к оригинальному атрибуту)
print(person._age)   # 35 (доступ к оригинальному атрибуту)
```

## Принципы SOLID в Python

SOLID — это набор принципов объектно-ориентированного проектирования, которые помогают создавать более гибкие, поддерживаемые и расширяемые системы.

### S - принцип единственной ответственности (Single Responsibility Principle)

Класс должен иметь только одну причину для изменения.

```python
# Плохо: класс имеет несколько ответственностей
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def save(self):
        # Сохраняет пользователя в базу данных
        pass
    
    def send_email(self, subject, body):
        # Отправляет email пользователю
        pass
    
    def generate_report(self):
        # Генерирует отчет о пользователе
        pass

# Хорошо: разделение ответственности
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # Сохраняет пользователя в базу данных
        pass
    
    def find_by_email(self, email):
        # Находит пользователя по email
        pass

class EmailService:
    def send_email(self, user, subject, body):
        # Отправляет email пользователю
        pass

class ReportGenerator:
    def generate_user_report(self, user):
        # Генерирует отчет о пользователе
        pass
```

### O - принцип открытости/закрытости (Open/Closed Principle)

Классы должны быть открыты для расширения, но закрыты для модификации.

```python
# Плохо: необходимо изменять класс для добавления новых форм
class AreaCalculator:
    def calculate_area(self, shape):
        if isinstance(shape, Rectangle):
            return shape.width * shape.height
        elif isinstance(shape, Circle):
            return 3.14 * shape.radius ** 2
        # При добавлении новой фигуры придется менять этот метод

# Хорошо: используем полиморфизм
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

class AreaCalculator:
    def calculate_area(self, shape):
        return shape.area()

# Теперь можно добавлять новые фигуры без изменения AreaCalculator
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height
```

### L - принцип подстановки Лисков (Liskov Substitution Principle)

Объекты базового класса должны иметь возможность быть замененными объектами их подклассов без нарушения работы программы.

```python
# Плохо: нарушение принципа подстановки Лисков
class Bird:
    def fly(self):
        return "Я летаю"

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Пингвины не могут летать")

# Функция, которая сломается с подклассом
def make_bird_fly(bird):
    return bird.fly()

# Хорошо: правильная иерархия классов
class Bird:
    def move(self):
        return "Я двигаюсь"

class FlyingBird(Bird):
    def move(self):
        return "Я летаю"
    
    def fly(self):
        return "Я летаю высоко"

class NonFlyingBird(Bird):
    def move(self):
        return "Я хожу или плаваю"

class Sparrow(FlyingBird):
    pass

class Penguin(NonFlyingBird):
    pass

# Функция, которая работает с любой птицей
def make_bird_move(bird):
    return bird.move()
```

### I - принцип разделения интерфейса (Interface Segregation Principle)

Клиенты не должны зависеть от интерфейсов, которые они не используют.

```python
# Плохо: большой интерфейс
class Worker:
    def work(self):
        pass
    
    def eat(self):
        pass
    
    def sleep(self):
        pass

# Классам-наследникам приходится реализовывать методы, которые они не используют
class Robot(Worker):
    def work(self):
        return "Я работаю"
    
    def eat(self):
        raise NotImplementedError("Роботы не едят")
    
    def sleep(self):
        raise NotImplementedError("Роботы не спят")

# Хорошо: разделенные интерфейсы
class Workable:
    def work(self):
        pass

class Eatable:
    def eat(self):
        pass

class Sleepable:
    def sleep(self):
        pass

class Human(Workable, Eatable, Sleepable):
    def work(self):
        return "Я работаю"
    
    def eat(self):
        return "Я ем"
    
    def sleep(self):
        return "Я сплю"

class Robot(Workable):
    def work(self):
        return "Я работаю без перерывов"
```

### D - принцип инверсии зависимостей (Dependency Inversion Principle)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.

```python
# Плохо: жесткая зависимость от конкретной реализации
class MySQLDatabase:
    def connect(self):
        return "Подключение к MySQL"
    
    def execute(self, query):
        return f"Выполнение запроса '{query}' в MySQL"

class UserRepository:
    def __init__(self):
        self.db = MySQLDatabase()  # Жесткая привязка к MySQL
    
    def save(self, user):
        query = f"INSERT INTO users (name, email) VALUES ('{user.name}', '{user.email}')"
        return self.db.execute(query)

# Хорошо: зависимость от абстракции
class Database:
    def connect(self):
        pass
    
    def execute(self, query):
        pass

class MySQLDatabase(Database):
    def connect(self):
        return "Подключение к MySQL"
    
    def execute(self, query):
        return f"Выполнение запроса '{query}' в MySQL"

class PostgreSQLDatabase(Database):
    def connect(self):
        return "Подключение к PostgreSQL"
    
    def execute(self, query):
        return f"Выполнение запроса '{query}' в PostgreSQL"

class UserRepository:
    def __init__(self, database):
        self.db = database  # Зависимость от абстракции
    
    def save(self, user):
        query = f"INSERT INTO users (name, email) VALUES ('{user.name}', '{user.email}')"
        return self.db.execute(query)

# Использование
mysql_db = MySQLDatabase()
postgres_db = PostgreSQLDatabase()

mysql_repo = UserRepository(mysql_db)
postgres_repo = UserRepository(postgres_db)

user = User("Иван", "ivan@example.com")
print(mysql_repo.save(user))    # Выполнение в MySQL
print(postgres_repo.save(user))  # Выполнение в PostgreSQL
```

## Практические задачи

### Задача 1: Система управления библиотекой
Создайте систему классов для управления библиотекой:
1. Классы для различных типов изданий (книги, журналы, электронные материалы)
2. Классы для пользователей библиотеки (читатели, библиотекари, администраторы)
3. Функциональность для выдачи, возврата, продления срока пользования
4. Систему поиска и фильтрации изданий
5. Управление штрафами за просрочку

### Задача 2: Интернет-магазин
Разработайте систему классов для интернет-магазина:
1. Товары разных категорий с различными атрибутами
2. Корзина покупок с возможностью добавления/удаления товаров
3. Система скидок и промокодов
4. Различные способы оплаты и доставки
5. Система управления заказами (создание, отслеживание, отмена)

### Задача 3: Игра "Подземелье и драконы"
Создайте простую текстовую RPG-игру:
1. Иерархию персонажей (воины, маги, лучники и т.д.)
2. Систему боя с использованием полиморфизма для различных типов атак
3. Инвентарь и экипировку персонажей
4. Систему прокачки и развития персонажей
5. Генерацию различных типов подземелий и противников

### Задача 4: Симулятор банковской системы
Разработайте симулятор банковской системы:
1. Разные типы счетов (текущий, сберегательный, кредитный)
2. Систему транзакций между счетами
3. Начисление процентов по разным правилам для разных типов счетов
4. Систему уведомлений о транзакциях и состоянии счетов
5. Функциональность для генерации выписок и отчетов

### Задача 5: Система управления контентом (CMS)
Создайте базовую CMS:
1. Различные типы контента (статьи, галереи, видео)
2. Систему пользователей с разными правами
3. Систему тегов и категорий для организации контента
4. Механизм комментирования и оценок
5. Систему плагинов для расширения функциональности

## Полезные ресурсы

- [Официальная документация Python по классам](https://docs.python.org/3/tutorial/classes.html)
- [Руководство по специальным методам](https://docs.python.org/3/reference/datamodel.html#special-method-names)
- [Руководство по абстрактным базовым классам](https://docs.python.org/3/library/abc.html)
- [Руководство по дескрипторам](https://docs.python.org/3/howto/descriptor.html)
- [Руководство по метаклассам](https://docs.python.org/3/reference/datamodel.html#metaclasses)
- [Принципы SOLID в Python](https://realpython.com/solid-principles-python/)
- [Шаблоны проектирования в Python](https://refactoring.guru/design-patterns/python)
- [Книга "Fluent Python" by Luciano Ramalho](https://www.oreilly.com/library/view/fluent-python/9781491946237/)
- [Книга "Python 3 Object-Oriented Programming" by Dusty Phillips](https://www.packtpub.com/product/python-3-object-oriented-programming-third-edition/9781789615852)
