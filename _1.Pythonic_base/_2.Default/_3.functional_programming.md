# Функциональное программирование в Python

## Содержание
1. [Введение](#введение)
2. [Основные принципы функционального программирования](#основные-принципы-функционального-программирования)
   - [Чистые функции](#чистые-функции)
   - [Иммутабельность](#иммутабельность)
   - [Функции высшего порядка](#функции-высшего-порядка)
   - [Рекурсия вместо циклов](#рекурсия-вместо-циклов)
3. [Функции как объекты первого класса](#функции-как-объекты-первого-класса)
   - [Присваивание функций переменным](#присваивание-функций-переменным)
   - [Передача функций в качестве аргументов](#передача-функций-в-качестве-аргументов)
   - [Возврат функций из функций](#возврат-функций-из-функций)
4. [Встроенные функции для функционального программирования](#встроенные-функции-для-функционального-программирования)
   - [map()](#map)
   - [filter()](#filter)
   - [reduce()](#reduce)
   - [sorted()](#sorted)
5. [Лямбда-функции](#лямбда-функции)
   - [Синтаксис и примеры](#синтаксис-и-примеры)
   - [Лямбда-функции с map, filter и reduce](#лямбда-функции-с-map-filter-и-reduce)
   - [Ограничения лямбда-функций](#ограничения-лямбда-функций)
6. [List comprehensions и генераторные выражения](#list-comprehensions-и-генераторные-выражения)
   - [List comprehensions](#list-comprehensions)
   - [Generator expressions](#generator-expressions)
   - [Dict и Set comprehensions](#dict-и-set-comprehensions)
7. [Функциональные инструменты в модуле functools](#функциональные-инструменты-в-модуле-functools)
   - [partial()](#partial)
   - [lru_cache()](#lru_cache)
   - [reduce()](#reduce-1)
   - [Декораторы в functools](#декораторы-в-functools)
8. [Замыкания (Closures)](#замыкания-closures)
   - [Определение и принцип работы](#определение-и-принцип-работы)
   - [Создание замыканий](#создание-замыканий)
   - [Примеры использования замыканий](#примеры-использования-замыканий)
9. [Декораторы](#декораторы)
   - [Что такое декоратор](#что-такое-декоратор)
   - [Создание простых декораторов](#создание-простых-декораторов)
   - [Декораторы с аргументами](#декораторы-с-аргументами)
   - [Цепочки декораторов](#цепочки-декораторов)
   - [Примеры практического использования](#примеры-практического-использования)
10. [Итерабельное программирование](#итерабельное-программирование)
    - [Генераторы](#генераторы)
    - [Ленивые вычисления](#ленивые-вычисления)
    - [Бесконечные последовательности](#бесконечные-последовательности)
11. [Модуль itertools](#модуль-itertools)
    - [Бесконечные итераторы](#бесконечные-итераторы)
    - [Итераторы, завершающиеся по кратчайшему входному итератору](#итераторы-завершающиеся-по-кратчайшему-входному-итератору)
    - [Комбинаторные итераторы](#комбинаторные-итераторы)
12. [Практические задания](#практические-задания)
    - [Задание 1: Обработка данных с использованием функциональных инструментов](#задание-1-обработка-данных-с-использованием-функциональных-инструментов)
    - [Задание 2: Создание декораторов для профилирования функций](#задание-2-создание-декораторов-для-профилирования-функций)
    - [Задание 3: Работа с генераторами и бесконечными последовательностями](#задание-3-работа-с-генераторами-и-бесконечными-последовательностями)
    - [Задание 4: Проект "Мини-библиотека для обработки текста"](#задание-4-проект-мини-библиотека-для-обработки-текста)

## Введение

Функциональное программирование (ФП) — это парадигма программирования, в которой процесс вычисления рассматривается как вычисление значений функций. В отличие от императивного программирования, где программы построены из последовательности инструкций, изменяющих состояние, функциональное программирование делает упор на применение и композицию функций.

Python не является чисто функциональным языком, как, например, Haskell или Lisp, но он поддерживает многие функциональные конструкции и паттерны, которые позволяют писать код в функциональном стиле.

В этом уроке мы рассмотрим основные принципы функционального программирования и как они реализуются в Python, а также изучим различные функциональные инструменты и техники, доступные в языке.

## Основные принципы функционального программирования

### Чистые функции

**Чистая функция** — это функция, которая:
1. При одних и тех же входных данных всегда возвращает один и тот же результат
2. Не имеет побочных эффектов (т.е. не изменяет состояние вне своей области видимости)

Пример чистой функции:

```python
def add(a, b):
    return a + b
```

Эта функция всегда будет возвращать одинаковый результат для одинаковых входных данных и не имеет побочных эффектов.

Пример функции с побочным эффектом:

```python
total = 0

def add_to_total(value):
    global total
    total += value
    return total
```

Эта функция изменяет глобальную переменную `total`, что является побочным эффектом.

### Иммутабельность

**Иммутабельность** означает, что после создания объекта его состояние не может быть изменено.

В Python некоторые типы данных являются иммутабельными по своей природе:
- Числа (int, float, complex)
- Строки (str)
- Кортежи (tuple)
- Frozenset

Другие типы (списки, словари, множества) являются мутабельными.

В функциональном программировании предпочтение отдается иммутабельным структурам данных, так как они более предсказуемы и безопасны для многопоточной обработки.

Пример работы с иммутабельными данными:

```python
# Императивный подход (изменение существующего списка)
def add_element_imperative(lst, element):
    lst.append(element)  # Изменяет исходный список
    return lst

# Функциональный подход (создание нового списка)
def add_element_functional(lst, element):
    return lst + [element]  # Возвращает новый список, не изменяя исходный
```

### Функции высшего порядка

**Функция высшего порядка** — это функция, которая либо принимает одну или несколько функций в качестве аргументов, либо возвращает функцию в качестве результата, либо и то, и другое.

Примеры функций высшего порядка в Python:
- `map()`
- `filter()`
- `reduce()`
- Декораторы

```python
def apply_operation(x, y, operation):
    """Применяет операцию к двум числам."""
    return operation(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

# Использование функции высшего порядка
result1 = apply_operation(5, 3, add)  # 8
result2 = apply_operation(5, 3, multiply)  # 15
```

### Рекурсия вместо циклов

В функциональном программировании для повторяющихся операций часто используется рекурсия вместо циклов. Это соответствует принципу отсутствия изменяемого состояния.

Пример расчета факториала с использованием рекурсии:

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
```

**Примечание**: В Python есть ограничение на глубину рекурсии (обычно 1000 вызовов), поэтому для больших объемов данных рекурсия может быть не лучшим выбором. Однако существует техника хвостовой рекурсии и оптимизации, которые позволяют обойти это ограничение в некоторых случаях.

## Функции как объекты первого класса

В Python функции являются **объектами первого класса** (first-class objects), что означает, что они могут:
- Быть присвоены переменным
- Быть переданы в качестве аргументов другим функциям
- Быть возвращены из функций
- Быть сохранены в структурах данных

Эта особенность Python делает его мощным языком для функционального программирования.

### Присваивание функций переменным

```python
def greet(name):
    return f"Hello, {name}!"

# Присваивание функции переменной
say_hello = greet

# Вызов функции через переменную
print(say_hello("Alice"))  # "Hello, Alice!"
```

### Передача функций в качестве аргументов

```python
def apply_to_list(func, lst):
    return [func(item) for item in lst]

def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = apply_to_list(square, numbers)  # [1, 4, 9, 16, 25]
```

### Возврат функций из функций

```python
def create_multiplier(factor):
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

## Встроенные функции для функционального программирования

Python предоставляет несколько встроенных функций, которые следуют функциональной парадигме и позволяют эффективно работать с последовательностями данных.

### map()

Функция `map()` применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.

Синтаксис:
```python
map(function, iterable, ...)
```

Пример:
```python
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # [1, 4, 9, 16, 25]
```

Функция `map()` может принимать несколько итерируемых объектов:

```python
def add(a, b):
    return a + b

list1 = [1, 2, 3]
list2 = [10, 20, 30]
result = map(add, list1, list2)
print(list(result))  # [11, 22, 33]
```

### filter()

Функция `filter()` создает итератор, содержащий элементы итерируемого объекта, для которых указанная функция возвращает `True`.

Синтаксис:
```python
filter(function, iterable)
```

Пример:
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # [2, 4, 6, 8, 10]
```

Если вместо функции передать `None`, то `filter()` будет фильтровать элементы на истинность:

```python
values = [0, 1, False, True, "", "hello", None, []]
filtered = filter(None, values)
print(list(filtered))  # [1, True, "hello"]
```

### reduce()

Функция `reduce()` применяет указанную функцию к элементам итерируемого объекта, накапливая результат. Она находится в модуле `functools`.

Синтаксис:
```python
from functools import reduce
reduce(function, iterable[, initializer])
```

Пример:
```python
from functools import reduce

def multiply(x, y):
    return x * y

numbers = [1, 2, 3, 4, 5]
product = reduce(multiply, numbers)
print(product)  # 120 (1*2*3*4*5)
```

С начальным значением:
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
sum_plus_10 = reduce(lambda x, y: x + y, numbers, 10)
print(sum_plus_10)  # 25 (10+1+2+3+4+5)
```

### sorted()

Функция `sorted()` возвращает новый отсортированный список из элементов итерируемого объекта.

Синтаксис:
```python
sorted(iterable, *, key=None, reverse=False)
```

Пример:
```python
numbers = [5, 2, 8, 1, 9]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # [1, 2, 5, 8, 9]
```

С пользовательской функцией ключа:
```python
fruits = ["apple", "banana", "cherry", "date", "elderberry"]
sorted_by_length = sorted(fruits, key=len)
print(sorted_by_length)  # ["date", "apple", "cherry", "banana", "elderberry"]

# Сортировка по последней букве
sorted_by_last_letter = sorted(fruits, key=lambda s: s[-1])
print(sorted_by_last_letter)  # ["banana", "apple", "date", "cherry", "elderberry"]
```

## Лямбда-функции

**Лямбда-функции** (или анонимные функции) — это небольшие функции, которые можно определить "на лету", без использования инструкции `def`. Они особенно полезны в функциональном программировании, когда нужно передать простую функцию в качестве аргумента.

### Синтаксис и примеры

Синтаксис:
```python
lambda parameters: expression
```

Лямбда-функция может иметь любое количество параметров, но только одно выражение, результат которого будет возвращен.

Примеры:
```python
# Лямбда-функция с одним параметром
square = lambda x: x ** 2
print(square(5))  # 25

# Лямбда-функция с несколькими параметрами
add = lambda a, b: a + b
print(add(3, 5))  # 8

# Лямбда-функция с условным выражением
is_even = lambda x: x % 2 == 0
print(is_even(4))  # True
print(is_even(5))  # False
```

### Лямбда-функции с map, filter и reduce

Лямбда-функции часто используются вместе с функциями `map()`, `filter()` и `reduce()`:

```python
# map() с лямбда-функцией
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# filter() с лямбда-функцией
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]

# reduce() с лямбда-функцией
from functools import reduce
sum_of_numbers = reduce(lambda x, y: x + y, numbers)
print(sum_of_numbers)  # 15
```

### Ограничения лямбда-функций

Хотя лямбда-функции очень удобны, у них есть некоторые ограничения:
- Они могут содержать только одно выражение
- Они не могут содержать операторы (например, `if`, `for`, `return`)
- Они не могут включать документацию (docstring)
- Более сложные функции лучше определять с помощью `def`

## List comprehensions и генераторные выражения

List comprehensions (списковые включения) и генераторные выражения — это лаконичные и эффективные способы создания последовательностей в Python, которые соответствуют функциональному стилю программирования.

### List comprehensions

List comprehension позволяет создать новый список, применяя выражение к каждому элементу итерируемого объекта.

Синтаксис:
```python
[expression for item in iterable if condition]
```

Часть `if condition` является необязательной.

Примеры:
```python
# Квадраты чисел
squares = [x ** 2 for x in range(1, 6)]
print(squares)  # [1, 4, 9, 16, 25]

# Четные числа
even_numbers = [x for x in range(1, 11) if x % 2 == 0]
print(even_numbers)  # [2, 4, 6, 8, 10]

# Преобразование списка строк
fruits = ["apple", "banana", "cherry"]
uppercase_fruits = [fruit.upper() for fruit in fruits]
print(uppercase_fruits)  # ["APPLE", "BANANA", "CHERRY"]

# С условным выражением (тернарный оператор)
numbers = [1, 2, 3, 4, 5]
result = ["Четное" if x % 2 == 0 else "Нечетное" for x in numbers]
print(result)  # ["Нечетное", "Четное", "Нечетное", "Четное", "Нечетное"]
```

List comprehensions эквивалентны следующей конструкции с циклом `for`:
```python
# С использованием цикла for
squares = []
for x in range(1, 6):
    squares.append(x ** 2)
```

Но list comprehension более лаконичен и часто более эффективен.

### Generator expressions

**Генераторные выражения** похожи на list comprehensions, но они не создают список в памяти сразу. Вместо этого они генерируют элементы "на лету", по мере необходимости, что делает их более эффективными с точки зрения использования памяти, особенно для больших последовательностей.

Синтаксис:
```python
(expression for item in iterable if condition)
```

Примеры:
```python
# Создание генератора квадратов
squares_gen = (x ** 2 for x in range(1, 6))

# Генератор не вычисляет все значения сразу
print(squares_gen)  # <generator object <genexpr> at 0x...>

# Значения генерируются по мере итерации
for square in squares_gen:
    print(square)  # 1, 4, 9, 16, 25

# Или преобразование в список
squares_gen = (x ** 2 for x in range(1, 6))
squares_list = list(squares_gen)
print(squares_list)  # [1, 4, 9, 16, 25]
```

Генераторные выражения особенно полезны, когда вы не нужно хранить все элементы в памяти одновременно, а только обработать их последовательно.

### Dict и Set comprehensions

Python также поддерживает аналогичные конструкции для создания словарей и множеств:

Dict comprehension:
```python
# Создание словаря квадратов
squares_dict = {x: x ** 2 for x in range(1, 6)}
print(squares_dict)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# Преобразование списка в словарь
fruits = ["apple", "banana", "cherry"]
fruit_lengths = {fruit: len(fruit) for fruit in fruits}
print(fruit_lengths)  # {"apple": 5, "banana": 6, "cherry": 6}
```

Set comprehension:
```python
# Создание множества квадратов
squares_set = {x ** 2 for x in range(1, 6)}
print(squares_set)  # {1, 4, 9, 16, 25}

# Уникальные символы в строке
text = "hello"
unique_chars = {char for char in text}
print(unique_chars)  # {"h", "e", "l", "o"}
```

## Функциональные инструменты в модуле functools

Модуль `functools` в Python предоставляет набор полезных инструментов для функционального программирования.

### partial()

Функция `partial()` позволяет создавать частично примененные функции, то есть функции с предустановленными значениями некоторых аргументов.

```python
from functools import partial

def multiply(x, y):
    return x * y

# Создаем новую функцию, которая умножает на 2
double = partial(multiply, 2)

print(double(5))  # 10 (2 * 5)
print(double(7))  # 14 (2 * 7)
```

Это также работает с именованными аргументами:

```python
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

# Создаем функцию для испанского приветствия
greet_in_spanish = partial(greet, greeting="Hola")

print(greet_in_spanish("Alice"))  # "Hola, Alice!"
print(greet_in_spanish("Bob"))    # "Hola, Bob!"
```

### lru_cache()

Декоратор `lru_cache` реализует механизм кэширования функции, запоминая результаты вызовов с теми же аргументами, что может значительно ускорить выполнение функций с дорогостоящими вычислениями.

```python
from functools import lru_cache
import time

# Без кэширования
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# С кэшированием
@lru_cache(maxsize=None)
def fibonacci_cached(n):
    if n < 2:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

# Сравнение производительности
start_time = time.time()
fibonacci(30)
end_time = time.time()
print(f"Без кэширования: {end_time - start_time:.2f} сек")

start_time = time.time()
fibonacci_cached(30)
end_time = time.time()
print(f"С кэшированием: {end_time - start_time:.2f} сек")
```

### reduce()

Функция `reduce()`, как мы уже упоминали, находится в модуле `functools`. Она применяет указанную функцию к элементам итерируемого объекта, накапливая результат.

```python
from functools import reduce

# Вычисление произведения всех чисел в списке
numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 120 (1*2*3*4*5)

# Нахождение максимального значения
max_value = reduce(lambda x, y: x if x > y else y, numbers)
print(max_value)  # 5

# Объединение списка строк
words = ["Hello", "world", "!"]
sentence = reduce(lambda x, y: x + " " + y, words)
print(sentence)  # "Hello world !"
```

### Декораторы в functools

Модуль `functools` также предоставляет несколько полезных декораторов:

- `@wraps()` — правильно сохраняет метаданные функции при создании декораторов
- `@total_ordering` — автоматически генерирует методы сравнения на основе реализации `__eq__` и одного из методов сравнения
- `@singledispatch` — реализует одиночную диспетчеризацию для функций

Пример использования `@wraps`:

```python
from functools import wraps
import time

def timing_decorator(func):
    @wraps(func)  # Сохраняет метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Функция {func.__name__} выполнялась {end_time - start_time:.2f} сек")
        return result
    return wrapper

@timing_decorator
def slow_function():
    """Эта функция выполняется медленно."""
    time.sleep(1)
    return "Готово!"

# Вызов функции
result = slow_function()
print(result)

# Доступ к метаданным оригинальной функции
print(slow_function.__name__)  # "slow_function" (а не "wrapper")
print(slow_function.__doc__)   # "Эта функция выполняется медленно."
```

## Замыкания (Closures)

### Определение и принцип работы

**Замыкание** — это функция, которая запоминает значения из области видимости, в которой она была создана, даже если эта область видимости больше не доступна в программе.

В Python замыкания создаются, когда вложенная функция ссылается на значения из своей объемлющей функции.

### Создание замыканий

```python
def create_counter():
    count = 0  # Переменная во внешней функции
    
    def increment():
        nonlocal count  # Используем nonlocal для изменения переменной из внешней функции
        count += 1
        return count
    
    return increment  # Возвращаем вложенную функцию

# Создаем счетчик
counter = create_counter()

# Каждый вызов увеличивает счетчик
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

В этом примере функция `increment` является замыканием, которое запоминает переменную `count` из функции `create_counter`, даже после того, как выполнение `create_counter` завершилось.

### Примеры использования замыканий

1. **Создание фабрик функций**:

```python
def power_factory(exponent):
    def power(base):
        return base ** exponent
    return power

square = power_factory(2)
cube = power_factory(3)

print(square(4))  # 16 (4^2)
print(cube(4))    # 64 (4^3)
```

2. **Сохранение состояния без использования классов**:

```python
def create_accumulator(initial_value=0):
    total = initial_value
    
    def add(value):
        nonlocal total
        total += value
        return total
    
    return add

accumulator = create_accumulator(10)
print(accumulator(5))  # 15
print(accumulator(3))  # 18
print(accumulator(2))  # 20
```

3. **Создание декораторов**:

```python
def logged(func):
    import logging
    logging.basicConfig(level=logging.INFO)
    
    def wrapper(*args, **kwargs):
        logging.info(f"Вызов {func.__name__} с аргументами {args}, {kwargs}")
        return func(*args, **kwargs)
    
    return wrapper

@logged
def add(a, b):
    return a + b

result = add(3, 5)  # В логах: "Вызов add с аргументами (3, 5), {}"
```

## Декораторы

### Что такое декоратор

**Декоратор** — это функция, которая принимает другую функцию в качестве аргумента и расширяет её поведение без явного изменения исходного кода. Декораторы широко используются в Python для реализации аспектно-ориентированного программирования.

### Создание простых декораторов

```python
def simple_decorator(func):
    def wrapper():
        print("Что-то перед вызовом функции")
        func()
        print("Что-то после вызова функции")
    return wrapper

@simple_decorator
def say_hello():
    print("Привет, мир!")

# Вызов функции
say_hello()
```

Результат:
```
Что-то перед вызовом функции
Привет, мир!
Что-то после вызова функции
```

Запись `@simple_decorator` эквивалентна:
```python
def say_hello():
    print("Привет, мир!")

say_hello = simple_decorator(say_hello)
```

### Декораторы для функций с аргументами

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print(f"Аргументы: {args}, {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

result = add(3, 5)
print(f"Результат: {result}")
```

Результат:
```
Аргументы: (3, 5), {}
Результат: 8
```

### Декораторы с аргументами

```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(n):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    return f"Привет, {name}!"

print(greet("Alice"))
```

Результат:
```
['Привет, Alice!', 'Привет, Alice!', 'Привет, Alice!']
```

Запись `@repeat(3)` эквивалентна:
```python
def greet(name):
    return f"Привет, {name}!"

greet = repeat(3)(greet)
```

### Цепочки декораторов

Декораторы можно применять в цепочке, где результат одного декоратора передается следующему:

```python
def decorator1(func):
    def wrapper(*args, **kwargs):
        print("Decorator 1")
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    def wrapper(*args, **kwargs):
        print("Decorator 2")
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def say_hello():
    print("Привет, мир!")

say_hello()
```

Результат:
```
Decorator 1
Decorator 2
Привет, мир!
```

Порядок выполнения декораторов идет снизу вверх, то есть сначала применяется `decorator2`, затем `decorator1`.

### Примеры практического использования

1. **Измерение времени выполнения**:

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Функция {func.__name__} выполнялась {end_time - start_time:.6f} сек")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(1)
    return "Готово!"

result = slow_function()
```

2. **Логирование**:

```python
import logging
logging.basicConfig(level=logging.INFO)

def log_function_call(func):
    def wrapper(*args, **kwargs):
        logging.info(f"Вызов {func.__name__} с аргументами {args}, {kwargs}")
        result = func(*args, **kwargs)
        logging.info(f"Функция {func.__name__} вернула {result}")
        return result
    return wrapper

@log_function_call
def divide(a, b):
    return a / b

result = divide(10, 2)
```

3. **Кэширование результатов**:

```python
def memoize(func):
    cache = {}
    def wrapper(*args):
        if args in cache:
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result
    return wrapper

@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(35))  # Быстрое выполнение благодаря кэшированию
```

## Итерабельное программирование

Итерабельное программирование — это важная часть функционального программирования в Python, основанная на работе с последовательностями значений.

### Генераторы

**Генераторы** — это простой и мощный инструмент для создания итераторов. Они записываются как обычные функции, но используют оператор `yield` вместо `return` для возврата значений.

```python
def count_up_to(n):
    i = 0
    while i < n:
        yield i
        i += 1

# Использование генератора
for number in count_up_to(5):
    print(number)  # 0, 1, 2, 3, 4
```

Отличие генератора от обычной функции в том, что генератор "запоминает" свое состояние между вызовами и возобновляет выполнение с того места, где остановился в прошлый раз.

Генераторы очень эффективны с точки зрения использования памяти, так как они генерируют значения "на лету".

### Ленивые вычисления

**Ленивые вычисления** — это стратегия вычислений, при которой выражение не вычисляется до тех пор, пока его значение не понадобится. Генераторы в Python реализуют ленивые вычисления.

```python
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

# Создание бесконечного генератора
gen = infinite_sequence()

# Получение первых нескольких значений
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 2

# Получение нескольких следующих значений с помощью islice
from itertools import islice
print(list(islice(gen, 5)))  # [3, 4, 5, 6, 7]
```

### Бесконечные последовательности

С помощью генераторов можно создавать бесконечные последовательности, такие как все натуральные числа, простые числа, числа Фибоначчи и т.д.

```python
def fibonacci_generator():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# Создание генератора чисел Фибоначчи
fibonacci = fibonacci_generator()

# Получение первых 10 чисел Фибоначчи
from itertools import islice
first_10 = list(islice(fibonacci, 10))
print(first_10)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

## Модуль itertools

Модуль `itertools` предоставляет набор быстрых, эффективных инструментов для работы с итераторами и последовательностями в функциональном стиле.

### Бесконечные итераторы

- `count(start, step)` — генерирует бесконечную последовательность чисел, начиная с `start` с шагом `step`
- `cycle(iterable)` — бесконечно повторяет элементы итерируемого объекта
- `repeat(elem, n=None)` — повторяет элемент n раз или бесконечно, если n не указано

```python
import itertools

# Создание счетчика, начиная с 10 с шагом 2
counter = itertools.count(10, 2)
print(next(counter))  # 10
print(next(counter))  # 12
print(next(counter))  # 14

# Циклическое повторение элементов
cycler = itertools.cycle(['A', 'B', 'C'])
print(next(cycler))  # 'A'
print(next(cycler))  # 'B'
print(next(cycler))  # 'C'
print(next(cycler))  # 'A'

# Повторение элемента
repeater = itertools.repeat('X', 3)
print(list(repeater))  # ['X', 'X', 'X']
```

### Итераторы, завершающиеся по кратчайшему входному итератору

- `chain(iter1, iter2, ...)` — объединяет несколько итераторов в один
- `zip_longest(iter1, iter2, ..., fillvalue=None)` — как `zip()`, но продолжает до исчерпания самого длинного итератора, заполняя отсутствующие значения с помощью `fillvalue`
- `islice(iterable, start, stop, step)` — возвращает срез итератора

```python
import itertools

# Объединение нескольких итераторов
numbers = [1, 2, 3]
letters = ['A', 'B', 'C']
combined = itertools.chain(numbers, letters)
print(list(combined))  # [1, 2, 3, 'A', 'B', 'C']

# zip_longest
short = [1, 2]
long = ['A', 'B', 'C', 'D']
zipped = itertools.zip_longest(short, long, fillvalue=0)
print(list(zipped))  # [(1, 'A'), (2, 'B'), (0, 'C'), (0, 'D')]

# islice
from itertools import islice
counter = itertools.count(1)  # Бесконечный счетчик
first_5 = islice(counter, 5)
print(list(first_5))  # [1, 2, 3, 4, 5]
```

### Комбинаторные итераторы

- `product(iter1, iter2, ...)` — декартово произведение итераторов
- `permutations(iterable, r=None)` — все возможные перестановки r элементов
- `combinations(iterable, r)` — все возможные комбинации r элементов
- `combinations_with_replacement(iterable, r)` — все возможные комбинации r элементов с возможностью повторения

```python
import itertools

# Декартово произведение
print(list(itertools.product('AB', '12')))
# [('A', '1'), ('A', '2'), ('B', '1'), ('B', '2')]

# Перестановки
print(list(itertools.permutations('ABC', 2)))
# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

# Комбинации
print(list(itertools.combinations('ABC', 2)))
# [('A', 'B'), ('A', 'C'), ('B', 'C')]

# Комбинации с повторениями
print(list(itertools.combinations_with_replacement('ABC', 2)))
# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]
```

## Практические задания

### Задание 1: Обработка данных с использованием функциональных инструментов

**Задача**: Вам дан файл с данными о студентах, содержащий имя, возраст и средний балл. Используя функциональные инструменты Python, выполните следующие операции:
1. Загрузите данные из файла
2. Отфильтруйте студентов старше 18 лет
3. Преобразуйте имена студентов в верхний регистр
4. Вычислите средний балл для всех отфильтрованных студентов
5. Найдите студентов с наивысшим и наименьшим средним баллом

**Решение**:

```python
import csv
from functools import reduce

def load_student_data(file_path):
    """Загружает данные о студентах из CSV-файла."""
    with open(file_path, 'r', encoding='utf-8') as file:
        reader = csv.reader(file)
        # Пропускаем заголовок
        next(reader)
        # Преобразуем данные в список словарей
        students = [{'name': row[0], 'age': int(row[1]), 'grade': float(row[2])} 
                    for row in reader]
    return students

def process_students(students):
    """Обрабатывает данные о студентах с использованием функциональных инструментов."""
    # Фильтрация студентов старше 18 лет
    adults = filter(lambda student: student['age'] > 18, students)
    
    # Преобразование имен в верхний регистр
    students_uppercase = map(
        lambda student: {**student, 'name': student['name'].upper()},
        adults
    )
    
    # Конвертируем в список для дальнейшей обработки
    students_processed = list(students_uppercase)
    
    # Вычисление среднего балла
    if students_processed:
        total_grade = reduce(lambda acc, student: acc + student['grade'], students_processed, 0)
        average_grade = total_grade / len(students_processed)
    else:
        average_grade = 0
    
    # Нахождение студентов с наивысшим и наименьшим средним баллом
    if students_processed:
        highest_grade_student = max(students_processed, key=lambda student: student['grade'])
        lowest_grade_student = min(students_processed, key=lambda student: student['grade'])
    else:
        highest_grade_student = None
        lowest_grade_student = None
    
    return {
        'processed_students': students_processed,
        'average_grade': average_grade,
        'highest_grade_student': highest_grade_student,
        'lowest_grade_student': lowest_grade_student
    }

# Пример использования
if __name__ == "__main__":
    # Предполагаем, что у нас есть файл 'students.csv' с данными
    # Формат: имя, возраст, средний балл
    try:
        students = load_student_data('students.csv')
        results = process_students(students)
        
        print("Обработанные данные студентов:")
        for student in results['processed_students']:
            print(f"{student['name']}, возраст: {student['age']}, средний балл: {student['grade']}")
        
        print(f"\nОбщий средний балл: {results['average_grade']:.2f}")
        
        if results['highest_grade_student']:
            print(f"\nСтудент с наивысшим баллом:")
            student = results['highest_grade_student']
            print(f"{student['name']}, возраст: {student['age']}, средний балл: {student['grade']}")
        
        if results['lowest_grade_student']:
            print(f"\nСтудент с наименьшим баллом:")
            student = results['lowest_grade_student']
            print(f"{student['name']}, возраст: {student['age']}, средний балл: {student['grade']}")
    
    except FileNotFoundError:
        print("Файл 'students.csv' не найден.")
        print("Пример содержимого файла:")
        print("name,age,grade")
        print("Alice,19,4.5")
        print("Bob,17,3.8")
        print("Charlie,20,4.2")
```

Пример содержимого файла `students.csv`:
```
name,age,grade
Alice,19,4.5
Bob,17,3.8
Charlie,20,4.2
Diana,22,4.8
Eddie,18,3.5
```

**Идеи для улучшения**:
1. Добавьте обработку ошибок для случаев с некорректными данными
2. Реализуйте сортировку студентов по различным критериям
3. Добавьте возможность группировки студентов по возрастным группам или диапазонам оценок
4. Реализуйте сохранение обработанных данных в новый файл
5. Добавьте возможность фильтрации и обработки по дополнительным критериям

### Задание 2: Создание декораторов для профилирования функций

**Задача**: Создайте набор декораторов для профилирования функций, которые будут:
1. Измерять время выполнения функции
2. Считать количество вызовов функции
3. Кэшировать результаты функции для одинаковых аргументов
4. Логировать аргументы и результаты вызова функции

**Решение**:

```python
import time
import functools
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def timing_decorator(func):
    """Декоратор, измеряющий время выполнения функции."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        logger.info(f"Функция {func.__name__} выполнялась {end_time - start_time:.6f} сек")
        return result
    return wrapper

def count_calls(func):
    """Декоратор, подсчитывающий количество вызовов функции."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.count += 1
        logger.info(f"Функция {func.__name__} была вызвана {wrapper.count} раз")
        return func(*args, **kwargs)
    wrapper.count = 0
    return wrapper

def memoize(func):
    """Декоратор, кэширующий результаты функции для одинаковых аргументов."""
    cache = {}
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Создаем ключ кэша из аргументов
        # Для kwargs сортируем ключи, чтобы обеспечить одинаковый порядок
        key = str(args) + str(sorted(kwargs.items()))
        if key in cache:
            logger.info(f"Используется кэшированный результат для {func.__name__}")
            return cache[key]
        result = func(*args, **kwargs)
        cache[key] = result
        return result
    return wrapper

def log_function(func):
    """Декоратор, логирующий аргументы и результаты вызова функции."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger.info(f"Вызов {func.__name__} с аргументами: {args}, {kwargs}")
        result = func(*args, **kwargs)
        logger.info(f"Функция {func.__name__} вернула: {result}")
        return result
    return wrapper

# Пример использования декораторов
@timing_decorator
@count_calls
@memoize
@log_function
def fibonacci(n):
    """Вычисляет n-е число Фибоначчи."""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Тестирование
if __name__ == "__main__":
    print("Вычисление чисел Фибоначчи с использованием декораторов:")
    
    print(f"fibonacci(10) = {fibonacci(10)}")
    print(f"fibonacci(10) снова = {fibonacci(10)}")  # Должен использовать кэш
    
    print(f"fibonacci(15) = {fibonacci(15)}")
```

**Идеи для улучшения**:
1. Добавьте декоратор для ограничения максимального времени выполнения функции
2. Создайте декоратор для повторных попыток выполнения функции в случае ошибки
3. Реализуйте декоратор для профилирования использования памяти
4. Добавьте возможность сохранения результатов профилирования в файл
5. Создайте декоратор, который параллельно выполняет функцию в отдельном потоке или процессе

### Задание 3: Работа с генераторами и бесконечными последовательностями

**Задача**: Реализуйте набор функций для работы с числовыми последовательностями с использованием генераторов:
1. Генератор простых чисел
2. Генератор чисел Фибоначчи
3. Функцию для получения среза бесконечной последовательности
4. Функцию для фильтрации последовательности по условию
5. Функцию для применения операции к соседним элементам последовательности

**Решение**:

```python
import itertools
from math import sqrt

def primes():
    """Генератор простых чисел."""
    # Начинаем с 2 - первого простого числа
    yield 2
    
    # Все четные числа кроме 2 не являются простыми,
    # поэтому далее проверяем только нечетные числа
    candidate = 3
    
    # Вспомогательная функция для проверки простоты числа
    def is_prime(n):
        # Проверяем делители до корня из числа
        for i in range(3, int(sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    while True:
        if is_prime(candidate):
            yield candidate
        candidate += 2

def fibonacci():
    """Генератор чисел Фибоначчи."""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

def take(n, sequence):
    """
    Получает первые n элементов из последовательности.
    
    Args:
        n: Количество элементов
        sequence: Итератор или генератор
        
    Returns:
        Список из первых n элементов
    """
    return list(itertools.islice(sequence, n))

def filter_sequence(condition, sequence):
    """
    Фильтрует последовательность по заданному условию.
    
    Args:
        condition: Функция условия, принимающая элемент и возвращающая bool
        sequence: Итератор или генератор
        
    Returns:
        Генератор отфильтрованных элементов
    """
    for item in sequence:
        if condition(item):
            yield item

def pairwise_apply(operation, sequence):
    """
    Применяет операцию к соседним элементам последовательности.
    
    Args:
        operation: Функция, принимающая два аргумента
        sequence: Итератор или генератор
        
    Returns:
        Генератор результатов операции над соседними элементами
    """
    # Получаем первый элемент
    try:
        a = next(sequence)
    except StopIteration:
        return
    
    # Применяем операцию к соседним элементам
    for b in sequence:
        yield operation(a, b)
        a = b

# Пример использования
if __name__ == "__main__":
    # Генератор простых чисел
    prime_generator = primes()
    print("Первые 10 простых чисел:")
    print(take(10, prime_generator))
    
    # Генератор чисел Фибоначчи
    fib_generator = fibonacci()
    print("\nПервые 10 чисел Фибоначчи:")
    print(take(10, fib_generator))
    
    # Фильтрация последовательности
    print("\nПервые 5 простых чисел больше 20:")
    filtered_primes = filter_sequence(lambda x: x > 20, primes())
    print(take(5, filtered_primes))
    
    # Применение операции к соседним элементам
    print("\nСумма соседних элементов среди первых 10 чисел Фибоначчи:")
    fib_generator = fibonacci()
    fib_first_10 = take(10, fib_generator)
    sums = list(pairwise_apply(lambda a, b: a + b, iter(fib_first_10)))
    print(sums)
    
    # Комбинирование функций
    print("\nПервые 5 чисел Фибоначчи, которые также являются простыми:")
    fib_gen = fibonacci()
    prime_fibs = filter_sequence(lambda x: x in take(100, primes()), fib_gen)
    print(take(5, prime_fibs))
```

**Идеи для улучшения**:
1. Реализуйте генераторы для других математических последовательностей (треугольные числа, совершенные числа)
2. Добавьте возможность объединения нескольких последовательностей
3. Реализуйте функцию для "зиппования" двух последовательностей
4. Создайте функцию для получения скользящего окна заданного размера из последовательности
5. Добавьте функцию для поиска первого элемента в последовательности, удовлетворяющего условию

### Задание 4: Проект "Мини-библиотека для обработки текста"

**Задача**: Создайте функциональную библиотеку для обработки текста, которая будет включать следующие возможности:
1. Очистка текста от специальных символов и лишних пробелов
2. Разбиение текста на предложения и слова
3. Подсчет частотности слов
4. Поиск наиболее распространенных n-грамм (последовательностей из n слов)
5. Простой анализ тональности текста

**Решение**:

```python
import re
import string
from collections import Counter
from functools import partial, reduce

def clean_text(text):
    """
    Очищает текст от специальных символов и лишних пробелов.
    
    Args:
        text: Исходный текст
        
    Returns:
        Очищенный текст
    """
    # Заменяем переносы строк на пробелы
    text = text.replace('\n', ' ')
    
    # Удаляем пунктуацию
    text = text.translate(str.maketrans('', '', string.punctuation))
    
    # Удаляем лишние пробелы
    text = re.sub(r'\s+', ' ', text).strip()
    
    return text

def split_into_sentences(text):
    """
    Разбивает текст на предложения.
    
    Args:
        text: Исходный текст
        
    Returns:
        Список предложений
    """
    # Паттерн для разделения текста на предложения
    # Учитываем точки, восклицательные и вопросительные знаки как окончания предложений
    pattern = r'(?<=[.!?])\s+'
    sentences = re.split(pattern, text)
    
    # Фильтруем пустые предложения
    return list(filter(bool, sentences))

def split_into_words(text):
    """
    Разбивает текст на слова.
    
    Args:
        text: Исходный текст
        
    Returns:
        Список слов в нижнем регистре
    """
    # Очищаем текст
    clean = clean_text(text)
    
    # Разбиваем на слова
    words = clean.lower().split()
    
    return words

def count_word_frequency(text):
    """
    Подсчитывает частотность слов в тексте.
    
    Args:
        text: Исходный текст
        
    Returns:
        Словарь {слово: количество}
    """
    words = split_into_words(text)
    return Counter(words)

def find_most_common_words(text, n=10):
    """
    Находит n наиболее часто встречающихся слов в тексте.
    
    Args:
        text: Исходный текст
        n: Количество слов для возврата
        
    Returns:
        Список (слово, количество) пар
    """
    word_counts = count_word_frequency(text)
    return word_counts.most_common(n)

def get_ngrams(text, n=2):
    """
    Извлекает n-граммы из текста.
    
    Args:
        text: Исходный текст
        n: Размер n-граммы
        
    Returns:
        Список n-грамм
    """
    words = split_into_words(text)
    
    # Если слов меньше, чем размер n-граммы, возвращаем пустой список
    if len(words) < n:
        return []
    
    # Создаем n-граммы
    ngrams = [tuple(words[i:i+n]) for i in range(len(words) - n + 1)]
    
    return ngrams

def find_most_common_ngrams(text, n=2, top=10):
    """
    Находит наиболее часто встречающиеся n-граммы в тексте.
    
    Args:
        text: Исходный текст
        n: Размер n-граммы
        top: Количество результатов для возврата
        
    Returns:
        Список (n-грамма, количество) пар
    """
    ngrams = get_ngrams(text, n)
    ngram_counts = Counter(ngrams)
    
    return ngram_counts.most_common(top)

def sentiment_analyze(text, positive_words=None, negative_words=None):
    """
    Проводит простой анализ тональности текста.
    
    Args:
        text: Исходный текст
        positive_words: Список позитивных слов
        negative_words: Список негативных слов
        
    Returns:
        Словарь с результатами анализа
    """
    # Список базовых позитивных слов (на русском)
    default_positive = [
        'хорошо', 'отлично', 'замечательно', 'прекрасно', 'великолепно',
        'радость', 'счастье', 'любовь', 'восторг', 'наслаждение',
        'плюс', 'положительно', 'успех', 'удача', 'победа'
    ]
    
    # Список базовых негативных слов (на русском)
    default_negative = [
        'плохо', 'ужасно', 'отвратительно', 'кошмарно', 'ужасающе',
        'грусть', 'печаль', 'ненависть', 'злость', 'разочарование',
        'минус', 'отрицательно', 'провал', 'неудача', 'поражение'
    ]
    
    # Используем переданные списки или значения по умолчанию
    positive_words = positive_words or default_positive
    negative_words = negative_words or default_negative
    
    # Получаем список слов из текста
    words = split_into_words(text)
    
    # Подсчитываем количество позитивных и негативных слов
    positive_count = sum(1 for word in words if word in positive_words)
    negative_count = sum(1 for word in words if word in negative_words)
    
    # Определяем тональность текста
    if positive_count > negative_count:
        sentiment = 'positive'
    elif positive_count < negative_count:
        sentiment = 'negative'
    else:
        sentiment = 'neutral'
    
    # Вычисляем общий счет
    total_words = len(words)
    if total_words > 0:
        positive_score = positive_count / total_words
        negative_score = negative_count / total_words
    else:
        positive_score = 0
        negative_score = 0
    
    return {
        'sentiment': sentiment,
        'positive_count': positive_count,
        'negative_count': negative_count,
        'positive_score': positive_score,
        'negative_score': negative_score,
        'total_words': total_words
    }

def process_text(text, operations):
    """
    Обрабатывает текст с использованием цепочки операций.
    
    Args:
        text: Исходный текст
        operations: Список функций для применения к тексту
        
    Returns:
        Результат обработки
    """
    return reduce(lambda result, op: op(result), operations, text)

# Пример использования
if __name__ == "__main__":
    # Пример текста (на русском)
    sample_text = """
    Программирование на Python - это здорово! Язык очень гибкий и удобный.
    Иногда он может быть немного медленным, но для большинства задач это не проблема.
    Python имеет огромную экосистему библиотек и фреймворков.
    Это делает его отличным выбором для многих проектов.
    """
    
    print("Исходный текст:")
    print(sample_text)
    
    print("\nОчищенный текст:")
    cleaned = clean_text(sample_text)
    print(cleaned)
    
    print("\nПредложения:")
    sentences = split_into_sentences(sample_text)
    for i, sentence in enumerate(sentences, 1):
        print(f"{i}. {sentence}")
    
    print("\nЧастотность слов:")
    word_freq = count_word_frequency(sample_text)
    for word, count in word_freq.most_common(10):
        print(f"{word}: {count}")
    
    print("\nБиграммы:")
    bigrams = find_most_common_ngrams(sample_text, n=2, top=5)
    for bigram, count in bigrams:
        print(f"{' '.join(bigram)}: {count}")
    
    print("\nАнализ тональности:")
    sentiment = sentiment_analyze(sample_text)
    print(f"Тональность: {sentiment['sentiment']}")
    print(f"Позитивных слов: {sentiment['positive_count']}")
    print(f"Негативных слов: {sentiment['negative_count']}")
    print(f"Позитивный счет: {sentiment['positive_score']:.2f}")
    print(f"Негативный счет: {sentiment['negative_score']:.2f}")
    
    # Пример цепочки операций
    print("\nПрименение цепочки операций:")
    operations = [
        clean_text,
        lambda t: t.lower(),
        lambda t: f"Обработанный текст: {t}",
    ]
    
    result = process_text(sample_text, operations)
    print(result)
```

**Идеи для улучшения**:
1. Добавьте поддержку стоп-слов (слов, которые нужно игнорировать при анализе)
2. Реализуйте стемминг или лемматизацию для приведения слов к основной форме
3. Добавьте более сложный алгоритм анализа тональности с использованием словарей тональности
4. Реализуйте функции для извлечения ключевых слов и фраз
5. Добавьте возможность визуализации результатов анализа
6. Реализуйте функции для сравнения текстов и определения их сходства
