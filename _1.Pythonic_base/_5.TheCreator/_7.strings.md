# Python: Обработка текста и строк

Этот документ содержит подробное описание встроенных библиотек Python для работы с текстом и строками. Документация ориентирована на Python 3.8+ и предназначена для senior-разработчиков.

## Содержание

- [Строки в Python](#строки-в-python)
- [string](#string)
- [re](#re)
- [difflib](#difflib)
- [textwrap](#textwrap)
- [unicodedata](#unicodedata)
- [stringprep](#stringprep)
- [readline](#readline)
- [rlcompleter](#rlcompleter)

## Строки в Python

Строки в Python 3 представляют собой последовательности Unicode-символов и имеют богатый набор встроенных методов.

**Внутреннее устройство:**
- Строки неизменяемы (immutable).
- Представляют символы в Unicode.
- Используют оптимизации для хранения ASCII и Latin-1 символов.
- Реализуют интерфейс последовательности (sequence).

**Ключевые методы строк:**
- **Поиск и проверки:**
  - `str.find(sub[, start[, end]])` - находит подстроку.
  - `str.index(sub[, start[, end]])` - находит подстроку, вызывает ValueError при отсутствии.
  - `str.count(sub[, start[, end]])` - считает вхождения подстроки.
  - `str.startswith(prefix[, start[, end]])` - проверяет начало строки.
  - `str.endswith(suffix[, start[, end]])` - проверяет окончание строки.
  - `str.isalpha()`, `str.isdigit()`, `str.isalnum()`, `str.isspace()` - проверки типа символов.

- **Регистр:**
  - `str.upper()`, `str.lower()` - преобразование к верхнему/нижнему регистру.
  - `str.capitalize()` - переводит первый символ в верхний регистр.
  - `str.title()` - преобразует начальные буквы всех слов в верхний регистр.
  - `str.swapcase()` - меняет регистр на противоположный.

- **Форматирование:**
  - `str.format(*args, **kwargs)` - форматирование строки.
  - `str.format_map(mapping)` - форматирование с использованием словаря.
  - `f"..."` - f-строки (Python 3.6+).
  - `str.center(width[, fillchar])`, `str.ljust(width[, fillchar])`, `str.rjust(width[, fillchar])` - выравнивание.
  - `str.zfill(width)` - дополняет строку нулями слева.

- **Разделение и объединение:**
  - `str.split(sep=None, maxsplit=-1)` - разделяет строку на список подстрок.
  - `str.rsplit(sep=None, maxsplit=-1)` - разделяет строку справа.
  - `str.splitlines([keepends])` - разделяет строку по строкам.
  - `str.join(iterable)` - объединяет строки из итерируемого объекта.

- **Удаление символов:**
  - `str.strip([chars])` - удаляет символы в начале и конце.
  - `str.lstrip([chars])`, `str.rstrip([chars])` - удаляет символы слева/справа.

- **Замена:**
  - `str.replace(old, new[, count])` - заменяет подстроку.
  - `str.translate(table)` - заменяет символы согласно таблице преобразования.
  - `str.expandtabs(tabsize=8)` - заменяет табуляции пробелами.

- **Кодировка:**
  - `str.encode(encoding="utf-8", errors="strict")` - кодирует строку в байты.

**Примеры:**
```python
# Базовые операции со строками
s = "Hello, World!"
print(len(s))             # 13
print(s[0])               # 'H'
print(s[7:12])            # 'World'
print(s.upper())          # 'HELLO, WORLD!'
print(s.find("World"))    # 7
print("World" in s)       # True

# Разделение и объединение
words = s.split(", ")     # ['Hello', 'World!']
new_s = ", ".join(words)  # 'Hello, World!'

# Различные проверки
digits = "12345"
print(digits.isdigit())   # True
print(s.isalpha())        # False

# Удаление символов
whitespace = "   content   "
print(whitespace.strip())  # 'content'

# Форматирование
name = "Alice"
age = 30
print(f"{name} is {age} years old")  # 'Alice is 30 years old'
print("{} is {} years old".format(name, age))  # То же самое

# Замена и модификация
text = "Hello, World!"
new_text = text.replace("World", "Python")  # 'Hello, Python!'

# Многострочный текст
multi = """Это
многострочная
строка"""
lines = multi.splitlines()  # ['Это', 'многострочная', 'строка']
```

**Особенности для senior-разработчиков:**
- Строки в Python 3 всегда используют Unicode, в отличие от Python 2, где были отдельные типы `str` (байты) и `unicode`.
- Операции со строками не изменяют исходную строку, а создают новую, что важно учитывать при оптимизации.
- Для конкатенации большого количества строк используйте `.join()` вместо оператора `+`, т.к. это эффективнее.
- F-строки (f"...") в Python 3.6+ обеспечивают более понятное и производительное форматирование.
- С Python 3.8 для f-строк добавлен специальный синтаксис `=` для отладки: `f"{expr=}"` выводит и выражение, и его значение.
- Метод `.casefold()` предоставляет более агрессивное преобразование регистра, чем `.lower()`, учитывая особенности разных языков.
- Для построения сложных строк с высокой производительностью используйте `io.StringIO`.

## string

Модуль `string` предоставляет общие константы и классы для работы со строками.

**Описание:** Содержит полезные константы и классы для работы с различными шаблонами строк.

**Ключевые компоненты:**
- **Константы:**
  - `string.ascii_letters` - все буквы ASCII (a-z и A-Z).
  - `string.ascii_lowercase` - строчные буквы ASCII (a-z).
  - `string.ascii_uppercase` - заглавные буквы ASCII (A-Z).
  - `string.digits` - десятичные цифры (0-9).
  - `string.hexdigits` - шестнадцатеричные цифры (0-9, a-f, A-F).
  - `string.octdigits` - восьмеричные цифры (0-7).
  - `string.punctuation` - символы пунктуации.
  - `string.printable` - все печатаемые символы ASCII.
  - `string.whitespace` - пробельные символы.

- **Классы:**
  - `string.Template` - шаблоны для подстановки строк.
  - `string.Formatter` - форматирование строк с расширенными возможностями.

**Примеры:**
```python
import string
import random

# Использование констант
print(string.ascii_lowercase)  # 'abcdefghijklmnopqrstuvwxyz'
print(string.digits)           # '0123456789'

# Создание набора символов для паролей
password_chars = string.ascii_letters + string.digits + string.punctuation

# Генерация случайного пароля
def generate_password(length=12):
    return ''.join(random.choice(password_chars) for _ in range(length))

password = generate_password()
print(password)  # Что-то вроде: 'a8$2Kl*p9X!z'

# Использование шаблонов
template = string.Template("$name работает в $company")
result = template.substitute(name="Иван", company="Acme Inc.")
print(result)  # 'Иван работает в Acme Inc.'

# Безопасная подстановка с значениями по умолчанию
data = {"name": "Мария"}
try:
    result = template.substitute(data)  # Вызовет KeyError: 'company'
except KeyError:
    result = template.safe_substitute(data)  # 'Мария работает в $company'
    print(result)

# Кастомизация синтаксиса шаблона
class MyTemplate(string.Template):
    delimiter = '%'  # Заменяем $ на %
    idpattern = '[a-z]+'  # Допускаем только строчные буквы в именах

my_template = MyTemplate("%name любит %language")
print(my_template.substitute(name="Алиса", language="Python"))  # 'Алиса любит Python'
```

**Особенности для senior-разработчиков:**
- `string.Template` предоставляет более безопасный способ для подстановки пользовательских данных по сравнению с `.format()`.
- `.safe_substitute()` не вызывает исключений при отсутствии ключей, что полезно для шаблонизации с частичными данными.
- Константы модуля полезны для создания валидаторов, генераторов паролей и других подобных инструментов.
- Класс `string.Formatter` лежит в основе метода `str.format()` и может быть расширен для создания кастомизированных форматировщиков.
- При создании пользовательских шаблонов можно переопределить не только разделитель, но и шаблоны для идентификаторов и шаблонных экранирований.
- По производительности `string.Template` уступает f-строкам и `.format()`, поэтому используйте их, когда безопасность важнее скорости.

## re

Модуль `re` предоставляет поддержку регулярных выражений.

**Описание:** Мощный инструмент для поиска и манипулирования строками на основе шаблонов.

**Внутреннее устройство:**
- Реализует движок регулярных выражений на основе детерминированных конечных автоматов (DFA).
- Компилирует регулярные выражения в объекты шаблонов для многократного использования.
- Поддерживает расширенный синтаксис регулярных выражений PCRE-like.

**Ключевые функции:**
- `re.compile(pattern, flags=0)` - компилирует регулярное выражение в объект шаблона.
- `re.search(pattern, string, flags=0)` - ищет любое вхождение шаблона.
- `re.match(pattern, string, flags=0)` - ищет шаблон только в начале строки.
- `re.fullmatch(pattern, string, flags=0)` - проверяет соответствие всей строки шаблону.
- `re.findall(pattern, string, flags=0)` - находит все непересекающиеся вхождения.
- `re.finditer(pattern, string, flags=0)` - возвращает итератор по объектам Match.
- `re.split(pattern, string, maxsplit=0, flags=0)` - разделяет строку по шаблону.
- `re.sub(pattern, repl, string, count=0, flags=0)` - заменяет вхождения шаблона.
- `re.subn(pattern, repl, string, count=0, flags=0)` - как sub, но возвращает кортеж (новая_строка, количество_замен).

**Флаги:**
- `re.IGNORECASE` или `re.I` - игнорирование регистра.
- `re.MULTILINE` или `re.M` - режим многострочного соответствия.
- `re.DOTALL` или `re.S` - точка соответствует любому символу, включая перевод строки.
- `re.VERBOSE` или `re.X` - режим подробных регулярных выражений (с комментариями).
- `re.ASCII` или `re.A` - ограничивает \w, \W, \b, \B и т.д. только ASCII.
- `re.UNICODE` или `re.U` - интерпретирует шаблон как Unicode (по умолчанию).

**Примеры:**
```python
import re

# Простой поиск
text = "Python is a great programming language. Python is easy to learn."
matches = re.findall(r"Python", text)
print(matches)  # ['Python', 'Python']

# Использование групп
pattern = r"(\w+) is (\w+)"
matches = re.findall(pattern, text)
print(matches)  # [('Python', 'a'), ('Python', 'easy')]

# Компиляция для повторного использования
email_pattern = re.compile(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}")
emails = ["user@example.com", "invalid@", "another.user@company.co.uk"]
for email in emails:
    if email_pattern.match(email):
        print(f"{email} является корректным адресом электронной почты.")
    else:
        print(f"{email} не является корректным адресом электронной почты.")

# Использование search и объекта Match
match = re.search(r"Python (\w+) (\w+)", text)
if match:
    print(match.group(0))  # 'Python is a'
    print(match.group(1))  # 'is'
    print(match.group(2))  # 'a'
    print(match.groups())  # ('is', 'a')
    print(match.start(), match.end())  # 0 10

# Замена с помощью функции
def capitalize_word(match):
    return match.group(0).upper()

result = re.sub(r"\b\w+\b", capitalize_word, "python is great", count=2)
print(result)  # 'PYTHON IS great'

# Использование именованных групп
pattern = r"(?P<name>\w+) is (?P<attribute>\w+)"
match = re.search(pattern, text)
if match:
    print(match.groupdict())  # {'name': 'Python', 'attribute': 'a'}

# Многострочные и подробные регулярные выражения
pattern = re.compile(r"""
    \b          # Граница слова
    [A-Z]       # Первая буква - заглавная
    \w*         # Оставшиеся буквы
    \b          # Граница слова
""", re.VERBOSE)
```

**Особенности для senior-разработчиков:**
- Всегда используйте сырые строки (r"...") для регулярных выражений, чтобы избежать проблем с экранированием.
- Компиляция регулярных выражений (`re.compile()`) значительно повышает производительность при многократном использовании.
- Используйте неперехватывающие группы `(?:...)` вместо `(...)`, когда не нужно сохранять совпадения.
- При написании сложных регулярных выражений используйте флаг `re.VERBOSE` для улучшения читаемости и документирования.
- Функция `re.finditer()` более эффективна, чем `re.findall()` для последовательной обработки совпадений, особенно для больших текстов.
- Обратные ссылки `\1`, `\2` и т.д. (или `\g<1>`, `\g<2>`) в шаблоне замены позволяют включать найденные группы.
- Именованные группы `(?P<name>...)` и обращение к ним `\g<name>` делают сложные регулярные выражения более понятными.
- Для очень больших текстов или сложных шаблонов рассмотрите использование более специализированных библиотек, таких как `regex` (расширенная поддержка Unicode) или `pyahocorasick` (для поиска множества строк).

## difflib

Модуль `difflib` предоставляет инструменты для сравнения последовательностей и поиска различий.

**Описание:** Помогает находить различия между последовательностями, особенно текстовыми файлами.

**Внутреннее устройство:**
- Реализует алгоритмы для поиска наибольшей общей подпоследовательности (LCS).
- Генерирует различия в форматах, аналогичных Unix-утилите `diff`.
- Включает расширенные возможности для нечёткого сопоставления.

**Ключевые компоненты:**
- `difflib.SequenceMatcher` - сравнивает пары последовательностей.
- `difflib.Differ` - сравнивает последовательности строк и создаёт человекочитаемые различия.
- `difflib.HtmlDiff` - создаёт HTML-отчёты о различиях.
- `difflib.ndiff()` - сравнивает строки и создаёт diff-подобный вывод.
- `difflib.unified_diff()` - создаёт унифицированный diff.
- `difflib.context_diff()` - создаёт контекстный diff.
- `difflib.get_close_matches()` - находит близкие соответствия строке.

**Примеры:**
```python
import difflib

# Нахождение близких совпадений
words = ['привет', 'проспект', 'перспектива', 'приветствие', 'проект']
matches = difflib.get_close_matches('привет', words, n=3, cutoff=0.5)
print(matches)  # ['привет', 'проект', 'проспект']

# Сравнение строк с SequenceMatcher
s = difflib.SequenceMatcher(None, "абвгд", "абд")
print(s.ratio())  # 0.75 (степень сходства)
print(s.get_matching_blocks())  # Список совпадающих блоков

# Использование различных форматов diff
text1 = '''Привет, это первая строка.
Вторая строка без изменений.
Третья строка будет изменена.
Четвертая строка будет удалена.
Пятая строка без изменений.'''.splitlines()

text2 = '''Привет, это первая строка изменена.
Вторая строка без изменений.
Третья строка изменена.
Новая строка добавлена.
Пятая строка без изменений.'''.splitlines()

# Создание diff в унифицированном формате
diff = list(difflib.unified_diff(text1, text2, lineterm=''))
for line in diff:
    print(line)

# Использование Differ для подробного сравнения
d = difflib.Differ()
diff = list(d.compare(text1, text2))
print('\n'.join(diff))

# Создание HTML-отчёта
html_diff = difflib.HtmlDiff().make_file(text1, text2, 'Версия 1', 'Версия 2')
with open('diff.html', 'w', encoding='utf-8') as f:
    f.write(html_diff)

# Поиск различий с пользовательской функцией равенства
def case_insensitive_equal(a, b):
    return a.lower() == b.lower()

s = difflib.SequenceMatcher(None, "Hello World", "hello world", case_insensitive_equal)
print(s.ratio())  # 1.0
```

**Особенности для senior-разработчиков:**
- `SequenceMatcher` работает с любыми сравнимыми последовательностями, не только со строками.
- Функция `SequenceMatcher.get_opcodes()` возвращает список операций (тег, i1, i2, j1, j2), где тег - один из: 'replace', 'delete', 'insert', 'equal'.
- Для улучшения производительности при сравнении текстовых файлов используйте параметр `autojunk=False` в `SequenceMatcher`.
- При сравнении длинных последовательностей, содержащих много общих элементов (например, HTML-файлы), рассмотрите параметр `isjunk` для игнорирования частых, но незначимых элементов.
- Для оптимизации сравнения можно предварительно преобразовать последовательности, например, разбить текст на слова вместо символов.
- `difflib.context_diff()` и `difflib.unified_diff()` генерируют выводы, совместимые с утилитами `patch`.
- Для визуализации различий в веб-приложениях можно использовать `HtmlDiff` с параметром `wrapcolumn` для контроля ширины вывода.

## textwrap

Модуль `textwrap` предоставляет различные утилиты для форматирования и обёртывания текста.

**Описание:** Позволяет переносить и форматировать текст, контролируя его ширину и отступы.

**Ключевые функции:**
- `textwrap.wrap(text, width=70, ...)` - оборачивает текст на строки заданной ширины.
- `textwrap.fill(text, width=70, ...)` - оборачивает текст и возвращает одну строку с переносами строк.
- `textwrap.dedent(text)` - удаляет общие отступы из многострочного текста.
- `textwrap.indent(text, prefix, predicate=None)` - добавляет префикс к выбранным строкам.
- `textwrap.shorten(text, width, ...)` - сокращает текст до указанной ширины.

**Примеры:**
```python
import textwrap

# Длинный текст для примеров
text = """Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur vitae lacus ipsum. 
Donec vulputate nisl ac mauris facilisis fermentum. Nullam eleifend libero mauris, 
non tristique quam vestibulum vel."""

# Перенос текста
wrapped = textwrap.wrap(text, width=50)
for line in wrapped:
    print(line)

# Заполнение с указанной шириной
filled = textwrap.fill(text, width=50)
print(filled)

# Работа с отступами
indented_text = """
    Этот текст имеет
    общий отступ из четырех пробелов.
    Мы хотим его удалить.
"""
dedented_text = textwrap.dedent(indented_text)
print("До:")
print(indented_text)
print("После:")
print(dedented_text)

# Добавление отступов
def should_indent(line):
    return len(line.strip()) > 0  # Не добавлять отступы к пустым строкам

indented = textwrap.indent(dedented_text, '> ', predicate=should_indent)
print(indented)

# Сокращение текста
shortened = textwrap.shorten(text, width=80, placeholder="...")
print(shortened)

# Комбинирование различных функций
original = """
    Этот текст имеет отступы
    и слишком длинные строки, которые нужно переформатировать
    в более читаемый вид с меньшей шириной.
"""
processed = textwrap.fill(textwrap.dedent(original).strip(), width=40)
print(processed)
```

**Особенности для senior-разработчиков:**
- Функция `dedent()` особенно полезна при работе с многострочными строками внутри кода с отступами.
- Параметр `initial_indent` позволяет задать специальный отступ для первой строки, а `subsequent_indent` - для последующих.
- Параметр `expand_tabs` (по умолчанию True) заменяет табуляцию на пробелы перед обработкой.
- `max_lines` в функции `shorten()` ограничивает количество строк в результате.
- Функция `indent()` с пользовательским `predicate` позволяет создавать сложное форматирование, например, для выделения определённых строк.
- Для сохранения параграфов при переносе используйте `textwrap.TextWrapper` с параметром `replace_whitespace=False`.
- Для более сложного форматирования рассмотрите использование специализированных библиотек, таких как `rich` или `docutils`.

## unicodedata

Модуль `unicodedata` предоставляет доступ к базе данных Unicode.

**Описание:** Позволяет работать с характеристиками Unicode-символов, такими как имя, категория, нормализация и декомпозиция.

**Внутреннее устройство:**
- Включает базу данных Unicode Character Database (UCD).
- Предоставляет функции для нормализации и определения свойств символов.
- Поддерживает различные формы нормализации (NFC, NFD, NFKC, NFKD).

**Ключевые функции:**
- `unicodedata.lookup(name)` - поиск символа по имени.
- `unicodedata.name(char[, default])` - возвращает имя символа Unicode.
- `unicodedata.category(char)` - возвращает категорию символа.
- `unicodedata.combining(char)` - возвращает ранг комбинирования символа.
- `unicodedata.east_asian_width(char)` - возвращает ширину символа в восточно-азиатском контексте.
- `unicodedata.normalize(form, unistr)` - нормализует строку Unicode.
- `unicodedata.decomposition(char)` - возвращает декомпозицию символа.
- `unicodedata.is_normalized(form, unistr)` - проверяет, нормализована ли строка.

**Примеры:**
```python
import unicodedata

# Поиск символа по имени
symbol = unicodedata.lookup("GREEK CAPITAL LETTER DELTA")
print(symbol)  # 'Δ'

# Получение имени символа
print(unicodedata.name('Δ'))  # 'GREEK CAPITAL LETTER DELTA'
print(unicodedata.name('£'))  # 'POUND SIGN'

# Категории символов
print(unicodedata.category('A'))  # 'Lu' (Letter, uppercase)
print(unicodedata.category(' '))  # 'Zs' (Separator, space)
print(unicodedata.category('1'))  # 'Nd' (Number, decimal digit)

# Нормализация строк
original = 'café'  # может быть записано двумя способами в Unicode
form1 = 'café'  # 'e' и акцент как отдельные символы
form2 = 'café'  # 'é' как один символ

print([unicodedata.name(c) for c in form1])
print([unicodedata.name(c) for c in form2])

# Нормализация NFC - композитная форма (предпочтительна для хранения)
nfc_form = unicodedata.normalize('NFC', form1)
print([unicodedata.name(c) for c in nfc_form])

# Нормализация NFD - декомпозиционная форма
nfd_form = unicodedata.normalize('NFD', form2)
print([unicodedata.name(c) for c in nfd_form])

# Сравнение строк после нормализации
text1 = 'café'
text2 = 'cafe\u0301'  # 'e' с комбинирующим акутом

print(text1 == text2)  # False
print(unicodedata.normalize('NFC', text1) == unicodedata.normalize('NFC', text2))  # True

# Удаление диакритических знаков
def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return ''.join([c for c in nfkd_form if not unicodedata.combining(c)])

print(remove_accents('Привéт'))  # 'Привет'
```

**Особенности для senior-разработчиков:**
- Для корректного сравнения строк с диакритическими знаками нормализуйте их перед сравнением.
- Нормализация NFC (композитная) обычно предпочтительнее для хранения, поскольку она более компактна.
- NFKC и NFKD формы нормализации могут изменять внешний вид строки, так как они заменяют совместимые символы на их канонические эквиваленты.
- Категории символов Unicode следуют схеме: первая буква - основная категория (L - буква, N - число, P - знак пунктуации и т.д.), вторая - подкатегория.
- При работе с юникодом в базах данных убедитесь, что используется соответствующая кодировка и правильная нормализация.
- Функция `is_normalized()` (Python 3.8+) позволяет эффективно проверять нормализацию без фактической нормализации.
- Для сложной обработки текста на разных языках рассмотрите специализированные библиотеки, такие как `unidecode` для транслитерации или `icu` для полной поддержки Unicode.

## stringprep

Модуль `stringprep` предоставляет функции для подготовки строк Unicode к протоколам Интернета.

**Описание:** Реализует алгоритм stringprep, описанный в RFC 3454, для подготовки строк Unicode к использованию в сетевых протоколах.

**Внутреннее устройство:**
- Включает таблицы запрещённых и разрешённых символов согласно RFC 3454.
- Предоставляет функции для проверки и трансформации строк.
- Применяется в протоколах IDNA, SASL и других.

**Ключевые функции:**
- `stringprep.in_table_a1(char)` - проверяет, присутствует ли символ в таблице A.1 (неприемлемые символы).
- `stringprep.in_table_b1(char)` - проверяет, присутствует ли символ в таблице B.1 (символы отображения в ничто).
- `stringprep.in_table_c*` - различные проверки для категорий C (символы, требующие особой обработки).
- `stringprep.in_table_d*` - проверки для бидирекциональных текстов.
- `stringprep.map_table_b2(char)` - маппинг символов согласно таблице B.2.
- `stringprep.map_table_b3(char)` - маппинг символов согласно таблице B.3.

**Примеры:**
```python
import stringprep
import unicodedata

# Проверка символов на приемлемость
def is_acceptable_for_idna(char):
    # Проверка, не входит ли символ в запрещённые таблицы
    if stringprep.in_table_a1(char):
        return False  # Неприемлемо - неназначенный код
    if stringprep.in_table_c12(char):
        return False  # Неприемлемо - управляющий символ
    if stringprep.in_table_c22(char):
        return False  # Неприемлемо - комбинирующая метка
    if stringprep.in_table_c3(char):
        return False  # Неприемлемо - символы форматирования
    if stringprep.in_table_c4(char):
        return False  # Неприемлемо - запрещённые символы
    if stringprep.in_table_c5(char):
        return False  # Неприемлемо - заместители суррогатных пар
    if stringprep.in_table_c6(char):
        return False  # Неприемлемо - недопустимые кодовые точки
    if stringprep.in_table_c7(char):
        return False  # Неприемлемо - приватное использование
    if stringprep.in_table_c8(char):
        return False  # Неприемлемо - устаревшие символы
    if stringprep.in_table_c9(char):
        return False  # Неприемлемо - символы тегов
    return True

# Полная подготовка строки для IDNA (упрощенная версия)
def prepare_for_idna(input_str):
    # Нормализация
    normalized = unicodedata.normalize('NFKC', input_str)
    
    # Проверка и фильтрация символов
    result = []
    for char in normalized:
        if stringprep.in_table_b1(char):
            continue  # Пропускаем символы, отображаемые в ничто
        if not is_acceptable_for_idna(char):
            raise ValueError(f"Неприемлемый символ: {char} ({unicodedata.name(char, 'Неизвестно')})")
        result.append(char)
    
    # Проверка на бидирекциональные символы
    has_r_al = any(stringprep.in_table_d1(c) for c in result)
    has_l = any(stringprep.in_table_d2(c) for c in result)
    
    if has_r_al:
        # Если есть символы RandALCat, первый и последний должны быть RandALCat
        if not (stringprep.in_table_d1(result[0]) and stringprep.in_table_d1(result[-1])):
            raise ValueError("Нарушение правил бидирекционального текста")
        # Не должно быть символов LCat
        if has_l:
            raise ValueError("Смешение бидирекциональных категорий")
    
    return ''.join(result)

# Тестирование
try:
    idna_string = prepare_for_idna("café")
    print(f"После подготовки: {idna_string}")
except ValueError as e:
    print(f"Ошибка: {e}")
```

**Особенности для senior-разработчиков:**
- Модуль `stringprep` редко используется напрямую; обычно применяются высокоуровневые API, такие как `idna` для доменных имен.
- Стандарт RFC 3454 определяет несколько профилей stringprep (для разных протоколов); какие таблицы используются, зависит от профиля.
- При работе с интернационализированными доменными именами (IDN) используйте специализированные библиотеки, такие как `idna`.
- При работе с протоколом XMPP (Jabber) используйте stringprep-профиль Nodeprep для подготовки имён пользователей.
- Современные реализации IDNA (IDNAv2008) используют алгоритм UTS #46 вместо stringprep, который устарел.
- При разработке новых протоколов рекомендуется использовать PRECIS Framework (RFC 8264) вместо stringprep.
- Работа с бидирекциональным текстом (смесь LTR и RTL) требует особого внимания для обеспечения однозначной интерпретации.

## readline

Модуль `readline` предоставляет интерфейс для библиотеки GNU Readline.

**Описание:** Обеспечивает редактирование командной строки и управление историей ввода для интерактивных программ.

**Внутреннее устройство:**
- Оболочка для библиотеки GNU Readline (в Unix) или libedit (в macOS).
- Не доступен в стандартной поставке Python для Windows.
- Предоставляет функции для управления историей и настройки автодополнения.

**Ключевые функции:**
- `readline.parse_and_bind(command)` - выполняет команду инициализации Readline.
- `readline.read_init_file([filename])` - читает файл инициализации Readline.
- `readline.get_line_buffer()` - возвращает текущую строку ввода.
- `readline.insert_text(text)` - вставляет текст в текущую строку.
- `readline.read_history_file([filename])` - читает историю из файла.
- `readline.write_history_file([filename])` - записывает историю в файл.
- `readline.set_completer([function])` - устанавливает функцию автодополнения.
- `readline.set_completer_delims(string)` - устанавливает разделители слов для автодополнения.
- `readline.add_history(line)` - добавляет строку в историю.
- `readline.get_history_item(index)` - получает элемент истории по индексу.
- `readline.remove_history_item(pos)` - удаляет элемент истории.
- `readline.replace_history_item(pos, line)` - заменяет элемент истории.

**Примеры:**
```python
import readline
import os
import atexit

# Путь к файлу истории
histfile = os.path.expanduser('~/.python_history')
history_length = 1000

# Загрузка истории при запуске
try:
    readline.read_history_file(histfile)
    readline.set_history_length(history_length)
except FileNotFoundError:
    pass

# Сохранение истории при выходе
atexit.register(readline.write_history_file, histfile)

# Настройка автодополнения
commands = ['help', 'list', 'load', 'save', 'exit', 'quit']

def completer(text, state):
    options = [cmd for cmd in commands if cmd.startswith(text)]
    if state < len(options):
        return options[state]
    return None

readline.set_completer(completer)
readline.parse_and_bind("tab: complete")  # Включение автодополнения по Tab

# Простая оболочка с историей и автодополнением
while True:
    try:
        line = input('> ')
        if line in ('exit', 'quit'):
            break
        elif line == 'history':
            # Вывод последних 10 команд истории
            for i in range(1, min(11, readline.get_current_history_length() + 1)):
                print(f"{i}: {readline.get_history_item(i)}")
        else:
            print(f"Выполнение команды: {line}")
    except KeyboardInterrupt:
        print("Прервано пользователем")
        break
    except EOFError:
        print("\nВыход")
        break
```

**Особенности для senior-разработчиков:**
- `readline` улучшает интерактивный опыт в командной строке, но не входит в стандартную поставку Python для Windows. Для кросс-платформенных решений рассмотрите `python-prompt-toolkit` или `pyreadline`.
- Настройка автодополнения с помощью контекстно-зависимых комплитеров повышает удобство использования интерактивных скриптов.
- Функция `set_pre_input_hook()` позволяет выполнить код перед началом ввода, что полезно для показа подсказок или предварительного заполнения строки.
- `set_startup_hook()` вызывается при каждом новом вводе, что позволяет настраивать контекст для каждой строки.
- Для управления корректной шириной терминала используйте `get_screen_size()` (где доступно).
- В Unix-подобных системах `readline` позволяет редактировать многострочный ввод и использовать сочетания клавиш в стиле Emacs или Vi.
- При разработке сложных интерактивных приложений рассмотрите использование специализированных библиотек, таких как `cmd`, `cmd2` или `python-prompt-toolkit`.

## rlcompleter

Модуль `rlcompleter` предоставляет функции автодополнения для интерактивной оболочки Python.

**Описание:** Расширяет возможности модуля `readline` для автодополнения имён Python.

**Внутреннее устройство:**
- Использует модуль `readline` для интеграции с механизмом автодополнения.
- Анализирует текущее состояние интерпретатора Python для поиска доступных имён.
- Включается автоматически в интерактивном режиме через файл `.pythonrc`.

**Ключевой класс:**
- `rlcompleter.Completer([namespace])` - создаёт объект-комплитер для автодополнения.

**Примеры:**
```python
import readline
import rlcompleter

# Активация автодополнения в интерактивной сессии
readline.parse_and_bind("tab: complete")

# Для Windows используйте следующее (требуется pyreadline)
# readline.parse_and_bind("bind ^I rl_complete")

# Создание комплитера с пользовательским пространством имён
namespace = {'os': __import__('os'), 'sys': __import__('sys')}
completer = rlcompleter.Completer(namespace)

# Ручное использование комплитера
for i in range(10):
    completion = completer.complete('os.', i)
    if completion is None:
        break
    print(completion)

# Создание кастомного комплитера на основе rlcompleter
class CustomCompleter(rlcompleter.Completer):
    def __init__(self, namespace=None):
        super().__init__(namespace)
        self.custom_commands = ['help', 'exit', 'load', 'save']
    
    def complete(self, text, state):
        # Проверяем сначала пользовательские команды
        if text.strip() and not '.' in text:
            matches = [cmd for cmd in self.custom_commands if cmd.startswith(text)]
            if state < len(matches):
                return matches[state]
            # Сдвигаем state для стандартного комплитера
            state -= len(matches)
        
        # Возвращаемся к обычному Python-автодополнению
        return super().complete(text, state)

# Установка пользовательского комплитера
custom_completer = CustomCompleter()
readline.set_completer(custom_completer.complete)
```

**Особенности для senior-разработчиков:**
- Модуль `rlcompleter` лучше всего подходит для интерактивных оболочек Python, а не для общих программ командной строки.
- Для интеграции автодополнения в проект можно использовать код из модуля `code` (интерактивные интерпретаторы).
- В пользовательском пространстве имён можно предоставить доступ только к безопасным или релевантным объектам.
- Для полноценной интерактивной оболочки с автодополнением рассмотрите использование `IPython` или `ptpython`.
- Комбинация `readline`, `rlcompleter` и модуля `code` позволяет создавать встроенные интерактивные консоли для отладки.
- В Windows для аналогичной функциональности необходимо установить `pyreadline` или использовать альтернативные решения.
- Кастомные комплитеры могут использоваться для интеграции документации, подсказок типов и других контекстно-зависимых возможностей.

## codecs

Модуль `codecs` предоставляет интерфейс для работы с кодировками и выполнения кодирования/декодирования.

**Описание:** Обеспечивает доступ к кодекам для преобразования между текстом и различными форматами кодировок.

**Внутреннее устройство:**
- Содержит реестр кодеков, поддерживаемых Python.
- Обеспечивает базовый интерфейс для всех кодеков через классы Codec, IncrementalEncoder/Decoder и StreamReader/Writer.
- Позволяет регистрировать собственные кодеки.

**Ключевые функции:**
- `codecs.encode(obj, encoding='utf-8', errors='strict')` - кодирует объект в заданную кодировку.
- `codecs.decode(obj, encoding='utf-8', errors='strict')` - декодирует объект из заданной кодировки.
- `codecs.open(filename, mode='r', encoding=None, errors='strict', ...)` - открывает файл с указанной кодировкой.
- `codecs.getencoder(encoding)` - возвращает функцию кодирования.
- `codecs.getdecoder(encoding)` - возвращает функцию декодирования.
- `codecs.register(search_function)` - регистрирует новую поисковую функцию кодека.
- `codecs.lookup(encoding)` - ищет информацию о кодеке по имени.
- `codecs.EncodedFile(file, data_encoding, file_encoding=None)` - обертка над файлом для перекодирования.

**Варианты обработки ошибок:**
- `'strict'` - вызывает исключение при ошибке (по умолчанию).
- `'ignore'` - игнорирует некодируемые символы.
- `'replace'` - заменяет некодируемые символы маркером замены.
- `'xmlcharrefreplace'` - заменяет символы соответствующими XML-ссылками.
- `'backslashreplace'` - заменяет символы последовательностями с обратной косой чертой.
- `'namereplace'` - заменяет символы последовательностями \N{...}.

**Примеры:**
```python
import codecs
import sys

# Базовое кодирование и декодирование
text = "Привет, мир!"
encoded = codecs.encode(text, 'utf-8')
print(encoded)  # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82, \xd0\xbc\xd0\xb8\xd1\x80!'
decoded = codecs.decode(encoded, 'utf-8')
print(decoded)  # "Привет, мир!"

# Работа с файлами в определенной кодировке
with codecs.open('file.txt', 'w', encoding='utf-8') as f:
    f.write("Текст с Unicode символами: 你好, こんにちは, مرحبا")

with codecs.open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    print(content)

# Использование различных обработчиков ошибок
text_with_special_chars = "Символ евро: €, символ рубля: ₽"

# Кодирование с различными обработчиками ошибок
try:
    ascii_strict = codecs.encode(text_with_special_chars, 'ascii', 'strict')
except UnicodeEncodeError as e:
    print(f"Ошибка (strict): {e}")  # Выводит ошибку для символа '€'

ascii_ignore = codecs.encode(text_with_special_chars, 'ascii', 'ignore')
print(ascii_ignore)  # b'Symbol :, symbol :'

ascii_replace = codecs.encode(text_with_special_chars, 'ascii', 'replace')
print(ascii_replace)  # b'Symbol ?: ?, symbol ?: ?'

ascii_xmlcharrefreplace = codecs.encode(text_with_special_chars, 'ascii', 'xmlcharrefreplace')
print(ascii_xmlcharrefreplace)  # b'Symbol &#8364;: &#8364;, symbol &#8381;: &#8381;'

# Использование инкрементального кодирования
encoder = codecs.getincrementalencoder('utf-8')()
output = encoder.encode("Первая часть")
output += encoder.encode(" и вторая часть")
output += encoder.encode("", final=True)  # Завершение кодирования
print(output)

# Создание потока кодирования
writer = codecs.getwriter('utf-8')(sys.stdout.buffer)
writer.write("Вывод в UTF-8 на консоль\n")
```

**Особенности для senior-разработчиков:**
- Функция `codecs.open()` предпочтительнее встроенной `open()` для работы со старыми версиями Python, где встроенная может не обрабатывать кодировки корректно.
- При работе с файлами в разных кодировках, всегда явно указывайте кодировку, избегая автоопределения.
- Для обработки потоков данных с разными кодировками используйте `IncrementalEncoder/Decoder`.
- При разработке собственных кодеков, следуйте протоколу кодека, реализуя методы encode() и decode().
- Используйте `StreamReader` и `StreamWriter` для высокоуровневой работы с закодированными данными.
- Для обработки ошибок в специфических сценариях, можно регистрировать собственные обработчики ошибок через `codecs.register_error()`.
- Модуль `codecs` обеспечивает поддержку BOM (Byte Order Mark), что важно при работе с форматами UTF-16 и UTF-32.

## gettext

Модуль `gettext` предоставляет интернационализацию (i18n) и локализацию (l10n) для приложений Python.

**Описание:** Обеспечивает механизм для перевода текстовых строк в приложениях.

**Внутреннее устройство:**
- Использует каталоги сообщений в формате GNU gettext (.mo файлы).
- Поддерживает контекстные переводы и множественные формы.
- Позволяет переводить приложение без изменения его кода.

**Ключевые функции:**
- `gettext.gettext(message)` - возвращает перевод сообщения.
- `gettext.dgettext(domain, message)` - возвращает перевод из указанного домена.
- `gettext.ngettext(singular, plural, n)` - обрабатывает множественные формы.
- `gettext.dngettext(domain, singular, plural, n)` - множественные формы из указанного домена.
- `gettext.pgettext(context, message)` - контекстный перевод.
- `gettext.dpgettext(domain, context, message)` - контекстный перевод из указанного домена.
- `gettext.install(domain, localedir=None)` - устанавливает переводы глобально.
- `gettext.translation(domain, localedir=None, languages=None)` - возвращает объект перевода.
- `gettext.find(domain, localedir=None, languages=None)` - ищет файл перевода.

**Примеры:**
```python
import gettext
import os

# Настройка локализации
# Предполагается, что каталоги переводов находятся в ./locale/LANG/LC_MESSAGES/myapp.mo
localedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'locale')

# Инициализация с установкой перевода в глобальном пространстве
gettext.install('myapp', localedir)

# Теперь функция _() доступна глобально для перевода строк
print(_("Hello, world!"))  # Будет переведено, если есть перевод

# Использование без глобальной установки
t = gettext.translation('myapp', localedir, fallback=True)
_ = t.gettext  # Функция перевода

print(_("Welcome to my application"))  # Будет переведено

# Множественные формы
n = 5
print(gettext.ngettext("There is %d item", "There are %d items", n) % n)

# Контекстный перевод (используется, когда одно слово может иметь разные переводы в разных контекстах)
print(gettext.pgettext("menu", "File"))  # "File" в контексте меню
print(gettext.pgettext("disk", "File"))  # "File" в контексте файловой системы

# Пример класса с переводом
class LocalizedApplication:
    def __init__(self, language=None):
        self.language = language
        # Установка перевода для этого экземпляра
        if language:
            self.translator = gettext.translation('myapp', localedir, 
                                                 languages=[language], fallback=True)
        else:
            self.translator = gettext.translation('myapp', localedir, fallback=True)
        
        self._ = self.translator.gettext
    
    def greet(self, name):
        # Перевод с форматированием
        return self._("Hello, {}!").format(name)

# Создание экземпляров с разными языками
app_en = LocalizedApplication('en')
app_ru = LocalizedApplication('ru')
app_de = LocalizedApplication('de')

print(app_en.greet("John"))  # Английский перевод
print(app_ru.greet("John"))  # Русский перевод
print(app_de.greet("John"))  # Немецкий перевод
```

**Особенности для senior-разработчиков:**
- Для полноценной локализации используйте специализированные инструменты для создания и поддержки .po/.mo файлов: `xgettext`, `msgfmt`, `poedit`.
- Структура каталогов для переводов обычно: `locale/LANG/LC_MESSAGES/domain.mo`, где LANG - код языка (например, 'ru', 'en_US').
- Используйте одинарную функцию (_) для простых строк и различные вариации (N_, P_, D_) для множественных форм и контекстных переводов.
- Для более сложных сценариев (например, веб-приложения) рассмотрите библиотеки высокого уровня, такие как Flask-Babel или Django i18n.
- При работе с `%` для форматирования переводов, учитывайте, что порядок аргументов может меняться в разных языках. Используйте именованные параметры или современное форматирование строк (`.format()` или f-строки).
- Если ваше приложение использует многопоточность, используйте локальную привязку перевода к потоку, а не глобальную установку.
- Для мультидоменных приложений (например, с плагинами) используйте `DomainTextWrapper` для переключения между доменами.
- При разработке библиотек, избегайте использования `gettext.install()`, чтобы не влиять на окружение приложений, которые используют вашу библиотеку.

## chardet

Модуль `chardet` предоставляет возможность определения кодировки текстового содержимого.

**Описание:** Определяет кодировку текста или файла на основе статистического анализа содержимого.

**Внутреннее устройство:**
- Использует алгоритмы определения кодировки из различных браузеров.
- Анализирует распределение байт и последовательности символов для определения кодировки.
- Поддерживает множество кодировок, включая восточноазиатские.

**Примечание:** `chardet` не является встроенным модулем Python и требует установки: `pip install chardet`.

**Ключевые функции:**
- `chardet.detect(byte_str)` - определяет кодировку байтовой строки.
- `chardet.UniversalDetector` - класс для инкрементального определения кодировки.

**Примеры:**
```python
import chardet

# Определение кодировки строки
sample_text_cp1251 = "Привет, мир!".encode('cp1251')
result = chardet.detect(sample_text_cp1251)
print(result)  # {'encoding': 'windows-1251', 'confidence': 0.99, 'language': 'Russian'}

# Декодирование с использованием определенной кодировки
decoded_text = sample_text_cp1251.decode(result['encoding'])
print(decoded_text)  # "Привет, мир!"

# Определение кодировки файла
def detect_file_encoding(filename):
    with open(filename, 'rb') as f:
        rawdata = f.read()
        result = chardet.detect(rawdata)
        return result

# Пример использования с файлом
try:
    encoding_info = detect_file_encoding('sample.txt')
    print(f"Кодировка: {encoding_info['encoding']}, уверенность: {encoding_info['confidence']}")
    
    # Чтение файла с определенной кодировкой
    with open('sample.txt', 'r', encoding=encoding_info['encoding']) as f:
        content = f.read()
        print(content)
except FileNotFoundError:
    print("Файл не найден.")

# Инкрементальное определение кодировки для больших файлов
def detect_encoding_incrementally(filename):
    detector = chardet.UniversalDetector()
    with open(filename, 'rb') as f:
        for line in f:
            detector.feed(line)
            if detector.done:
                break
    detector.close()
    return detector.result

# Применение инкрементального детектора
try:
    result = detect_encoding_incrementally('large_file.txt')
    print(result)
except FileNotFoundError:
    print("Файл не найден.")
```

**Особенности для senior-разработчиков:**
- `chardet` дает приближенный результат; точность зависит от длины и содержимого текста.
- Для повышения точности предоставляйте как можно больше текста (обычно >1KB).
- Поле `confidence` в результате указывает на уверенность в определении (от 0 до 1).
- Для очень больших файлов используйте `UniversalDetector` для экономии памяти.
- При работе с веб-страницами сначала проверяйте HTTP-заголовок Content-Type и метатег charset.
- У определенных языков (например, японский) может быть несколько распространенных кодировок, поэтому дополнительные предположения о языке могут повысить точность.
- Для критически важных приложений рассмотрите альтернативные детекторы кодировки, такие как ICU или настраиваемые решения, которые учитывают специфику ваших данных.
- После определения кодировки рекомендуется стандартизировать данные в UTF-8 для дальнейшей обработки.