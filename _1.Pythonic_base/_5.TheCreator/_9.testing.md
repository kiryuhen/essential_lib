# Тестирование в Python

## Основные концепции

Тестирование — неотъемлемая часть разработки программного обеспечения, особенно для middle/senior разработчиков. Хорошо протестированный код более надежен, легче поддерживается и рефакторится, а также служит формой документации.

В Python существует множество инструментов и подходов к тестированию:

- **Виды тестирования**: модульное, интеграционное, функциональное, нагрузочное
- **Фреймворки для тестирования**: pytest, unittest, nose
- **Мокирование и патчинг**: unittest.mock, pytest-mock
- **Покрытие кода**: coverage.py
- **Фикстуры и параметризация**: pytest fixtures, pytest.mark.parametrize
- **Тестирование веб-приложений**: requests, selenium, pytest-django, pytest-flask

## Модульное тестирование (Unit Testing)

### unittest

Стандартная библиотека Python предоставляет фреймворк для модульного тестирования — `unittest`.

```python
# mymath.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

```python
# test_mymath.py
import unittest
from mymath import add, subtract, multiply, divide

class TestMathFunctions(unittest.TestCase):
    
    def test_add(self):
        self.assertEqual(add(3, 5), 8)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(-1, -1), -2)
    
    def test_subtract(self):
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(1, 1), 0)
        self.assertEqual(subtract(-1, -1), 0)
    
    def test_multiply(self):
        self.assertEqual(multiply(3, 5), 15)
        self.assertEqual(multiply(-1, 1), -1)
        self.assertEqual(multiply(-1, -1), 1)
    
    def test_divide(self):
        self.assertEqual(divide(6, 3), 2)
        self.assertEqual(divide(1, 1), 1)
        self.assertAlmostEqual(divide(1, 3), 0.333333, places=5)
        
        # Проверка исключения
        with self.assertRaises(ValueError):
            divide(1, 0)

if __name__ == '__main__':
    unittest.main()
```

Запуск тестов: `python -m unittest test_mymath.py`

### pytest

pytest — более современный и мощный фреймворк для тестирования, который значительно упрощает написание тестов.

```python
# test_mymath_pytest.py
import pytest
from mymath import add, subtract, multiply, divide

def test_add():
    assert add(3, 5) == 8
    assert add(-1, 1) == 0
    assert add(-1, -1) == -2

def test_subtract():
    assert subtract(5, 3) == 2
    assert subtract(1, 1) == 0
    assert subtract(-1, -1) == 0

def test_multiply():
    assert multiply(3, 5) == 15
    assert multiply(-1, 1) == -1
    assert multiply(-1, -1) == 1

def test_divide():
    assert divide(6, 3) == 2
    assert divide(1, 1) == 1
    assert divide(1, 3) == pytest.approx(0.333333, 0.00001)
    
    # Проверка исключения
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(1, 0)
```

Запуск тестов: `pytest test_mymath_pytest.py -v`

### Фикстуры в pytest

Фикстуры (fixtures) — это механизм в pytest, который позволяет установить состояние перед запуском тестов и очистить после.

```python
# test_with_fixtures.py
import pytest
import tempfile
import os

@pytest.fixture
def temp_file():
    """Фикстура, которая создает временный файл."""
    # Подготовка - создаем временный файл
    fd, path = tempfile.mkstemp()
    with os.fdopen(fd, 'w') as f:
        f.write("Hello, World!")
    
    # Передаем путь к файлу тесту
    yield path
    
    # Очистка - удаляем файл после теста
    os.remove(path)

def test_read_file(temp_file):
    """Тест, который использует фикстуру temp_file."""
    with open(temp_file, 'r') as f:
        content = f.read()
    assert content == "Hello, World!"
```

### Параметризация тестов

Параметризация тестов позволяет запускать один и тот же тест с разными входными данными.

```python
# test_parametrize.py
import pytest
from mymath import add, subtract, multiply, divide

@pytest.mark.parametrize("a, b, expected", [
    (1, 2, 3),
    (5, 5, 10),
    (-1, 1, 0),
    (0, 0, 0),
])
def test_add_parametrized(a, b, expected):
    assert add(a, b) == expected

@pytest.mark.parametrize("a, b, expected", [
    (6, 2, 3),
    (10, 2, 5),
    (1, 1, 1),
    (0, 1, 0),
])
def test_divide_parametrized(a, b, expected):
    assert divide(a, b) == expected

@pytest.mark.parametrize("a, b", [
    (1, 0),
    (5, 0),
    (-1, 0),
])
def test_divide_by_zero(a, b):
    with pytest.raises(ValueError):
        divide(a, b)
```

### Пропуск тестов и условное выполнение

```python
# test_skipping.py
import pytest
import sys
import platform

def test_basic():
    assert 1 + 1 == 2

@pytest.mark.skip(reason="Временно отключен")
def test_skipped():
    assert 1 + 1 == 3  # Этот тест не будет выполнен

@pytest.mark.skipif(sys.version_info < (3, 7), reason="Требуется Python 3.7+")
def test_new_feature():
    # Тест для функционала, который работает только в Python 3.7+
    assert True

@pytest.mark.xfail(reason="Известная проблема")
def test_expected_to_fail():
    assert 1 + 1 == 3  # Тест будет выполнен, но ожидается, что он провалится

@pytest.mark.xfail(platform.system() == "Windows", reason="Не работает на Windows")
def test_platform_specific():
    # Тест, который может провалиться на Windows
    assert True
```

## Мокирование и патчинг

### Основы патчинга с unittest.mock

Модуль `unittest.mock` позволяет заменять части системы фиктивными объектами (мокам) во время тестирования.

```python
# user_service.py
import requests

def get_user_data(user_id):
    """Получает данные пользователя из API."""
    response = requests.get(f"https://jsonplaceholder.typicode.com/users/{user_id}")
    if response.status_code == 200:
        return response.json()
    else:
        return None

def get_user_name(user_id):
    """Получает имя пользователя."""
    user_data = get_user_data(user_id)
    if user_data:
        return user_data.get('name')
    return None
```

```python
# test_user_service.py
import unittest
from unittest.mock import patch
from user_service import get_user_data, get_user_name

class TestUserService(unittest.TestCase):
    
    @patch('user_service.requests.get')
    def test_get_user_data(self, mock_get):
        # Настраиваем мок
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'id': 1,
            'name': 'John Doe',
            'email': 'john@example.com'
        }
        mock_get.return_value = mock_response
        
        # Вызываем тестируемую функцию
        user_data = get_user_data(1)
        
        # Проверяем результат
        self.assertEqual(user_data['name'], 'John Doe')
        self.assertEqual(user_data['email'], 'john@example.com')
        
        # Проверяем, что запрос был сделан с правильным URL
        mock_get.assert_called_once_with('https://jsonplaceholder.typicode.com/users/1')
    
    @patch('user_service.get_user_data')
    def test_get_user_name(self, mock_get_user_data):
        # Настраиваем мок для get_user_data
        mock_get_user_data.return_value = {
            'id': 1,
            'name': 'John Doe',
            'email': 'john@example.com'
        }
        
        # Вызываем тестируемую функцию
        name = get_user_name(1)
        
        # Проверяем результат
        self.assertEqual(name, 'John Doe')
        
        # Проверяем, что get_user_data был вызван с правильным ID
        mock_get_user_data.assert_called_once_with(1)
```

### Мокирование с pytest-mock

`pytest-mock` — это плагин для pytest, который предоставляет удобную фикстуру `mocker` для мокирования.

```python
# test_with_pytest_mock.py
import pytest
from user_service import get_user_data, get_user_name

def test_get_user_data(mocker):
    # Создаем и настраиваем мок
    mock_get = mocker.patch('user_service.requests.get')
    mock_response = mocker.Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        'id': 1,
        'name': 'John Doe',
        'email': 'john@example.com'
    }
    mock_get.return_value = mock_response
    
    # Вызываем тестируемую функцию
    user_data = get_user_data(1)
    
    # Проверяем результат
    assert user_data['name'] == 'John Doe'
    assert user_data['email'] == 'john@example.com'
    
    # Проверяем, что запрос был сделан с правильным URL
    mock_get.assert_called_once_with('https://jsonplaceholder.typicode.com/users/1')

def test_get_user_name(mocker):
    # Создаем и настраиваем мок
    mock_data = {
        'id': 1,
        'name': 'John Doe',
        'email': 'john@example.com'
    }
    mocker.patch('user_service.get_user_data', return_value=mock_data)
    
    # Вызываем тестируемую функцию
    name = get_user_name(1)
    
    # Проверяем результат
    assert name == 'John Doe'
```

### Шпионы (Spies)

Шпионы позволяют отслеживать вызовы реальных методов, не заменяя их функциональность.

```python
# test_spying.py
def test_spy_on_method(mocker):
    # Создаем объект для тестирования
    class Calculator:
        def add(self, a, b):
            return a + b
        
        def calculate(self, a, b):
            # Этот метод вызывает add
            return self.add(a, b)
    
    calc = Calculator()
    
    # Создаем шпиона для метода add
    spy = mocker.spy(calc, 'add')
    
    # Вызываем метод, который должен использовать add
    result = calc.calculate(2, 3)
    
    # Проверяем результат
    assert result == 5
    
    # Проверяем, что add был вызван с правильными параметрами
    spy.assert_called_once_with(2, 3)
```

### Mагические (специальные) методы

Mock поддерживает магические методы Python:

```python
# test_magic_methods.py
def test_magic_methods(mocker):
    # Создаем мок с реализацией магических методов
    mock_obj = mocker.MagicMock()
    
    # Настраиваем поведение __str__
    mock_obj.__str__.return_value = "Mock Object"
    
    # Настраиваем поведение __len__
    mock_obj.__len__.return_value = 5
    
    # Настраиваем поведение __getitem__
    mock_obj.__getitem__.side_effect = lambda key: {
        'name': 'John',
        'age': 30
    }.get(key)
    
    # Проверяем поведение
    assert str(mock_obj) == "Mock Object"
    assert len(mock_obj) == 5
    assert mock_obj['name'] == 'John'
    assert mock_obj['age'] == 30
```

## Интеграционное тестирование

Интеграционное тестирование проверяет взаимодействие между компонентами системы.

### Тестирование с базой данных

```python
# database.py
import sqlite3

class UserDatabase:
    def __init__(self, db_path=':memory:'):
        self.db_path = db_path
        self.connection = None
    
    def connect(self):
        self.connection = sqlite3.connect(self.db_path)
        cursor = self.connection.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL
        )
        ''')
        self.connection.commit()
    
    def close(self):
        if self.connection:
            self.connection.close()
            self.connection = None
    
    def add_user(self, name, email):
        cursor = self.connection.cursor()
        try:
            cursor.execute(
                'INSERT INTO users (name, email) VALUES (?, ?)',
                (name, email)
            )
            self.connection.commit()
            return cursor.lastrowid
        except sqlite3.IntegrityError:
            self.connection.rollback()
            return None
    
    def get_user(self, user_id):
        cursor = self.connection.cursor()
        cursor.execute('SELECT id, name, email FROM users WHERE id = ?', (user_id,))
        user_data = cursor.fetchone()
        if user_data:
            return {
                'id': user_data[0],
                'name': user_data[1],
                'email': user_data[2]
            }
        return None

# user_repository.py
class UserRepository:
    def __init__(self, database):
        self.db = database
    
    def create_user(self, name, email):
        return self.db.add_user(name, email)
    
    def get_user(self, user_id):
        return self.db.get_user(user_id)
```

```python
# test_user_repository.py
import pytest
from database import UserDatabase
from user_repository import UserRepository

@pytest.fixture
def user_db():
    # Настройка - создаем и подключаемся к БД
    db = UserDatabase(':memory:')
    db.connect()
    yield db
    # Очистка - закрываем соединение
    db.close()

@pytest.fixture
def user_repository(user_db):
    return UserRepository(user_db)

def test_create_user(user_repository):
    # Создаем пользователя
    user_id = user_repository.create_user("John Doe", "john@example.com")
    
    # Проверяем, что ID был возвращен
    assert user_id is not None
    assert user_id > 0

def test_get_user(user_repository):
    # Создаем пользователя
    user_id = user_repository.create_user("Jane Smith", "jane@example.com")
    
    # Получаем пользователя
    user = user_repository.get_user(user_id)
    
    # Проверяем данные
    assert user is not None
    assert user['name'] == "Jane Smith"
    assert user['email'] == "jane@example.com"

def test_create_duplicate_email(user_repository):
    # Создаем первого пользователя
    user_repository.create_user("John Doe", "same@example.com")
    
    # Пытаемся создать второго с тем же email
    user_id = user_repository.create_user("Jane Smith", "same@example.com")
    
    # Проверяем, что пользователь не был создан
    assert user_id is None
```

### Тестирование HTTP API

```python
# api_client.py
import requests

class UserClient:
    def __init__(self, base_url):
        self.base_url = base_url
    
    def get_user(self, user_id):
        response = requests.get(f"{self.base_url}/users/{user_id}")
        if response.status_code == 200:
            return response.json()
        return None
    
    def create_user(self, name, email):
        response = requests.post(
            f"{self.base_url}/users",
            json={"name": name, "email": email}
        )
        if response.status_code == 201:
            return response.json()
        return None
```

```python
# test_api_client.py
import pytest
import responses
from api_client import UserClient

@pytest.fixture
def user_client():
    return UserClient("https://api.example.com")

@responses.activate
def test_get_user(user_client):
    # Настраиваем моки для HTTP-запросов
    responses.add(
        responses.GET,
        "https://api.example.com/users/1",
        json={"id": 1, "name": "John Doe", "email": "john@example.com"},
        status=200
    )
    
    # Вызываем тестируемый метод
    user = user_client.get_user(1)
    
    # Проверяем результат
    assert user is not None
    assert user["name"] == "John Doe"
    assert user["email"] == "john@example.com"

@responses.activate
def test_get_user_not_found(user_client):
    # Настраиваем мок для несуществующего пользователя
    responses.add(
        responses.GET,
        "https://api.example.com/users/999",
        json={"error": "User not found"},
        status=404
    )
    
    # Вызываем тестируемый метод
    user = user_client.get_user(999)
    
    # Проверяем результат
    assert user is None

@responses.activate
def test_create_user(user_client):
    # Настраиваем мок для создания пользователя
    responses.add(
        responses.POST,
        "https://api.example.com/users",
        json={"id": 1, "name": "John Doe", "email": "john@example.com"},
        status=201
    )
    
    # Вызываем тестируемый метод
    user = user_client.create_user("John Doe", "john@example.com")
    
    # Проверяем результат
    assert user is not None
    assert user["id"] == 1
    assert user["name"] == "John Doe"
    
    # Проверяем, что запрос был отправлен с правильными данными
    assert len(responses.calls) == 1
    assert responses.calls[0].request.url == "https://api.example.com/users"
    assert responses.calls[0].request.body == b'{"name": "John Doe", "email": "john@example.com"}'
```

## Тестирование веб-приложений

### Тестирование Flask-приложений

```python
# app.py
from flask import Flask, jsonify, request, abort

app = Flask(__name__)

# Имитация базы данных
USERS = {}
NEXT_ID = 1

@app.route('/users', methods=['GET'])
def get_users():
    return jsonify(list(USERS.values()))

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = USERS.get(user_id)
    if not user:
        abort(404)
    return jsonify(user)

@app.route('/users', methods=['POST'])
def create_user():
    global NEXT_ID
    
    if not request.json or not 'name' in request.json or not 'email' in request.json:
        abort(400)
    
    user = {
        'id': NEXT_ID,
        'name': request.json['name'],
        'email': request.json['email']
    }
    
    USERS[NEXT_ID] = user
    NEXT_ID += 1
    
    return jsonify(user), 201

if __name__ == '__main__':
    app.run(debug=True)
```

```python
# test_flask_app.py
import pytest
import json
from app import app as flask_app

@pytest.fixture
def app():
    # Настройка приложения для тестирования
    flask_app.config.update({
        "TESTING": True,
    })
    yield flask_app

@pytest.fixture
def client(app):
    return app.test_client()

def test_get_users_empty(client):
    # Проверяем получение списка пользователей (пустой)
    response = client.get('/users')
    assert response.status_code == 200
    assert response.json == []

def test_create_user(client):
    # Создаем пользователя
    response = client.post(
        '/users',
        data=json.dumps({
            'name': 'John Doe',
            'email': 'john@example.com'
        }),
        content_type='application/json'
    )
    
    # Проверяем ответ
    assert response.status_code == 201
    assert response.json['name'] == 'John Doe'
    assert response.json['email'] == 'john@example.com'
    assert 'id' in response.json

def test_get_user(client):
    # Сначала создаем пользователя
    response = client.post(
        '/users',
        data=json.dumps({
            'name': 'Jane Smith',
            'email': 'jane@example.com'
        }),
        content_type='application/json'
    )
    user_id = response.json['id']
    
    # Теперь получаем пользователя по ID
    response = client.get(f'/users/{user_id}')
    assert response.status_code == 200
    assert response.json['name'] == 'Jane Smith'
    assert response.json['email'] == 'jane@example.com'

def test_get_user_not_found(client):
    # Запрашиваем несуществующего пользователя
    response = client.get('/users/999')
    assert response.status_code == 404
```

### Тестирование Django-приложений

```python
# models.py
from django.db import models

class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name

# views.py
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.core.exceptions import ObjectDoesNotExist
import json
from .models import User

@require_http_methods(["GET"])
def get_users(request):
    users = User.objects.all().values('id', 'name', 'email')
    return JsonResponse(list(users), safe=False)

@require_http_methods(["GET"])
def get_user(request, user_id):
    try:
        user = User.objects.values('id', 'name', 'email').get(pk=user_id)
        return JsonResponse(user)
    except ObjectDoesNotExist:
        return JsonResponse({"error": "User not found"}, status=404)

@require_http_methods(["POST"])
def create_user(request):
    try:
        data = json.loads(request.body)
        if not 'name' in data or not 'email' in data:
            return JsonResponse({"error": "Name and email are required"}, status=400)
        
        user = User.objects.create(name=data['name'], email=data['email'])
        return JsonResponse({
            'id': user.id,
            'name': user.name,
            'email': user.email
        }, status=201)
    except json.JSONDecodeError:
        return JsonResponse({"error": "Invalid JSON"}, status=400)
```

```python
# test_django_views.py
import json
import pytest
from django.urls import reverse
from django.test import Client
from .models import User

@pytest.fixture
def client():
    return Client()

@pytest.mark.django_db
def test_get_users_empty(client):
    # Проверяем получение списка пользователей (пустой)
    url = reverse('get_users')
    response = client.get(url)
    
    assert response.status_code == 200
    assert response.json() == []

@pytest.mark.django_db
def test_create_user(client):
    # Создаем пользователя
    url = reverse('create_user')
    data = {
        'name': 'John Doe',
        'email': 'john@example.com'
    }
    
    response = client.post(
        url,
        data=json.dumps(data),
        content_type='application/json'
    )
    
    # Проверяем ответ
    assert response.status_code == 201
    assert response.json()['name'] == 'John Doe'
    assert response.json()['email'] == 'john@example.com'
    assert 'id' in response.json()
    
    # Проверяем, что пользователь был создан в базе
    assert User.objects.count() == 1
    assert User.objects.first().name == 'John Doe'

@pytest.mark.django_db
def test_get_user(client):
    # Сначала создаем пользователя
    user = User.objects.create(name='Jane Smith', email='jane@example.com')
    
    # Теперь получаем пользователя по ID
    url = reverse('get_user', args=[user.id])
    response = client.get(url)
    
    assert response.status_code == 200
    assert response.json()['name'] == 'Jane Smith'
    assert response.json()['email'] == 'jane@example.com'

@pytest.mark.django_db
def test_get_user_not_found(client):
    # Запрашиваем несуществующего пользователя
    url = reverse('get_user', args=[999])
    response = client.get(url)
    
    assert response.status_code == 404
    assert response.json()['error'] == 'User not found'
```

### Тестирование FastAPI-приложений

```python
# main.py
from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

# Модель данных
class UserCreate(BaseModel):
    name: str
    email: str

class User(UserCreate):
    id: int

# Имитация базы данных
USERS = {}
NEXT_ID = 1

@app.get("/users", response_model=List[User])
def get_users():
    """Получить список всех пользователей."""
    return list(USERS.values())

@app.get("/users/{user_id}", response_model=User)
def get_user(user_id: int):
    """Получить пользователя по ID."""
    if user_id not in USERS:
        raise HTTPException(status_code=404, detail="User not found")
    return USERS[user_id]

@app.post("/users", response_model=User, status_code=201)
def create_user(user: UserCreate = Body(...)):
    """Создать нового пользователя."""
    global NEXT_ID
    
    new_user = User(id=NEXT_ID, **user.dict())
    USERS[NEXT_ID] = new_user
    NEXT_ID += 1
    
    return new_user
```

```python
# test_fastapi_app.py
from fastapi.testclient import TestClient
import pytest
from main import app

@pytest.fixture
def client():
    # Сбрасываем "базу данных" перед каждым тестом
    from main import USERS, NEXT_ID
    USERS.clear()
    globals()['NEXT_ID'] = 1
    
    return TestClient(app)

def test_get_users_empty(client):
    # Проверяем получение списка пользователей (пустой)
    response = client.get('/users')
    assert response.status_code == 200
    assert response.json() == []

def test_create_user(client):
    # Создаем пользователя
    response = client.post(
        '/users',
        json={
            'name': 'John Doe',
            'email': 'john@example.com'
        }
    )
    
    # Проверяем ответ
    assert response.status_code == 201
    assert response.json()['name'] == 'John Doe'
    assert response.json()['email'] == 'john@example.com'
    assert response.json()['id'] == 1

def test_get_user(client):
    # Сначала создаем пользователя
    response = client.post(
        '/users',
        json={
            'name': 'Jane Smith',
            'email': 'jane@example.com'
        }
    )
    user_id = response.json()['id']
    
    # Теперь получаем пользователя по ID
    response = client.get(f'/users/{user_id}')
    assert response.status_code == 200
    assert response.json()['name'] == 'Jane Smith'
    assert response.json()['email'] == 'jane@example.com'

def test_get_user_not_found(client):
    # Запрашиваем несуществующего пользователя
    response = client.get('/users/999')
    assert response.status_code == 404
    assert response.json()['detail'] == 'User not found'
```

## Функциональное тестирование

Функциональное тестирование проверяет работу системы в целом с точки зрения пользователя.

### Тестирование с Selenium

Selenium позволяет автоматизировать взаимодействие с веб-браузером.

```python
# test_selenium.py
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@pytest.fixture
def driver():
    # Инициализация драйвера браузера
    driver = webdriver.Chrome()
    driver.maximize_window()
    yield driver
    # Закрытие браузера после теста
    driver.quit()

def test_search_in_python_org(driver):
    # Открываем сайт python.org
    driver.get("https://www.python.org")
    
    # Находим поле для поиска
    search_box = driver.find_element(By.NAME, "q")
    
    # Вводим поисковый запрос
    search_box.send_keys("pycon")
    
    # Отправляем форму поиска
    search_box.submit()
    
    # Ждем загрузки результатов поиска
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.CLASS_NAME, "list-recent-events"))
    )
    
    # Проверяем наличие результатов
    results = driver.find_elements(By.CSS_SELECTOR, ".list-recent-events li")
    assert len(results) > 0
    
    # Проверяем, что на странице есть упоминание PyCon
    page_text = driver.find_element(By.TAG_NAME, "body").text
    assert "PyCon" in page_text

def test_login_form(driver):
    # Открываем страницу входа
    driver.get("https://example.com/login")
    
    # Находим поля формы и заполняем их
    username_input = driver.find_element(By.ID, "username")
    password_input = driver.find_element(By.ID, "password")
    
    username_input.send_keys("testuser")
    password_input.send_keys("password")
    
    # Нажимаем кнопку входа
    login_button = driver.find_element(By.ID, "login-button")
    login_button.click()
    
    # Ждем перенаправления на страницу профиля
    WebDriverWait(driver, 10).until(
        EC.url_contains("/profile")
    )
    
    # Проверяем, что вход выполнен успешно
    welcome_message = driver.find_element(By.ID, "welcome-message")
    assert "Welcome, testuser" in welcome_message.text
```

### Тестирование с Playwright

Playwright — современная альтернатива Selenium с рядом преимуществ.

```python
# test_playwright.py
import pytest
from playwright.sync_api import sync_playwright, Page, expect

@pytest.fixture(scope="session")
def browser():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        yield browser
        browser.close()

@pytest.fixture
def page(browser):
    page = browser.new_page()
    yield page
    page.close()

def test_search_in_python_org(page):
    # Открываем сайт python.org
    page.goto("https://www.python.org")
    
    # Находим поле для поиска и заполняем его
    page.fill('input[name="q"]', "pycon")
    
    # Отправляем форму поиска
    page.press('input[name="q"]', "Enter")
    
    # Ждем загрузки результатов поиска
    page.wait_for_selector(".list-recent-events")
    
    # Проверяем наличие результатов
    results = page.query_selector_all(".list-recent-events li")
    assert len(results) > 0
    
    # Проверяем, что на странице есть упоминание PyCon
    text_content = page.text_content("body")
    assert "PyCon" in text_content

def test_login_form(page):
    # Открываем страницу входа
    page.goto("https://example.com/login")
    
    # Заполняем форму входа
    page.fill("#username", "testuser")
    page.fill("#password", "password")
    
    # Нажимаем кнопку входа
    page.click("#login-button")
    
    # Ждем перенаправления на страницу профиля
    page.wait_for_url("**/profile")
    
    # Проверяем, что вход выполнен успешно
    expect(page.locator("#welcome-message")).to_contain_text("Welcome, testuser")
```

## Покрытие кода тестами

Покрытие кода тестами — это метрика, которая показывает, какая часть кода выполняется при запуске тестов.

### Использование coverage.py

```bash
# Установка coverage.py
pip install coverage

# Запуск тестов с измерением покрытия
coverage run -m pytest

# Вывод отчета о покрытии
coverage report

# Создание HTML-отчета для более детального анализа
coverage html
```

Пример создания отчета о покрытии кода тестами:

```python
# mymath.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

def factorial(n):
    if n < 0:
        raise ValueError("Factorial is defined only for non-negative integers")
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)
```

```python
# test_mymath.py
import pytest
from mymath import add, subtract, multiply, divide, factorial

def test_add():
    assert add(1, 2) == 3
    assert add(-1, 1) == 0

def test_subtract():
    assert subtract(5, 3) == 2
    assert subtract(1, 1) == 0

def test_multiply():
    assert multiply(3, 5) == 15
    assert multiply(-1, 1) == -1

def test_divide():
    assert divide(6, 3) == 2
    assert divide(1, 1) == 1
    
    with pytest.raises(ValueError):
        divide(1, 0)

# Нет тестов для функции factorial, что приведет к неполному покрытию
```

Запуск тестов с измерением покрытия:

```bash
coverage run -m pytest test_mymath.py
coverage report -m
```

Результат будет примерно таким:

```
Name         Stmts   Miss  Cover   Missing
------------------------------------------
mymath.py       15      5    67%   17-21
------------------------------------------
TOTAL           15      5    67%
```

### Использование pytest-cov

pytest-cov — это плагин для pytest, который интегрирует coverage.py с pytest.

```bash
# Установка pytest-cov
pip install pytest-cov

# Запуск тестов с измерением покрытия
pytest --cov=mymath test_mymath.py

# Создание HTML-отчета
pytest --cov=mymath --cov-report=html test_mymath.py
```

### Анализ покрытия и улучшение тестов

```python
# Добавляем недостающие тесты
def test_factorial():
    assert factorial(0) == 1
    assert factorial(1) == 1
    assert factorial(5) == 120
    
    with pytest.raises(ValueError):
        factorial(-1)
```

После добавления тестов покрытие должно достигнуть 100%.

## Организация тестов в проекте

### Структура каталогов

Типичная структура проекта с тестами:

```
my_project/
├── my_package/
│   ├── __init__.py
│   ├── module1.py
│   └── module2.py
└── tests/
    ├── __init__.py
    ├── test_module1.py
    └── test_module2.py
```

### Оптимальная организация тестов

- **Одна функция — один тест**: каждая функция тестирует один аспект
- **Один модуль — один файл с тестами**: каждый модуль имеет соответствующий файл с тестами
- **Группировка связанных тестов**: используйте классы для группировки связанных тестов
- **Именование тестов**: используйте говорящие имена, начинающиеся с test_

### Фикстуры и конфигурация

Для общих настроек используйте фикстуры pytest:

```python
# conftest.py
import pytest
import os
import tempfile
from myapp import create_app, db

@pytest.fixture
def app():
    """Создает и настраивает тестовое приложение."""
    # Создаем временную директорию для базы данных
    db_fd, db_path = tempfile.mkstemp()
    
    app = create_app({
        'TESTING': True,
        'DATABASE': db_path,
    })
    
    # Создаем таблицы базы данных
    with app.app_context():
        db.create_all()
    
    yield app
    
    # Очистка после теста
    os.close(db_fd)
    os.unlink(db_path)

@pytest.fixture
def client(app):
    """Создает тестовый клиент."""
    return app.test_client()

@pytest.fixture
def runner(app):
    """Создает тестовый CLI runner."""
    return app.test_cli_runner()
```

## Best Practices и рекомендации

### Принципы хорошего тестирования

1. **Тесты должны быть изолированными** — тесты не должны влиять друг на друга
2. **Тесты должны быть атомарными** — каждый тест проверяет одну конкретную вещь
3. **Тесты должны быть детерминированными** — тесты должны давать одинаковые результаты при каждом запуске
4. **Тесты должны быть легко читаемыми** — тесты должны быть простыми и понятными
5. **Тесты должны быть быстрыми** — тесты должны выполняться быстро
6. **Тесты должны быть поддерживаемыми** — тесты должны легко обновляться при изменении кода

### Паттерны тестирования

#### AAA (Arrange-Act-Assert)

```python
def test_add_user():
    # Arrange - подготовка
    database = UserDatabase(':memory:')
    database.connect()
    repository = UserRepository(database)
    
    # Act - действие
    user_id = repository.create_user("John", "john@example.com")
    
    # Assert - проверка
    assert user_id is not None
    user = repository.get_user(user_id)
    assert user['name'] == "John"
    assert user['email'] == "john@example.com"
```

#### Given-When-Then (BDD)

```python
def test_user_creation():
    # Given - начальные условия
    database = UserDatabase(':memory:')
    database.connect()
    repository = UserRepository(database)
    
    # When - выполняемое действие
    user_id = repository.create_user("John", "john@example.com")
    
    # Then - ожидаемый результат
    assert user_id is not None
    user = repository.get_user(user_id)
    assert user['name'] == "John"
    assert user['email'] == "john@example.com"
```

### Избегание антипаттернов

#### 1. Неизолированные тесты

Плохо:
```python
def test_create_user():
    # Тест создает пользователя, который может повлиять на другие тесты
    user_id = create_user("John", "john@example.com")
    assert user_id is not None

def test_get_user():
    # Тест зависит от предыдущего теста, который создал пользователя
    user = get_user(1)
    assert user['name'] == "John"
```

Хорошо:
```python
def test_create_user():
    # Настройка изолированной среды
    setup_test_database()
    
    # Тест
    user_id = create_user("John", "john@example.com")
    assert user_id is not None
    
    # Очистка
    teardown_test_database()

def test_get_user():
    # Настройка изолированной среды
    setup_test_database()
    
    # Создаем пользователя специально для этого теста
    user_id = create_user("Jane", "jane@example.com")
    
    # Тест
    user = get_user(user_id)
    assert user['name'] == "Jane"
    
    # Очистка
    teardown_test_database()
```

#### 2. Избыточное мокирование

Плохо:
```python
def test_over_mocking(mocker):
    # Мокирование всего, что можно
    mocker.patch('os.path.exists', return_value=True)
    mocker.patch('os.mkdir')
    mocker.patch('builtins.open')
    mocker.patch('json.dump')
    
    # Тестирование функции
    result = save_user_data({"name": "John"})
    assert result is True
```

Хорошо:
```python
def test_better_approach(tmp_path):
    # Использование временного каталога вместо мокирования файловой системы
    user_data = {"name": "John"}
    data_file = tmp_path / "users.json"
    
    # Тестирование функции с реальной файловой системой
    result = save_user_data(user_data, str(data_file))
    assert result is True
    
    # Проверка, что файл был создан и содержит корректные данные
    assert data_file.exists()
    with open(data_file, 'r') as f:
        saved_data = json.load(f)
        assert saved_data == user_data
```

#### 3. Тесты без проверок

Плохо:
```python
def test_without_assertions():
    # Тест выполняет функцию, но не проверяет результат
    process_data()
    # Нет assert, тест всегда проходит
```

Хорошо:
```python
def test_with_assertions():
    # Тест выполняет функцию и проверяет результат
    result = process_data()
    assert result is not None
    assert result['status'] == 'success'
```

#### 4. Волшебные строки и числа

Плохо:
```python
def test_magic_numbers():
    # Использование "волшебных" чисел без объяснения
    result = calculate_discount(100, 20)
    assert result == 80
```

Хорошо:
```python
def test_discount_calculation():
    # Ясное объяснение входных данных и ожидаемого результата
    original_price = 100
    discount_percent = 20
    expected_price = original_price * (1 - discount_percent / 100)
    
    result = calculate_discount(original_price, discount_percent)
    assert result == expected_price
```

## Тестирование производительности

### Профилирование и бенчмаркинг

```python
# test_performance.py
import pytest
import time

@pytest.mark.benchmark
def test_performance(benchmark):
    # Функция для тестирования
    def slow_function():
        time.sleep(0.1)
        return sum(i for i in range(1000000))
    
    # Запуск бенчмарка
    result = benchmark(slow_function)
    
    # Проверка результата
    assert result == 499999500000

# Запуск с pytest-benchmark
# pip install pytest-benchmark
# pytest test_performance.py -v
```

### Нагрузочное тестирование

```python
# load_test.py
import asyncio
import aiohttp
import time
from statistics import mean, median, stdev

async def fetch(session, url):
    """Выполняет GET-запрос и возвращает время ответа."""
    start_time = time.time()
    async with session.get(url) as response:
        await response.text()
        end_time = time.time()
        return end_time - start_time

async def load_test(url, num_requests, concurrency):
    """Проводит нагрузочное тестирование для указанного URL."""
    conn = aiohttp.TCPConnector(limit=concurrency)
    async with aiohttp.ClientSession(connector=conn) as session:
        tasks = []
        for _ in range(num_requests):
            tasks.append(fetch(session, url))
        
        # Выполняем все запросы
        response_times = await asyncio.gather(*tasks)
        
        # Анализируем результаты
        total_time = sum(response_times)
        avg_time = mean(response_times)
        med_time = median(response_times)
        min_time = min(response_times)
        max_time = max(response_times)
        std_dev = stdev(response_times) if len(response_times) > 1 else 0
        
        # Выводим статистику
        print(f"Всего запросов: {num_requests}")
        print(f"Одновременных соединений: {concurrency}")
        print(f"Общее время: {total_time:.2f} сек")
        print(f"Среднее время ответа: {avg_time:.4f} сек")
        print(f"Медианное время ответа: {med_time:.4f} сек")
        print(f"Минимальное время ответа: {min_time:.4f} сек")
        print(f"Максимальное время ответа: {max_time:.4f} сек")
        print(f"Стандартное отклонение: {std_dev:.4f} сек")
        print(f"Запросов в секунду: {num_requests / total_time:.2f}")
        
        return {
            'total_requests': num_requests,
            'concurrency': concurrency,
            'total_time': total_time,
            'avg_time': avg_time,
            'median_time': med_time,
            'min_time': min_time,
            'max_time': max_time,
            'std_dev': std_dev,
            'requests_per_second': num_requests / total_time
        }

# Запуск нагрузочного теста
async def main():
    url = "http://localhost:8000/api/users"
    
    # Тестирование с разным уровнем конкурентности
    concurrency_levels = [1, 5, 10, 20, 50]
    num_requests = 100
    
    for concurrency in concurrency_levels:
        print(f"\nТестирование с {concurrency} одновременными соединениями:")
        await load_test(url, num_requests, concurrency)

# asyncio.run(main())
```

## Continuous Integration и автоматизация тестирования

### Настройка тестов в GitHub Actions

```yaml
# .github/workflows/python-tests.yml
name: Python Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.8, 3.9, 3.10]

    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov flake8
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    
    - name: Lint with flake8
      run: |
        # Проверка синтаксиса
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # Проверка стиля кода
        flake8 . --count --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Test with pytest
      run: |
        pytest --cov=./ --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
      with:
        file: ./coverage.xml
        flags: unittests
        env_vars: OS,PYTHON
        fail_ci_if_error: true
```

### Использование tox для тестирования с разными версиями Python

```ini
# tox.ini
[tox]
envlist = py38, py39, py310, flake8

[testenv]
deps =
    pytest
    pytest-cov
    pytest-mock
commands =
    pytest --cov=myproject {posargs:tests}

[testenv:flake8]
deps = flake8
commands = flake8 myproject tests

[flake8]
max-line-length = 120
exclude = .git,__pycache__,build,dist

[pytest]
testpaths = tests
python_files = test_*.py
python_functions = test_*
```

## Ресурсы для дальнейшего изучения

### Книги
- "Python Testing with pytest" by Brian Okken
- "Test-Driven Development with Python" by Harry Percival
- "Effective Python Testing with pytest" by Adam Parkin, Dane Hillard

### Документация
- [pytest Documentation](https://docs.pytest.org/)
- [unittest Documentation](https://docs.python.org/3/library/unittest.html)
- [coverage.py Documentation](https://coverage.readthedocs.io/)
- [Selenium Python Documentation](https://selenium-python.readthedocs.io/)
- [Playwright Python Documentation](https://playwright.dev/python/)

### Курсы и видео
- "Python Testing" на Pluralsight
- "Test-Driven Development in Python" на Coursera
- "Advanced Python Testing" на LinkedIn Learning
- "Pytest Tutorial" на YouTube by Corey Schafer

### Статьи и блоги
- [Real Python: Getting Started with Testing in Python](https://realpython.com/python-testing/)
- [Martin Fowler: Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html)
- [The Clean Architecture in Python](https://www.thedigitalcatonline.com/blog/2016/11/14/clean-architectures-in-python-a-step-by-step-example/)
