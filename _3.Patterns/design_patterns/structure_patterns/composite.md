# Паттерн Composite (Компоновщик)

## Описание

Компоновщик — это структурный паттерн проектирования, который позволяет группировать объекты в древовидные структуры для представления иерархий "часть-целое". Компоновщик позволяет клиентам одинаково обращаться как к отдельным объектам, так и к группам объектов, объединенным в древовидную структуру.

## Когда использовать

- Когда нужно представить иерархическую структуру объектов типа "часть-целое"
- Когда клиентский код должен единообразно трактовать как простые, так и составные объекты
- Когда структура объектов представляет древовидную рекурсивную структуру
- Когда нужно выполнять операции над объектами и их составными частями одинаковым способом
- Когда важна возможность добавлять новые типы компонентов без изменения существующего кода

## Преимущества

- Определяет иерархии классов, содержащие как примитивные, так и сложные объекты
- Упрощает клиентский код, позволяя работать с единым интерфейсом
- Позволяет добавлять новые виды компонентов, не нарушая существующий код
- Облегчает построение сложных древовидных структур
- Реализует принцип открытости/закрытости: можно внедрять новые типы компонентов без изменения существующего кода

## Недостатки

- Может усложнить дизайн системы, если единообразная обработка всех объектов не требуется
- Трудно обеспечить ограничения на тип дочерних компонентов
- Иногда трудно найти баланс между безопасностью и удобством использования иерархии

## Реализация на Python

```python
from abc import ABC, abstractmethod
from typing import List

# Базовый компонент
class Component(ABC):
    def __init__(self, name):
        self.name = name
    
    @abstractmethod
    def display(self, indent=0):
        pass
    
    def add(self, component):
        raise NotImplementedError
    
    def remove(self, component):
        raise NotImplementedError
    
    def get_child(self, index):
        raise NotImplementedError

# Лист (примитивный объект)
class Leaf(Component):
    def display(self, indent=0):
        indentation = " " * indent
        return f"{indentation}- {self.name}"

# Композит (составной объект)
class Composite(Component):
    def __init__(self, name):
        super().__init__(name)
        self.children: List[Component] = []
    
    def add(self, component):
        self.children.append(component)
    
    def remove(self, component):
        self.children.remove(component)
    
    def get_child(self, index):
        return self.children[index]
    
    def display(self, indent=0):
        indentation = " " * indent
        result = [f"{indentation}+ {self.name}"]
        
        for child in self.children:
            result.append(child.display(indent + 2))
        
        return "\n".join(result)

# Использование
# Создаем структуру файловой системы
root = Composite("root")
home = Composite("home")
alex = Composite("alex")
bob = Composite("bob")

home.add(alex)
home.add(bob)
root.add(home)

documents = Composite("documents")
alex.add(documents)

file1 = Leaf("file1.txt")
file2 = Leaf("file2.txt")
file3 = Leaf("file3.txt")

documents.add(file1)
documents.add(file2)
alex.add(file3)

# Отображаем структуру
print(root.display())
```

## Где применяется в реальных проектах

- Графические интерфейсы пользователя (контейнеры и компоненты)
- Представление файловых систем (директории и файлы)
- Структуры документов (разделы, главы, параграфы)
- Организационные структуры (отделы, команды, сотрудники)
- Меню и подменю в приложениях
- Структуры данных в компиляторах (абстрактные синтаксические деревья)
- Композиция графических фигур в редакторах
- XML/HTML DOM-деревья
- Структуры в играх (сцены, группы объектов)

## Связанные паттерны

- **Декоратор**: Часто используется вместе с Компоновщиком, добавляя функциональность к объектам
- **Итератор**: Используется для обхода составных структур
- **Посетитель**: Для выполнения операций над всеми элементами составной структуры
- **Цепочка обязанностей**: Часто компоненты дерева образуют цепочки обязанностей
- **Прототип**: Для клонирования сложных структур компоновщика
- **Фабрика**: Для создания объектов в древовидной структуре

## Рекомендации по использованию

- Определите общий интерфейс для простых и составных объектов
- Решите, будет ли базовый класс компонента объявлять все операции для управления дочерними компонентами
- Для безопасности выбросите исключения в операциях управления дочерними компонентами в базовом классе
- Решите, должен ли составной объект хранить ссылку на своего родителя
- Продумайте эффективные методы для добавления и удаления дочерних компонентов
- При необходимости реализуйте кэширование для повышения производительности при обходе структуры
- Рассмотрите возможность реализации методов перемещения по структуре в базовом классе компонента
