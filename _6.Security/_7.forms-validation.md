# Работа с формами и валидация в Python

## Содержание
- [Введение](#введение)
- [Формы в Django](#формы-в-django)
- [Формы в Flask](#формы-в-flask)
- [Формы в FastAPI](#формы-в-fastapi)
- [Валидация данных](#валидация-данных)
- [CSRF-защита](#csrf-защита)
- [Обработка файлов](#обработка-файлов)
- [JavaScript и AJAX](#javascript-и-ajax)
- [REST API и формы](#rest-api-и-формы)
- [Сравнительный анализ](#сравнительный-анализ)
- [Лучшие практики](#лучшие-практики)
- [Подводные камни](#подводные-камни)
- [Полезные ресурсы](#полезные-ресурсы)

## Введение

Формы являются ключевым элементом взаимодействия пользователя с веб-приложениями. Они позволяют собирать данные от пользователей, проверять их корректность и обрабатывать для дальнейшего использования. В экосистеме Python существует множество инструментов для работы с формами, от низкоуровневых библиотек валидации до полноценных фреймворков, предоставляющих комплексные решения.

### Основные задачи при работе с формами

1. **Создание HTML-разметки** — генерация полей, меток, кнопок
2. **Сбор и обработка данных** — получение данных из запросов
3. **Валидация** — проверка корректности и безопасности вводимых данных
4. **Преобразование типов** — конвертация строковых данных в нужные типы
5. **Обработка ошибок** — отображение сообщений об ошибках
6. **CSRF-защита** — предотвращение атак подделки межсайтовых запросов
7. **Обработка файлов** — загрузка и валидация файлов

## Формы в Django

Django предоставляет комплексную систему для работы с формами, включающую генерацию HTML, валидацию данных и обработку ошибок.

### Базовые формы

```python
# forms.py
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(label='Ваше имя', max_length=100)  # Текстовое поле с ограничением длины
    email = forms.EmailField(label='Email')  # Поле для email с встроенной валидацией
    message = forms.CharField(label='Сообщение', widget=forms.Textarea)  # Текстовая область
    priority = forms.ChoiceField(label='Приоритет', choices=[
        ('low', 'Низкий'),
        ('medium', 'Средний'),
        ('high', 'Высокий'),
    ])  # Выпадающий список
    subscribe = forms.BooleanField(label='Подписаться на новости', required=False)  # Чекбокс
```

### Использование форм в представлениях

```python
# views.py
from django.shortcuts import render, redirect
from django.http import HttpResponse
from .forms import ContactForm

def contact_view(request):
    # Проверка типа запроса
    if request.method == 'POST':
        # Создание формы с данными из запроса
        form = ContactForm(request.POST)
        
        # Валидация формы
        if form.is_valid():
            # Доступ к очищенным данным формы
            name = form.cleaned_data['name']
            email = form.cleaned_data['email']
            message = form.cleaned_data['message']
            
            # Обработка данных (например, отправка email)
            # send_email(name, email, message)
            
            # Перенаправление после успешной отправки
            return redirect('contact_success')
    else:
        # Создание пустой формы для GET-запроса
        form = ContactForm()
    
    # Рендеринг шаблона с формой
    return render(request, 'contact.html', {'form': form})
```

### Отображение в шаблоне

```html
<!-- contact.html -->
<form method="post">
    {% csrf_token %}
    
    <!-- Вывод всей формы автоматически -->
    {{ form.as_p }}
    
    <!-- или ручной вывод с полным контролем -->
    <div class="form-group">
        <label for="{{ form.name.id_for_label }}">{{ form.name.label }}</label>
        {{ form.name }}
        {% if form.name.errors %}
            <div class="error">{{ form.name.errors }}</div>
        {% endif %}
    </div>
    
    <button type="submit">Отправить</button>
</form>
```

### ModelForm

ModelForm автоматически создает форму на основе модели Django, что упрощает работу с CRUD-операциями.

```python
# models.py
from django.db import models

class Article(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    published_date = models.DateField()
    category = models.CharField(max_length=100)
    is_featured = models.BooleanField(default=False)

# forms.py
from django import forms
from .models import Article

class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article  # Модель, на основе которой создается форма
        fields = ['title', 'content', 'published_date', 'category', 'is_featured']  # Поля, которые включаются в форму
        # или fields = '__all__' для включения всех полей
        # или exclude = ['field_name'] для исключения полей
        
        # Дополнительные настройки полей
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 5}),
            'published_date': forms.DateInput(attrs={'type': 'date'}),
        }
        
        labels = {
            'title': 'Заголовок статьи',
            'is_featured': 'Рекомендованная статья',
        }
        
        help_texts = {
            'content': 'Поддерживается форматирование Markdown.',
        }
        
        error_messages = {
            'title': {
                'max_length': 'Заголовок слишком длинный!',
            },
        }
```

### Использование ModelForm в представлениях

```python
# views.py
from django.shortcuts import render, redirect, get_object_or_404
from .models import Article
from .forms import ArticleForm

# Создание новой статьи
def article_create(request):
    if request.method == 'POST':
        form = ArticleForm(request.POST)
        if form.is_valid():
            article = form.save()  # Сохранение формы создает новый объект модели
            return redirect('article_detail', pk=article.pk)
    else:
        form = ArticleForm()
    return render(request, 'article_form.html', {'form': form})

# Редактирование существующей статьи
def article_update(request, pk):
    article = get_object_or_404(Article, pk=pk)
    
    if request.method == 'POST':
        form = ArticleForm(request.POST, instance=article)  # Привязка к существующему объекту
        if form.is_valid():
            article = form.save()
            return redirect('article_detail', pk=article.pk)
    else:
        form = ArticleForm(instance=article)  # Предзаполнение формы данными из модели
        
    return render(request, 'article_form.html', {'form': form})
```

### Валидация в Django Forms

```python
from django import forms
from django.core.validators import RegexValidator, MinValueValidator

class RegistrationForm(forms.Form):
    username = forms.CharField(
        min_length=3,  # Минимальная длина
        max_length=30,  # Максимальная длина
        validators=[
            RegexValidator(
                regex='^[a-zA-Z0-9]+$',
                message='Имя пользователя может содержать только буквы и цифры'
            )
        ]
    )
    
    email = forms.EmailField()
    
    password = forms.CharField(widget=forms.PasswordInput)
    confirm_password = forms.CharField(widget=forms.PasswordInput)
    
    age = forms.IntegerField(
        validators=[
            MinValueValidator(18, message='Вам должно быть не менее 18 лет')
        ]
    )
    
    # Пользовательский метод валидации поля
    def clean_username(self):
        username = self.cleaned_data.get('username')
        # Проверка, что имя пользователя не занято
        # if User.objects.filter(username=username).exists():
        #     raise forms.ValidationError('Это имя пользователя уже занято')
        return username
    
    # Валидация, зависящая от нескольких полей
    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        
        if password and confirm_password and password != confirm_password:
            self.add_error('confirm_password', 'Пароли не совпадают')
        
        return cleaned_data
```

### Расширенные возможности Django Forms

#### Формсеты (Formsets)

Формсеты позволяют работать с несколькими экземплярами одной формы на одной странице.

```python
# forms.py
from django import forms
from django.forms import formset_factory

class ItemForm(forms.Form):
    name = forms.CharField(max_length=100)
    quantity = forms.IntegerField(min_value=1)
    price = forms.DecimalField(max_digits=10, decimal_places=2)

# Создание формсета
ItemFormSet = formset_factory(
    ItemForm,  # Базовая форма
    extra=3,  # Количество пустых форм
    min_num=1,  # Минимальное количество форм
    max_num=10,  # Максимальное количество форм
    validate_min=True,  # Валидация минимального количества
    validate_max=True,  # Валидация максимального количества
    can_delete=True  # Возможность удаления форм
)

# views.py
def order_items(request):
    if request.method == 'POST':
        formset = ItemFormSet(request.POST, prefix='items')
        if formset.is_valid():
            total = 0
            for form in formset:
                if form.cleaned_data:  # Проверка, что форма не пустая
                    name = form.cleaned_data['name']
                    quantity = form.cleaned_data['quantity']
                    price = form.cleaned_data['price']
                    total += quantity * price
                    # Сохранение данных
            return redirect('order_summary')
    else:
        formset = ItemFormSet(prefix='items')
    
    return render(request, 'order_form.html', {'formset': formset})
```

#### ModelFormsets

ModelFormsets аналогичны формсетам, но работают с моделями.

```python
from django.forms import modelformset_factory
from .models import Item

# Создание модельного формсета
ItemModelFormSet = modelformset_factory(
    Item,  # Модель
    fields=('name', 'quantity', 'price'),  # Поля модели
    extra=3,
    can_delete=True
)

# views.py
def manage_items(request):
    if request.method == 'POST':
        formset = ItemModelFormSet(request.POST, request.FILES)
        if formset.is_valid():
            formset.save()  # Сохранение всех форм
            return redirect('items_list')
    else:
        formset = ItemModelFormSet(queryset=Item.objects.filter(owner=request.user))
    
    return render(request, 'manage_items.html', {'formset': formset})
```

#### Инлайн-формсеты (Inline Formsets)

Инлайн-формсеты позволяют редактировать связанные объекты на одной странице.

```python
from django.forms import inlineformset_factory
from .models import Author, Book

# Создание инлайн-формсета
BookFormSet = inlineformset_factory(
    Author,  # Родительская модель
    Book,    # Дочерняя модель
    fields=('title', 'publication_date', 'pages'),
    extra=2,
    can_delete=True
)

# views.py
def author_books(request, author_id):
    author = get_object_or_404(Author, pk=author_id)
    
    if request.method == 'POST':
        formset = BookFormSet(request.POST, instance=author)
        if formset.is_valid():
            formset.save()
            return redirect('author_detail', author_id=author.id)
    else:
        formset = BookFormSet(instance=author)
    
    return render(request, 'author_books.html', {'formset': formset, 'author': author})
```

### Стилизация форм Django

#### Django Crispy Forms

Django Crispy Forms — популярная библиотека для стилизации форм Django.

```python
# settings.py
INSTALLED_APPS = [
    # ...
    'crispy_forms',
    'crispy_bootstrap5',  # или другой пакет для нужного фреймворка
]

CRISPY_ALLOWED_TEMPLATE_PACKS = 'bootstrap5'
CRISPY_TEMPLATE_PACK = 'bootstrap5'

# forms.py
from django import forms
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Layout, Submit, Row, Column, Div

class ContactForm(forms.Form):
    name = forms.CharField()
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper()
        self.helper.form_method = 'post'
        self.helper.form_class = 'form-horizontal'
        self.helper.label_class = 'col-lg-2'
        self.helper.field_class = 'col-lg-8'
        self.helper.layout = Layout(
            Row(
                Column('name', css_class='form-group col-md-6 mb-0'),
                Column('email', css_class='form-group col-md-6 mb-0'),
                css_class='form-row'
            ),
            'message',
            Div(
                Submit('submit', 'Отправить', css_class='btn btn-primary'),
                css_class='form-group'
            )
        )
```

```html
<!-- template.html -->
{% load crispy_forms_tags %}

<form method="post">
    {% csrf_token %}
    {% crispy form %}
</form>
```

## Формы в Flask

Flask не имеет встроенного механизма работы с формами, но предоставляет расширение Flask-WTF, которое интегрирует WTForms с Flask.

### Установка и настройка

```bash
pip install Flask-WTF
```

```python
# app.py
from flask import Flask, render_template, redirect, url_for
from flask_wtf import FlaskForm
from flask_wtf.csrf import CSRFProtect
from wtforms import StringField, TextAreaField, SubmitField, SelectField, BooleanField
from wtforms.validators import DataRequired, Email, Length

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'  # Необходимо для CSRF защиты
csrf = CSRFProtect(app)  # Инициализация CSRF защиты
```

### Определение форм

```python
# forms.py
from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, SubmitField, SelectField, BooleanField
from wtforms.validators import DataRequired, Email, Length

class ContactForm(FlaskForm):
    name = StringField('Ваше имя', validators=[
        DataRequired(message='Это поле обязательно'),
        Length(min=2, max=100, message='Имя должно быть от 2 до 100 символов')
    ])
    
    email = StringField('Email', validators=[
        DataRequired(message='Это поле обязательно'),
        Email(message='Введите корректный email')
    ])
    
    message = TextAreaField('Сообщение', validators=[
        DataRequired(message='Это поле обязательно')
    ])
    
    priority = SelectField('Приоритет', choices=[
        ('low', 'Низкий'),
        ('medium', 'Средний'),
        ('high', 'Высокий')
    ])
    
    subscribe = BooleanField('Подписаться на новости')
    
    submit = SubmitField('Отправить')
```

### Использование форм в представлениях

```python
# routes.py
from flask import render_template, redirect, url_for, flash
from app import app
from forms import ContactForm

@app.route('/contact', methods=['GET', 'POST'])
def contact():
    form = ContactForm()
    
    # Валидация формы
    if form.validate_on_submit():
        # Доступ к данным формы
        name = form.name.data
        email = form.email.data
        message = form.message.data
        priority = form.priority.data
        subscribe = form.subscribe.data
        
        # Обработка данных
        # send_email(name, email, message, priority)
        
        # Отображение сообщения об успехе
        flash('Спасибо за ваше сообщение!', 'success')
        
        # Перенаправление
        return redirect(url_for('contact_success'))
    
    # Если форма не прошла валидацию или это GET-запрос
    return render_template('contact.html', form=form)
```

### Отображение в шаблоне

```html
<!-- contact.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Контактная форма</title>
</head>
<body>
    <h1>Свяжитесь с нами</h1>
    
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
                <div class="alert alert-{{ category }}">{{ message }}</div>
            {% endfor %}
        {% endif %}
    {% endwith %}
    
    <form method="post">
        {{ form.hidden_tag() }}
        
        <div>
            {{ form.name.label }}
            {{ form.name() }}
            {% if form.name.errors %}
                <ul class="errors">
                    {% for error in form.name.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div>
            {{ form.email.label }}
            {{ form.email() }}
            {% if form.email.errors %}
                <ul class="errors">
                    {% for error in form.email.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div>
            {{ form.message.label }}
            {{ form.message() }}
            {% if form.message.errors %}
                <ul class="errors">
                    {% for error in form.message.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div>
            {{ form.priority.label }}
            {{ form.priority() }}
        </div>
        
        <div>
            {{ form.subscribe() }}
            {{ form.subscribe.label }}
        </div>
        
        <div>
            {{ form.submit() }}
        </div>
    </form>
</body>
</html>
```

### Расширенные возможности Flask-WTF

#### Пользовательские валидаторы

```python
from wtforms.validators import ValidationError

# Пользовательский валидатор как функция
def username_check(form, field):
    if len(field.data) < 5:
        raise ValidationError('Имя пользователя должно быть не менее 5 символов')
    if not field.data.isalnum():
        raise ValidationError('Имя пользователя должно содержать только буквы и цифры')

class RegistrationForm(FlaskForm):
    username = StringField('Имя пользователя', validators=[
        DataRequired(),
        username_check  # Использование пользовательского валидатора
    ])
    
    # Пользовательский валидатор как метод
    def validate_email(self, field):
        if 'admin' in field.data:
            raise ValidationError('Email не может содержать "admin"')
        # Проверка уникальности
        # if User.query.filter_by(email=field.data).first():
        #     raise ValidationError('Этот email уже зарегистрирован')
```

#### Работа с файлами

```python
from flask_wtf import FlaskForm
from flask_wtf.file import FileField, FileRequired, FileAllowed
from werkzeug.utils import secure_filename

class UploadForm(FlaskForm):
    image = FileField('Изображение', validators=[
        FileRequired(message='Выберите файл'),
        FileAllowed(['jpg', 'png', 'jpeg'], message='Разрешены только изображения')
    ])
    submit = SubmitField('Загрузить')

@app.route('/upload', methods=['GET', 'POST'])
def upload():
    form = UploadForm()
    
    if form.validate_on_submit():
        f = form.image.data
        filename = secure_filename(f.filename)
        f.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        return redirect(url_for('uploaded_file', filename=filename))
        
    return render_template('upload.html', form=form)
```

#### Динамические поля формы

```python
from flask_wtf import FlaskForm
from wtforms import StringField, FieldList, FormField, SubmitField

class ItemForm(FlaskForm):
    name = StringField('Название')
    quantity = StringField('Количество')
    
    # Метакласс для вложенной формы
    class Meta:
        csrf = False  # Отключение CSRF для вложенной формы

class OrderForm(FlaskForm):
    customer_name = StringField('Имя клиента')
    items = FieldList(FormField(ItemForm), min_entries=1)
    submit = SubmitField('Отправить заказ')

@app.route('/order', methods=['GET', 'POST'])
def order():
    form = OrderForm()
    
    if form.validate_on_submit():
        # Обработка данных
        return redirect(url_for('order_success'))
    
    return render_template('order.html', form=form)
```

```html
<!-- order.html -->
<form method="post">
    {{ form.hidden_tag() }}
    
    {{ form.customer_name.label }}
    {{ form.customer_name() }}
    
    <h3>Товары</h3>
    {% for item_form in form.items %}
        <div class="item">
            {{ item_form.name.label }} {{ item_form.name() }}
            {{ item_form.quantity.label }} {{ item_form.quantity() }}
        </div>
    {% endfor %}
    
    <div>
        <button type="button" id="add-item">Добавить товар</button>
    </div>
    
    {{ form.submit() }}
</form>

<script>
    document.getElementById('add-item').addEventListener('click', function() {
        var items = document.getElementsByClassName('item');
        var newItem = items[0].cloneNode(true);
        var inputs = newItem.querySelectorAll('input');
        
        // Очистка значений и обновление индексов
        inputs.forEach(function(input) {
            input.value = '';
            var name = input.getAttribute('name');
            var newIndex = items.length;
            input.setAttribute('name', name.replace(/items-\d+/, 'items-' + newIndex));
            input.setAttribute('id', input.getAttribute('id').replace(/items-\d+/, 'items-' + newIndex));
        });
        
        items[items.length - 1].after(newItem);
    });
</script>
```

## Формы в FastAPI

FastAPI использует Pydantic для валидации данных, что отличает его от Django и Flask.

### Базовое использование форм

```python
from fastapi import FastAPI, Form, Request
from fastapi.templating import Jinja2Templates
from fastapi.responses import RedirectResponse

app = FastAPI()
templates = Jinja2Templates(directory="templates")

@app.get("/contact")
async def contact_form(request: Request):
    return templates.TemplateResponse("contact.html", {"request": request})

@app.post("/contact")
async def process_contact(
    request: Request,
    name: str = Form(...),
    email: str = Form(...),
    message: str = Form(...)
):
    # Обработка данных
    # send_email(name, email, message)
    
    # Перенаправление
    return RedirectResponse(url="/contact/success", status_code=303)

@app.get("/contact/success")
async def contact_success(request: Request):
    return templates.TemplateResponse("success.html", {"request": request})
```

### Интеграция с Pydantic

```python
from typing import List, Optional
from fastapi import FastAPI, Form, Request, Depends
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel, EmailStr, Field, validator
from fastapi.responses import RedirectResponse

app = FastAPI()
templates = Jinja2Templates(directory="templates")

# Модель данных с валидацией
class ContactModel(BaseModel):
    name: str = Field(..., min_length=2, max_length=100)
    email: EmailStr
    message: str = Field(..., min_length=10)
    
    @validator('name')
    def name_must_not_contain_numbers(cls, v):
        if any(char.isdigit() for char in v):
            raise ValueError('Имя не должно содержать цифры')
        return v

# Функция для создания модели из данных формы
async def get_contact_form(
    name: str = Form(...),
    email: str = Form(...),
    message: str = Form(...)
) -> ContactModel:
    return ContactModel(
        name=name,
        email=email,
        message=message
    )

@app.post("/contact")
async def process_contact(
    request: Request,
    contact: ContactModel = Depends(get_contact_form)
):
    # Данные уже валидированы через Pydantic
    # send_email(contact.name, contact.email, contact.message)
    
    return RedirectResponse(url="/contact/success", status_code=303)
```

### Использование со сторонними библиотеками форм

```python
from fastapi import FastAPI, Request, Depends
from fastapi.templating import Jinja2Templates
from fastapi.responses import RedirectResponse
from typing import Optional

from pydantic import BaseModel, EmailStr
from wtforms import Form, StringField, TextAreaField, validators

app = FastAPI()
templates = Jinja2Templates(directory="templates")

# WTForms форма
class ContactForm(Form):
    name = StringField('Имя', [
        validators.Length(min=2, max=100, message='Имя должно быть от 2 до 100 символов'),
        validators.DataRequired(message='Это поле обязательно')
    ])
    email = StringField('Email', [
        validators.Email(message='Введите корректный email'),
        validators.DataRequired(message='Это поле обязательно')
    ])
    message = TextAreaField('Сообщение', [
        validators.DataRequired(message='Это поле обязательно')
    ])

# Pydantic модель
class ContactModel(BaseModel):
    name: str
    email: EmailStr
    message: str

@app.get("/contact")
async def contact_form(request: Request):
    form = ContactForm()
    return templates.TemplateResponse("contact_wtf.html", {"request": request, "form": form})

@app.post("/contact")
async def process_contact(request: Request):
    form_data = await request.form()
    form = ContactForm(form_data)
    
    if form.validate():
        # Создание Pydantic модели из валидированных данных
        contact = ContactModel(
            name=form.name.data,
            email=form.email.data,
            message=form.message.data
        )
        
        # Обработка данных
        # send_email(contact.name, contact.email, contact.message)
        
        return RedirectResponse(url="/contact/success", status_code=303)
    else:
        # Возврат формы с ошибками
        return templates.TemplateResponse(
            "contact_wtf.html",
            {"request": request, "form": form}
        )
```

```html
<!-- contact_wtf.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Контактная форма</title>
</head>
<body>
    <h1>Свяжитесь с нами</h1>
    
    <form method="post">
        <div>
            <label for="{{ form.name.id }}">{{ form.name.label }}</label>
            {{ form.name(class_="form-control") }}
            {% if form.name.errors %}
                <ul class="errors">
                    {% for error in form.name.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div>
            <label for="{{ form.email.id }}">{{ form.email.label }}</label>
            {{ form.email(class_="form-control") }}
            {% if form.email.errors %}
                <ul class="errors">
                    {% for error in form.email.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div>
            <label for="{{ form.message.id }}">{{ form.message.label }}</label>
            {{ form.message(class_="form-control", rows=5) }}
            {% if form.message.errors %}
                <ul class="errors">
                    {% for error in form.message.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <button type="submit">Отправить</button>
    </form>
</body>
</html>
```

## Валидация данных

### Встроенные валидаторы

#### Django

```python
from django import forms
from django.core.validators import (
    RegexValidator,
    MinValueValidator,
    MaxValueValidator,
    MinLengthValidator,
    MaxLengthValidator,
    EmailValidator,
    URLValidator,
    validate_slug,
    validate_ipv4_address
)

class AdvancedForm(forms.Form):
    username = forms.CharField(
        validators=[
            RegexValidator(
                regex=r'^[a-zA-Z0-9_]+$',
                message='Имя пользователя может содержать только буквы, цифры и подчеркивания'
            ),
            MinLengthValidator(4, message='Минимум 4 символа'),
            MaxLengthValidator(30, message='Максимум 30 символов')
        ]
    )
    
    age = forms.IntegerField(
        validators=[
            MinValueValidator(18, message='Вам должно быть не менее 18 лет'),
            MaxValueValidator(120, message='Введите корректный возраст')
        ]
    )
    
    email = forms.EmailField(
        validators=[
            EmailValidator(message='Введите корректный email')
        ]
    )
    
    website = forms.URLField(
        validators=[
            URLValidator(message='Введите корректный URL')
        ]
    )
    
    slug = forms.SlugField(
        validators=[
            validate_slug
        ]
    )
    
    ip_address = forms.CharField(
        validators=[
            validate_ipv4_address
        ]
    )
```

#### WTForms (Flask)

```python
from wtforms import Form, StringField, IntegerField, validators
from wtforms.validators import (
    DataRequired,
    Email,
    Length,
    NumberRange,
    URL,
    Regexp,
    AnyOf,
    NoneOf,
    Optional,
    IPAddress
)

class AdvancedForm(Form):
    username = StringField('Имя пользователя', [
        DataRequired(message='Это поле обязательно'),
        Length(min=4, max=30, message='Длина должна быть от 4 до 30 символов'),
        Regexp(r'^[a-zA-Z0-9_]+$', message='Допустимы только буквы, цифры и подчеркивания')
    ])
    
    age = IntegerField('Возраст', [
        DataRequired(message='Это поле обязательно'),
        NumberRange(min=18, max=120, message='Возраст должен быть от 18 до 120 лет')
    ])
    
    email = StringField('Email', [
        DataRequired(message='Это поле обязательно'),
        Email(message='Введите корректный email')
    ])
    
    website = StringField('Веб-сайт', [
        Optional(),  # Поле необязательное
        URL(message='Введите корректный URL')
    ])
    
    role = StringField('Роль', [
        AnyOf(['admin', 'user', 'editor'], message='Роль должна быть одной из: admin, user, editor')
    ])
    
    banned_words = StringField('Текст', [
        NoneOf(['spam', 'реклама', 'бесплатно'], message='Текст содержит запрещенные слова')
    ])
    
    ip_address = StringField('IP-адрес', [
        IPAddress(message='Введите корректный IP-адрес', ipv4=True, ipv6=False)
    ])
```

#### Pydantic (FastAPI)

```python
from typing import List, Optional
from pydantic import (
    BaseModel,
    Field,
    EmailStr,
    HttpUrl,
    validator,
    constr,
    conint,
    confloat,
    IPvAnyAddress
)
import re

class User(BaseModel):
    id: Optional[int] = None
    username: constr(min_length=4, max_length=30, regex=r'^[a-zA-Z0-9_]+$')
    email: EmailStr
    age: conint(ge=18, le=120)
    website: Optional[HttpUrl] = None
    role: str = Field(..., description="User role")
    score: confloat(ge=0, le=100) = Field(0, description="User score")
    ip_address: Optional[IPvAnyAddress] = None
    
    # Пользовательские валидаторы
    @validator('role')
    def role_must_be_valid(cls, v):
        valid_roles = ['admin', 'user', 'editor']
        if v not in valid_roles:
            raise ValueError(f'Роль должна быть одной из: {", ".join(valid_roles)}')
        return v
    
    @validator('username')
    def username_must_not_contain_special_words(cls, v):
        banned_words = ['admin', 'root', 'system']
        for word in banned_words:
            if word in v.lower():
                raise ValueError(f'Имя пользователя не должно содержать: {word}')
        return v
    
    # Валидатор зависимых полей
    @validator('website', always=True)
    def website_required_for_admin(cls, v, values):
        if 'role' in values and values['role'] == 'admin' and not v:
            raise ValueError('Для администраторов веб-сайт обязателен')
        return v
```

### Пользовательские валидаторы

#### Django

```python
from django import forms
from django.core.exceptions import ValidationError
import re

# Функция-валидатор
def validate_no_special_chars(value):
    if re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
        raise ValidationError('Значение не должно содержать специальные символы')

# Класс валидатора
class NoDigitsValidator:
    def __init__(self, message=None):
        self.message = message or 'Значение не должно содержать цифры'
    
    def __call__(self, value):
        if any(char.isdigit() for char in value):
            raise ValidationError(self.message)

class UserProfileForm(forms.Form):
    firstname = forms.CharField(
        validators=[
            validate_no_special_chars,
            NoDigitsValidator('Имя не должно содержать цифры')
        ]
    )
    
    bio = forms.CharField(widget=forms.Textarea)
    
    def clean_bio(self):
        # Валидация одного поля
        bio = self.cleaned_data.get('bio')
        word_count = len(bio.split())
        
        if word_count < 10:
            raise ValidationError('Биография должна содержать не менее 10 слов')
        
        return bio
    
    def clean(self):
        # Валидация формы целиком
        cleaned_data = super().clean()
        firstname = cleaned_data.get('firstname')
        bio = cleaned_data.get('bio')
        
        if firstname and bio and firstname.lower() in bio.lower():
            self.add_error('bio', 'Биография не должна содержать ваше имя')
        
        return cleaned_data
```

#### WTForms (Flask)

```python
from wtforms import Form, StringField, validators
from wtforms.validators import ValidationError
import re

# Пользовательский валидатор как функция
def no_special_chars(form, field):
    if re.search(r'[!@#$%^&*(),.?":{}|<>]', field.data):
        raise ValidationError('Значение не должно содержать специальные символы')

# Пользовательский валидатор как класс
class NoDigits:
    def __init__(self, message=None):
        self.message = message or 'Значение не должно содержать цифры'
    
    def __call__(self, form, field):
        if any(char.isdigit() for char in field.data):
            raise ValidationError(self.message)

class UserProfileForm(Form):
    firstname = StringField('Имя', [
        validators.DataRequired(),
        no_special_chars,
        NoDigits(message='Имя не должно содержать цифры')
    ])
    
    bio = StringField('Биография', [
        validators.DataRequired()
    ])
    
    def validate_bio(self, field):
        # Валидация одного поля
        word_count = len(field.data.split())
        
        if word_count < 10:
            raise ValidationError('Биография должна содержать не менее 10 слов')
    
    def validate(self):
        # Валидация формы целиком
        if not super().validate():
            return False
        
        firstname = self.firstname.data
        bio = self.bio.data
        
        if firstname and bio and firstname.lower() in bio.lower():
            self.bio.errors.append('Биография не должна содержать ваше имя')
            return False
        
        return True
```

#### Pydantic (FastAPI)

```python
from typing import Optional, List
from pydantic import BaseModel, validator, root_validator, Field
import re

class UserProfile(BaseModel):
    firstname: str = Field(..., min_length=2, max_length=50)
    bio: str = Field(..., min_length=10)
    interests: List[str] = []
    
    # Валидатор для одного поля
    @validator('firstname')
    def name_must_be_valid(cls, v):
        if re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('Имя не должно содержать специальные символы')
        
        if any(char.isdigit() for char in v):
            raise ValueError('Имя не должно содержать цифры')
        
        return v
    
    # Валидатор для одного поля с доступом к другим полям
    @validator('bio')
    def bio_must_have_enough_words(cls, v):
        word_count = len(v.split())
        
        if word_count < 10:
            raise ValueError('Биография должна содержать не менее 10 слов')
        
        return v
    
    # Валидатор для множества полей
    @root_validator
    def check_name_not_in_bio(cls, values):
        firstname = values.get('firstname')
        bio = values.get('bio')
        
        if firstname and bio and firstname.lower() in bio.lower():
            raise ValueError('Биография не должна содержать ваше имя')
        
        return values
    
    # Валидатор с предварительной обработкой
    @validator('interests', pre=True)
    def split_interests(cls, v):
        if isinstance(v, str):
            return [i.strip() for i in v.split(',')]
        return v
```

### Перекрестная валидация полей

#### Django

```python
from django import forms
from django.core.exceptions import ValidationError

class PasswordChangeForm(forms.Form):
    old_password = forms.CharField(widget=forms.PasswordInput)
    new_password1 = forms.CharField(widget=forms.PasswordInput, label='Новый пароль')
    new_password2 = forms.CharField(widget=forms.PasswordInput, label='Подтверждение пароля')
    
    def clean(self):
        cleaned_data = super().clean()
        old_password = cleaned_data.get('old_password')
        new_password1 = cleaned_data.get('new_password1')
        new_password2 = cleaned_data.get('new_password2')
        
        # Проверка старого пароля
        # if not user.check_password(old_password):
        #     self.add_error('old_password', 'Неверный пароль')
        
        # Проверка, что новый пароль отличается от старого
        if old_password and new_password1 and old_password == new_password1:
            self.add_error('new_password1', 'Новый пароль должен отличаться от старого')
        
        # Проверка совпадения паролей
        if new_password1 and new_password2 and new_password1 != new_password2:
            self.add_error('new_password2', 'Пароли не совпадают')
        
        return cleaned_data
```

#### WTForms (Flask)

```python
from wtforms import Form, StringField, validators
from wtforms.validators import ValidationError

class PasswordChangeForm(Form):
    old_password = StringField('Текущий пароль', [validators.DataRequired()])
    new_password1 = StringField('Новый пароль', [validators.DataRequired()])
    new_password2 = StringField('Подтверждение пароля', [validators.DataRequired()])
    
    def validate(self):
        if not super().validate():
            return False
        
        old_password = self.old_password.data
        new_password1 = self.new_password1.data
        new_password2 = self.new_password2.data
        
        # Проверка старого пароля
        # if not check_password(old_password):
        #     self.old_password.errors.append('Неверный пароль')
        #     return False
        
        # Проверка, что новый пароль отличается от старого
        if old_password and new_password1 and old_password == new_password1:
            self.new_password1.errors.append('Новый пароль должен отличаться от старого')
            return False
        
        # Проверка совпадения паролей
        if new_password1 and new_password2 and new_password1 != new_password2:
            self.new_password2.errors.append('Пароли не совпадают')
            return False
        
        return True
```

#### Pydantic (FastAPI)

```python
from pydantic import BaseModel, validator, root_validator

class PasswordChange(BaseModel):
    old_password: str
    new_password1: str
    new_password2: str
    
    @root_validator
    def passwords_match(cls, values):
        old_password = values.get('old_password')
        new_password1 = values.get('new_password1')
        new_password2 = values.get('new_password2')
        
        # Проверка старого пароля
        # if not check_password(old_password):
        #     raise ValueError('Неверный пароль')
        
        # Проверка, что новый пароль отличается от старого
        if old_password and new_password1 and old_password == new_password1:
            raise ValueError({'new_password1': 'Новый пароль должен отличаться от старого'})
        
        # Проверка совпадения паролей
        if new_password1 and new_password2 and new_password1 != new_password2:
            raise ValueError({'new_password2': 'Пароли не совпадают'})
        
        return values
```

### Валидация в зависимости от условий

#### Django

```python
from django import forms

class ShippingForm(forms.Form):
    DELIVERY_CHOICES = [
        ('pickup', 'Самовывоз'),
        ('courier', 'Курьер'),
        ('post', 'Почта')
    ]
    
    delivery_method = forms.ChoiceField(choices=DELIVERY_CHOICES)
    
    # Поля для доставки курьером
    address = forms.CharField(required=False)
    apartment = forms.CharField(required=False)
    
    # Поля для почтовой доставки
    post_code = forms.CharField(required=False)
    region = forms.CharField(required=False)
    
    def clean(self):
        cleaned_data = super().clean()
        delivery_method = cleaned_data.get('delivery_method')
        
        if delivery_method == 'courier':
            # Проверка полей для доставки курьером
            address = cleaned_data.get('address')
            apartment = cleaned_data.get('apartment')
            
            if not address:
                self.add_error('address', 'Это поле обязательно для доставки курьером')
            
            if not apartment:
                self.add_error('apartment', 'Это поле обязательно для доставки курьером')
        
        elif delivery_method == 'post':
            # Проверка полей для почтовой доставки
            post_code = cleaned_data.get('post_code')
            region = cleaned_data.get('region')
            
            if not post_code:
                self.add_error('post_code', 'Это поле обязательно для почтовой доставки')
            
            if not region:
                self.add_error('region', 'Это поле обязательно для почтовой доставки')
        
        return cleaned_data
```

#### WTForms (Flask)

```python
from wtforms import Form, StringField, SelectField, validators
from wtforms.validators import ValidationError

class ShippingForm(Form):
    delivery_method = SelectField('Способ доставки', choices=[
        ('pickup', 'Самовывоз'),
        ('courier', 'Курьер'),
        ('post', 'Почта')
    ])
    
    address = StringField('Адрес')
    apartment = StringField('Квартира/офис')
    
    post_code = StringField('Почтовый индекс')
    region = StringField('Регион')
    
    def validate(self):
        if not super().validate():
            return False
        
        delivery_method = self.delivery_method.data
        
        if delivery_method == 'courier':
            if not self.address.data:
                self.address.errors.append('Это поле обязательно для доставки курьером')
                return False
            
            if not self.apartment.data:
                self.apartment.errors.append('Это поле обязательно для доставки курьером')
                return False
        
        elif delivery_method == 'post':
            if not self.post_code.data:
                self.post_code.errors.append('Это поле обязательно для почтовой доставки')
                return False
            
            if not self.region.data:
                self.region.errors.append('Это поле обязательно для почтовой доставки')
                return False
        
        return True
```

#### Pydantic (FastAPI)

```python
from typing import Optional
from enum import Enum
from pydantic import BaseModel, validator, root_validator

class DeliveryMethod(str, Enum):
    pickup = 'pickup'
    courier = 'courier'
    post = 'post'

class ShippingData(BaseModel):
    delivery_method: DeliveryMethod
    
    # Необязательные поля, которые могут быть обязательными в зависимости от условий
    address: Optional[str] = None
    apartment: Optional[str] = None
    
    post_code: Optional[str] = None
    region: Optional[str] = None
    
    @root_validator
    def check_delivery_fields(cls, values):
        delivery_method = values.get('delivery_method')
        
        if delivery_method == DeliveryMethod.courier:
            address = values.get('address')
            apartment = values.get('apartment')
            
            if not address:
                raise ValueError({'address': 'Это поле обязательно для доставки курьером'})
            
            if not apartment:
                raise ValueError({'apartment': 'Это поле обязательно для доставки курьером'})
        
        elif delivery_method == DeliveryMethod.post:
            post_code = values.get('post_code')
            region = values.get('region')
            
            if not post_code:
                raise ValueError({'post_code': 'Это поле обязательно для почтовой доставки'})
            
            if not region:
                raise ValueError({'region': 'Это поле обязательно для почтовой доставки'})
        
        return values
```

## CSRF-защита

### Django

CSRF-защита включена в Django по умолчанию.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.middleware.csrf.CsrfViewMiddleware',
    # ...
]

# В шаблоне
<form method="post">
    {% csrf_token %}
    <!-- поля формы -->
    <button type="submit">Отправить</button>
</form>

# Для AJAX-запросов
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

const csrftoken = getCookie('csrftoken');

fetch('/api/endpoint/', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken
    },
    body: JSON.stringify(data)
})

# Отключение для определенного представления (не рекомендуется)
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def my_view(request):
    # ...
```

### Flask

```python
from flask import Flask, render_template, request
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
csrf = CSRFProtect(app)  # Инициализация CSRF защиты

@app.route('/form', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':
        # Обработка данных
        return 'Success'
    return render_template('form.html')

# В шаблоне
<form method="post">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
    <!-- поля формы -->
    <button type="submit">Отправить</button>
</form>

# Для AJAX-запросов
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

fetch('/api/endpoint', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrfToken
    },
    body: JSON.stringify(data)
})

# Отключение для определенного маршрута
@app.route('/no-csrf', methods=['POST'])
@csrf.exempt
def no_csrf():
    # ...
```

### FastAPI

```python
from fastapi import FastAPI, Request, Depends, Form, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from starlette.middleware.sessions import SessionMiddleware
import secrets
import hashlib
import time

app = FastAPI()
app.add_middleware(SessionMiddleware, secret_key="your-secret-key")
templates = Jinja2Templates(directory="templates")

# Генерация CSRF-токена
def generate_csrf_token(request: Request):
    if "csrf_token" not in request.session:
        request.session["csrf_token"] = secrets.token_hex(16)
    return request.session["csrf_token"]

# Проверка CSRF-токена
async def verify_csrf_token(request: Request, csrf_token: str = Form(...)):
    session_token = request.session.get("csrf_token")
    if not session_token or not secrets.compare_digest(csrf_token, session_token):
        raise HTTPException(status_code=400, detail="CSRF token validation failed")

@app.get("/form", response_class=HTMLResponse)
async def form_get(request: Request):
    csrf_token = generate_csrf_token(request)
    return templates.TemplateResponse("form.html", {"request": request, "csrf_token": csrf_token})

@app.post("/form")
async def form_post(
    request: Request,
    csrf_valid: bool = Depends(verify_csrf_token),
    name: str = Form(...),
    email: str = Form(...)
):
    # Обработка данных
    return {"status": "success"}

# В шаблоне
<form method="post">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
    <!-- поля формы -->
    <button type="submit">Отправить</button>
</form>
```

## Обработка файлов

### Django

```python
# models.py
from django.db import models

class Document(models.Model):
    title = models.CharField(max_length=100)
    document = models.FileField(upload_to='documents/')
    uploaded_at = models.DateTimeField(auto_now_add=True)

# forms.py
from django import forms
from .models import Document

class DocumentForm(forms.ModelForm):
    class Meta:
        model = Document
        fields = ('title', 'document')
        
    def clean_document(self):
        document = self.cleaned_data.get('document')
        if document:
            # Проверка расширения файла
            file_ext = document.name.split('.')[-1].lower()
            if file_ext not in ['pdf', 'doc', 'docx', 'txt']:
                raise forms.ValidationError('Разрешены только файлы PDF, DOC, DOCX и TXT')
            
            # Проверка размера файла (5MB)
            if document.size > 5 * 1024 * 1024:
                raise forms.ValidationError('Размер файла не должен превышать 5MB')
        
        return document

# views.py
from django.shortcuts import render, redirect
from .forms import DocumentForm

def upload_document(request):
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return redirect('document_list')
    else:
        form = DocumentForm()
    return render(request, 'upload_document.html', {'form': form})
```

### Flask

```python
import os
from flask import Flask, request, redirect, url_for, render_template, flash
from werkzeug.utils import secure_filename

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads/'
app.config['MAX_CONTENT_LENGTH'] = 5 * 1024 * 1024  # 5MB limit
app.secret_key = 'your-secret-key'

ALLOWED_EXTENSIONS = {'txt', 'pdf', 'doc', 'docx'}

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        # Проверка наличия файла в запросе
        if 'file' not in request.files:
            flash('Нет выбранного файла')
            return redirect(request.url)
        
        file = request.files['file']
        
        # Проверка, что имя файла не пустое
        if file.filename == '':
            flash('Нет выбранного файла')
            return redirect(request.url)
        
        # Проверка файла и сохранение
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            flash('Файл успешно загружен')
            return redirect(url_for('uploaded_file', filename=filename))
        else:
            flash('Разрешены только файлы PDF, DOC, DOCX и TXT')
            return redirect(request.url)
    
    return render_template('upload.html')
```

### FastAPI

```python
import os
import shutil
from typing import List
from fastapi import FastAPI, File, UploadFile, HTTPException, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

app = FastAPI()
templates = Jinja2Templates(directory="templates")

# Директория для загрузки файлов
UPLOAD_DIRECTORY = "uploads/"
os.makedirs(UPLOAD_DIRECTORY, exist_ok=True)

# Разрешенные типы файлов
ALLOWED_EXTENSIONS = {"txt", "pdf", "doc", "docx"}

def allowed_file(filename: str) -> bool:
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

@app.get("/upload", response_class=HTMLResponse)
async def upload_form(request: Request):
    return templates.TemplateResponse("upload.html", {"request": request})

@app.post("/upload")
async def upload_file(
    title: str = Form(...),
    file: UploadFile = File(...)
):
    # Проверка типа файла
    if not allowed_file(file.filename):
        raise HTTPException(status_code=400, detail="Разрешены только файлы PDF, DOC, DOCX и TXT")
    
    # Сохранение файла
    file_path = os.path.join(UPLOAD_DIRECTORY, file.filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    return {"filename": file.filename, "title": title}

@app.post("/uploadfiles")
async def upload_files(files: List[UploadFile] = File(...)):
    # Обработка нескольких файлов
    saved_files = []
    for file in files:
        if allowed_file(file.filename):
            file_path = os.path.join(UPLOAD_DIRECTORY, file.filename)
            with open(file_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            saved_files.append(file.filename)
    
    return {"filenames": saved_files}
```

## JavaScript и AJAX

### Django

```html
<!-- Django шаблон с AJAX-отправкой формы -->
<form id="contactForm">
    {% csrf_token %}
    <div class="form-group">
        <label for="id_name">Имя:</label>
        <input type="text" id="id_name" name="name" class="form-control">
        <div class="invalid-feedback" id="name-error"></div>
    </div>
    
    <div class="form-group">
        <label for="id_email">Email:</label>
        <input type="email" id="id_email" name="email" class="form-control">
        <div class="invalid-feedback" id="email-error"></div>
    </div>
    
    <div class="form-group">
        <label for="id_message">Сообщение:</label>
        <textarea id="id_message" name="message" class="form-control"></textarea>
        <div class="invalid-feedback" id="message-error"></div>
    </div>
    
    <button type="submit" class="btn btn-primary">Отправить</button>
</form>

<div id="success-message" class="alert alert-success mt-3" style="display: none;">
    Сообщение успешно отправлено!
</div>

<script>
    // Получение CSRF-токена из cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    document.getElementById('contactForm').addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Сбор данных формы
        const formData = new FormData(this);
        
        // Очистка предыдущих ошибок
        document.querySelectorAll('.invalid-feedback').forEach(function(element) {
            element.textContent = '';
            element.style.display = 'none';
        });
        
        document.querySelectorAll('.form-control').forEach(function(element) {
            element.classList.remove('is-invalid');
        });
        
        // AJAX-запрос
        fetch('/contact/ajax/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Успешная отправка
                document.getElementById('contactForm').reset();
                document.getElementById('success-message').style.display = 'block';
                
                // Скрытие сообщения через 5 секунд
                setTimeout(function() {
                    document.getElementById('success-message').style.display = 'none';
                }, 5000);
            } else {
                // Отображение ошибок валидации
                const errors = data.errors;
                
                for (const field in errors) {
                    const errorElement = document.getElementById(field + '-error');
                    if (errorElement) {
                        errorElement.textContent = errors[field][0];
                        errorElement.style.display = 'block';
                        
                        const inputElement = document.getElementById('id_' + field);
                        if (inputElement) {
                            inputElement.classList.add('is-invalid');
                        }
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    });
</script>
```

```python
# views.py
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from .forms import ContactForm

@require_POST
def contact_ajax(request):
    form = ContactForm(request.POST)
    
    if form.is_valid():
        # Обработка данных формы
        # form.save() или другая логика
        
        return JsonResponse({
            'success': True
        })
    else:
        return JsonResponse({
            'success': False,
            'errors': form.errors
        })
```

### Flask

```html
<!-- Flask шаблон с AJAX-отправкой формы -->
<form id="contactForm">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    
    <div class="form-group">
        <label for="name">Имя:</label>
        <input type="text" id="name" name="name" class="form-control">
        <div class="invalid-feedback" id="name-error"></div>
    </div>
    
    <div class="form-group">
        <label for="email">Email:</label>
        <input type="email" id="email" name="email" class="form-control">
        <div class="invalid-feedback" id="email-error"></div>
    </div>
    
    <div class="form-group">
        <label for="message">Сообщение:</label>
        <textarea id="message" name="message" class="form-control"></textarea>
        <div class="invalid-feedback" id="message-error"></div>
    </div>
    
    <button type="submit" class="btn btn-primary">Отправить</button>
</form>

<div id="success-message" class="alert alert-success mt-3" style="display: none;">
    Сообщение успешно отправлено!
</div>

<script>
    document.getElementById('contactForm').addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Сбор данных формы
        const formData = new FormData(this);
        
        // Очистка предыдущих ошибок
        document.querySelectorAll('.invalid-feedback').forEach(function(element) {
            element.textContent = '';
            element.style.display = 'none';
        });
        
        document.querySelectorAll('.form-control').forEach(function(element) {
            element.classList.remove('is-invalid');
        });
        
        // AJAX-запрос
        fetch('/contact/ajax', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Успешная отправка
                document.getElementById('contactForm').reset();
                document.getElementById('success-message').style.display = 'block';
                
                // Скрытие сообщения через 5 секунд
                setTimeout(function() {
                    document.getElementById('success-message').style.display = 'none';
                }, 5000);
            } else {
                // Отображение ошибок валидации
                const errors = data.errors;
                
                for (const field in errors) {
                    const errorElement = document.getElementById(field + '-error');
                    if (errorElement) {
                        errorElement.textContent = errors[field][0];
                        errorElement.style.display = 'block';
                        
                        const inputElement = document.getElementById(field);
                        if (inputElement) {
                            inputElement.classList.add('is-invalid');
                        }
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    });
</script>
```

```python
# routes.py
from flask import request, jsonify
from app import app
from forms import ContactForm

@app.route('/contact/ajax', methods=['POST'])
def contact_ajax():
    form = ContactForm(request.form)
    
    if form.validate():
        # Обработка данных формы
        # Например, сохранение в БД или отправка email
        
        return jsonify({
            'success': True
        })
    else:
        errors = {}
        for field, error_messages in form.errors.items():
            errors[field] = error_messages
        
        return jsonify({
            'success': False,
            'errors': errors
        })
```

### FastAPI

```html
<!-- Шаблон с AJAX-отправкой формы для FastAPI -->
<form id="contactForm">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
    
    <div class="form-group">
        <label for="name">Имя:</label>
        <input type="text" id="name" name="name" class="form-control">
        <div class="invalid-feedback" id="name-error"></div>
    </div>
    
    <div class="form-group">
        <label for="email">Email:</label>
        <input type="email" id="email" name="email" class="form-control">
        <div class="invalid-feedback" id="email-error"></div>
    </div>
    
    <div class="form-group">
        <label for="message">Сообщение:</label>
        <textarea id="message" name="message" class="form-control"></textarea>
        <div class="invalid-feedback" id="message-error"></div>
    </div>
    
    <button type="submit" class="btn btn-primary">Отправить</button>
</form>

<div id="success-message" class="alert alert-success mt-3" style="display: none;">
    Сообщение успешно отправлено!
</div>

<script>
    document.getElementById('contactForm').addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Сбор данных формы
        const formData = new FormData(this);
        
        // Очистка предыдущих ошибок
        document.querySelectorAll('.invalid-feedback').forEach(function(element) {
            element.textContent = '';
            element.style.display = 'none';
        });
        
        document.querySelectorAll('.form-control').forEach(function(element) {
            element.classList.remove('is-invalid');
        });
        
        // AJAX-запрос
        fetch('/api/contact', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Успешная отправка
                document.getElementById('contactForm').reset();
                document.getElementById('success-message').style.display = 'block';
                
                // Скрытие сообщения через 5 секунд
                setTimeout(function() {
                    document.getElementById('success-message').style.display = 'none';
                }, 5000);
            } else {
                // Отображение ошибок валидации
                const errors = data.errors || {};
                
                for (const field in errors) {
                    const errorElement = document.getElementById(field + '-error');
                    if (errorElement) {
                        errorElement.textContent = errors[field];
                        errorElement.style.display = 'block';
                        
                        const inputElement = document.getElementById(field);
                        if (inputElement) {
                            inputElement.classList.add('is-invalid');
                        }
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    });
</script>
```

```python
# main.py
from fastapi import FastAPI, Form, Request, Depends, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr, validator
from typing import Optional, Dict

app = FastAPI()

# Эндпоинт для AJAX-обработки формы
@app.post("/api/contact", response_model=dict)
async def contact_form(
    request: Request,
    name: str = Form(...),
    email: str = Form(...),
    message: str = Form(...)
):
    # Проверка CSRF-токена (если реализовано)
    # csrf_token = await request.form().get("csrf_token")
    # verify_csrf_token(request, csrf_token)
    
    errors: Dict[str, str] = {}
    
    # Валидация данных
    if len(name) < 2:
        errors["name"] = "Имя должно содержать не менее 2 символов"
    
    # Валидация email (могла бы быть автоматической с Pydantic)
    if "@" not in email:
        errors["email"] = "Введите корректный email"
    
    if len(message) < 10:
        errors["message"] = "Сообщение должно содержать не менее 10 символов"
    
    if errors:
        return {"success": False, "errors": errors}
    
    # Обработка данных формы
    # например, сохранение в БД или отправка email
    
    return {"success": True}
```

## REST API и формы

### Django REST Framework

```python
# serializers.py
from rest_framework import serializers
from .models import Contact

class ContactSerializer(serializers.ModelSerializer):
    class Meta:
        model = Contact
        fields = ['name', 'email', 'message', 'created_at']
        read_only_fields = ['created_at']
    
    def validate_name(self, value):
        if len(value) < 2:
            raise serializers.ValidationError('Имя должно содержать не менее 2 символов')
        return value
    
    def validate_message(self, value):
        if len(value) < 10:
            raise serializers.ValidationError('Сообщение должно содержать не менее 10 символов')
        return value

# views.py
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .serializers import ContactSerializer

@api_view(['POST'])
def contact_api(request):
    serializer = ContactSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response({'success': True}, status=status.HTTP_201_CREATED)
    return Response({'success': False, 'errors': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
```

### Flask-RESTful

```python
from flask import Flask
from flask_restful import Api, Resource, reqparse
from werkzeug.exceptions import BadRequest
import re

app = Flask(__name__)
api = Api(app)

# Парсер аргументов для контактной формы
contact_parser = reqparse.RequestParser()
contact_parser.add_argument('name', type=str, required=True, help='Имя обязательно')
contact_parser.add_argument('email', type=str, required=True, help='Email обязателен')
contact_parser.add_argument('message', type=str, required=True, help='Сообщение обязательно')

class ContactAPI(Resource):
    def post(self):
        args = contact_parser.parse_args()
        
        # Валидация данных
        errors = {}
        
        if len(args['name']) < 2:
            errors['name'] = 'Имя должно содержать не менее 2 символов'
        
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_regex, args['email']):
            errors['email'] = 'Введите корректный email'
        
        if len(args['message']) < 10:
            errors['message'] = 'Сообщение должно содержать не менее 10 символов'
        
        if errors:
            return {'success': False, 'errors': errors}, 400
        
        # Обработка данных
        # ...
        
        return {'success': True}, 201

api.add_resource(ContactAPI, '/api/contact')
```

### FastAPI

```python
from fastapi import FastAPI, Body, HTTPException
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Dict

app = FastAPI()

class ContactRequest(BaseModel):
    name: str = Field(..., min_length=2, max_length=100)
    email: EmailStr
    message: str = Field(..., min_length=10)
    
    @validator('name')
    def name_must_not_contain_numbers(cls, v):
        if any(char.isdigit() for char in v):
            raise ValueError('Имя не должно содержать цифры')
        return v

@app.post("/api/contact")
async def contact_api(contact: ContactRequest):
    # Данные уже валидированы Pydantic
    
    # Обработка данных
    # ...
    
    return {"success": True}

# Обработка ошибок валидации
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"success": False, "errors": exc.detail},
    )
```

## Сравнительный анализ

### Таблица сравнения подходов к формам

| Критерий | Django Forms | Flask-WTF | FastAPI/Pydantic |
|----------|--------------|-----------|------------------|
| **Интеграция с ORM** | Тесная (ModelForm) | Нет (отдельные пакеты) | Частичная |
| **Генерация HTML** | Встроенная | Встроенная | Отсутствует |
| **Валидация** | Декларативная | Декларативная | Основана на типах |
| **CSRF-защита** | Из коробки | Из коробки | Требует реализации |
| **Обработка файлов** | Встроенная | Через расширения | Базовая |
| **Гибкость** | Средняя | Высокая | Очень высокая |
| **Производительность** | Хорошая | Хорошая | Отличная |
| **Асинхронность** | Нет | Нет | Из коробки |
| **Сложность** | Низкая | Средняя | Средняя |
| **Типизация** | Динамическая | Динамическая | Статическая |
| **Экосистема** | Большая | Средняя | Растущая |
| **Документация** | Отличная | Хорошая | Отличная |

### Рекомендации по выбору

#### Django Forms подходят, если:
- Вы разрабатываете на Django
- Требуется тесная интеграция с моделями Django
- Важна скорость разработки
- Нужна встроенная HTML-генерация и CSRF-защита

#### Flask-WTF подходит, если:
- Вы используете Flask
- Нужна гибкость и модульность
- Предпочитаете декларативный подход
- Требуется хорошая поддержка HTML-форм

#### FastAPI/Pydantic подходит, если:
- Требуется высокая производительность
- Предпочитаете асинхронность
- Важна строгая типизация
- Фокус на API, а не на HTML-формах

## Лучшие практики

### Общие рекомендации

1. **Валидация на стороне клиента и сервера**
   - Клиентская валидация для улучшения UX
   - Серверная валидация для безопасности
   - Консистентная обработка ошибок

2. **Атомарная валидация**
   - Разделение сложных проверок на отдельные валидаторы
   - Повторное использование валидаторов
   - Понятные сообщения об ошибках

3. **Безопасность**
   - CSRF-защита для всех форм
   - Валидация входящих данных
   - Ограничение размера загружаемых файлов
   - Проверка типов файлов

4. **Пользовательский опыт**
   - Сохранение данных при ошибках валидации
   - Предзаполнение форм при редактировании
   - Понятные сообщения об ошибках
   - Прогрессивное улучшение (форма должна работать даже без JavaScript)

### Django

1. **Использование ModelForm**
   - Для CRUD-операций с моделями
   - Custom clean_* методы для сложной валидации
   - Метаклассы для настройки полей и виджетов

2. **Формсеты**
   - Для работы с несколькими экземплярами одной формы
   - Инлайн-формсеты для связанных объектов
   - Настройка extra, max_num, can_delete

3. **Классы представлений для форм**
   - FormView, CreateView, UpdateView, DeleteView
   - success_url для перенаправления
   - get_form_kwargs для дополнительных параметров

4. **Кастомизация форм**
   - Django Crispy Forms для стилизации
   - Наследование от базовой формы для общей функциональности
   - Переопределение init для динамической настройки

### Flask

1. **Структурирование форм**
   - Отдельный модуль для определения форм
   - Наследование от общего базового класса
   - Расширение WTForms для дополнительных полей

2. **Валидация**
   - Использование validate_on_submit() в представлениях
   - Пользовательские валидаторы для сложной логики
   - Валидация, зависящая от нескольких полей

3. **Рендеринг форм**
   - Использование Jinja2 макросов для стандартизации
   - Bootstrap или другие CSS-фреймворки для стилизации
   - Отображение ошибок рядом с соответствующими полями

4. **Обработка файлов**
   - secure_filename для безопасного сохранения
   - Проверка MIME-типов в дополнение к расширениям
   - Ограничение размера файлов в конфигурации

### FastAPI

1. **Модели данных**
   - Pydantic для валидации входящих данных
   - Схемы для запросов и ответов
   - Использование Field для дополнительных ограничений

2. **Зависимости**
   - Depends для получения данных формы
   - Зависимости для валидации и авторизации
   - Переиспользование зависимостей

3. **Обработка ошибок**
   - Единообразная структура ответов
   - HTTPException с понятными сообщениями
   - Обработчики исключений для Pydantic ValidationError

4. **HTML-формы**
   - Интеграция с Jinja2Templates
   - Использование Form для получения данных формы
   - CSRF-защита через middleware

## Подводные камни

### Django

1. **Валидация с сохранением файлов**
   - Файлы сохраняются при вызове form.save(), но не доступны в clean()
   - Необходимо проверять файлы в clean_* методах
   
2. **Проблемы с ChoiceField**
   - Необходимо обновлять choices для динамического контента
   - Проблемы с использованием querysets в choices

3. **Ленивая трансляция**
   - Использование lazy_gettext для локализации строк в формах
   - Проблемы с переводом сообщений об ошибках в валидаторах

4. **Обработка даты и времени**
   - Несоответствие форматов между HTML5-полями и Django
   - Необходимость настройки виджетов для корректного отображения

### Flask

1. **Передача файлов в WTForms**
   - Необходимость установки Flask-WTF и обработки request.files вручную
   - Отсутствие встроенной валидации MIME-типов

2. **CSRF-токены для AJAX**
   - Извлечение токена из мета-тегов или форм
   - Настройка заголовков для AJAX-запросов

3. **Валидация вложенных форм**
   - Сложность в передаче ошибок вложенных форм
   - Необходимость ручной настройки для FormField

4. **Интеграция с ORM**
   - Отсутствие встроенной интеграции с Flask-SQLAlchemy
   - Необходимость ручной синхронизации между формами и моделями

### FastAPI

1. **Работа с HTML-формами**
   - Отсутствие встроенной генерации HTML
   - Необходимость ручного создания шаблонов и обработки ошибок

2. **CSRF-защита**
   - Отсутствие встроенной защиты, требуется собственная реализация
   - Проблемы с куки-заголовками в асинхронном коде

3. **Валидация зависимых полей**
   - Pydantic root_validator не всегда удобен для сложных зависимостей
   - Сложность в передаче контекста в валидаторы

4. **Интеграция с ORM**
   - Асинхронные ORM требуют особого внимания
   - Преобразование между ORM-моделями и Pydantic-моделями

## Полезные ресурсы

### Django

- [Официальная документация по формам](https://docs.djangoproject.com/en/3.2/topics/forms/)
- [Руководство по Django ModelForms](https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/)
- [Django Crispy Forms](https://django-crispy-forms.readthedocs.io/en/latest/)
- [Django Form Tools](https://django-formtools.readthedocs.io/) - для многостраничных форм и мастеров

### Flask

- [Flask-WTF документация](https://flask-wtf.readthedocs.io/)
- [WTForms документация](https://wtforms.readthedocs.io/)
- [Flask Mega-Tutorial: формы](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms)
- [Flask Web Development](https://www.oreilly.com/library/view/flask-web-development/9781491991725/) - книга от Miguel Grinberg

### FastAPI

- [Документация FastAPI по работе с формами](https://fastapi.tiangolo.com/tutorial/request-forms/)
- [Документация Pydantic](https://pydantic-docs.helpmanual.io/)
- [FastAPI с Jinja Templates](https://fastapi.tiangolo.com/advanced/templates/)
- [Starlette CSRF](https://github.com/small-dunk/starlette-csrf) - расширение для CSRF-защиты в FastAPI

### Общие ресурсы

- [MDN: Руководство по формам HTML](https://developer.mozilla.org/ru/docs/Learn/Forms)
- [OWASP: Принципы валидации](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)
- [Web Form Design Patterns](https://www.smashingmagazine.com/2017/06/designing-perfect-web-form-ux-tips/)
- [CSS-Tricks: Form Validation UX](https://css-tricks.com/form-validation-ux-html-css/)
