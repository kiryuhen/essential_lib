# 11.6. Антипаттерны и рефакторинг

## Распространённые антипаттерны

Антипаттерны — это распространённые ошибочные решения и практики, которые часто приводят к проблемам в программном обеспечении. В отличие от паттернов проектирования, которые предлагают эффективные решения для типичных проблем, антипаттерны описывают то, чего следует избегать.

### God Object (Божественный объект)

**Описание**: Этот антипаттерн возникает, когда один класс берет на себя слишком много ответственности, становясь "всезнающим" и "всемогущим". God Object знает слишком много и делает слишком много.

**Признаки**:
- Класс содержит множество полей и методов
- Методы и свойства имеют низкую связность
- Класс имеет множество зависимостей
- Другие классы сильно зависят от него

**Проблемы**:
- Затрудняет понимание и сопровождение кода
- Усложняет тестирование
- Нарушает принцип единственной ответственности (SRP)
- Приводит к дублированию кода

**Пример на Python**:

```python
class OnlineStore:
    def __init__(self):
        self.products = []
        self.users = []
        self.orders = []
        self.payments = []
        self.shipping_methods = []
        self.discounts = []
        self.tax_rates = {}
        self.inventory = {}
        # ... и еще много данных
    
    def add_product(self, product):
        # Логика добавления продукта
        self.products.append(product)
        self.inventory[product.id] = product.initial_stock
    
    def register_user(self, username, password, email, address):
        # Логика регистрации пользователя, включая валидацию email
        user = {"username": username, "password": self._hash_password(password), 
                "email": email, "address": address}
        self.users.append(user)
        return user
    
    def _hash_password(self, password):
        # Логика хеширования пароля
        return "hashed_" + password  # Очень упрощенно
    
    def place_order(self, user_id, products, payment_info):
        # Логика создания заказа
        # Проверка инвентаря
        for product_id, quantity in products.items():
            if self.inventory.get(product_id, 0) < quantity:
                return "Недостаточно товара на складе"
        
        # Обработка платежа
        payment_result = self._process_payment(payment_info)
        if not payment_result["success"]:
            return "Ошибка платежа: " + payment_result["message"]
        
        # Создание заказа
        order = {
            "id": len(self.orders) + 1,
            "user_id": user_id,
            "products": products,
            "payment": payment_result,
            "status": "подтвержден"
        }
        self.orders.append(order)
        
        # Обновление инвентаря
        for product_id, quantity in products.items():
            self.inventory[product_id] -= quantity
        
        # Отправка email подтверждения
        self._send_confirmation_email(user_id, order)
        
        return order
    
    def _process_payment(self, payment_info):
        # Логика обработки платежа
        # ... сложная реализация ...
        return {"success": True, "transaction_id": "12345"}
    
    def _send_confirmation_email(self, user_id, order):
        # Логика отправки email
        user = next((u for u in self.users if u.get("id") == user_id), None)
        if user:
            print(f"Отправка email на адрес {user['email']}: Заказ #{order['id']} подтвержден")
    
    def generate_sales_report(self, start_date, end_date):
        # Логика создания отчета о продажах
        # ... сложная реализация ...
        return "Отчет о продажах за период"
    
    def apply_discount(self, order_id, discount_code):
        # Логика применения скидки
        # ... и так далее ...
    
    # ... и еще десятки методов
```

**Решение**: Разбить God Object на множество меньших классов с четкой ответственностью. Например:
- `ProductManager` для управления продуктами и инвентарем
- `UserManager` для управления пользователями
- `OrderService` для обработки заказов
- `PaymentProcessor` для обработки платежей
- `EmailService` для отправки писем
- `ReportGenerator` для создания отчетов

### Spaghetti Code (Спагетти-код)

**Описание**: Код с запутанной и сложной структурой управления, в котором трудно проследить поток выполнения программы. Часто содержит глубоко вложенные условные операторы, множество переходов (goto) или неявных связей между компонентами.

**Признаки**:
- Сложная и запутанная структура кода
- Избыточное использование глобальных переменных
- Длинные методы с многочисленными ветвлениями
- Отсутствие структуры и организации

**Проблемы**:
- Чрезвычайно сложно понять, как работает программа
- Высокая вероятность появления ошибок при модификации
- Трудности с тестированием
- Невозможность повторного использования кода

**Пример на Python**:

```python
def process_order(order, user, inventory, config, shipping_rules, payment_processor):
    # Много глобальных переменных и сложных взаимозависимостей
    global orders, users, payments, shipping_rates
    
    # Проверка доступности товаров
    for item in order['items']:
        if item['product_id'] in inventory:
            if inventory[item['product_id']] < item['quantity']:
                print("Недостаточно товара")
                if config['out_of_stock_behavior'] == 'reject':
                    return {'status': 'rejected', 'reason': 'out_of_stock'}
                elif config['out_of_stock_behavior'] == 'backorder':
                    item['backordered'] = True
                else:
                    # Неизвестная конфигурация
                    x = 10  # Неиспользуемая переменная
                    pass
        else:
            print("Продукт не найден")
            return {'status': 'rejected', 'reason': 'product_not_found'}
    
    # Расчет стоимости доставки
    shipping_cost = 0
    if order['shipping_method'] == 'standard':
        for region, rate in shipping_rates.items():
            if user['address']['region'] == region:
                shipping_cost = rate['standard']
                break
        if order['total'] > 100:
            shipping_cost = 0  # Бесплатная доставка для заказов > $100
    elif order['shipping_method'] == 'express':
        if user['status'] == 'premium':
            shipping_cost = 15  # Фиксированная цена для премиум-пользователей
        else:
            # Сложный расчет для обычных пользователей
            weight = sum(item['weight'] * item['quantity'] for item in order['items'])
            distance = shipping_rules.get_distance(user['address'])
            shipping_cost = weight * 0.1 + distance * 0.05
            if shipping_cost < 20:
                shipping_cost = 20  # Минимальная стоимость
    else:
        return {'status': 'rejected', 'reason': 'invalid_shipping_method'}
    
    # Добавление налогов
    tax_rate = 0
    if user['address']['country'] == 'US':
        tax_rate = us_tax_rates[user['address']['state']]
    else:
        tax_rate = international_tax_rates.get(user['address']['country'], 0)
    
    order_total = order['subtotal'] + shipping_cost
    tax_amount = order_total * tax_rate
    final_total = order_total + tax_amount
    
    # Обработка платежа
    payment_result = payment_processor.process(user['payment_info'], final_total)
    if payment_result['status'] != 'approved':
        return {'status': 'rejected', 'reason': 'payment_failed'}
    
    # Обновление инвентаря
    for item in order['items']:
        if not item.get('backordered'):
            inventory[item['product_id']] -= item['quantity']
    
    # Подготовка и возврат результата
    result = {
        'status': 'approved',
        'order_id': len(orders) + 1,
        'final_total': final_total,
        'shipping_cost': shipping_cost,
        'tax_amount': tax_amount,
        'estimated_delivery': calculate_delivery_date(order['shipping_method'])
    }
    
    # Сохранение заказа в глобальном списке
    orders.append({
        'id': result['order_id'],
        'user_id': user['id'],
        'items': order['items'],
        'total': final_total,
        'status': 'pending'
    })
    
    return result

# Вспомогательная функция для расчета даты доставки
def calculate_delivery_date(shipping_method):
    from datetime import datetime, timedelta
    today = datetime.now()
    if shipping_method == 'standard':
        return today + timedelta(days=7)
    elif shipping_method == 'express':
        return today + timedelta(days=2)
    else:
        return today + timedelta(days=14)  # Значение по умолчанию
```

**Решение**:
- Разбить большие функции на маленькие с ясной ответственностью
- Использовать структуру и объектно-ориентированное программирование
- Определить четкие интерфейсы между компонентами
- Избегать глобальных переменных, использовать передачу аргументов
- Применять паттерны проектирования для создания более понятной структуры

### Copy-Paste Programming (Программирование методом копирования и вставки)

**Описание**: Этот антипаттерн возникает, когда разработчики копируют и вставляют существующий код с небольшими изменениями, вместо того чтобы создавать абстракции и следовать принципу DRY (Don't Repeat Yourself).

**Признаки**:
- Дублирование кода со схожей функциональностью
- Небольшие вариации в дублированном коде
- При изменении одного экземпляра необходимо вносить те же изменения во все копии

**Проблемы**:
- Усложняет сопровождение кода
- Увеличивает размер кодовой базы
- Повышает вероятность ошибок при обновлении
- Нарушает принцип DRY

**Пример на Python**:

```python
# Функциональность для обработки заказов на книги
def process_book_order(order):
    # Проверяем наличие книг
    for book in order['books']:
        if not check_book_inventory(book['id'], book['quantity']):
            return {'success': False, 'message': f"Книга {book['id']} не доступна в запрошенном количестве"}
    
    # Рассчитываем стоимость
    total = sum(get_book_price(book['id']) * book['quantity'] for book in order['books'])
    
    # Применяем скидку для книг
    if total > 100:
        total *= 0.9  # 10% скидка на заказы книг > $100
    
    # Добавляем налог
    tax = total * 0.08
    total_with_tax = total + tax
    
    # Сохраняем заказ
    save_book_order(order, total_with_tax)
    
    # Обновляем инвентарь
    for book in order['books']:
        update_book_inventory(book['id'], -book['quantity'])
    
    # Отправляем уведомление
    send_book_order_notification(order, total_with_tax)
    
    return {'success': True, 'total': total_with_tax, 'order_id': order['id']}


# Скопированный и слегка измененный код для обработки заказов на электронику
def process_electronics_order(order):
    # Проверяем наличие электроники
    for item in order['items']:
        if not check_electronics_inventory(item['id'], item['quantity']):
            return {'success': False, 'message': f"Товар {item['id']} не доступен в запрошенном количестве"}
    
    # Рассчитываем стоимость
    total = sum(get_electronics_price(item['id']) * item['quantity'] for item in order['items'])
    
    # Применяем скидку для электроники
    if total > 500:
        total *= 0.85  # 15% скидка на заказы электроники > $500
    
    # Добавляем налог
    tax = total * 0.08
    total_with_tax = total + tax
    
    # Сохраняем заказ
    save_electronics_order(order, total_with_tax)
    
    # Обновляем инвентарь
    for item in order['items']:
        update_electronics_inventory(item['id'], -item['quantity'])
    
    # Отправляем уведомление
    send_electronics_order_notification(order, total_with_tax)
    
    return {'success': True, 'total': total_with_tax, 'order_id': order['id']}


# Еще одна копия для обработки заказов на одежду
def process_clothing_order(order):
    # Проверяем наличие одежды
    for item in order['clothes']:
        if not check_clothing_inventory(item['id'], item['quantity']):
            return {'success': False, 'message': f"Одежда {item['id']} не доступна в запрошенном количестве"}
    
    # Рассчитываем стоимость
    total = sum(get_clothing_price(item['id']) * item['quantity'] for item in order['clothes'])
    
    # Применяем скидку для одежды
    if total > 200:
        total *= 0.8  # 20% скидка на заказы одежды > $200
    
    # Добавляем налог
    tax = total * 0.08
    total_with_tax = total + tax
    
    # Сохраняем заказ
    save_clothing_order(order, total_with_tax)
    
    # Обновляем инвентарь
    for item in order['clothes']:
        update_clothing_inventory(item['id'], -item['quantity'])
    
    # Отправляем уведомление
    send_clothing_order_notification(order, total_with_tax)
    
    return {'success': True, 'total': total_with_tax, 'order_id': order['id']}
```

**Решение**: Создать абстракцию, которая обобщает общую функциональность, и применить полиморфизм для обработки различий:

```python
class Order:
    def __init__(self, order_id, items):
        self.id = order_id
        self.items = items
    
    def get_discount_threshold(self):
        raise NotImplementedError("Subclasses must implement this")
    
    def get_discount_rate(self):
        raise NotImplementedError("Subclasses must implement this")
    
    def get_tax_rate(self):
        return 0.08  # Общая ставка налога для всех типов заказов


class BookOrder(Order):
    def get_discount_threshold(self):
        return 100
    
    def get_discount_rate(self):
        return 0.1  # 10% скидка


class ElectronicsOrder(Order):
    def get_discount_threshold(self):
        return 500
    
    def get_discount_rate(self):
        return 0.15  # 15% скидка


class ClothingOrder(Order):
    def get_discount_threshold(self):
        return 200
    
    def get_discount_rate(self):
        return 0.2  # 20% скидка


class OrderProcessor:
    def __init__(self, inventory_service, notification_service):
        self.inventory_service = inventory_service
        self.notification_service = notification_service
    
    def process_order(self, order):
        # Проверяем наличие товаров
        for item in order.items:
            if not self.inventory_service.check_availability(item['id'], item['quantity']):
                return {'success': False, 'message': f"Товар {item['id']} не доступен в запрошенном количестве"}
        
        # Рассчитываем стоимость
        total = sum(self.inventory_service.get_price(item['id']) * item['quantity'] for item in order.items)
        
        # Применяем скидку в зависимости от типа заказа
        if total > order.get_discount_threshold():
            total *= (1 - order.get_discount_rate())
        
        # Добавляем налог
        tax = total * order.get_tax_rate()
        total_with_tax = total + tax
        
        # Сохраняем заказ
        order_id = self.inventory_service.save_order(order, total_with_tax)
        
        # Обновляем инвентарь
        for item in order.items:
            self.inventory_service.update_inventory(item['id'], -item['quantity'])
        
        # Отправляем уведомление
        self.notification_service.send_order_notification(order, total_with_tax)
        
        return {'success': True, 'total': total_with_tax, 'order_id': order_id}
```

### Shotgun Surgery (Хирургия дробовиком)

**Описание**: Антипаттерн, когда для внесения одного изменения приходится модифицировать много разных классов. Это прямая противоположность God Object — вместо объединения всего в одном классе, функциональность слишком сильно распределена.

**Признаки**:
- Для реализации одной логической функции требуется изменение множества классов
- Тесная связанность между множеством компонентов
- Изменения, затрагивающие всю систему

**Проблемы**:
- Высокая вероятность пропустить необходимое изменение
- Сложность в понимании, как функциональность реализована
- Сложность тестирования
- Увеличение времени на внедрение изменений

**Пример на Python**:
Представим, что нам нужно добавить функциональность аудита (логирование операций) в нашу систему:

```python
# В файле users.py
def create_user(username, email, password):
    # Логирование для аудита
    print(f"[AUDIT] Creating user: {username}")
    # Логика создания пользователя
    
def update_user(user_id, **fields):
    # Логирование для аудита
    print(f"[AUDIT] Updating user: {user_id} with fields: {fields}")
    # Логика обновления пользователя
    
def delete_user(user_id):
    # Логирование для аудита
    print(f"[AUDIT] Deleting user: {user_id}")
    # Логика удаления пользователя


# В файле products.py
def add_product(name, price, description):
    # Логирование для аудита
    print(f"[AUDIT] Adding product: {name} at ${price}")
    # Логика добавления продукта
    
def update_product(product_id, **fields):
    # Логирование для аудита
    print(f"[AUDIT] Updating product: {product_id} with fields: {fields}")
    # Логика обновления продукта
    
def delete_product(product_id):
    # Логирование для аудита
    print(f"[AUDIT] Deleting product: {product_id}")
    # Логика удаления продукта


# В файле orders.py
def place_order(user_id, products):
    # Логирование для аудита
    print(f"[AUDIT] Placing order for user: {user_id}, products: {products}")
    # Логика размещения заказа
    
def cancel_order(order_id, reason):
    # Логирование для аудита
    print(f"[AUDIT] Cancelling order: {order_id}, reason: {reason}")
    # Логика отмены заказа


# В файле payments.py
def process_payment(order_id, amount, payment_method):
    # Логирование для аудита
    print(f"[AUDIT] Processing payment for order: {order_id}, amount: ${amount}, method: {payment_method}")
    # Логика обработки платежа
    
def refund_payment(payment_id, amount, reason):
    # Логирование для аудита
    print(f"[AUDIT] Refunding payment: {payment_id}, amount: ${amount}, reason: {reason}")
    # Логика возврата платежа
```

**Решение**: Применить аспектно-ориентированное программирование или создать централизованный компонент для обработки сквозной функциональности:

```python
# Создаем централизованный сервис аудита
class AuditLogger:
    def log_event(self, event_type, details):
        print(f"[AUDIT] {event_type}: {details}")


# Применяем его в нашем коде
audit_logger = AuditLogger()

# В файле users.py
def create_user(username, email, password):
    audit_logger.log_event("Create User", {"username": username})
    # Логика создания пользователя
    
def update_user(user_id, **fields):
    audit_logger.log_event("Update User", {"user_id": user_id, "fields": fields})
    # Логика обновления пользователя


# Можно также использовать декораторы
def audit(event_type):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Логируем до выполнения функции
            details = {"args": args, "kwargs": kwargs}
            audit_logger.log_event(event_type, details)
            
            # Выполняем функцию
            result = func(*args, **kwargs)
            
            # Логируем после выполнения функции, если нужно
            return result
        return wrapper
    return decorator


# Теперь можно применить декоратор к функциям
@audit("Delete User")
def delete_user(user_id):
    # Логика удаления пользователя
    pass
```

### Premature Optimization (Преждевременная оптимизация)

**Описание**: Этот антипаттерн заключается в оптимизации программного кода до того, как выявлены реальные проблемы с производительностью. Часто приводит к усложнению кода и затруднению его понимания.

**Признаки**:
- Сложный, трудночитаемый код ради незначительного улучшения производительности
- Оптимизация без измерения фактической производительности
- Потеря архитектурной чистоты из-за оптимизации

**Проблемы**:
- Увеличивает сложность кода
- Затрудняет поддержку и расширение
- Нередко приводит к новым ошибкам
- Часто затрачиваются усилия на оптимизацию нерелевантных частей системы

**Пример на Python**:

```python
def calculate_statistics(data):
    # Преждевременная оптимизация: использование предвычисленных значений
    # и избыток микрооптимизаций, которые усложняют чтение кода
    n = len(data)
    if n == 0:
        return {"mean": 0, "median": 0, "std_dev": 0}
    
    # "Оптимизация" суммирования
    total = 0
    i = 0
    while i < n:  # Использование while вместо for, думая что это быстрее
        total += data[i]
        i += 1
    
    # "Оптимизация" расчета среднего
    mean = total / n
    
    # "Оптимизация" расчета медианы
    if n & 1:  # Побитовая операция для проверки на нечетность
        median = sorted(data)[n >> 1]  # Побитовое смещение для деления на 2
    else:
        sorted_data = sorted(data)
        i1 = n >> 1
        i2 = i1 - 1
        median = (sorted_data[i1] + sorted_data[i2]) / 2
    
    # "Оптимизация" расчета стандартного отклонения
    squared_diffs_sum = 0
    for i in range(n):
        diff = data[i] - mean
        squared_diffs_sum += diff * diff
    
    variance = squared_diffs_sum / n
    std_dev = variance ** 0.5  # Избегание использования math.sqrt
    
    return {
        "mean": mean,
        "median": median,
        "std_dev": std_dev
    }
```

**Решение**: Писать чистый, понятный код и оптимизировать только после выявления реальных узких мест с помощью профилирования:

```python
import statistics

def calculate_statistics(data):
    # Ясный, читаемый код, использующий стандартную библиотеку
    if not data:
        return {"mean": 0, "median": 0, "std_dev": 0}
    
    mean = statistics.mean(data)
    median = statistics.median(data)
    std_dev = statistics.stdev(data) if len(data) > 1 else 0
    
    return {
        "mean": mean,
        "median": median,
        "std_dev": std_dev
    }

# Если профилирование показало, что эта функция слишком медленная для больших наборов данных,
# только тогда следует приступать к оптимизации с четким пониманием узких мест
```

### Magic Numbers/Strings (Магические числа/строки)

**Описание**: Антипаттерн, при котором в коде используются числовые или строковые литералы без понятного объяснения их значения или источника.

**Признаки**:
- Использование чисел и строк напрямую в коде без объяснения
- Повторение одних и тех же значений в разных местах
- Отсутствие констант для часто используемых значений

**Проблемы**:
- Затрудняет понимание кода
- Усложняет поддержку и модификацию
- Потенциальный источник ошибок при обновлении значений
- Дублирование значений

**Пример на Python**:

```python
def calculate_price(product_type, base_price, quantity):
    # Магические числа без объяснения их значения
    if product_type == 1:  # Что означает 1?
        if quantity > 10:
            return base_price * quantity * 0.9  # Что означает 0.9?
        return base_price * quantity
    elif product_type == 2:  # Что означает 2?
        tax = base_price * 0.07  # Что означает 0.07?
        if quantity > 5:
            shipping = 15  # Что означает 15?
        else:
            shipping = 20  # Что означает 20?
        return (base_price + tax) * quantity + shipping
    elif product_type == 3:  # Что означает 3?
        if base_price > 100:
            return base_price * quantity
        return base_price * quantity + 25  # Что означает 25?
    else:
        return base_price * quantity * 1.05  # Что означает 1.05?
```

**Решение**: Использовать именованные константы и перечисления для описания значений:

```python
from enum import Enum

# Определение констант и перечислений
class ProductType(Enum):
    STANDARD = 1
    TAXABLE = 2
    PREMIUM = 3

# Константы для налогов, скидок и доставки
BULK_DISCOUNT_RATE = 0.9
STANDARD_TAX_RATE = 0.07
LOW_QUANTITY_SHIPPING = 20
HIGH_QUANTITY_SHIPPING = 15
STANDARD_FEE = 25
DEFAULT_MARKUP = 1.05

# Пороги для применения различных условий
BULK_QUANTITY_THRESHOLD = 10
REDUCED_SHIPPING_THRESHOLD = 5
PREMIUM_PRICE_THRESHOLD = 100

def calculate_price(product_type, base_price, quantity):
    if product_type == ProductType.STANDARD:
        if quantity > BULK_QUANTITY_THRESHOLD:
            return base_price * quantity * BULK_DISCOUNT_RATE
        return base_price * quantity
    
    elif product_type == ProductType.TAXABLE:
        tax = base_price * STANDARD_TAX_RATE
        if quantity > REDUCED_SHIPPING_THRESHOLD:
            shipping = HIGH_QUANTITY_SHIPPING
        else:
            shipping = LOW_QUANTITY_SHIPPING
        return (base_price + tax) * quantity + shipping
    
    elif product_type == ProductType.PREMIUM:
        if base_price > PREMIUM_PRICE_THRESHOLD:
            return base_price * quantity
        return base_price * quantity + STANDARD_FEE
    
    else:
        return base_price * quantity * DEFAULT_MARKUP
```

## Признаки плохого кода ("запахи кода")

"Запахи кода" (Code Smells) — это признаки в исходном коде, которые могут указывать на более глубокие проблемы. Сами по себе они не являются ошибками, но часто сигнализируют о проблемах с дизайном или реализацией.

### Длинный метод (Long Method)

**Описание**: Метод, который содержит слишком много строк кода, выполняет слишком много действий или имеет слишком высокую сложность.

**Признаки**:
- Большое количество строк кода (обычно более 20-30)
- Множество локальных переменных и параметров
- Множество условных операторов и циклов
- Комментарии для объяснения различных секций метода

**Пример на Python**:

```python
def process_customer_order(customer_id, items, payment_info, shipping_address, promo_code=None):
    # Проверка клиента
    customer = database.get_customer(customer_id)
    if not customer:
        return {"success": False, "error": "Customer not found"}
    
    # Проверка items
    total = 0
    for item in items:
        product = database.get_product(item['product_id'])
        if not product:
            return {"success": False, "error": f"Product {item['product_id']} not found"}
        
        if product.inventory < item['quantity']:
            return {"success": False, "error": f"Not enough inventory for {product.name}"}
        
        # Рассчитываем стоимость для каждого товара
        item_price = product.price * item['quantity']
        
        # Применение скидок на уровне товара
        if product.is_on_sale:
            item_price *= 0.9
        
        total += item_price
    
    # Применение промо-кода, если есть
    if promo_code:
        promo = database.get_promo_code(promo_code)
        if promo and promo.is_valid:
            if promo.discount_type == 'percentage':
                total *= (1 - promo.discount_value / 100)
            else:  # fixed amount
                total = max(0, total - promo.discount_value)
    
    # Добавление налога
    if shipping_address.country == 'US':
        state_tax = US_TAX_RATES.get(shipping_address.state, 0)
        total *= (1 + state_tax)
    
    # Расчет стоимости доставки
    shipping_cost = 0
    if total < 50:
        shipping_cost = 9.99
    
    # Проверка платежной информации
    if payment_info.type == 'credit_card':
        if not validate_credit_card(payment_info.card_number, payment_info.expiry, payment_info.cvv):
            return {"success": False, "error": "Invalid credit card information"}
    elif payment_info.type == 'paypal':
        if not validate_paypal_account(payment_info.email):
            return {"success": False, "error": "Invalid PayPal account"}
    else:
        return {"success": False, "error": "Unsupported payment method"}
    
    # Обработка платежа
    payment_result = payment_processor.process_payment(
        payment_info,
        total + shipping_cost,
        f"Order for customer {customer_id}"
    )
    
    if not payment_result.success:
        return {"success": False, "error": f"Payment failed: {payment_result.error}"}
    
    # Создание заказа в базе данных
    order = Order(
        customer_id=customer_id,
        items=items,
        total=total,
        shipping_cost=shipping_cost,
        payment_id=payment_result.payment_id,
        shipping_address=shipping_address
    )
    
    database.save_order(order)
    
    # Обновление инвентаря
    for item in items:
        database.update_product_inventory(item['product_id'], -item['quantity'])
    
    # Отправка подтверждения по email
    email_service.send_order_confirmation(
        customer.email,
        order.id,
        total + shipping_cost,
        items
    )
    
    return {
        "success": True,
        "order_id": order.id,
        "total": total,
        "shipping_cost": shipping_cost,
        "grand_total": total + shipping_cost
    }
```

**Решение**: Разбить длинный метод на несколько меньших, каждый с ясной ответственностью:

```python
def process_customer_order(customer_id, items, payment_info, shipping_address, promo_code=None):
    # Проверка клиента
    customer = get_verified_customer(customer_id)
    if not customer:
        return {"success": False, "error": "Customer not found"}
    
    # Проверка и оценка товаров
    items_result = validate_and_price_items(items)
    if not items_result["success"]:
        return items_result
    
    # Расчет общей стоимости с учетом скидок и налогов
    pricing_result = calculate_total_price(
        items_result["priced_items"],
        shipping_address,
        promo_code
    )
    
    # Расчет стоимости доставки
    shipping_cost = calculate_shipping_cost(pricing_result["total"])
    
    # Обработка платежа
    payment_result = process_payment(
        payment_info,
        pricing_result["total"] + shipping_cost,
        customer_id
    )
    
    if not payment_result["success"]:
        return payment_result
    
    # Создание и сохранение заказа
    order = create_order(
        customer_id,
        items,
        pricing_result["total"],
        shipping_cost,
        payment_result["payment_id"],
        shipping_address
    )
    
    # Обновление инвентаря и отправка уведомлений
    update_inventory(items)
    send_order_confirmation(customer, order, pricing_result["total"] + shipping_cost)
    
    return {
        "success": True,
        "order_id": order.id,
        "total": pricing_result["total"],
        "shipping_cost": shipping_cost,
        "grand_total": pricing_result["total"] + shipping_cost
    }
```

Каждый из новых методов (`get_verified_customer`, `validate_and_price_items` и т.д.) выполняет одну конкретную функцию и делает это хорошо.

### Класс с большим количеством полей (Large Class)

**Описание**: Класс с большим количеством полей, методов или и того, и другого. Часто это признак того, что класс пытается делать слишком много.

**Признаки**:
- Множество полей и/или методов в одном классе
- Методы работают только с подмножеством полей класса
- Сложность в понимании класса целиком
- Частые изменения в разных частях класса по разным причинам

**Пример на Python**:

```python
class UserManager:
    def __init__(self, database_connection):
        self.db = database_connection
        self.users = {}
        self.roles = {}
        self.permissions = {}
        self.settings = {}
        self.active_sessions = {}
        self.password_reset_tokens = {}
        self.email_verification_tokens = {}
        self.login_attempts = {}
        self.notifications = []
        self.emails_to_send = []
        self.analytics = {}
        # ... и множество других полей
    
    def create_user(self, username, email, password):
        # Логика создания пользователя
        pass
    
    def authenticate_user(self, username, password):
        # Логика аутентификации
        pass
    
    def reset_password(self, email):
        # Логика сброса пароля
        pass
    
    def update_user_profile(self, user_id, **fields):
        # Логика обновления профиля
        pass
    
    def assign_role(self, user_id, role_id):
        # Логика назначения роли
        pass
    
    def create_role(self, name, permissions):
        # Логика создания роли
        pass
    
    def check_permission(self, user_id, permission):
        # Логика проверки разрешений
        pass
    
    def log_user_activity(self, user_id, activity):
        # Логика журналирования активности
        pass
    
    def send_verification_email(self, user_id):
        # Логика отправки письма для верификации
        pass
    
    def process_email_queue(self):
        # Логика обработки очереди email
        pass
    
    def update_settings(self, user_id, settings):
        # Логика обновления настроек пользователя
        pass
    
    def generate_analytics_report(self):
        # Логика генерации отчетов
        pass
    
    def clean_expired_sessions(self):
        # Логика очистки устаревших сессий
        pass
    
    def ban_user(self, user_id, reason):
        # Логика блокировки пользователя
        pass
    
    # ... и множество других методов
```

**Решение**: Разбить класс на несколько меньших, каждый с конкретной ответственностью:

```python
# Класс для управления пользователями
class UserManager:
    def __init__(self, database_connection):
        self.db = database_connection
        self.users = {}
    
    def create_user(self, username, email, password):
        # Логика создания пользователя
        pass
    
    def update_user_profile(self, user_id, **fields):
        # Логика обновления профиля
        pass
    
    def get_user(self, user_id):
        # Логика получения пользователя
        pass
    
    def delete_user(self, user_id):
        # Логика удаления пользователя
        pass


# Класс для управления аутентификацией и авторизацией
class AuthManager:
    def __init__(self, user_manager):
        self.user_manager = user_manager
        self.active_sessions = {}
        self.login_attempts = {}
        self.password_reset_tokens = {}
    
    def authenticate_user(self, username, password):
        # Логика аутентификации
        pass
    
    def reset_password(self, email):
        # Логика сброса пароля
        pass
    
    def logout_user(self, user_id):
        # Логика выхода пользователя
        pass
    
    def clean_expired_sessions(self):
        # Логика очистки устаревших сессий
        pass


# Класс для управления ролями и разрешениями
class RoleManager:
    def __init__(self, database_connection):
        self.db = database_connection
        self.roles = {}
        self.permissions = {}
    
    def create_role(self, name, permissions):
        # Логика создания роли
        pass
    
    def assign_role(self, user_id, role_id):
        # Логика назначения роли
        pass
    
    def check_permission(self, user_id, permission):
        # Логика проверки разрешений
        pass


# Класс для управления уведомлениями и электронной почтой
class NotificationManager:
    def __init__(self, email_service):
        self.email_service = email_service
        self.notifications = []
        self.emails_to_send = []
        self.email_verification_tokens = {}
    
    def send_verification_email(self, user_id, email):
        # Логика отправки письма для верификации
        pass
    
    def process_email_queue(self):
        # Логика обработки очереди email
        pass
    
    def notify_user(self, user_id, message):
        # Логика отправки уведомления пользователю
        pass


# И так далее для других функциональных областей
```

### Длинный список параметров (Long Parameter List)

**Описание**: Метод с большим количеством параметров, что затрудняет его понимание и использование.

**Признаки**:
- Метод принимает 4 или более параметров
- Сложно запомнить порядок и значение параметров
- Некоторые параметры часто передаются со значениями по умолчанию
- Параметры логически связаны друг с другом

**Пример на Python**:

```python
def create_user(username, email, password, first_name, last_name, date_of_birth, address_line1, 
                address_line2, city, state, zip_code, country, phone, role, department, 
                is_active=True, send_welcome_email=True, require_email_verification=True):
    # Логика создания пользователя
    pass
```

**Решение**: Использовать объекты для группировки связанных параметров, именованные аргументы или построители (builders):

```python
class UserData:
    def __init__(self, username, email, password, first_name=None, last_name=None):
        self.username = username
        self.email = email
        self.password = password
        self.first_name = first_name
        self.last_name = last_name


class Address:
    def __init__(self, line1, city, state, zip_code, country, line2=None):
        self.line1 = line1
        self.line2 = line2
        self.city = city
        self.state = state
        self.zip_code = zip_code
        self.country = country


class UserSettings:
    def __init__(self, is_active=True, send_welcome_email=True, require_email_verification=True):
        self.is_active = is_active
        self.send_welcome_email = send_welcome_email
        self.require_email_verification = require_email_verification


def create_user(user_data, address, phone=None, role=None, department=None, settings=None):
    # Используем объекты вместо длинного списка параметров
    if settings is None:
        settings = UserSettings()
    
    # Логика создания пользователя
    pass


# Использование
user_data = UserData(
    username="johndoe",
    email="john@example.com",
    password="secure_password",
    first_name="John",
    last_name="Doe"
)

address = Address(
    line1="123 Main St",
    line2="Apt 4B",
    city="New York",
    state="NY",
    zip_code="10001",
    country="US"
)

settings = UserSettings(
    send_welcome_email=False
)

create_user(user_data, address, phone="123-456-7890", role="admin", settings=settings)
```

### Дублирование кода (Duplicated Code)

**Описание**: Один и тот же или похожий код встречается в нескольких местах. Это нарушает принцип DRY (Don't Repeat Yourself).

**Признаки**:
- Повторяющиеся фрагменты кода в разных методах или классах
- Схожие алгоритмы, отличающиеся некоторыми параметрами или действиями
- При изменении одной части кода нужно вносить те же изменения и в другие части

**Пример на Python**:

```python
# В одном модуле
def validate_user_data(user_data):
    if not user_data.get('username'):
        return False, "Username is required"
    if len(user_data.get('username', '')) < 3:
        return False, "Username must be at least 3 characters"
    if not user_data.get('email'):
        return False, "Email is required"
    if '@' not in user_data.get('email', ''):
        return False, "Invalid email format"
    if not user_data.get('password'):
        return False, "Password is required"
    if len(user_data.get('password', '')) < 8:
        return False, "Password must be at least 8 characters"
    return True, "Validation successful"


# В другом модуле
def check_user_input(data):
    if not data.get('username'):
        return False, "Username is required"
    if len(data.get('username', '')) < 3:
        return False, "Username must be at least 3 characters"
    if not data.get('email'):
        return False, "Email is required"
    if '@' not in data.get('email', ''):
        return False, "Invalid email format"
    if not data.get('password'):
        return False, "Password is required"
    if len(data.get('password', '')) < 8:
        return False, "Password must be at least 8 characters"
    return True, "Validation successful"
```

**Решение**: Выделить общую функциональность в отдельный метод или класс и использовать его везде:

```python
def validate_user_data(user_data):
    """Проверяет данные пользователя на корректность"""
    validations = [
        ('username', lambda u: bool(u), "Username is required"),
        ('username', lambda u: len(u) >= 3, "Username must be at least 3 characters"),
        ('email', lambda e: bool(e), "Email is required"),
        ('email', lambda e: '@' in e, "Invalid email format"),
        ('password', lambda p: bool(p), "Password is required"),
        ('password', lambda p: len(p) >= 8, "Password must be at least 8 characters")
    ]
    
    for field, validation_func, error_message in validations:
        value = user_data.get(field, '')
        if not validation_func(value):
            return False, error_message
    
    return True, "Validation successful"


# Теперь этот метод можно использовать в обоих модулях
```

### Спагетти-код (Spaghetti Code)

**Описание**: Код с запутанной и сложной структурой управления, в котором трудно проследить поток выполнения программы.

**Признаки**:
- Чрезмерное количество вложенных условий и циклов
- Большое количество переходов (goto) или их эмуляций
- Отсутствие четкой структуры данных и функций
- Сложность в прослеживании потока выполнения

**Пример на Python**:

```python
def process_data(data):
    result = []
    i = 0
    while i < len(data):
        if data[i] > 0:
            if data[i] % 2 == 0:
                # Обработка четных положительных чисел
                temp = data[i] * 2
                if temp > 100:
                    # Если результат слишком большой
                    result.append(100)
                else:
                    # Иначе добавляем результат
                    result.append(temp)
            else:
                # Обработка нечетных положительных чисел
                if data[i] < 10:
                    # Маленькие нечетные числа
                    result.append(data[i] * 3)
                else:
                    # Большие нечетные числа
                    if data[i] > 50:
                        # Очень большие числа
                        result.append(50)
                    else:
                        # Средние числа
                        result.append(data[i])
        else:
            # Обработка отрицательных или нулевых чисел
            if data[i] == 0:
                # Особая обработка нулей
                if i > 0 and data[i-1] > 0:
                    # Если перед нулем положительное число
                    result.append(1)
                else:
                    # Иначе просто добавляем ноль
                    result.append(0)
            else:
                # Отрицательные числа
                if data[i] > -10:
                    # Небольшие отрицательные числа
                    result.append(abs(data[i]))
                else:
                    # Большие отрицательные числа остаются как есть
                    result.append(data[i])
        i += 1
    return result
```

**Решение**: Рефакторинг с разбиением на меньшие функции с понятными именами и использованием более простых структур управления:

```python
def process_positive_even(num):
    """Обрабатывает четные положительные числа"""
    result = num * 2
    return min(result, 100)  # Ограничиваем максимальным значением 100

def process_positive_odd(num):
    """Обрабатывает нечетные положительные числа"""
    if num < 10:
        return num * 3
    else:
        return min(num, 50)

def process_zero(previous_num):
    """Обрабатывает нули"""
    if previous_num > 0:
        return 1
    return 0

def process_negative(num):
    """Обрабатывает отрицательные числа"""
    if num > -10:
        return abs(num)
    return num

def process_data(data):
    """Обрабатывает массив данных с применением различных правил"""
    result = []
    
    for i, num in enumerate(data):
        if num > 0:
            if num % 2 == 0:
                result.append(process_positive_even(num))
            else:
                result.append(process_positive_odd(num))
        elif num == 0:
            previous_num = data[i-1] if i > 0 else 0
            result.append(process_zero(previous_num))
        else:  # num < 0
            result.append(process_negative(num))
    
    return result
```

### Неуместная близость (Feature Envy)

**Описание**: Код, который чрезмерно заинтересован в данных или методах другого класса, а не своего собственного. Это частое нарушение принципа инкапсуляции.

**Признаки**:
- Метод больше вызывает методы другого класса, чем своего
- Метод больше использует данные другого класса, чем своего
- Повторяющиеся последовательности вызовов одного и того же объекта

**Пример на Python**:

```python
class Customer:
    def __init__(self, name, address, phone):
        self.name = name
        self.address = address
        self.phone = phone


class Address:
    def __init__(self, street, city, state, zip_code):
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code


class Order:
    def __init__(self, customer, items, total):
        self.customer = customer
        self.items = items
        self.total = total
    
    def get_shipping_label(self):
        # Этот метод проявляет "зависть" к данным класса Address
        # Вместо того, чтобы работать с Order, он сосредоточен на данных Address
        return (f"{self.customer.name}\n"
                f"{self.customer.address.street}\n"
                f"{self.customer.address.city}, {self.customer.address.state} "
                f"{self.customer.address.zip_code}")
```

**Решение**: Переместить метод в класс, чьими данными он в основном оперирует:

```python
class Customer:
    def __init__(self, name, address, phone):
        self.name = name
        self.address = address
        self.phone = phone
    
    def get_full_name(self):
        return self.name


class Address:
    def __init__(self, street, city, state, zip_code):
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code
    
    def get_formatted_address(self):
        """Возвращает отформатированный адрес"""
        return f"{self.street}\n{self.city}, {self.state} {self.zip_code}"


class Order:
    def __init__(self, customer, items, total):
        self.customer = customer
        self.items = items
        self.total = total
    
    def get_shipping_label(self):
        # Теперь метод использует соответствующие методы классов Customer и Address
        return f"{self.customer.get_full_name()}\n{self.customer.address.get_formatted_address()}"
```

### Непонятные имена (Cryptic Naming)

**Описание**: Имена переменных, методов или классов, которые не передают их предназначение или не соответствуют тому, что они делают.

**Признаки**:
- Короткие, сокращенные имена, не понятные без контекста
- Имена, не отражающие сущность объекта или функции
- Противоречие между именем и функциональностью
- Слишком общие имена, которые могут относиться к чему угодно

**Пример на Python**:

```python
def pc(d, sd, ed):
    """Функция для расчета с"""
    r = []
    for i in d:
        if i['dt'] >= sd and i['dt'] <= ed:
            r.append(i['v'])
    return sum(r)

# Использование
data = [{'dt': '2023-01-01', 'v': 100}, {'dt': '2023-01-15', 'v': 200}, {'dt': '2023-02-01', 'v': 300}]
result = pc(data, '2023-01-01', '2023-01-31')
```

**Решение**: Использовать ясные, описательные имена, которые объясняют предназначение и функцию:

```python
def calculate_total_value_in_period(data_points, start_date, end_date):
    """
    Рассчитывает сумму значений для точек данных, 
    находящихся в указанном временном периоде.
    
    Args:
        data_points: Список словарей с точками данных, содержащими 'dt' (дата) и 'v' (значение)
        start_date: Начальная дата периода (включительно)
        end_date: Конечная дата периода (включительно)
        
    Returns:
        Сумма значений в указанном периоде
    """
    values_in_period = []
    for data_point in data_points:
        if data_point['dt'] >= start_date and data_point['dt'] <= end_date:
            values_in_period.append(data_point['v'])
    return sum(values_in_period)

# Использование
data = [{'dt': '2023-01-01', 'v': 100}, {'dt': '2023-01-15', 'v': 200}, {'dt': '2023-02-01', 'v': 300}]
total_january_value = calculate_total_value_in_period(data, '2023-01-01', '2023-01-31')
```

### Жесткое кодирование (Hardcoding)

**Описание**: Практика внедрения постоянных значений непосредственно в код вместо использования конфигурационных файлов, констант или параметров.

**Признаки**:
- Литералы и константы, разбросанные по коду
- Отсутствие возможности изменить поведение без редактирования кода
- Дублирование одних и тех же значений в нескольких местах

**Пример на Python**:

```python
def send_email(user_email, subject, body):
    import smtplib
    from email.mime.text import MIMEText
    
    # Жестко закодированные настройки SMTP-сервера
    server = smtplib.SMTP('smtp.company.com', 587)
    server.starttls()
    server.login('system@company.com', 'p@ssw0rd!')
    
    # Жестко закодированные детали отправителя
    sender = 'noreply@company.com'
    
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = user_email
    
    server.send_message(msg)
    server.quit()


def generate_report():
    # Жестко закодированный путь к файлам
    with open('/var/www/html/reports/sales.csv', 'r') as f:
        data = f.read()
    
    # Жестко закодированные параметры отчета
    report_title = "Monthly Sales Report"
    report_period = "January 2023"
    
    # ... генерация отчета ...
    
    # Жестко закодированный список получателей
    recipients = ['manager1@company.com', 'manager2@company.com', 'ceo@company.com']
    
    for recipient in recipients:
        send_email(recipient, report_title, "Please find attached the " + report_period + " report.")
```

**Решение**: Использовать конфигурационные файлы, переменные окружения или параметры функций:

```python
import os
import json
from typing import List, Dict, Any

# Загрузка конфигурации из файла
def load_config(config_path: str = 'config.json') -> Dict[str, Any]:
    """Загружает конфигурацию из JSON-файла"""
    with open(config_path, 'r') as config_file:
        return json.load(config_file)

# Или загрузка из переменных окружения
def get_email_config() -> Dict[str, Any]:
    """Получает конфигурацию email из переменных окружения"""
    return {
        'smtp_server': os.environ.get('SMTP_SERVER', 'smtp.company.com'),
        'smtp_port': int(os.environ.get('SMTP_PORT', 587)),
        'smtp_user': os.environ.get('SMTP_USER', 'system@company.com'),
        'smtp_password': os.environ.get('SMTP_PASSWORD', ''),
        'sender': os.environ.get('EMAIL_SENDER', 'noreply@company.com')
    }

def send_email(user_email: str, subject: str, body: str, config: Dict[str, Any] = None) -> None:
    """
    Отправляет электронное письмо
    
    Args:
        user_email: Адрес получателя
        subject: Тема письма
        body: Текст письма
        config: Конфигурация для отправки (если None, будет загружена)
    """
    import smtplib
    from email.mime.text import MIMEText
    
    # Используем переданную конфигурацию или загружаем из окружения
    email_config = config or get_email_config()
    
    server = smtplib.SMTP(email_config['smtp_server'], email_config['smtp_port'])
    server.starttls()
    server.login(email_config['smtp_user'], email_config['smtp_password'])
    
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = email_config['sender']
    msg['To'] = user_email
    
    server.send_message(msg)
    server.quit()


def generate_report(config_path: str = 'report_config.json') -> None:
    """Генерирует отчет на основе конфигурации"""
    # Загружаем конфигурацию отчета
    config = load_config(config_path)
    
    # Используем пути из конфигурации
    with open(config['data_path'], 'r') as f:
        data = f.read()
    
    # Используем параметры из конфигурации
    report_title = config['title']
    report_period = config['period']
    
    # ... генерация отчета ...
    
    # Используем список получателей из конфигурации
    for recipient in config['recipients']:
        send_email(recipient, report_title, f"Please find attached the {report_period} report.")
```

## Техники рефакторинга

Рефакторинг — это процесс изменения внутренней структуры программы без изменения ее внешнего поведения с целью улучшения ее читаемости, снижения сложности и облегчения сопровождения.

### Извлечение метода (Extract Method)

**Описание**: Выделение фрагмента кода в отдельный метод с понятным именем, описывающим его предназначение.

**Когда применять**:
- Часть метода можно выделить и дать ей имя, отражающее ее назначение
- Код становится слишком длинным или сложным для понимания
- Фрагмент кода используется в нескольких местах

**Пример до рефакторинга**:

```python
def print_invoice(invoice):
    # Печать заголовка
    print("*" * 50)
    print("INVOICE")
    print("*" * 50)
    print(f"Customer: {invoice['customer_name']}")
    print(f"Date: {invoice['date']}")
    print("-" * 50)
    
    # Печать деталей
    total = 0
    for item in invoice['items']:
        price = item['price']
        quantity = item['quantity']
        item_total = price * quantity
        total += item_total
        print(f"{item['description']}: {quantity} x ${price} = ${item_total}")
    
    # Расчет и печать налогов
    tax_rate = 0.08
    tax_amount = total * tax_rate
    grand_total = total + tax_amount
    
    # Печать итогов
    print("-" * 50)
    print(f"Subtotal: ${total}")
    print(f"Tax ({tax_rate * 100}%): ${tax_amount}")
    print(f"Total: ${grand_total}")
    print("*" * 50)
    print("Thank you for your business!")
    print("*" * 50)
```

**Пример после рефакторинга**:

```python
def print_invoice(invoice):
    print_invoice_header(invoice)
    total = print_invoice_items(invoice['items'])
    tax_amount, grand_total = calculate_taxes(total)
    print_invoice_footer(total, tax_amount, grand_total)


def print_invoice_header(invoice):
    """Печатает заголовок счета"""
    print("*" * 50)
    print("INVOICE")
    print("*" * 50)
    print(f"Customer: {invoice['customer_name']}")
    print(f"Date: {invoice['date']}")
    print("-" * 50)


def print_invoice_items(items):
    """Печатает элементы счета и возвращает общую сумму"""
    total = 0
    for item in items:
        price = item['price']
        quantity = item['quantity']
        item_total = price * quantity
        total += item_total
        print(f"{item['description']}: {quantity} x ${price} = ${item_total}")
    
    return total


def calculate_taxes(subtotal):
    """Рассчитывает налог и общую сумму"""
    tax_rate = 0.08
    tax_amount = subtotal * tax_rate
    grand_total = subtotal + tax_amount
    return tax_amount, grand_total


def print_invoice_footer(subtotal, tax_amount, grand_total):
    """Печатает итоговую часть счета"""
    tax_rate = 0.08
    print("-" * 50)
    print(f"Subtotal: ${subtotal}")
    print(f"Tax ({tax_rate * 100}%): ${tax_amount}")
    print(f"Total: ${grand_total}")
    print("*" * 50)
    print("Thank you for your business!")
    print("*" * 50)
```

### Извлечение класса (Extract Class)

**Описание**: Создание нового класса и перемещение в него полей и методов из существующего класса, которые связаны общей темой.

**Когда применять**:
- Класс имеет слишком много обязанностей
- Некоторые поля и методы класса логически связаны между собой
- Части класса меняются по разным причинам или в разное время

**Пример до рефакторинга**:

```python
class Customer:
    def __init__(self, name, email, phone, street, city, state, zip_code):
        self.name = name
        self.email = email
        self.phone = phone
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code
    
    def get_full_name(self):
        return self.name
    
    def get_contact_info(self):
        return f"Email: {self.email}, Phone: {self.phone}"
    
    def get_address(self):
        return f"{self.street}, {self.city}, {self.state} {self.zip_code}"
    
    def format_address_for_shipping(self):
        return f"{self.name}\n{self.street}\n{self.city}, {self.state} {self.zip_code}"
    
    def is_in_state(self, state):
        return self.state == state
    
    def is_in_zip_range(self, start_zip, end_zip):
        zip_int = int(self.zip_code)
        return start_zip <= zip_int <= end_zip
```

**Пример после рефакторинга**:

```python
class Address:
    def __init__(self, street, city, state, zip_code):
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code
    
    def get_formatted_address(self):
        return f"{self.street}, {self.city}, {self.state} {self.zip_code}"
    
    def format_for_shipping(self, recipient_name):
        return f"{recipient_name}\n{self.street}\n{self.city}, {self.state} {self.zip_code}"
    
    def is_in_state(self, state):
        return self.state == state
    
    def is_in_zip_range(self, start_zip, end_zip):
        zip_int = int(self.zip_code)
        return start_zip <= zip_int <= end_zip


class Customer:
    def __init__(self, name, email, phone, address):
        self.name = name
        self.email = email
        self.phone = phone
        self.address = address  # Теперь это объект класса Address
    
    def get_full_name(self):
        return self.name
    
    def get_contact_info(self):
        return f"Email: {self.email}, Phone: {self.phone}"
    
    def get_address(self):
        return self.address.get_formatted_address()
    
    def format_address_for_shipping(self):
        return self.address.format_for_shipping(self.name)

# Использование
address = Address("123 Main St", "New York", "NY", "10001")
customer = Customer("John Doe", "john@example.com", "555-123-4567", address)
```

### Встраивание метода (Inline Method)

**Описание**: Замена вызова метода его содержимым, когда метод не упрощает код.

**Когда применять**:
- Метод слишком простой и его вызов не проясняет намерения
- Абстракция не добавляет ценности
- В результате предыдущих рефакторингов метод стал излишним
- Необходимо объединить несколько методов в один

**Пример до рефакторинга**:

```python
class Order:
    def __init__(self, items, customer):
        self.items = items
        self.customer = customer
    
    def get_total(self):
        return self.calculate_total()
    
    def calculate_total(self):
        total = 0
        for item in self.items:
            total += item.price * item.quantity
        return total
    
    def is_eligible_for_discount(self):
        return self.get_total() > 100
```

**Пример после рефакторинга**:

```python
class Order:
    def __init__(self, items, customer):
        self.items = items
        self.customer = customer
    
    def get_total(self):
        total = 0
        for item in self.items:
            total += item.price * item.quantity
        return total
    
    def is_eligible_for_discount(self):
        return self.get_total() > 100
```

### Замена условного выражения полиморфизмом (Replace Conditional with Polymorphism)

**Описание**: Замена сложного условного кода (switch/if-else) полиморфными вызовами, когда условие проверяет тип объекта или его свойства.

**Когда применять**:
- Есть условный оператор, который выбирает различное поведение в зависимости от типа объекта
- Код различных вариантов условия разрастается
- При добавлении нового типа нужно менять условный оператор

**Пример до рефакторинга**:

```python
class Employee:
    def __init__(self, name, employee_type, base_salary, hours_worked=0, sales=0):
        self.name = name
        self.employee_type = employee_type  # 'hourly', 'salaried', 'commissioned'
        self.base_salary = base_salary
        self.hours_worked = hours_worked
        self.sales = sales
    
    def calculate_pay(self):
        if self.employee_type == 'hourly':
            return self.hours_worked * self.base_salary
        elif self.employee_type == 'salaried':
            return self.base_salary
        elif self.employee_type == 'commissioned':
            return self.base_salary + (self.sales * 0.1)
        else:
            raise ValueError(f"Unknown employee type: {self.employee_type}")
```

**Пример после рефакторинга**:

```python
class Employee:
    def __init__(self, name):
        self.name = name
    
    def calculate_pay(self):
        raise NotImplementedError("Subclasses must implement calculate_pay")


class HourlyEmployee(Employee):
    def __init__(self, name, hourly_rate, hours_worked):
        super().__init__(name)
        self.hourly_rate = hourly_rate
        self.hours_worked = hours_worked
    
    def calculate_pay(self):
        return self.hours_worked * self.hourly_rate


class SalariedEmployee(Employee):
    def __init__(self, name, salary):
        super().__init__(name)
        self.salary = salary
    
    def calculate_pay(self):
        return self.salary


class CommissionedEmployee(Employee):
    def __init__(self, name, base_salary, sales):
        super().__init__(name)
        self.base_salary = base_salary
        self.sales = sales
    
    def calculate_pay(self):
        return self.base_salary + (self.sales * 0.1)
```

### Объединение функций в класс (Combine Functions into Class)

**Описание**: Объединение нескольких функций, работающих с одними и теми же данными, в класс, где эти данные становятся полями.

**Когда применять**:
- Несколько функций работают с одними и теми же данными
- Функции логически связаны между собой
- Данные и операции над ними образуют смысловую единицу

**Пример до рефакторинга**:

```python
def read_temperature_data(file_path):
    """Чтение данных о температуре из файла"""
    with open(file_path, 'r') as file:
        lines = file.readlines()
    
    data = []
    for line in lines:
        parts = line.strip().split(',')
        if len(parts) == 2:
            date = parts[0]
            temp = float(parts[1])
            data.append((date, temp))
    
    return data


def calculate_average_temperature(data):
    """Расчет средней температуры"""
    if not data:
        return 0
    
    total = sum(temp for _, temp in data)
    return total / len(data)


def find_highest_temperature(data):
    """Поиск максимальной температуры"""
    if not data:
        return (None, float('-inf'))
    
    return max(data, key=lambda x: x[1])


def find_lowest_temperature(data):
    """Поиск минимальной температуры"""
    if not data:
        return (None, float('inf'))
    
    return min(data, key=lambda x: x[1])


def generate_temperature_report(file_path):
    """Генерация отчета о температуре"""
    data = read_temperature_data(file_path)
    avg_temp = calculate_average_temperature(data)
    highest_date, highest_temp = find_highest_temperature(data)
    lowest_date, lowest_temp = find_lowest_temperature(data)
    
    report = f"Temperature Report\n"
    report += f"Average temperature: {avg_temp:.1f}°C\n"
    report += f"Highest temperature: {highest_temp:.1f}°C on {highest_date}\n"
    report += f"Lowest temperature: {lowest_temp:.1f}°C on {lowest_date}\n"
    
    return report
```

**Пример после рефакторинга**:

```python
class TemperatureAnalyzer:
    def __init__(self, file_path=None):
        self.data = []
        if file_path:
            self.read_data(file_path)
    
    def read_data(self, file_path):
        """Чтение данных о температуре из файла"""
        with open(file_path, 'r') as file:
            lines = file.readlines()
        
        self.data = []
        for line in lines:
            parts = line.strip().split(',')
            if len(parts) == 2:
                date = parts[0]
                temp = float(parts[1])
                self.data.append((date, temp))
    
    def calculate_average(self):
        """Расчет средней температуры"""
        if not self.data:
            return 0
        
        total = sum(temp for _, temp in self.data)
        return total / len(self.data)
    
    def find_highest(self):
        """Поиск максимальной температуры"""
        if not self.data:
            return (None, float('-inf'))
        
        return max(self.data, key=lambda x: x[1])
    
    def find_lowest(self):
        """Поиск минимальной температуры"""
        if not self.data:
            return (None, float('inf'))
        
        return min(self.data, key=lambda x: x[1])
    
    def generate_report(self):
        """Генерация отчета о температуре"""
        avg_temp = self.calculate_average()
        highest_date, highest_temp = self.find_highest()
        lowest_date, lowest_temp = self.find_lowest()
        
        report = f"Temperature Report\n"
        report += f"Average temperature: {avg_temp:.1f}°C\n"
        report += f"Highest temperature: {highest_temp:.1f}°C on {highest_date}\n"
        report += f"Lowest temperature: {lowest_temp:.1f}°C on {lowest_date}\n"
        
        return report

# Использование
analyzer = TemperatureAnalyzer('temperature_data.csv')
report = analyzer.generate_report()
print(report)
```

### Удаление промежуточных переменных (Remove Middle Man)

**Описание**: Когда класс просто делегирует большинство своих методов другому объекту, следует избавиться от промежуточного класса.

**Когда применять**:
- Класс только делегирует операции без добавления ценности
- Клиентам приходится вызывать множество простых делегирующих методов
- Чрезмерно большое количество методов просто перенаправляются другому объекту

**Пример до рефакторинга**:

```python
class Department:
    def __init__(self, name, manager):
        self.name = name
        self.manager = manager
    
    def get_name(self):
        return self.name
    
    def get_manager(self):
        return self.manager


class Employee:
    def __init__(self, name, department):
        self.name = name
        self.department = department
    
    def get_name(self):
        return self.name
    
    # Методы-делегаты, которые просто перенаправляют вызов
    def get_department_name(self):
        return self.department.get_name()
    
    def get_manager(self):
        return self.department.get_manager()
    
    def get_manager_name(self):
        return self.department.get_manager().get_name()


# Использование
manager = Employee("Jane Smith", None)
department = Department("Development", manager)
employee = Employee("John Doe", department)

# Клиентский код использует методы-делегаты
print(f"Employee: {employee.get_name()}")
print(f"Department: {employee.get_department_name()}")
print(f"Manager: {employee.get_manager_name()}")
```

**Пример после рефакторинга**:

```python
class Department:
    def __init__(self, name, manager):
        self.name = name
        self.manager = manager
    
    def get_name(self):
        return self.name
    
    def get_manager(self):
        return self.manager


class Employee:
    def __init__(self, name, department):
        self.name = name
        self.department = department
    
    def get_name(self):
        return self.name
    
    # Удаляем методы-делегаты и предоставляем прямой доступ к департаменту
    def get_department(self):
        return self.department


# Использование
manager = Employee("Jane Smith", None)
department = Department("Development", manager)
employee = Employee("John Doe", department)

# Клиентский код обращается напрямую к объектам
print(f"Employee: {employee.get_name()}")
print(f"Department: {employee.get_department().get_name()}")
print(f"Manager: {employee.get_department().get_manager().get_name()}")
```

### Замена параметра объектом (Introduce Parameter Object)

**Описание**: Замена группы параметров, которые часто используются вместе, одним объектом.

**Когда применять**:
- Функция имеет длинный список параметров
- Группа параметров часто встречается вместе в нескольких методах
- Параметры являются логически связанной группой

**Пример до рефакторинга**:

```python
def calculate_shipping(customer_name, customer_address, customer_city, customer_state, 
                      customer_zip, product_weight, product_dimensions, shipping_method):
    # Расчет стоимости доставки на основе адреса клиента,
    # характеристик продукта и метода доставки
    # ...
    return shipping_cost


def calculate_tax(customer_name, customer_address, customer_city, customer_state, 
                 customer_zip, order_total):
    # Расчет налога на основе адреса клиента и суммы заказа
    # ...
    return tax_amount


def format_shipping_label(customer_name, customer_address, customer_city, customer_state, 
                         customer_zip):
    # Форматирование почтовой этикетки
    # ...
    return shipping_label
```

**Пример после рефакторинга**:

```python
class Address:
    def __init__(self, name, address, city, state, zip_code):
        self.name = name
        self.address = address
        self.city = city
        self.state = state
        self.zip_code = zip_code


class ProductInfo:
    def __init__(self, weight, dimensions):
        self.weight = weight
        self.dimensions = dimensions


def calculate_shipping(customer_address, product_info, shipping_method):
    # Расчет стоимости доставки на основе адреса клиента,
    # характеристик продукта и метода доставки
    # ...
    return shipping_cost


def calculate_tax(customer_address, order_total):
    # Расчет налога на основе адреса клиента и суммы заказа
    # ...
    return tax_amount


def format_shipping_label(customer_address):
    # Форматирование почтовой этикетки
    # ...
    return shipping_label


# Использование
customer_address = Address("John Doe", "123 Main St", "New York", "NY", "10001")
product_info = ProductInfo(1.5, (10, 5, 2))

shipping_cost = calculate_shipping(customer_address, product_info, "express")
tax_amount = calculate_tax(customer_address, 99.99)
shipping_label = format_shipping_label(customer_address)
```

### Замена условного кода с защитными условиями (Replace Nested Conditional with Guard Clauses)

**Описание**: Замена вложенных условных выражений, затрудняющих понимание основного потока выполнения, защитными условиями, которые обрабатывают особые случаи и сразу возвращают результат.

**Когда применять**:
- Код содержит глубоко вложенные условные операторы
- Трудно определить нормальный поток выполнения
- Условия проверяют особые или необычные ситуации

**Пример до рефакторинга**:

```python
def calculate_pay(employee):
    result = 0
    if employee.is_active:
        if employee.hours_worked > 0:
            if employee.employee_type == 'hourly':
                if employee.hours_worked <= 40:
                    result = employee.hours_worked * employee.hourly_rate
                else:
                    regular_pay = 40 * employee.hourly_rate
                    overtime_pay = (employee.hours_worked - 40) * employee.hourly_rate * 1.5
                    result = regular_pay + overtime_pay
            elif employee.employee_type == 'salaried':
                result = employee.salary
            else:
                result = 0
        else:
            result = 0
    else:
        result = 0
    
    return result
```

**Пример после рефакторинга**:

```python
def calculate_pay(employee):
    # Защитные условия для обработки особых случаев
    if not employee.is_active:
        return 0
    
    if employee.hours_worked <= 0:
        return 0
    
    if employee.employee_type == 'hourly':
        if employee.hours_worked <= 40:
            return employee.hours_worked * employee.hourly_rate
        
        regular_pay = 40 * employee.hourly_rate
        overtime_pay = (employee.hours_worked - 40) * employee.hourly_rate * 1.5
        return regular_pay + overtime_pay
    
    if employee.employee_type == 'salaried':
        return employee.salary
    
    # Если ни одно из условий не сработало, возвращаем 0
    return 0
```

### Выделение интерфейса (Extract Interface)

**Описание**: Создание интерфейса, который определяет общий контракт для нескольких классов.

**Когда применять**:
- Несколько классов имеют общий набор методов
- Клиенты используют только определенную часть интерфейса класса
- Нужно определить общий контракт для набора классов

**Пример до рефакторинга**:

```python
class EmailSender:
    def __init__(self, smtp_server, username, password):
        self.smtp_server = smtp_server
        self.username = username
        self.password = password
    
    def send(self, to_address, subject, body):
        print(f"Sending email to {to_address} via SMTP")
        # Логика отправки email через SMTP
        return True


class SMSService:
    def __init__(self, api_key):
        self.api_key = api_key
    
    def send(self, phone_number, message):
        print(f"Sending SMS to {phone_number} via API")
        # Логика отправки SMS через API
        return True


class PushNotificationService:
    def __init__(self, app_id, api_key):
        self.app_id = app_id
        self.api_key = api_key
    
    def send(self, device_token, title, message):
        print(f"Sending push notification to device {device_token}")
        # Логика отправки push-уведомления
        return True


# Использование
email_sender = EmailSender("smtp.gmail.com", "user", "password")
sms_service = SMSService("api_key_123")
push_service = PushNotificationService("app_123", "push_api_key")

# Отправка уведомлений через разные сервисы
email_sender.send("user@example.com", "Hello", "This is an email message")
sms_service.send("+1234567890", "This is an SMS message")
push_service.send("device_token_123", "Notification", "This is a push notification")
```

**Пример после рефакторинга**:

```python
from abc import ABC, abstractmethod

# Выделяем интерфейс для всех типов уведомлений
class NotificationService(ABC):
    @abstractmethod
    def send_notification(self, recipient, subject, message):
        """Отправляет уведомление получателю"""
        pass


# Реализации интерфейса
class EmailService(NotificationService):
    def __init__(self, smtp_server, username, password):
        self.smtp_server = smtp_server
        self.username = username
        self.password = password
    
    def send_notification(self, recipient, subject, message):
        print(f"Sending email to {recipient} via SMTP")
        # Логика отправки email через SMTP
        return True


class SMSService(NotificationService):
    def __init__(self, api_key):
        self.api_key = api_key
    
    def send_notification(self, recipient, subject, message):
        print(f"Sending SMS to {recipient} via API")
        # Логика отправки SMS через API (игнорируем subject для SMS)
        return True


class PushNotificationService(NotificationService):
    def __init__(self, app_id, api_key):
        self.app_id = app_id
        self.api_key = api_key
    
    def send_notification(self, recipient, subject, message):
        print(f"Sending push notification to device {recipient}")
        # Логика отправки push-уведомления
        return True


# Код, работающий с унифицированным интерфейсом
def send_notification_to_user(user, notification_service, subject, message):
    """
    Отправляет уведомление пользователю через любой сервис уведомлений.
    
    Args:
        user: Пользователь (содержит email, телефон или device_token)
        notification_service: Сервис уведомлений, реализующий NotificationService
        subject: Тема уведомления
        message: Текст уведомления
    """
    if isinstance(notification_service, EmailService):
        recipient = user.email
    elif isinstance(notification_service, SMSService):
        recipient = user.phone
    elif isinstance(notification_service, PushNotificationService):
        recipient = user.device_token
    else:
        raise ValueError("Unsupported notification service")
    
    notification_service.send_notification(recipient, subject, message)


# Использование
email_service = EmailService("smtp.gmail.com", "user", "password")
sms_service = SMSService("api_key_123")
push_service = PushNotificationService("app_123", "push_api_key")

# Отправка уведомлений через разные сервисы
email_service.send_notification("user@example.com", "Hello", "This is an email message")
sms_service.send_notification("+1234567890", "Ignored", "This is an SMS message")
push_service.send_notification("device_token_123", "Notification", "This is a push notification")
```

### Замена наследования делегированием (Replace Inheritance with Delegation)

**Описание**: Замена наследования композицией, когда подкласс использует только часть интерфейса суперкласса или не разделяет его поведение, но хочет использовать его функциональность.

**Когда применять**:
- Подкласс использует не все методы суперкласса
- Подкласс нарушает принцип подстановки Лисков (LSP)
- Нужно изменить поведение, определенное в суперклассе
- Реальная связь между классами — это "имеет", а не "является"

**Пример до рефакторинга**:

```python
class Stack:
    def __init__(self):
        self.elements = []
    
    def push(self, element):
        self.elements.append(element)
    
    def pop(self):
        if not self.is_empty():
            return self.elements.pop()
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.elements[-1]
        return None
    
    def is_empty(self):
        return len(self.elements) == 0
    
    def size(self):
        return len(self.elements)
    
    def clear(self):
        self.elements = []


class StackWithLog(Stack):
    def __init__(self):
        super().__init__()
        self.log = []
    
    def push(self, element):
        self.log.append(f"Push: {element}")
        super().push(element)
    
    def pop(self):
        element = super().pop()
        if element is not None:
            self.log.append(f"Pop: {element}")
        return element
    
    def get_log(self):
        return self.log
```

**Пример после рефакторинга**:

```python
class Stack:
    def __init__(self):
        self.elements = []
    
    def push(self, element):
        self.elements.append(element)
    
    def pop(self):
        if not self.is_empty():
            return self.elements.pop()
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.elements[-1]
        return None
    
    def is_empty(self):
        return len(self.elements) == 0
    
    def size(self):
        return len(self.elements)
    
    def clear(self):
        self.elements = []


class StackWithLog:
    def __init__(self):
        self.stack = Stack()  # Делегирование вместо наследования
        self.log = []
    
    def push(self, element):
        self.log.append(f"Push: {element}")
        self.stack.push(element)
    
    def pop(self):
        element = self.stack.pop()
        if element is not None:
            self.log.append(f"Pop: {element}")
        return element
    
    def peek(self):
        return self.stack.peek()
    
    def is_empty(self):
        return self.stack.is_empty()
    
    def size(self):
        return self.stack.size()
    
    def clear(self):
        self.stack.clear()
        self.log.append("Clear")
    
    def get_log(self):
        return self.log
```

### Введение null-объекта (Introduce Null Object)

**Описание**: Замена проверки на null специальным Null-объектом, который реализует тот же интерфейс, что и основной объект, но с "пустой" реализацией.

**Когда применять**:
- Код содержит множество проверок на null
- Такие проверки разбросаны по разным местам
- Есть стандартное поведение, которое должно выполняться, когда объект равен null

**Пример до рефакторинга**:

```python
class Customer:
    def __init__(self, name, email, discount_rate):
        self.name = name
        self.email = email
        self.discount_rate = discount_rate
    
    def get_discount_rate(self):
        return self.discount_rate


class Order:
    def __init__(self, customer, items):
        self.customer = customer
        self.items = items
    
    def calculate_total(self):
        total = sum(item.price for item in self.items)
        
        # Проверка на null
        if self.customer is not None:
            discount = self.customer.get_discount_rate()
            total *= (1 - discount)
        
        return total
    
    def send_confirmation_email(self):
        # Проверка на null
        if self.customer is not None and self.customer.email is not None:
            print(f"Sending confirmation to {self.customer.email}")
        else:
            print("No email available")
    
    def generate_invoice(self):
        # Проверка на null
        customer_name = "Guest" if self.customer is None else self.customer.name
        
        invoice = f"Invoice for: {customer_name}\n"
        invoice += "Items:\n"
        
        for item in self.items:
            invoice += f"- {item.name}: ${item.price}\n"
        
        return invoice
```

**Пример после рефакторинга**:

```python
class Customer:
    def __init__(self, name, email, discount_rate):
        self.name = name
        self.email = email
        self.discount_rate = discount_rate
    
    def get_discount_rate(self):
        return self.discount_rate
    
    def get_email(self):
        return self.email
    
    def get_name(self):
        return self.name


class NullCustomer(Customer):
    def __init__(self):
        # Вызываем конструктор базового класса с нулевыми значениями
        super().__init__("Guest", None, 0)
    
    def get_discount_rate(self):
        return 0
    
    def get_email(self):
        return None
    
    def get_name(self):
        return "Guest"
    
    # Метод для проверки, является ли объект null-объектом
    def is_null(self):
        return True


# Дополняем базовый класс методом is_null()
def Customer_is_null(self):
    return False

Customer.is_null = Customer_is_null


class Order:
    def __init__(self, customer, items):
        # Используем Null Object Pattern
        self.customer = customer if customer is not None else NullCustomer()
        self.items = items
    
    def calculate_total(self):
        total = sum(item.price for item in self.items)
        
        # Больше не нужно проверять на null
        discount = self.customer.get_discount_rate()
        total *= (1 - discount)
        
        return total
    
    def send_confirmation_email(self):
        # Проверяем только наличие email, а не объекта customer
        email = self.customer.get_email()
        if email is not None:
            print(f"Sending confirmation to {email}")
        else:
            print("No email available")
    
    def generate_invoice(self):
        # Больше не нужно проверять на null
        invoice = f"Invoice for: {self.customer.get_name()}\n"
        invoice += "Items:\n"
        
        for item in self.items:
            invoice += f"- {item.name}: ${item.price}\n"
        
        return invoice
```

### Декомпозиция условного выражения (Decompose Conditional)

**Описание**: Разбиение сложного условного выражения на отдельные осмысленные части, каждая из которых имеет понятное название.

**Когда применять**:
- Условное выражение стало слишком сложным и трудночитаемым
- Условие содержит сложную логику, которую можно выделить и именовать
- Одно и то же условие встречается в нескольких местах кода

**Пример до рефакторинга**:

```python
def calculate_charge(date, quantity, plan):
    charge = 0
    
    if (date.month < 6 or date.month > 8) and plan == "winter" and quantity > 100:
        # Зимний план со скидкой за большой объем вне летнего сезона
        charge = quantity * 0.6
    else:
        if date.month >= 6 and date.month <= 8 and plan == "summer" and quantity <= 100:
            # Летний план с наценкой за небольшой объем в летний сезон
            charge = quantity * 0.9
        else:
            # Стандартный тариф
            charge = quantity * 0.75
    
    return charge
```

**Пример после рефакторинга**:

```python
def is_winter_season(date):
    """Проверяет, является ли дата зимним сезоном (не летом)"""
    return date.month < 6 or date.month > 8

def is_summer_season(date):
    """Проверяет, является ли дата летним сезоном"""
    return date.month >= 6 and date.month <= 8

def is_high_quantity(quantity):
    """Проверяет, является ли количество большим"""
    return quantity > 100

def is_low_quantity(quantity):
    """Проверяет, является ли количество малым"""
    return quantity <= 100

def is_winter_plan(plan):
    """Проверяет, является ли план зимним"""
    return plan == "winter"

def is_summer_plan(plan):
    """Проверяет, является ли план летним"""
    return plan == "summer"

def calculate_charge(date, quantity, plan):
    if is_winter_season(date) and is_winter_plan(plan) and is_high_quantity(quantity):
        return calculate_winter_high_volume_charge(quantity)
    
    if is_summer_season(date) and is_summer_plan(plan) and is_low_quantity(quantity):
        return calculate_summer_low_volume_charge(quantity)
    
    return calculate_standard_charge(quantity)

def calculate_winter_high_volume_charge(quantity):
    """Рассчитывает стоимость для зимнего плана с большим объемом"""
    return quantity * 0.6

def calculate_summer_low_volume_charge(quantity):
    """Рассчитывает стоимость для летнего плана с малым объемом"""
    return quantity * 0.9

def calculate_standard_charge(quantity):
    """Рассчитывает стандартную стоимость"""
    return quantity * 0.75
```

### Переименование метода/переменной (Rename Method/Variable)

**Описание**: Изменение имени метода или переменной, чтобы оно лучше отражало их назначение.

**Когда применять**:
- Имя не отражает назначение метода/переменной
- Имя слишком длинное, короткое или неясное
- Следование соглашениям об именовании в проекте требует изменения

**Пример до рефакторинга**:

```python
def calc(a, b, op):
    """
    Выполняет математическую операцию
    
    Args:
        a: Первый операнд
        b: Второй операнд
        op: Операция ("+", "-", "*", "/")
    """
    if op == "+":
        return a + b
    elif op == "-":
        return a - b
    elif op == "*":
        return a * b
    elif op == "/":
        if b != 0:
            return a / b
        else:
            raise ValueError("Division by zero")
    else:
        raise ValueError("Unknown operation")


def get_emp_data(id):
    """Получает данные сотрудника по ID"""
    # ...получение данных сотрудника...
    return {"nm": "John Smith", "sal": 50000, "dept": "Engineering"}


class Usr:
    def __init__(self, n, e, pwd):
        self.n = n  # имя
        self.e = e  # email
        self.pwd = pwd  # пароль
    
    def v_pwd(self, p):
        """Проверяет, совпадает ли пароль"""
        return self.pwd == p
    
    def ch_pwd(self, new_p):
        """Изменяет пароль"""
        self.pwd = new_p
    
    def get_fn(self):
        """Возвращает полное имя"""
        return self.n
```

**Пример после рефакторинга**:

```python
def calculate_operation(first_operand, second_operand, operation):
    """
    Выполняет математическую операцию
    
    Args:
        first_operand: Первый операнд
        second_operand: Второй операнд
        operation: Операция ("+", "-", "*", "/")
    """
    if operation == "+":
        return first_operand + second_operand
    elif operation == "-":
        return first_operand - second_operand
    elif operation == "*":
        return first_operand * second_operand
    elif operation == "/":
        if second_operand != 0:
            return first_operand / second_operand
        else:
            raise ValueError("Division by zero")
    else:
        raise ValueError("Unknown operation")


def get_employee_data(employee_id):
    """Получает данные сотрудника по ID"""
    # ...получение данных сотрудника...
    return {"name": "John Smith", "salary": 50000, "department": "Engineering"}


class User:
    def __init__(self, name, email, password):
        self.name = name
        self.email = email
        self.password = password
    
    def verify_password(self, password_attempt):
        """Проверяет, совпадает ли пароль"""
        return self.password == password_attempt
    
    def change_password(self, new_password):
        """Изменяет пароль"""
        self.password = new_password
    
    def get_full_name(self):
        """Возвращает полное имя"""
        return self.name
```

## Стратегии внедрения паттернов в существующий код

Внедрение паттернов проектирования в существующий код — процесс, требующий аккуратного подхода, чтобы не нарушить работоспособность системы. Рассмотрим несколько стратегий, которые помогают безопасно и эффективно внедрять паттерны проектирования.

### Стратегия постепенной миграции

**Описание**: Вместо полной переработки кода, изменения вносятся постепенно, с сохранением обратной совместимости.

**Основные шаги**:
1. Идентифицировать код, который нуждается в рефакторинге
2. Создать новые классы/интерфейсы согласно выбранному паттерну
3. Создать адаптеры между старым и новым кодом
4. Постепенно перевести клиентский код на использование нового интерфейса
5. Удалить старую реализацию, когда она больше не используется

**Пример**:

Предположим, у нас есть класс для работы с файлами, который мы хотим переработать с использованием паттерна Стратегия:

```python
# Исходный код
class FileProcessor:
    def process_file(self, file_path, format_type):
        if format_type == "csv":
            # Обработка CSV-файла
            print(f"Processing CSV file: {file_path}")
            # ... логика обработки CSV
        elif format_type == "json":
            # Обработка JSON-файла
            print(f"Processing JSON file: {file_path}")
            # ... логика обработки JSON
        elif format_type == "xml":
            # Обработка XML-файла
            print(f"Processing XML file: {file_path}")
            # ... логика обработки XML
        else:
            raise ValueError(f"Unsupported format: {format_type}")
```

**Шаг 1**: Создаем новые классы с паттерном Стратегия:

```python
# Новый код с паттерном Стратегия
from abc import ABC, abstractmethod

class FileProcessingStrategy(ABC):
    @abstractmethod
    def process(self, file_path):
        pass

class CSVProcessingStrategy(FileProcessingStrategy):
    def process(self, file_path):
        print(f"Processing CSV file: {file_path}")
        # ... логика обработки CSV

class JSONProcessingStrategy(FileProcessingStrategy):
    def process(self, file_path):
        print(f"Processing JSON file: {file_path}")
        # ... логика обработки JSON

class XMLProcessingStrategy(FileProcessingStrategy):
    def process(self, file_path):
        print(f"Processing XML file: {file_path}")
        # ... логика обработки XML

class NewFileProcessor:
    def __init__(self, strategy=None):
        self.strategy = strategy
    
    def set_strategy(self, strategy):
        self.strategy = strategy
    
    def process_file(self, file_path):
        if self.strategy is None:
            raise ValueError("No processing strategy set")
        return self.strategy.process(file_path)
```

**Шаг 2**: Создаем адаптер для сохранения обратной совместимости:

```python
class FileProcessorAdapter:
    def __init__(self):
        self.new_processor = NewFileProcessor()
        # Словарь для маппинга строковых форматов к стратегиям
        self.format_strategies = {
            "csv": CSVProcessingStrategy(),
            "json": JSONProcessingStrategy(),
            "xml": XMLProcessingStrategy()
        }
    
    def process_file(self, file_path, format_type):
        """
        Адаптер, сохраняющий старый интерфейс для обратной совместимости
        """
        if format_type not in self.format_strategies:
            raise ValueError(f"Unsupported format: {format_type}")
        
        strategy = self.format_strategies[format_type]
        self.new_processor.set_strategy(strategy)
        return self.new_processor.process_file(file_path)
```

**Шаг 3**: Обновляем исходный класс для использования адаптера:

```python
class FileProcessor:
    def __init__(self):
        self.adapter = FileProcessorAdapter()
    
    def process_file(self, file_path, format_type):
        """
        Сохраняем старый интерфейс, но делегируем работу адаптеру
        """
        return self.adapter.process_file(file_path, format_type)
```

**Шаг 4**: Поощряем клиентский код к переходу на новый интерфейс, документируя устаревшие методы:

```python
class FileProcessor:
    def __init__(self):
        self.adapter = FileProcessorAdapter()
        self.new_processor = NewFileProcessor()
    
    def process_file(self, file_path, format_type):
        """
        УСТАРЕВШИЙ МЕТОД: Используйте get_processor() и соответствующую стратегию.
        
        Будет удален в версии 2.0.
        """
        import warnings
        warnings.warn("This method is deprecated. Use get_processor() instead.", DeprecationWarning, stacklevel=2)
        return self.adapter.process_file(file_path, format_type)
    
    def get_processor(self):
        """
        Возвращает экземпляр нового процессора, который следует использовать
        с соответствующей стратегией.
        """
        return self.new_processor
    
    # Методы-помощники для удобства
    def get_csv_strategy(self):
        return CSVProcessingStrategy()
    
    def get_json_strategy(self):
        return JSONProcessingStrategy()
    
    def get_xml_strategy(self):
        return XMLProcessingStrategy()
```

### Применение паттерна Strangler (Удушение)

**Описание**: Метод "удушения" старого кода новым, где новая система постепенно "обвивает" старую, перехватывая всё больше функциональности, пока старая система не становится лишней и может быть полностью удалена.

**Основные шаги**:
1. Создать фасад перед старой системой
2. Постепенно перехватывать вызовы функциональности и направлять их на новую реализацию
3. Увеличивать объем перехватываемой функциональности
4. Удалить оригинальную систему, когда она полностью замещена

**Пример**:

Предположим, у нас есть старая система аутентификации, которую мы хотим заменить на новую с использованием паттерна Стратегия для поддержки разных методов аутентификации:

```python
# Старая система аутентификации
class LegacyAuthentication:
    def __init__(self, database_connection):
        self.db = database_connection
    
    def authenticate(self, username, password):
        # Простая аутентификация по паролю из базы данных
        stored_user = self.db.find_user(username)
        if stored_user and stored_user['password'] == password:
            return True
        return False
    
    def authorize(self, username, resource):
        # Проверка доступа к ресурсу
        user_roles = self.db.get_user_roles(username)
        resource_permissions = self.db.get_resource_permissions(resource)
        
        for role in user_roles:
            if role in resource_permissions:
                return True
        
        return False
```

**Шаг 1**: Создать фасад и новую систему:

```python
from abc import ABC, abstractmethod

# Определение интерфейсов для новой системы
class AuthenticationMethod(ABC):
    @abstractmethod
    def authenticate(self, credentials):
        pass

class PasswordAuthentication(AuthenticationMethod):
    def __init__(self, database_connection):
        self.db = database_connection
    
    def authenticate(self, credentials):
        username = credentials.get('username')
        password = credentials.get('password')
        
        if not username or not password:
            return False
        
        stored_user = self.db.find_user(username)
        if stored_user and stored_user['password'] == password:
            return True
        return False

class OAuthAuthentication(AuthenticationMethod):
    def __init__(self, oauth_provider):
        self.provider = oauth_provider
    
    def authenticate(self, credentials):
        token = credentials.get('token')
        if not token:
            return False
        
        # Проверка токена через провайдера OAuth
        return self.provider.verify_token(token)

# Новая система аутентификации
class NewAuthenticationSystem:
    def __init__(self, auth_method):
        self.auth_method = auth_method
    
    def set_auth_method(self, auth_method):
        self.auth_method = auth_method
    
    def authenticate(self, credentials):
        return self.auth_method.authenticate(credentials)
    
    def authorize(self, user_id, resource):
        # Новая логика авторизации
        pass

# Фасад для обеих систем
class AuthenticationFacade:
    def __init__(self, legacy_system, new_system, use_new_system_percentage=0):
        self.legacy_system = legacy_system
        self.new_system = new_system
        self.use_new_system_percentage = use_new_system_percentage
    
    def set_new_system_usage(self, percentage):
        """Устанавливает процент использования новой системы"""
        self.use_new_system_percentage = max(0, min(100, percentage))
    
    def authenticate(self, credentials):
        """
        Аутентифицирует пользователя, используя старую или новую систему
        в зависимости от настроенного процента использования.
        """
        import random
        
        # Решаем, какую систему использовать на основе случайного числа и процента
        use_new = random.random() * 100 < self.use_new_system_percentage
        
        if use_new:
            print("Using new authentication system")
            return self.new_system.authenticate(credentials)
        else:
            print("Using legacy authentication system")
            username = credentials.get('username')
            password = credentials.get('password')
            return self.legacy_system.authenticate(username, password)
    
    def authorize(self, user_info, resource):
        """
        Выполняет авторизацию, используя преимущественно старую систему,
        пока новая не будет полностью готова.
        """
        # В этом примере продолжаем использовать только старую систему для авторизации
        username = user_info.get('username')
        return self.legacy_system.authorize(username, resource)
```

**Шаг 2**: Постепенное увеличение использования новой системы:

```python
# Начальная настройка
legacy_auth = LegacyAuthentication(database_connection)
password_auth = PasswordAuthentication(database_connection)
new_auth = NewAuthenticationSystem(password_auth)

# Создаем фасад с начальным использованием новой системы 10%
auth_facade = AuthenticationFacade(legacy_auth, new_auth, 10)

# Со временем увеличиваем использование новой системы
# Например, через месяц:
auth_facade.set_new_system_usage(30)

# Через два месяца:
auth_facade.set_new_system_usage(60)

# После тщательного тестирования:
auth_facade.set_new_system_usage(100)
```

**Шаг 3**: Завершение миграции — полный переход на новую систему:

```python
# После полной миграции можно отказаться от фасада и напрямую использовать новую систему
def migrate_to_new_system():
    global auth_system
    
    # Проверяем, что фасад настроен на 100% использование новой системы
    if auth_facade.use_new_system_percentage == 100:
        # Заменяем глобальную ссылку на систему аутентификации
        auth_system = new_auth
        print("Migration complete - now using new authentication system directly")
    else:
        print("Cannot complete migration - still using legacy system partially")
```

### Использование Branch By Abstraction

**Описание**: Техника, позволяющая разработчикам изменять большие части кода постепенно, сохраняя возможность системы работать на всем протяжении изменений.

**Основные шаги**:
1. Создать абстракцию, скрывающую различия между старой и новой реализацией
2. Перевести все клиентские вызовы на использование этой абстракции
3. Создать новую реализацию абстракции
4. Постепенно переключить часть вызовов на новую реализацию и проверить работоспособность
5. Полностью переключиться на новую реализацию
6. Удалить старую реализацию, когда она больше не используется

**Пример**:

Предположим, у нас есть система обработки платежей, которую мы хотим перевести с использования устаревшего API на новый облачный провайдер:

```python
# Оригинальный код, напрямую использующий старый API
class PaymentProcessor:
    def __init__(self, api_key):
        self.api_key = api_key
    
    def charge_customer(self, customer_id, amount, description):
        # Прямой вызов устаревшего API
        return legacy_payment_api.create_charge(
            api_key=self.api_key,
            customer=customer_id,
            amount=amount,
            description=description
        )
    
    def create_refund(self, charge_id, amount=None):
        # Прямой вызов устаревшего API
        return legacy_payment_api.refund_charge(
            api_key=self.api_key,
            charge_id=charge_id,
            amount=amount
        )
```

**Шаг 1**: Создаем абстракцию:

```python
from abc import ABC, abstractmethod

# Абстракция для обработки платежей
class PaymentService(ABC):
    @abstractmethod
    def charge(self, customer_id, amount, description):
        pass
    
    @abstractmethod
    def refund(self, charge_id, amount=None):
        pass


# Реализация для старого API
class LegacyPaymentService(PaymentService):
    def __init__(self, api_key):
        self.api_key = api_key
    
    def charge(self, customer_id, amount, description):
        return legacy_payment_api.create_charge(
            api_key=self.api_key,
            customer=customer_id,
            amount=amount,
            description=description
        )
    
    def refund(self, charge_id, amount=None):
        return legacy_payment_api.refund_charge(
            api_key=self.api_key,
            charge_id=charge_id,
            amount=amount
        )


# Реализация для нового API (будет реализована позже)
class CloudPaymentService(PaymentService):
    def __init__(self, api_key):
        self.api_key = api_key
    
    def charge(self, customer_id, amount, description):
        # Временная заглушка
        raise NotImplementedError("Cloud payment service not yet implemented")
    
    def refund(self, charge_id, amount=None):
        # Временная заглушка
        raise NotImplementedError("Cloud payment service not yet implemented")
```

**Шаг 2**: Обновляем ProcessorPayment для использования абстракции:

```python
class PaymentProcessor:
    def __init__(self, payment_service):
        self.payment_service = payment_service
    
    def charge_customer(self, customer_id, amount, description):
        return self.payment_service.charge(customer_id, amount, description)
    
    def create_refund(self, charge_id, amount=None):
        return self.payment_service.refund(charge_id, amount)
```

**Шаг 3**: Реализуем новую службу платежей:

```python
class CloudPaymentService(PaymentService):
    def __init__(self, api_key):
        self.api_key = api_key
        self.client = cloud_payment_sdk.Client(api_key)
    
    def charge(self, customer_id, amount, description):
        response = self.client.payments.create({
            'customer': customer_id,
            'amount': amount,
            'currency': 'usd',
            'description': description,
        })
        return {
            'id': response.id,
            'status': response.status,
            'amount': response.amount,
        }
    
    def refund(self, charge_id, amount=None):
        refund_params = {'payment': charge_id}
        if amount is not None:
            refund_params['amount'] = amount
        
        response = self.client.refunds.create(refund_params)
        return {
            'id': response.id,
            'status': response.status,
            'amount': response.amount,
        }
```

**Шаг 4**: Постепенно переключаем часть вызовов:

```python
class PaymentServiceFactory:
    """Фабрика для создания сервисов платежей с возможностью переключения"""
    
    def __init__(self, legacy_api_key, cloud_api_key, use_cloud_percent=0):
        self.legacy_api_key = legacy_api_key
        self.cloud_api_key = cloud_api_key
        self.use_cloud_percent = use_cloud_percent
    
    def create_payment_service(self, customer_id=None):
        """
        Создает сервис платежей, используя старый или новый API
        в зависимости от настроек и, возможно, от клиента.
        """
        import random
        
        # Возможно добавить логику для конкретных клиентов
        # Например, определенные тестовые клиенты всегда используют новый API
        test_customers = ["test_customer_1", "test_customer_2"]
        if customer_id in test_customers:
            return CloudPaymentService(self.cloud_api_key)
        
        # Для остальных клиентов используем случайный выбор на основе процентов
        use_cloud = random.random() * 100 < self.use_cloud_percent
        
        if use_cloud:
            return CloudPaymentService(self.cloud_api_key)
        else:
            return LegacyPaymentService(self.legacy_api_key)
```

**Шаг 5**: Полностью переключаемся на новую реализацию:

```python
# После тщательного тестирования и уверенности в новом API
factory.use_cloud_percent = 100

# Затем можно упростить фабрику
class PaymentServiceFactory:
    def __init__(self, cloud_api_key):
        self.cloud_api_key = cloud_api_key
    
    def create_payment_service(self, customer_id=None):
        return CloudPaymentService(self.cloud_api_key)
```

**Шаг 6**: Удаляем старый код, когда он больше не используется:

Удаляем `LegacyPaymentService` и связанный с ним код, так как он больше не используется.

### Рефакторинг с использованием Feature Toggles

**Описание**: Использование переключателей функциональности (feature toggles) для включения/отключения нового кода в процессе его разработки и внедрения.

**Основные шаги**:
1. Определить, какой функционал будет переключаться
2. Создать систему переключателей (Feature Toggle Service)
3. Обернуть обновляемый функционал условными операторами с переключателями
4. Постепенно разрабатывать и тестировать новый функционал
5. Включать новый функционал для всё большего числа пользователей
6. Удалить переключатели и старый код после полного перехода

**Пример**:

Предположим, мы хотим обновить систему рекомендаций продуктов, внедрив в неё машинное обучение:

```python
# Сервис переключателей функциональности
class FeatureToggleService:
    def __init__(self, config_source):
        self.config = config_source
        self.local_overrides = {}
    
    def is_enabled(self, feature_name, context=None):
        """
        Проверяет, включена ли определенная функция.
        
        Args:
            feature_name: Имя функции
            context: Дополнительный контекст (пользователь, окружение и т.д.)
            
        Returns:
            bool: True, если функция включена, иначе False
        """
        # Проверяем локальные переопределения
        if feature_name in self.local_overrides:
            return self.local_overrides[feature_name]
        
        # Проверяем конфигурацию
        if feature_name not in self.config:
            return False
        
        feature_config = self.config[feature_name]
        
        # Простое включение/выключение
        if isinstance(feature_config, bool):
            return feature_config
        
        # Процентное включение
        if 'percentage' in feature_config:
            import random
            return random.random() * 100 < feature_config['percentage']
        
        # Включение для определенных пользователей
        if 'users' in feature_config and context and 'user_id' in context:
            return context['user_id'] in feature_config['users']
        
        # По умолчанию выключено
        return False
    
    def set_override(self, feature_name, enabled):
        """Устанавливает локальное переопределение для функции"""
        self.local_overrides[feature_name] = enabled


# Класс рекомендательной системы с переключателями функциональности
class ProductRecommender:
    def __init__(self, feature_toggle_service):
        self.feature_toggles = feature_toggle_service
        
        # Инициализация старого рекомендательного движка
        self.legacy_recommender = LegacyRecommendationEngine()
        
        # Ленивая инициализация ML-движка, только если он будет использоваться
        self.ml_recommender = None
    
    def _get_ml_recommender(self):
        """Ленивая инициализация ML-рекомендательного движка"""
        if self.ml_recommender is None:
            print("Initializing ML recommendation engine...")
            self.ml_recommender = MLRecommendationEngine()
        return self.ml_recommender
    
    def get_recommendations(self, user_id, product_id, limit=5):
        """Получает рекомендации продуктов для пользователя"""
        # Проверяем, включена ли новая ML-система рекомендаций
        context = {'user_id': user_id}
        use_ml = self.feature_toggles.is_enabled('ml_recommendations', context)
        
        if use_ml:
            print(f"Using ML recommendations for user {user_id}")
            return self._get_ml_recommender().get_recommendations(user_id, product_id, limit)
        else:
            print(f"Using legacy recommendations for user {user_id}")
            return self.legacy_recommender.get_recommendations(user_id, product_id, limit)


# Старая система рекомендаций
class LegacyRecommendationEngine:
    def get_recommendations(self, user_id, product_id, limit=5):
        # Простая логика рекомендаций на основе категорий и популярности
        print("Using category-based recommendations")
        # ... реализация ...
        return ["product1", "product2", "product3", "product4", "product5"]


# Новая ML-система рекомендаций
class MLRecommendationEngine:
    def __init__(self):
        # Инициализация ML-модели может быть дорогостоящей,
        # поэтому мы используем ленивую инициализацию
        print("Loading ML model...")
        # ... загрузка модели ...
    
    def get_recommendations(self, user_id, product_id, limit=5):
        # Сложная логика на основе машинного обучения
        print("Using ML-based recommendations")
        # ... реализация ...
        return ["ml_product1", "ml_product2", "ml_product3", "ml_product4", "ml_product5"]


# Пример использования
# Конфигурация переключателей
feature_config = {
    'ml_recommendations': {
        'percentage': 20,  # Включено для 20% запросов
        'users': ['test_user_1', 'test_user_2', 'vip_user_1']  # Всегда включено для тестовых пользователей
    }
}

# Создание сервиса переключателей и рекомендательной системы
toggle_service = FeatureToggleService(feature_config)
recommender = ProductRecommender(toggle_service)

# Получение рекомендаций для разных пользователей
recommendations1 = recommender.get_recommendations('regular_user', 'product123')
recommendations2 = recommender.get_recommendations('test_user_1', 'product123')

# Постепенное увеличение процента пользователей с новой функциональностью
feature_config['ml_recommendations']['percentage'] = 50  # Увеличиваем до 50%

# После полного тестирования и уверенности в новой системе
feature_config['ml_recommendations'] = True  # Включаем для всех пользователей
```

После полного внедрения новой системы, переключатели можно удалить:

```python
class ProductRecommender:
    def __init__(self):
        self.recommender = MLRecommendationEngine()
    
    def get_recommendations(self, user_id, product_id, limit=5):
        """Получает рекомендации продуктов для пользователя"""
        return self.recommender.get_recommendations(user_id, product_id, limit)
```

## Заключение

Антипаттерны и рефакторинг — важные аспекты инженерии программного обеспечения. Распознавание антипаттернов и плохого кода позволяет выявить потенциальные проблемы в дизайне и реализации приложений. Рефакторинг предлагает набор техник для улучшения структуры кода без изменения его внешнего поведения.

Стратегии внедрения паттернов в существующий код дают возможность постепенно улучшать архитектуру системы, не нарушая её работоспособность. Эти методы особенно важны в корпоративной среде, где изменения должны вноситься с минимальным риском.

Ключевые выводы:
1. Регулярно анализируйте код на наличие антипаттернов и "запахов"
2. Применяйте рефакторинг малыми, управляемыми шагами
3. Поддерживайте полное покрытие тестами для безопасного рефакторинга
4. Используйте подходящие стратегии для внедрения паттернов в существующий код
5. Документируйте причины рефакторинга и внедрения паттернов
6. Помните, что паттерны — это инструменты, а не самоцель; применяйте их там, где они действительно решают проблемы

Понимание антипаттернов и владение техниками рефакторинга — важные навыки для любого разработчика, стремящегося создавать качественное программное обеспечение.