# Шаблон Active Object (Активный объект)

## Описание
Active Object — это паттерн, отделяющий вызов метода от его выполнения: клиент формирует запрос и кладёт его в очередь, а отдельный поток-исполнитель обрабатывает его асинхронно.

## Проблема
Непосредственный вызов ресурсоёмких или блокирующих операций блокирует вызывающий поток, усложняет синхронизацию и ухудшает отзывчивость, особенно в UI или сетевых приложениях.

## Решение
Active Object вводит интерфейс-прокси (Proxy), который принимает запросы от клиента и помещает их в очередь (Request Queue). Отдельный поток (Scheduler/Executor) извлекает запросы, передаёт их реальному объекту (Servant) для выполнения и возвращает результаты через Future или callback.

## Структура
1. **Proxy** — интерфейс для клиентов, создающий и отправляющий запросы в очередь.
2. **Request Queue** — буфер для запросов на выполнение.
3. **Scheduler / Executor** — извлекает запросы и запускает их выполнение.
4. **Servant** — реальный объект, содержащий бизнес-логику.
5. **Future / Result** — механизм передачи результатов асинхронного выполнения клиенту.

## Пример на Python
```python
import threading
import queue

class ActiveObject:
    def __init__(self):
        self._tasks = queue.Queue()
        threading.Thread(target=self._run, daemon=True).start()

    def _run(self):
        while True:
            func, args, future = self._tasks.get()
            try:
                result = func(*args)
                future['result'] = result
            except Exception as e:
                future['exception'] = e

    def submit(self, func, *args):
        future = {}
        self._tasks.put((func, args, future))
        return future

# Использование

def heavy_task(x, y):
    return x + y

ao = ActiveObject()
fut = ao.submit(heavy_task, 2, 3)
# ... другой код не блокируется
print("Результат:", fut.get('result'))
```

## Применение
- GUI-приложения для нен блокирования интерфейса
- Сетевые Клиенты/Сервера для фоновой обработки запросов
- Распределённые системы для асинхронных вызовов

## Плюсы
1. Асинхронность без явных блокировок клиента
2. Отделение интерфейса от логики исполнения
3. Улучшенная отзывчивость системы
4. Возможность горизонтального масштабирования очередей

## Минусы
1. Сложность обработки ошибок и исключений
2. Риск переполнения очереди при высоком обороте
3. Дополнительная задержка от постановки в очередь до выполнения

## Когда использовать
- Когда метод может блокировать вызывающий поток
- Для реализации асинхронных API в однопоточных средах (UI)
- При необходимости фоновой обработки долгих задач

