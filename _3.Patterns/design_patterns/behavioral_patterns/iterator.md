# Паттерн Iterator (Итератор)

## Описание
Итератор — это поведенческий паттерн проектирования, который позволяет последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления. Клиентский код может перебирать элементы разных коллекций единым способом.

## Проблема
Необходимость предоставить способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннюю структуру и реализацию. При этом нужно гарантировать, что код клиента не будет зависеть от конкретных классов коллекций.

## Решение
Паттерн Итератор выносит поведение обхода коллекции в отдельный объект, который называется итератором. Этот объект отслеживает текущее положение в обходе и знает, какие элементы уже были пройдены, а какие — нет.

## Структура
- **Iterator** — интерфейс, определяющий методы для доступа и обхода элементов
- **ConcreteIterator** — конкретная реализация итератора для определенной коллекции
- **Aggregate** — интерфейс, объявляющий фабричный метод для создания итератора
- **ConcreteAggregate** — конкретная коллекция, создающая экземпляр итератора

## Пример на Python

```python
from abc import ABC, abstractmethod
from typing import Any, List

# Iterator
class Iterator(ABC):
    @abstractmethod
    def has_next(self) -> bool:
        pass
    
    @abstractmethod
    def next(self) -> Any:
        pass

# ConcreteIterator
class ConcreteIterator(Iterator):
    def __init__(self, collection: List[Any]):
        self._collection = collection
        self._position = 0
    
    def has_next(self) -> bool:
        return self._position < len(self._collection)
    
    def next(self) -> Any:
        if self.has_next():
            value = self._collection[self._position]
            self._position += 1
            return value
        return None

# Aggregate
class Aggregate(ABC):
    @abstractmethod
    def create_iterator(self) -> Iterator:
        pass

# ConcreteAggregate
class ConcreteAggregate(Aggregate):
    def __init__(self):
        self._items: List[Any] = []
    
    def add_item(self, item: Any) -> None:
        self._items.append(item)
    
    def create_iterator(self) -> Iterator:
        return ConcreteIterator(self._items)
```

## Применение
В Python итераторы являются стандартным механизмом, встроенным в язык. Протокол итератора включает методы `__iter__()` и `__next__()`, что делает объекты совместимыми с циклом `for`. В реальных приложениях Итератор часто используется для:

- Обхода сложных структур данных (деревья, графы)
- Предоставления единообразного интерфейса для обхода различных структур данных
- Реализации ленивых вычислений (получение элементов по мере необходимости)
- Работы с большими наборами данных, которые нельзя загрузить в память целиком
- Реализации пагинации

## Плюсы
1. Упрощает интерфейс коллекции, перенося функциональность обхода в отдельный класс
2. Позволяет использовать несколько разных итераторов для одной коллекции
3. Позволяет создавать новые способы обхода, не изменяя код коллекции
4. Обеспечивает единый способ обхода различных структур данных
5. Реализует принцип единственной ответственности (SRP)

## Минусы
1. Не всегда оправдан для простых коллекций
2. Может излишне усложнить код, если требуется только один способ обхода
3. Требует дополнительных классов и увеличивает объем кода
4. Итераторы могут стать неактуальными, если структура коллекции изменится

## Когда использовать
- Когда коллекция имеет сложную внутреннюю структуру, но вы хотите скрыть её от клиентов
- Когда нужно предоставить несколько способов обхода одной и той же коллекции
- Когда нужен единый интерфейс для обхода различных структур данных
- Когда нужна возможность приостанавливать и возобновлять обход коллекции