# Парадигмы решения алгоритмических задач

В этом разделе мы рассмотрим основные парадигмы алгоритмов — ключевые подходы к решению алгоритмических задач. Эти стратегии помогут вам структурировать мышление при столкновении с новыми проблемами.

## 1. Разделяй и властвуй (Divide and Conquer)

Подход "разделяй и властвуй" разбивает задачу на меньшие подзадачи того же типа, решает каждую подзадачу отдельно, а затем объединяет результаты.

### Ключевые шаги:
1. **Разделение**: Разбить задачу на подзадачи
2. **Решение**: Решить каждую подзадачу рекурсивно
3. **Объединение**: Скомбинировать решения подзадач в решение исходной задачи

### Пример: Сортировка слиянием

```python
def merge_sort(arr):
    # Базовый случай: список из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Разделение: находим середину и разделяем массив
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # Решение: рекурсивно сортируем обе половины
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    # Объединение: слияние двух отсортированных половин
    return merge(left_half, right_half)

def merge(left, right):
    result = []
    i = j = 0
    
    # Сравниваем элементы из обоих массивов и добавляем меньший в результат
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Добавляем оставшиеся элементы
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Пример использования
print(merge_sort([5, 2, 4, 7, 1, 3, 2, 6]))  # [1, 2, 2, 3, 4, 5, 6, 7]
```

### Применение в веб-разработке:
- Обработка больших JSON-структур
- Параллельная обработка данных
- Эффективное разделение работы между несколькими воркерами

## 2. Жадные алгоритмы (Greedy Algorithms)

Жадные алгоритмы принимают локально оптимальное решение на каждом шаге с надеждой, что это приведет к глобально оптимальному решению.

### Ключевой принцип:
На каждом шаге выбирается самый выгодный вариант, без пересмотра предыдущих решений.

### Пример: Размен монет

```python
def coin_change_greedy(amount, coins):
    # Сортируем монеты по убыванию номинала
    coins.sort(reverse=True)
    
    result = []
    
    # Для каждого номинала монеты
    for coin in coins:
        # Используем максимально возможное количество монет данного номинала
        while amount >= coin:
            result.append(coin)
            amount -= coin
    
    return result if amount == 0 else "Нет решения"

# Пример использования
print(coin_change_greedy(63, [25, 10, 5, 1]))  # [25, 25, 10, 1, 1, 1]
```

> **Важно**: Жадные алгоритмы не всегда дают оптимальное решение. Например, для системы монет [1, 3, 4] и суммы 6, жадный алгоритм даст [4, 1, 1], тогда как оптимальное решение — [3, 3].

### Применение в веб-разработке:
- Алгоритмы кеширования (например, LRU — Least Recently Used)
- Планирование задач
- Балансировка нагрузки

## 3. Динамическое программирование (Dynamic Programming)

Динамическое программирование решает сложные задачи, разбивая их на подзадачи и сохраняя промежуточные результаты, чтобы избежать повторных вычислений.

### Ключевые характеристики:
1. **Оптимальная подструктура**: Оптимальное решение задачи содержит оптимальные решения подзадач
2. **Перекрывающиеся подзадачи**: Одни и те же подзадачи решаются многократно

### Пример: Числа Фибоначчи с мемоизацией

```python
def fibonacci_dp(n, memo={}):
    # Проверяем, есть ли результат в кеше
    if n in memo:
        return memo[n]
    
    # Базовые случаи
    if n <= 1:
        return n
    
    # Вычисляем результат и сохраняем в кеш
    memo[n] = fibonacci_dp(n-1, memo) + fibonacci_dp(n-2, memo)
    return memo[n]

# Пример использования
print(fibonacci_dp(50))  # Выполняется очень быстро благодаря мемоизации
```

### Пример: Задача о рюкзаке (табличный метод)

```python
def knapsack(weights, values, capacity):
    n = len(weights)
    # Создаем таблицу размером (n+1) x (capacity+1)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    # Заполняем таблицу
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Если текущий предмет не помещается, берем предыдущее решение
            if weights[i-1] > w:
                dp[i][w] = dp[i-1][w]
            else:
                # Максимум из "не брать текущий предмет" или "взять текущий предмет"
                dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w-weights[i-1]])
    
    return dp[n][capacity]

# Пример использования
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 8
print(knapsack(weights, values, capacity))  # 9
```

### Применение в веб-разработке:
- Оптимизация маршрутов в API
- Кеширование результатов тяжелых вычислений
- Генерация оптимальных планов запросов к базе данных

## 4. Поиск с возвратом (Backtracking)

Поиск с возвратом — это метод перебора с отсечением неперспективных ветвей. Алгоритм пошагово строит решение и отказывается от него, как только становится ясно, что оно не приведет к полному решению.

### Ключевые принципы:
1. **Инкрементальное построение**: Строим решение по частям
2. **Проверка на допустимость**: Отсекаем неперспективные варианты
3. **Возврат**: При неудаче возвращаемся к предыдущему состоянию и пробуем другие варианты

### Пример: Задача о N ферзях

```python
def solve_n_queens(n):
    board = [['.' for _ in range(n)] for _ in range(n)]
    solutions = []
    
    def is_safe(row, col):
        # Проверка столбца
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # Проверка диагонали сверху слева
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        # Проверка диагонали сверху справа
        for i, j in zip(range(row-1, -1, -1), range(col+1, n)):
            if board[i][j] == 'Q':
                return False
        
        return True
    
    def backtrack(row):
        # Если все ферзи размещены, добавляем решение
        if row == n:
            solutions.append([''.join(row) for row in board])
            return
        
        # Пробуем разместить ферзя в каждой колонке текущей строки
        for col in range(n):
            if is_safe(row, col):
                board[row][col] = 'Q'  # Размещаем ферзя
                backtrack(row + 1)     # Рекурсивно решаем для следующей строки
                board[row][col] = '.'  # Возвращаемся (backtrack)
    
    backtrack(0)
    return solutions

# Пример использования
solutions = solve_n_queens(4)
for sol in solutions:
    for row in sol:
        print(row)
    print()
```

### Применение в веб-разработке:
- Генерация всех возможных комбинаций параметров
- Поиск оптимальных маршрутов в сложных системах
- Планирование задач с ограничениями

## 5. Метод ветвей и границ (Branch and Bound)

Метод ветвей и границ — это улучшенная версия поиска с возвратом, которая использует оценки для более эффективного отсечения неперспективных вариантов.

### Ключевые принципы:
1. **Ветвление**: Разбиение пространства решений на подмножества
2. **Оценка границ**: Вычисление верхних/нижних оценок для каждого подмножества
3. **Отсечение**: Исключение подмножеств, которые не могут содержать оптимальное решение

### Пример: Задача коммивояжера (упрощенный вариант)

```python
import heapq

def tsp_branch_and_bound(graph):
    n = len(graph)
    # Приоритетная очередь: (нижняя граница, путь, посещенные)
    priority_queue = [(0, [0], {0})]
    min_cost = float('inf')
    best_path = None
    
    while priority_queue:
        # Извлекаем путь с наименьшей нижней границей
        cost_so_far, path, visited = heapq.heappop(priority_queue)
        
        # Если все города посещены
        if len(visited) == n:
            # Добавляем стоимость возврата в начальный город
            total_cost = cost_so_far + graph[path[-1]][0]
            if total_cost < min_cost:
                min_cost = total_cost
                best_path = path + [0]  # Возвращаемся в начальный город
            continue
        
        # Рассматриваем следующие города
        for next_city in range(n):
            if next_city not in visited:
                # Вычисляем новую стоимость
                new_cost = cost_so_far + graph[path[-1]][next_city]
                
                # Простая нижняя оценка оставшегося пути
                lower_bound = new_cost
                
                # Если нижняя оценка меньше текущего минимума, добавляем в очередь
                if lower_bound < min_cost:
                    new_path = path + [next_city]
                    new_visited = visited | {next_city}
                    heapq.heappush(priority_queue, (new_cost, new_path, new_visited))
    
    return best_path, min_cost

# Пример использования
graph = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]
best_path, min_cost = tsp_branch_and_bound(graph)
print(f"Оптимальный путь: {best_path}, Стоимость: {min_cost}")
```

### Применение в веб-разработке:
- Оптимизация многоэтапных запросов
- Планирование ресурсов сервера
- Оптимальное распределение нагрузки

## 6. Сканирующая линия (Sweep Line)

Метод сканирующей линии обрабатывает задачи путем перемещения воображаемой линии через пространство или время.

### Ключевой принцип:
Сортировка событий по одной координате и последовательная обработка их при движении линии.

### Пример: Нахождение пересечений отрезков

```python
def find_intersections(segments):
    # События: (x, тип события, индекс отрезка)
    # Тип события: 0 - начало отрезка, 1 - конец отрезка
    events = []
    
    for i, ((x1, y1), (x2, y2)) in enumerate(segments):
        # Убедимся, что x1 <= x2
        if x1 > x2:
            x1, y1, x2, y2 = x2, y2, x1, y1
        
        events.append((x1, 0, i))  # Начало отрезка
        events.append((x2, 1, i))  # Конец отрезка
    
    # Сортируем события по x-координате
    events.sort()
    
    active_segments = set()
    intersections = []
    
    # Сканирующая линия
    for x, event_type, segment_idx in events:
        if event_type == 0:  # Начало отрезка
            # Проверяем пересечения с активными отрезками
            for active_idx in active_segments:
                if segments_intersect(segments[segment_idx], segments[active_idx]):
                    intersections.append((segment_idx, active_idx))
            
            active_segments.add(segment_idx)
        else:  # Конец отрезка
            active_segments.remove(segment_idx)
    
    return intersections

def segments_intersect(segment1, segment2):
    # Упрощенная функция проверки пересечения отрезков
    # В реальности нужна более сложная реализация
    ((x1, y1), (x2, y2)) = segment1
    ((x3, y3), (x4, y4)) = segment2
    
    # Определитель
    def det(a, b, c, d):
        return a * d - b * c
    
    # Векторное произведение
    def cross_product(p1, p2, p3):
        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])
    
    # Проверка положения точки относительно линии
    d1 = cross_product((x3, y3), (x4, y4), (x1, y1))
    d2 = cross_product((x3, y3), (x4, y4), (x2, y2))
    d3 = cross_product((x1, y1), (x2, y2), (x3, y3))
    d4 = cross_product((x1, y1), (x2, y2), (x4, y4))
    
    # Если знаки разные, отрезки пересекаются
    return (d1 * d2 <= 0) and (d3 * d4 <= 0)

# Пример использования
segments = [
    ((0, 0), (10, 10)),
    ((0, 10), (10, 0)),
    ((5, 0), (5, 10)),
    ((3, 3), (7, 7))
]
print(find_intersections(segments))
```

### Применение в веб-разработке:
- Обработка временных рядов
- Анализ логов запросов на сервер
- Планирование задач по времени

## 7. Рандомизированные алгоритмы

Рандомизированные алгоритмы используют случайность как часть своей логики для получения результатов с определенной вероятностью.

### Пример: Быстрая сортировка с случайным выбором опорного элемента

```python
import random

def quick_sort_randomized(arr):
    if len(arr) <= 1:
        return arr
    
    # Случайный выбор опорного элемента
    pivot_idx = random.randint(0, len(arr) - 1)
    pivot = arr[pivot_idx]
    
    # Разделение массива
    less = [x for i, x in enumerate(arr) if x <= pivot and i != pivot_idx]
    greater = [x for x in arr if x > pivot]
    
    # Рекурсивная сортировка и объединение
    return quick_sort_randomized(less) + [pivot] + quick_sort_randomized(greater)

# Пример использования
print(quick_sort_randomized([5, 2, 9, 1, 5, 6]))
```

### Применение в веб-разработке:
- Распределение нагрузки между серверами
- A/B тестирование
- Случайный выбор элементов для показа пользователю

## 8. Параллельные алгоритмы

Параллельные алгоритмы разделяют задачу на части, которые могут выполняться одновременно.

### Пример: Параллельная сортировка слиянием (концептуальный код)

```python
import concurrent.futures

def parallel_merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    
    # Используем пул потоков для параллельного выполнения
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Запускаем сортировку левой и правой частей параллельно
        future_left = executor.submit(parallel_merge_sort, arr[:mid])
        future_right = executor.submit(parallel_merge_sort, arr[mid:])
        
        left = future_left.result()
        right = future_right.result()
    
    # Слияние остается последовательным
    return merge(left, right)

def merge(left, right):
    # Функция слияния (как в обычной сортировке слиянием)
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Пример использования
print(parallel_merge_sort([5, 2, 9, 1, 5, 6]))
```

### Применение в веб-разработке:
- Параллельная обработка запросов
- Распределенные вычисления
- Асинхронные задачи

## Заключение

Эти парадигмы образуют фундамент алгоритмического мышления. Важно понимать, что многие сложные алгоритмы часто комбинируют несколько подходов.

При решении алгоритмической задачи:
1. **Проанализируйте проблему** и определите её основные характеристики
2. **Выберите подходящую парадигму** (или их комбинацию)
3. **Реализуйте** решение, учитывая особенности выбранного подхода
4. **Оцените эффективность** и при необходимости оптимизируйте

В веб-разработке, особенно в бэкенде, эти парадигмы помогают создавать эффективные, масштабируемые и надежные системы.

---

В следующих разделах мы рассмотрим конкретные алгоритмы поиска, сортировки и их применение в практических задачах веб-разработки.