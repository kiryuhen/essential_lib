# Python: Работа с файлами и операционной системой

Этот документ содержит подробное описание встроенных библиотек Python для работы с файлами и операционной системой. Документация ориентирована на Python 3.8+ и предназначена для senior-разработчиков.

## Содержание

- [os](#os)
  - [Работа с файлами и директориями](#работа-с-файлами-и-директориями)
  - [Управление процессами](#управление-процессами)
  - [Переменные окружения](#переменные-окружения)
- [os.path](#ospath)
- [pathlib](#pathlib)
- [shutil](#shutil)
- [glob](#glob)
- [fnmatch](#fnmatch)
- [tempfile](#tempfile)
- [fileinput](#fileinput)
- [io](#io)
- [mmap](#mmap)
- [fcntl](#fcntl)

## os

Модуль `os` предоставляет интерфейс для взаимодействия с операционной системой.

**Описание:** Позволяет работать с файлами, процессами, переменными окружения и другими функциями операционной системы.

**Внутреннее устройство:**
- Обеспечивает переносимый интерфейс к функциям, зависящим от ОС.
- Содержит подмодули для конкретных операционных систем.
- Включает обертки для системных вызовов POSIX в Unix-подобных системах.

### Работа с файлами и директориями

**Ключевые функции:**
- `os.listdir(path='.')` - возвращает список файлов и директорий в указанной директории.
- `os.mkdir(path, mode=0o777)` - создаёт директорию.
- `os.makedirs(path, mode=0o777, exist_ok=False)` - создаёт директории рекурсивно.
- `os.remove(path)` - удаляет файл.
- `os.rmdir(path)` - удаляет пустую директорию.
- `os.removedirs(path)` - удаляет директории рекурсивно, если они пусты.
- `os.rename(src, dst)` - переименовывает файл или директорию.
- `os.stat(path)` - возвращает информацию о файле.
- `os.chmod(path, mode)` - изменяет права доступа к файлу.
- `os.chown(path, uid, gid)` - изменяет владельца и группу файла (Unix).
- `os.getcwd()` - возвращает текущую рабочую директорию.
- `os.chdir(path)` - меняет текущую рабочую директорию.

**Примеры:**
```python
import os

# Работа с директориями
current_dir = os.getcwd()  # Текущая рабочая директория
os.chdir('/tmp')           # Смена директории
os.mkdir('new_folder')     # Создание директории
files = os.listdir()       # Список файлов и папок

# Работа с файлами
os.rename('old_name.txt', 'new_name.txt')  # Переименование файла
os.remove('file_to_delete.txt')            # Удаление файла

# Получение информации о файле
file_info = os.stat('some_file.txt')
print(f"Размер: {file_info.st_size} байт")
print(f"Последнее изменение: {file_info.st_mtime}")

# Рекурсивное создание директорий
os.makedirs('parent/child/grandchild', exist_ok=True)

# Проверка доступа к файлу
is_readable = os.access('file.txt', os.R_OK)  # Можно ли читать
is_writable = os.access('file.txt', os.W_OK)  # Можно ли писать
is_executable = os.access('file.txt', os.X_OK)  # Можно ли исполнять
```

**Особенности для senior-разработчиков:**
- `os.walk(top, ...)` - мощный генератор для рекурсивного обхода директорий.
- Используйте `os.path.join` для создания путей, совместимых с текущей ОС.
- `os.makedirs(exist_ok=True)` не вызывает исключение, если директория уже существует (добавлено в Python 3.2).
- В Unix-подобных системах `os.symlink()` создаёт символические ссылки.
- `os.DirEntry` (Python 3.5+) обеспечивает эффективные операции с файловой системой при использовании `os.scandir()`.

### Управление процессами

**Ключевые функции:**
- `os.system(command)` - выполняет команду в оболочке ОС и возвращает код возврата.
- `os.popen(command[, mode='r'[, buffering]])` - открывает канал к/от команды.
- `os.execl(path, arg0, arg1, ...)` - заменяет текущий процесс указанной программой.
- `os.fork()` - создаёт дочерний процесс (только Unix).
- `os.pipe()` - создаёт пару файловых дескрипторов для канала.
- `os.kill(pid, sig)` - отправляет сигнал процессу.
- `os.waitpid(pid, options)` - ожидает завершения дочернего процесса.
- `os.getpid()` - возвращает ID текущего процесса.
- `os.getppid()` - возвращает ID родительского процесса.

**Примеры:**
```python
import os
import signal
import sys

# Выполнение команды оболочки
exit_code = os.system('ls -la')

# Получение вывода команды
with os.popen('date') as pipe:
    date_output = pipe.read().strip()
    print(f"Текущая дата: {date_output}")

# Получение идентификатора процесса
pid = os.getpid()
print(f"ID процесса: {pid}")

# Обработка сигналов (Unix)
def signal_handler(signum, frame):
    print(f"Получен сигнал {signum}")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)

# Создание дочернего процесса (Unix)
if os.name == 'posix':
    child_pid = os.fork()
    if child_pid == 0:
        # Код дочернего процесса
        print("Я дочерний процесс")
        sys.exit(0)
    else:
        # Код родительского процесса
        print(f"Создан дочерний процесс с ID {child_pid}")
        # Ждём завершения дочернего процесса
        os.waitpid(child_pid, 0)
```

**Особенности для senior-разработчиков:**
- Предпочитайте модуль `subprocess` вместо `os.system` и `os.popen` для более гибкой работы с процессами.
- `os.execl` и аналоги заменяют текущий процесс без возврата, если выполнение успешно.
- `os.fork` создаёт копию текущего процесса, но доступен только в Unix-подобных системах.
- `os.getloadavg()` возвращает среднюю загрузку системы за 1, 5 и 15 минут (не доступно в Windows).
- Функции для работы с процессами и сигналами имеют много ограничений в Windows.

### Переменные окружения

**Ключевые функции:**
- `os.environ` - словарь переменных окружения.
- `os.getenv(key, default=None)` - получение значения переменной окружения.
- `os.putenv(key, value)` - устанавливает переменную окружения.
- `os.unsetenv(key)` - удаляет переменную окружения.

**Примеры:**
```python
import os

# Получение переменных окружения
home = os.environ.get('HOME')  # Или os.getenv('HOME')
path = os.environ['PATH']

# Установка переменной окружения
os.environ['MY_VARIABLE'] = 'some_value'

# Перебор всех переменных
for key, value in os.environ.items():
    print(f"{key} = {value}")

# Удаление переменной
if 'MY_VARIABLE' in os.environ:
    del os.environ['MY_VARIABLE']
```

**Особенности для senior-разработчиков:**
- Изменения в `os.environ` влияют на текущий процесс, но не на родительский или другие процессы.
- `os.putenv` и `os.unsetenv` не изменяют словарь `os.environ`, используйте прямые операции со словарём.
- Значения переменных окружения всегда строковые, при необходимости выполняйте преобразование типов.
- Для переносимого кода используйте переменные окружения вместо жестко закодированных путей.

## os.path

Модуль `os.path` предоставляет функции для работы с путями к файлам, совместимые с текущей ОС.

**Описание:** Обеспечивает переносимые операции для манипуляции путями к файлам.

**Внутреннее устройство:**
- Автоматически адаптируется к соглашениям ОС (разделители путей, абсолютные пути).
- Не обращается к файловой системе, за исключением определённых функций (exists, isdir и т.д.).
- Работает с путями как со строками, выполняя операции на уровне строк.

**Ключевые функции:**
- `os.path.join(path, *paths)` - объединяет пути с учётом особенностей ОС.
- `os.path.abspath(path)` - возвращает абсолютный путь.
- `os.path.basename(path)` - возвращает имя файла из пути.
- `os.path.dirname(path)` - возвращает директорию из пути.
- `os.path.split(path)` - разделяет путь на (директорию, имя файла).
- `os.path.splitext(path)` - разделяет путь на (путь, расширение).
- `os.path.exists(path)` - проверяет существование пути.
- `os.path.isfile(path)` - проверяет, является ли путь файлом.
- `os.path.isdir(path)` - проверяет, является ли путь директорией.
- `os.path.getsize(path)` - возвращает размер файла в байтах.
- `os.path.getmtime(path)` - возвращает время последнего изменения файла.

**Примеры:**
```python
import os.path

# Создание путей, совместимых с ОС
config_path = os.path.join('etc', 'app', 'config.ini')
print(config_path)  # 'etc/app/config.ini' в Unix, 'etc\\app\\config.ini' в Windows

# Разделение пути на компоненты
path = '/home/user/documents/file.txt'
dirname = os.path.dirname(path)   # '/home/user/documents'
basename = os.path.basename(path) # 'file.txt'
name, ext = os.path.splitext(basename)  # ('file', '.txt')

# Абсолютный путь
abs_path = os.path.abspath('relative/path')

# Проверки
if os.path.exists(path):
    if os.path.isfile(path):
        size = os.path.getsize(path)
        print(f"Файл размером {size} байт")
    elif os.path.isdir(path):
        print("Это директория")

# Работа с относительными путями
parent_dir = os.path.dirname(os.path.abspath(__file__))  # Директория текущего скрипта
```

**Особенности для senior-разработчиков:**
- `os.path.expanduser('~')` разворачивает `~` в домашнюю директорию пользователя.
- `os.path.normpath(path)` нормализует путь (убирает избыточные разделители, `.` и `..`).
- `os.path.commonpath([paths])` находит самый длинный общий префикс для нескольких путей.
- `os.path.relpath(path, start='.')` возвращает относительный путь к `path` от `start`.
- Важно понимать, что `os.path` не проверяет существование файла, если не вызывать явно функции проверки.

## pathlib

Модуль `pathlib` (добавлен в Python 3.4) предоставляет объектно-ориентированный интерфейс для работы с путями.

**Описание:** Обеспечивает удобную объектную модель для операций с файловыми путями.

**Внутреннее устройство:**
- Пути представлены как объекты, а не как строки.
- Разделяет пути на "чистые" (не взаимодействующие с ОС) и "конкретные" (для работы с файловой системой).
- Использует оператор `/` для построения путей (вместо `os.path.join`).

**Ключевые классы:**
- `Path` - основной класс для работы с путями.
- `PurePath` - базовый класс для манипуляций с путями без доступа к файловой системе.
- `PurePosixPath`/`PureWindowsPath` - версии PurePath для конкретных ОС, независимо от платформы.
- `PosixPath`/`WindowsPath` - конкретные реализации Path для соответствующих ОС.

**Основные методы Path:**
- `.resolve()` - возвращает абсолютный путь, разрешая символические ссылки.
- `.absolute()` - возвращает абсолютный путь.
- `.exists()`, `.is_file()`, `.is_dir()` - проверки файловой системы.
- `.glob(pattern)`, `.rglob(pattern)` - поиск файлов по шаблонам.
- `.mkdir(mode=0o777, parents=False, exist_ok=False)` - создание директории.
- `.rmdir()` - удаление директории.
- `.unlink(missing_ok=False)` - удаление файла.
- `.rename(target)` - переименование файла/директории.
- `.open(mode='r', ...)` - открытие файла.
- `.read_text()`, `.read_bytes()` - чтение содержимого файла.
- `.write_text()`, `.write_bytes()` - запись в файл.

**Примеры:**
```python
from pathlib import Path

# Создание объектов Path
current_file = Path(__file__)
home = Path.home()
config = Path('/etc') / 'app' / 'config.ini'  # Использование оператора /

# Компоненты пути
print(config.name)      # 'config.ini'
print(config.suffix)    # '.ini'
print(config.stem)      # 'config'
print(config.parent)    # Path('/etc/app')

# Преобразование и проверки
abs_path = config.absolute()
resolved_path = config.resolve()   # Разрешает символические ссылки

if config.exists():
    if config.is_file():
        print(f"Размер файла: {config.stat().st_size} байт")
        print(f"Содержимое: {config.read_text()}")
    elif config.is_dir():
        print("Это директория")

# Манипуляции с файловой системой
temp_dir = Path('temp_data')
temp_dir.mkdir(exist_ok=True)

# Создание и запись в файл
data_file = temp_dir / 'data.txt'
data_file.write_text("Hello, World!")

# Перебор файлов в директории
for py_file in Path('.').glob('*.py'):
    print(f"Python файл: {py_file}")
```

**Особенности для senior-разработчиков:**
- В Python 3.6+ `Path` поддерживает метод `__fspath__()`, что позволяет использовать его с большинством API, ожидающих строковые пути.
- Если требуется строка, можно просто использовать `str(path_obj)`.
- `.rglob(pattern)` эквивалентен `.glob('**/pattern')` - рекурсивному глобу.
- `.relative_to(other)` позволяет получить относительный путь между двумя объектами Path.
- С Python 3.9 добавлены методы `.is_mount()`, `.is_junction()`, `.hardlink_to()` и поддержка заменяемых компонентов в `.with_name()` и `.with_stem()`.
- Объект Path можно использовать в выражениях контекстного менеджера для открытия и автоматического закрытия файла.

## shutil

Модуль `shutil` предоставляет высокоуровневые операции с файлами и коллекциями файлов.

**Описание:** Содержит функции для копирования, перемещения, архивации файлов и директорий.

**Внутреннее устройство:**
- Обёртка над системными API для работы с файлами.
- Обеспечивает переносимость между разными операционными системами.
- Реализует сложные операции на основе базовых функций модуля `os`.

**Ключевые функции:**
- `shutil.copy(src, dst)` - копирует файл.
- `shutil.copy2(src, dst)` - копирует файл, сохраняя метаданные.
- `shutil.copytree(src, dst, ...)` - рекурсивно копирует дерево директорий.
- `shutil.move(src, dst)` - перемещает файл или директорию.
- `shutil.rmtree(path, ...)` - рекурсивно удаляет директорию и её содержимое.
- `shutil.disk_usage(path)` - информация об использовании диска.
- `shutil.make_archive(base_name, format, ...)` - создаёт архив из директории.
- `shutil.unpack_archive(filename, ...)` - извлекает содержимое архива.
- `shutil.which(cmd)` - поиск исполняемого файла в PATH.

**Примеры:**
```python
import shutil
import os
from pathlib import Path

# Копирование файлов
shutil.copy('source.txt', 'destination.txt')  # Только содержимое
shutil.copy2('source.txt', 'destination.txt')  # С метаданными

# Копирование дерева директорий
shutil.copytree('source_dir', 'destination_dir')

# С фильтрацией файлов (Python 3.8+)
shutil.copytree('source_dir', 'destination_dir', 
                ignore=shutil.ignore_patterns('*.log', '*.tmp'))

# Перемещение файлов или директорий
shutil.move('old_file.txt', 'new_location.txt')

# Удаление директории целиком
shutil.rmtree('directory_to_delete')

# Использование диска
total, used, free = shutil.disk_usage('/')
print(f"Всего: {total // (2**30)} ГБ")
print(f"Использовано: {used // (2**30)} ГБ")
print(f"Свободно: {free // (2**30)} ГБ")

# Работа с архивами
# Создание архива
shutil.make_archive('backup', 'zip', 'source_dir')

# Распаковка архива
shutil.unpack_archive('backup.zip', 'extract_dir')

# Поиск исполняемого файла
python_path = shutil.which('python')
```

**Особенности для senior-разработчиков:**
- `copytree` может принимать параметр `dirs_exist_ok=True` (Python 3.8+), что позволяет объединять директории при копировании.
- Функция `shutil.copyfileobj(fsrc, fdst[, length])` оптимизирована для копирования больших файлов с помощью буферизации.
- `shutil.copy2` сохраняет метаданные файла, но не копирует расширенные атрибуты или ACL.
- `shutil.get_archive_formats()` возвращает список поддерживаемых форматов архивов.
- `shutil.chown(path, user=None, group=None)` изменяет владельца и группу файла (Unix).
- При работе с большими файлами предпочтительно использовать `shutil.copyfileobj()` для контроля над использованием памяти.

## glob

Модуль `glob` предоставляет функции для поиска файлов по шаблонам пути.

**Описание:** Позволяет находить файлы с использованием шаблонов подстановки Unix.

**Внутреннее устройство:**
- Использует подстановочные знаки, аналогичные тем, что используются в оболочках Unix.
- Не использует регулярные выражения, а имеет собственный более простой синтаксис.
- В Python 3.5+ использует оптимизированный `os.scandir()`.

**Ключевые функции:**
- `glob.glob(pathname, *, recursive=False)` - находит все пути, соответствующие шаблону.
- `glob.iglob(pathname, *, recursive=False)` - ленивая версия glob, возвращающая итератор.
- `glob.escape(pathname)` - экранирует специальные символы в пути.

**Подстановочные символы:**
- `*` - соответствует любому количеству символов (кроме разделителя пути).
- `?` - соответствует одному символу (кроме разделителя пути).
- `[seq]` - соответствует любому символу из seq.
- `[!seq]` - соответствует любому символу, кроме тех, что в seq.
- `**` - (с `recursive=True`) соответствует директориям и поддиректориям.

**Примеры:**
```python
import glob
import os

# Найти все Python-файлы в текущей директории
py_files = glob.glob('*.py')
print(f"Python файлы: {py_files}")

# Найти все txt-файлы во всех поддиректориях
all_txt = glob.glob('**/*.txt', recursive=True)
print(f"Текстовые файлы: {all_txt}")

# Использование итератора для обработки больших списков файлов
for log_file in glob.iglob('logs/*.log'):
    process_log(log_file)

# Поиск с более сложными шаблонами
data_files = glob.glob('data/file_[0-9][0-9].csv')
log_files = glob.glob('logs/app_log_20??-??.log')

# Экранирование специальных символов
pattern = glob.escape('data[2020].txt')  # Ищет файл с литеральным именем "data[2020].txt"
found = glob.glob(pattern)
```

**Особенности для senior-разработчиков:**
- `glob` не сортирует результаты, порядок зависит от файловой системы. Используйте `sorted()`, если порядок важен.
- Параметр `recursive=True` доступен с Python 3.5 и позволяет использовать `**`.
- `glob` не поддерживает негативную фильтрацию. Для более сложной фильтрации используйте комбинацию `glob` и фильтрации списка результатов.
- Для поиска файлов с сохранением информации о файлах (размер, дата изменения) эффективнее использовать `os.scandir()` или `pathlib.Path().glob()`.
- В Windows метасимволы `*` и `?` не соответствуют файлам, начинающимся с точки.

## fnmatch

Модуль `fnmatch` предоставляет функции для сопоставления имен файлов по шаблонам в стиле Unix.

**Описание:** Позволяет выполнять сопоставление с шаблоном для имен файлов, аналогично оболочке Unix.

**Внутреннее устройство:**
- Преобразует шаблоны оболочки Unix в регулярные выражения для сопоставления.
- Учитывает специфику платформы при сопоставлении (например, case-sensitivity).
- Работает с именами, а не с путями, в отличие от `glob`.

**Ключевые функции:**
- `fnmatch.fnmatch(filename, pattern)` - проверяет, соответствует ли имя файла шаблону.
- `fnmatch.fnmatchcase(filename, pattern)` - то же, но с учетом регистра.
- `fnmatch.filter(names, pattern)` - фильтрует список имен, возвращая соответствующие шаблону.
- `fnmatch.translate(pattern)` - преобразует шаблон оболочки в регулярное выражение.

**Примеры:**
```python
import fnmatch
import os

# Проверка соответствия
is_log = fnmatch.fnmatch('app.log', '*.log')  # True
is_text = fnmatch.fnmatch('data.json', '*.txt')  # False

# Сопоставление с учетом регистра
is_py = fnmatch.fnmatchcase('script.PY', '*.py')  # False (регистр важен)

# Фильтрация списка файлов
files = os.listdir('.')
python_files = fnmatch.filter(files, '*.py')
log_files = fnmatch.filter(files, '*log*')

# Поиск всех файлов заданного типа в дереве директорий
matches = []
for root, dirnames, filenames in os.walk('project'):
    for filename in fnmatch.filter(filenames, '*.json'):
        matches.append(os.path.join(root, filename))

# Преобразование шаблона в регулярное выражение
regex_pattern = fnmatch.translate('*.log')
print(regex_pattern)  # (?s:.*\.log)\Z
```

**Особенности для senior-разработчиков:**
- В Windows `fnmatch` игнорирует регистр по умолчанию, в Unix - учитывает. Для единообразия используйте `fnmatchcase`.
- `fnmatch` работает только с именами файлов, не с полными путями. Для путей используйте `os.path.basename()` или `glob`.
- Шаблоны `fnmatch` проще регулярных выражений, но и менее мощные. Для сложных условий используйте `re`.
- `fnmatch.translate()` полезен, когда нужно получить регулярное выражение из шаблона для дальнейшего использования с `re`.
- В отличие от `glob`, `fnmatch` не обращается к файловой системе и работает со строками.

## tempfile

Модуль `tempfile` предоставляет функции для создания временных файлов и директорий.

**Описание:** Генерирует временные файлы и директории безопасным и переносимым способом.

**Внутреннее устройство:**
- Генерирует уникальные имена файлов в определенной директории для временных файлов.
- Обеспечивает безопасное создание и удаление временных файлов.
- Учитывает особенности ОС при выборе местоположения файлов.

**Ключевые функции и классы:**
- `tempfile.TemporaryFile(...)` - создает временный файл, который удаляется при закрытии.
- `tempfile.NamedTemporaryFile(...)` - создает именованный временный файл.
- `tempfile.SpooledTemporaryFile(max_size=...)` - файл, сохраняемый в памяти до достижения `max_size`.
- `tempfile.TemporaryDirectory(...)` - создает временную директорию.
- `tempfile.mktemp()` - создает имя файла (устаревшая функция, небезопасная).
- `tempfile.mkstemp()` - безопасно создает и открывает временный файл.
- `tempfile.mkdtemp()` - создает временную директорию.
- `tempfile.gettempdir()` - возвращает директорию для временных файлов.

**Примеры:**
```python
import tempfile
import os

# Создание временного файла, автоматически удаляемого
with tempfile.TemporaryFile() as temp:
    # Запись во временный файл
    temp.write(b'Hello world!')
    # Переход к началу файла
    temp.seek(0)
    # Чтение из файла
    data = temp.read()  # b'Hello world!'
# Файл автоматически закрывается и удаляется после блока with

# Именованный временный файл
with tempfile.NamedTemporaryFile() as named_temp:
    print(f"Временный файл: {named_temp.name}")
    # Использование имени файла в других функциях
    with open(named_temp.name, 'rb') as f:
        # Работа с файлом через стандартные функции
        pass

# Временная директория
with tempfile.TemporaryDirectory() as temp_dir:
    print(f"Временная директория: {temp_dir}")
    # Создание файлов во временной директории
    path = os.path.join(temp_dir, 'test.txt')
    with open(path, 'w') as f:
        f.write('Содержимое временного файла')
# Директория и всё её содержимое удаляются автоматически

# Для случаев, когда нужен более низкоуровневый контроль
fd, path = tempfile.mkstemp()
try:
    # Используем файловый дескриптор
    os.write(fd, b'Hello, low-level temp file')
finally:
    os.close(fd)
    os.unlink(path)  # Явное удаление

# Буферизованный в памяти временный файл
with tempfile.SpooledTemporaryFile(max_size=1024) as temp:
    # Файл хранится в памяти, пока его размер не превысит 1 КБ
    temp.write(b'Данные, хранящиеся в памяти')
```

**Особенности для senior-разработчиков:**
- `TemporaryFile` в Windows создаёт файл без имени в файловой системе, доступ к нему возможен только через файловый объект.
- Значение по умолчанию для `delete` в `NamedTemporaryFile` - `True`, что означает автоматическое удаление файла при закрытии.
- `SpooledTemporaryFile` хранит данные в памяти до достижения лимита размера, затем выгружает на диск, что полезно для оптимизации производительности.
- Функция `mktemp()` считается небезопасной из-за возможной гонки условий между получением имени и созданием файла.
- Используйте `dir` и `prefix` для указания директории и префикса имени временных файлов.
- Для низкоуровневых операций `mkstemp()` и `mkdtemp()` не удаляют файлы/директории автоматически.

## fileinput

Модуль `fileinput` предоставляет удобный способ итерации по строкам из нескольких входных потоков.

**Описание:** Позволяет эффективно обрабатывать один или несколько текстовых файлов строка за строкой.

**Внутреннее устройство:**
- Абстрагирует работу с набором файлов, представляя их как один последовательный поток строк.
- Поддерживает автоматическое определение текущего файла и номера строки.
- Включает возможность встроенного редактирования файлов.

**Ключевые функции:**
- `fileinput.input(files=None, inplace=False, ...)` - итерация по строкам файлов.
- `fileinput.FileInput` - класс, реализующий итератор для файлов.
- `fileinput.filename()` - возвращает имя текущего входного файла.
- `fileinput.fileno()` - возвращает файловый дескриптор текущего входного файла.
- `fileinput.lineno()` - возвращает номер текущей строки.
- `fileinput.filelineno()` - возвращает номер строки в текущем файле.
- `fileinput.isfirstline()` - проверяет, является ли строка первой в файле.
- `fileinput.isstdin()` - проверяет, является ли текущий файл stdin.

**Примеры:**
```python
import fileinput
import sys

# Обработка нескольких файлов
def process_files():
    for line in fileinput.input(['file1.txt', 'file2.txt']):
        print(f"{fileinput.filename()}:{fileinput.filelineno()}: {line}", end='')

# Редактирование файлов на месте (замена текста)
def replace_text():
    for line in fileinput.input(['file.txt'], inplace=True):
        # Вывод идет в файл, не на консоль
        line = line.replace('старый_текст', 'новый_текст')
        print(line, end='')

# Обработка файлов, переданных через аргументы командной строки
def process_cmdline_files():
    for line in fileinput.input():  # использует sys.argv[1:]
        if fileinput.isfirstline():
            print(f"--- {fileinput.filename()} ---")
        process_line(line)

# Использование в качестве контекстного менеджера
def process_with_context():
    with fileinput.FileInput(['log1.txt', 'log2.txt']) as f:
        for line in f:
            if 'ERROR' in line:
                print(f"{f.filename()}:{f.filelineno()}: {line}", end='')
```

**Особенности для senior-разработчиков:**
- Режим `inplace=True` позволяет модифицировать файлы "на месте", создавая временную копию и перенаправляя stdout.
- Если параметр `files` не указан или None, используются аргументы командной строки из `sys.argv[1:]`. Если и они пусты, используется stdin.
- Модификации файлов "на месте" могут быть опасны; всегда создавайте резервные копии файлов.
- Параметр `backup` позволяет задать расширение для автоматического создания резервных копий при inplace=True.
- Начиная с Python 3.2, `FileInput` может быть использован как контекстный менеджер.
- Для более гибкой обработки файлов (например, бинарных) используйте классы из модуля `io`.

## io

Модуль `io` предоставляет основные инструменты для работы с различными типами ввода/вывода.

**Описание:** Реализует интерфейс для работы с потоками различных типов (текстовыми, бинарными, буферами в памяти).

**Внутреннее устройство:**
- Определяет абстрактные базовые классы (ABC) для различных типов потоков.
- Разделяет потоки на текстовые (символы) и бинарные (байты).
- Обеспечивает последовательный интерфейс для различных источников/назначений данных.

**Ключевые классы:**
- `io.TextIOBase` - абстрактный базовый класс для текстовых потоков.
- `io.BufferedIOBase` - абстрактный базовый класс для буферизованных двоичных потоков.
- `io.RawIOBase` - абстрактный базовый класс для необработанных двоичных потоков.
- `io.StringIO` - текстовый поток в памяти.
- `io.BytesIO` - двоичный поток в памяти.
- `io.TextIOWrapper` - буферизованный текстовый поток с кодировкой.
- `io.BufferedWriter`, `io.BufferedReader`, `io.BufferedRWPair` - буферизованные двоичные потоки.
- `io.FileIO` - необработанный двоичный поток для работы с файлом.

**Примеры:**
```python
import io

# Текстовый поток в памяти
text_buffer = io.StringIO()
text_buffer.write("Привет, ")
text_buffer.write("мир!")
text_buffer.seek(0)  # Перемещение указателя в начало
content = text_buffer.read()  # "Привет, мир!"
text_buffer.close()

# Двоичный поток в памяти
binary_buffer = io.BytesIO()
binary_buffer.write(b'\x00\x01\x02\x03')
binary_buffer.seek(0)
data = binary_buffer.read()  # b'\x00\x01\x02\x03'
binary_buffer.close()

# Работа с текстовым файлом с нестандартной кодировкой
with open('file.txt', 'rb') as f:
    binary_data = f.read()
    
    # Предположим, нам нужно обработать файл с определенной кодировкой
    text_stream = io.TextIOWrapper(io.BytesIO(binary_data), encoding='utf-16')
    decoded_text = text_stream.read()

# Буферизованный запись и чтение
with open('data.bin', 'wb') as f:
    buffered = io.BufferedWriter(io.FileIO(f.fileno(), 'wb'))
    buffered.write(b'Hello, binary world')
    buffered.flush()  # Принудительная запись буфера на диск

# Конвертация между типами потоков
binary_buffer = io.BytesIO(b'Hello, world')
text_buffer = io.TextIOWrapper(binary_buffer, encoding='utf-8')
text = text_buffer.read()  # "Hello, world"
```

**Особенности для senior-разработчиков:**
- `StringIO` и `BytesIO` особенно полезны для тестирования и для операций, которые обычно работают с файлами, но должны выполняться в памяти.
- При работе с большим объемом данных, настройка размера буфера с помощью `buffer_size` может значительно повлиять на производительность.
- Для высокопроизводительного ввода-вывода рассмотрите `io.DEFAULT_BUFFER_SIZE` и настройте его в соответствии с характеристиками вашей системы.
- Обратите внимание на разделение уровней абстракции: `RawIOBase` -> `BufferedIOBase` -> `TextIOBase`, где каждый слой добавляет функциональность.
- `io.open` - это фактически то же самое, что и встроенная функция `open`.
- Вызов `flush()` принудительно записывает буферизованные данные, что важно для предотвращения потери данных при неожиданном прерывании программы.

## mmap

Модуль `mmap` предоставляет интерфейс для отображения файлов в память.

**Описание:** Позволяет работать с содержимым файла как с массивом байтов в памяти.

**Внутреннее устройство:**
- Использует системные вызовы mmap для отображения файла в память.
- Обеспечивает прямой доступ к содержимому файла без явного чтения/записи.
- В Unix поддерживает разделение отображения между процессами.

**Ключевые функции:**
- `mmap.mmap(fileno, length, ...)` - создаёт объект отображения памяти.

**Параметры mmap:**
- `fileno` - файловый дескриптор.
- `length` - длина отображаемого сегмента.
- `flags` - тип доступа (чтение/запись).
- `prot` - защита памяти (только Unix).
- `access` - режим доступа (только Windows).
- `offset` - смещение в файле.

**Примеры:**
```python
import mmap
import os
import re

# Создание файла для примера
with open("example.txt", "wb") as f:
    f.write(b"Hello, memory-mapped file!")

# Чтение из memory-mapped файла
with open("example.txt", "r+b") as f:
    # Создаём отображение всего файла
    mmapped_file = mmap.mmap(f.fileno(), 0)
    
    # Чтение из определённой позиции
    mmapped_file.seek(7)
    data = mmapped_file.read(10)  # b"memory-map"
    
    # Поиск подстроки
    position = mmapped_file.find(b"memory")
    
    # Поиск с регулярными выражениями
    for match in re.finditer(b"m[a-z]+", mmapped_file):
        print(f"Match at {match.start()}: {match.group()}")
    
    # Модификация файла
    mmapped_file.seek(0)
    mmapped_file.write(b"Modified")
    
    # Не забываем закрыть отображение
    mmapped_file.close()

# Использование mmap для обработки больших файлов
def count_lines(filename):
    with open(filename, "rb") as f:
        with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mmapped_file:
            return mmapped_file.count(b'\n')

# Использование mmap для разделения памяти между процессами (Unix)
def create_shared_memory():
    # Создание файла для разделения
    with open("shared.bin", "wb") as f:
        f.write(b"\x00" * 1024)  # Выделяем 1 KB
    
    # Отображение файла в память для записи
    with open("shared.bin", "r+b") as f:
        mm = mmap.mmap(f.fileno(), 1024)
        mm.write(b"Data to be shared")
        
        # В другом процессе можно открыть тот же файл и считать данные
        # (здесь представлено схематично)
        # Другой процесс: mm2 = mmap.mmap(f2.fileno(), 1024); data = mm2.read()
```

**Особенности для senior-разработчиков:**
- Использование `mmap` эффективно для работы с большими файлами, так как отображение не загружает весь файл в память.
- Объект mmap ведёт себя как массив байтов, поддерживая индексацию и срезы: `mmapped_file[10:20]`.
- В Unix можно использовать `MAP_SHARED` или `MAP_PRIVATE` для управления видимостью изменений между процессами.
- В Windows используйте `ACCESS_READ`, `ACCESS_WRITE`, `ACCESS_COPY` для определения режима доступа.
- Работа с `mmap` может быть значительно быстрее, чем стандартные операции файлового ввода-вывода, особенно для произвольного доступа.
- Будьте осторожны с изменением размера файла при активном отображении, это может привести к неопределённому поведению.
- Защита mmap с помощью `with` (контекстный менеджер) автоматически закрывает отображение при выходе из блока.

## fcntl

Модуль `fcntl` предоставляет доступ к функциям управления файловыми дескрипторами в Unix-подобных системах.

**Описание:** Обеспечивает низкоуровневую файловую блокировку и другие операции управления файловыми дескрипторами.

**Внутреннее устройство:**
- Интерфейс к системным вызовам fcntl() и ioctl().
- Доступен только в Unix-подобных системах.
- Обеспечивает системно-зависимые операции, которые обычно не нужны в переносимом коде.

**Ключевые функции:**
- `fcntl.fcntl(fd, cmd, arg=0)` - выполняет операцию управления файловым дескриптором.
- `fcntl.ioctl(fd, request, arg=0, mutate_flag=True)` - управление устройством.
- `fcntl.flock(fd, operation)` - применяет или снимает консультативную блокировку файла.
- `fcntl.lockf(fd, cmd, len=0, start=0, whence=0)` - блокировка части файла.

**Примеры:**
```python
import fcntl
import os

# Блокировка файла для эксклюзивного доступа
def lock_file(file_path):
    # Открываем файл
    fd = os.open(file_path, os.O_WRONLY | os.O_CREAT)
    try:
        # Устанавливаем эксклюзивную блокировку
        fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        print("Файл успешно заблокирован")
        
        # Здесь код для работы с файлом
        
        # Снимаем блокировку
        fcntl.flock(fd, fcntl.LOCK_UN)
    except IOError:
        print("Файл уже заблокирован другим процессом")
    finally:
        os.close(fd)

# Пример блокировки с использованием стандартных файловых объектов
def lock_file_with_open(file_path):
    with open(file_path, 'w') as f:
        try:
            fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            print("Файл успешно заблокирован")
            # Работа с файлом
        except IOError:
            print("Не удалось получить блокировку")
        finally:
            # Блокировка автоматически снимается при закрытии файла
            pass

# Установка флагов файлового дескриптора
def set_file_flags(file_path):
    with open(file_path, 'w') as f:
        # Получение текущих флагов
        flags = fcntl.fcntl(f.fileno(), fcntl.F_GETFL)
        
        # Установка флага O_NONBLOCK
        fcntl.fcntl(f.fileno(), fcntl.F_SETFL, flags | os.O_NONBLOCK)
        
        # Теперь файл открыт в неблокирующем режиме
```

**Особенности для senior-разработчиков:**
- Модуль `fcntl` доступен только в Unix-подобных системах. В Windows аналогичная функциональность может быть достигнута через `win32file` или другие модули.
- Блокировки с помощью `flock` являются консультативными, то есть другие процессы могут игнорировать их, если явно не проверяют наличие блокировки.
- `LOCK_NB` делает операцию блокировки неблокирующей - вместо ожидания освобождения ресурса вызывается исключение.
- Различайте `flock` (блокировка всего файла) и `lockf` (блокировка части файла). Они могут по-разному взаимодействовать в разных системах.
- При работе с низкоуровневыми файловыми операциями всегда обеспечивайте корректное закрытие файловых дескрипторов, чтобы избежать утечек ресурсов.
- `fcntl` редко используется в высокоуровневом Python-коде; обычно существуют более переносимые аналоги для решения задач многопроцессной синхронизации.