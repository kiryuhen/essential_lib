# Паттерн Proxy (Заместитель)

## Описание
Заместитель — это структурный паттерн проектирования, который предоставляет объект-заместитель для другого объекта и контролирует доступ к нему. Заместитель может выполнять множество полезных задач: контроль доступа, кэширование, ленивую инициализацию, протоколирование и т.д.

## Проблема
Необходимо контролировать доступ к объекту, добавлять функциональность до/после основного действия или откладывать создание тяжёлых объектов до момента реального использования.

## Решение
Паттерн Заместитель предлагает создать класс, который реализует тот же интерфейс, что и оригинальный объект, но выполняет дополнительные функции перед или после перенаправления вызова к оригинальному объекту.

## Структура
- **Subject** — интерфейс, описывающий общие методы для RealSubject и Proxy
- **RealSubject** — реальный объект, выполняющий основную работу
- **Proxy** — заместитель, контролирующий доступ к RealSubject и добавляющий дополнительные функции

## Пример на Python

```python
from abc import ABC, abstractmethod

# Subject
class Subject(ABC):
    @abstractmethod
    def request(self) -> None:
        pass

# Real Subject
class RealSubject(Subject):
    def request(self) -> None:
        print("RealSubject: Handling request.")

# Proxy
class Proxy(Subject):
    def __init__(self, real_subject: RealSubject) -> None:
        self._real_subject = real_subject
    
    def request(self) -> None:
        if self.check_access():
            self._real_subject.request()
            self.log_access()
    
    def check_access(self) -> bool:
        print("Proxy: Checking access prior to firing a real request.")
        return True
    
    def log_access(self) -> None:
        print("Proxy: Logging the time of request.")
```

## Применение
В реальных приложениях Заместитель часто используется для:
- Ленивой инициализации (создание объекта только при первом обращении)
- Контроля доступа (проверка прав перед выполнением операции)
- Кэширования (сохранение результатов запросов для повторного использования)
- Локального выполнения удалённых сервисов (RPC, REST API)
- Логирования (запись информации о вызовах методов)
- "Умных" ссылок (подсчёт ссылок, автоматическое освобождение ресурсов)

## Плюсы
1. Контроль над оригинальным объектом без изменения клиентского кода
2. Управление жизненным циклом объектов (ленивая загрузка)
3. Работа с объектом даже когда он недоступен или не существует
4. Добавление новой функциональности во время выполнения (прокси-декоратор)
5. Разделение кода доступа к удаленному объекту от основной логики

## Минусы
1. Усложнение кода из-за введения дополнительных классов
2. Задержка отклика от сервиса (из-за дополнительного слоя)
3. Некоторые клиенты могут быть чувствительны к задержкам, вызванным прокси
4. Реализация некоторых типов прокси может быть сложной (например, удаленный прокси)

## Когда использовать
- Когда требуется ленивая инициализация тяжелых объектов при первом обращении
- Когда необходим контроль доступа к объекту (защитный прокси)
- При работе с удаленными сервисами (удаленный прокси)
- Для реализации локального кэша для дорогостоящих операций (кэширующий прокси)
- Для добавления дополнительной логики при обращении к объекту (логирующий прокси)
- При работе с виртуальными объектами, которые требуют отложенной инициализации