# Middleware в Python

## Содержание
- [Введение](#введение)
- [Middleware в Django](#middleware-в-django)
- [Middleware в Flask](#middleware-в-flask)
- [Middleware в FastAPI](#middleware-в-fastapi)
- [WSGI Middleware](#wsgi-middleware)
- [ASGI Middleware](#asgi-middleware)
- [Межсекторные задачи](#межсекторные-задачи)
- [Паттерны проектирования Middleware](#паттерны-проектирования-middleware)
- [Производительность](#производительность)
- [Сравнительный анализ](#сравнительный-анализ)
- [Лучшие практики](#лучшие-практики)
- [Подводные камни](#подводные-камни)
- [Полезные ресурсы](#полезные-ресурсы)

## Введение

Middleware (промежуточное программное обеспечение) — это компоненты, которые располагаются между веб-сервером и приложением, перехватывая HTTP-запросы и ответы для выполнения различных функций, таких как аутентификация, кэширование, обработка сессий, CORS и многое другое. В контексте веб-фреймворков Python, middleware позволяет добавлять дополнительное поведение к обработке HTTP-запросов и ответов глобально, не изменяя каждый обработчик запросов (view) по отдельности.

### Ключевые концепции

1. **Обработка запросов/ответов** — middleware может изменять входящие запросы перед их обработкой приложением и исходящие ответы перед отправкой клиенту.

2. **Порядок выполнения** — middleware выполняются в определенном порядке, который может быть критически важен для правильной работы приложения.

3. **Глобальное применение** — middleware применяется ко всем или выбранным запросам, обеспечивая консистентное поведение.

4. **Цепочка ответственности** — запрос проходит через цепочку middleware, причем каждый компонент может прервать цепочку или продолжить обработку.

### Основные применения

- **Аутентификация и авторизация** — проверка подлинности пользователя и его прав доступа
- **Логирование и мониторинг** — запись информации о запросах и ответах
- **Кэширование** — сохранение результатов для повторного использования
- **Компрессия** — сжатие ответов для уменьшения трафика
- **Обработка сессий** — управление состоянием пользователя
- **CORS (Cross-Origin Resource Sharing)** — управление доступом к ресурсам с разных источников
- **CSRF-защита** — предотвращение атак подделки межсайтовых запросов
- **Безопасность** — добавление заголовков безопасности и проверка запросов
- **Модификация контента** — изменение содержимого запросов или ответов

## Middleware в Django

Django предоставляет мощную систему middleware с четко определенными хуками для обработки различных этапов запроса и ответа.

### Настройка и порядок выполнения

В Django middleware настраивается в списке `MIDDLEWARE` в настройках проекта:

```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'myapp.middleware.custom_middleware.CustomMiddleware',  # Пользовательский middleware
]
```

**Порядок выполнения:**
1. Входящий запрос обрабатывается middleware по порядку (сверху вниз)
2. Представление (view) обрабатывает запрос
3. Исходящий ответ обрабатывается middleware в обратном порядке (снизу вверх)

### Встроенные middleware

Django включает несколько встроенных middleware для решения распространенных задач:

#### SecurityMiddleware

Реализует различные улучшения безопасности, включая HTTPS-перенаправление, HSTS, XSS-защиту и т.д.

```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # ...
]

# Настройки безопасности
SECURE_SSL_REDIRECT = True  # Перенаправление на HTTPS
SECURE_HSTS_SECONDS = 31536000  # Включение HSTS
SECURE_CONTENT_TYPE_NOSNIFF = True  # Предотвращение MIME-сниффинга
SECURE_BROWSER_XSS_FILTER = True  # XSS-защита в браузере
```

#### SessionMiddleware

Обрабатывает сессии для запросов, делая объект `request.session` доступным в представлениях.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.contrib.sessions.middleware.SessionMiddleware',
    # ...
]

# Настройки сессий
SESSION_ENGINE = 'django.contrib.sessions.backends.db'  # Хранение в БД
SESSION_COOKIE_AGE = 1209600  # 2 недели (в секундах)
SESSION_COOKIE_SECURE = True  # Только для HTTPS
SESSION_COOKIE_HTTPONLY = True  # Недоступно для JavaScript
```

#### CommonMiddleware

Обрабатывает общие задачи, такие как добавление слеша в URL, обработка заголовка Host и т.д.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.middleware.common.CommonMiddleware',
    # ...
]

APPEND_SLASH = True  # Автоматическое добавление / в конце URL
USE_ETAGS = True  # Использование ETag для кэширования
```

#### CsrfViewMiddleware

Обеспечивает защиту от CSRF-атак, проверяя CSRF-токены в запросах.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.middleware.csrf.CsrfViewMiddleware',
    # ...
]

# В шаблонах
{% csrf_token %}

# Для исключения отдельных представлений
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def my_view(request):
    # ...
```

#### AuthenticationMiddleware

Связывает пользователей с запросами, делая `request.user` доступным в представлениях.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    # ...
]

# В представлениях
def my_view(request):
    if request.user.is_authenticated:
        # Пользователь авторизован
        username = request.user.username
    else:
        # Пользователь анонимный
        pass
```

#### MessageMiddleware

Обрабатывает временные сообщения для передачи информации между запросами.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.contrib.messages.middleware.MessageMiddleware',
    # ...
]

# В представлениях
from django.contrib import messages

def my_view(request):
    # Добавление сообщения
    messages.success(request, "Операция выполнена успешно!")
    
    # В шаблоне
    # {% for message in messages %}
    #     <div class="alert alert-{{ message.tags }}">{{ message }}</div>
    # {% endfor %}
```

#### XFrameOptionsMiddleware

Защищает от clickjacking-атак с помощью заголовка X-Frame-Options.

```python
# settings.py
MIDDLEWARE = [
    # ...
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # ...
]

X_FRAME_OPTIONS = 'DENY'  # Запрещает любое фреймирование
# или
X_FRAME_OPTIONS = 'SAMEORIGIN'  # Разрешает фреймирование только на том же домене
```

### Создание пользовательского middleware

В Django есть два способа создания middleware: функциональный и классовый.

#### Функциональный middleware

```python
# myapp/middleware/function_middleware.py
def simple_middleware(get_response):
    """
    Функциональный middleware получает get_response функцию 
    и возвращает функцию middleware.
    """
    # Код для выполнения при инициализации middleware
    print("Middleware initialized")
    
    def middleware(request):
        # Код для выполнения перед представлением (на входящем запросе)
        print(f"Processing request: {request.path}")
        
        # Вызов следующего middleware в цепочке
        response = get_response(request)
        
        # Код для выполнения после представления (на исходящем ответе)
        print(f"Processing response for: {request.path}")
        
        return response
    
    return middleware
```

#### Классовый middleware

```python
# myapp/middleware/class_middleware.py
class SimpleMiddleware:
    """
    Классовый middleware должен определять метод __init__ для инициализации
    и метод __call__ для обработки запросов.
    """
    def __init__(self, get_response):
        self.get_response = get_response
        # Инициализация, выполняется один раз при запуске сервера
        print("Middleware class initialized")
    
    def __call__(self, request):
        # Код для выполнения перед представлением
        print(f"Class middleware processing request: {request.path}")
        
        # Вызов следующего middleware в цепочке
        response = self.get_response(request)
        
        # Код для выполнения после представления
        print(f"Class middleware processing response for: {request.path}")
        
        return response
```

#### Регистрация middleware

```python
# settings.py
MIDDLEWARE = [
    # ...
    'myapp.middleware.function_middleware.simple_middleware',
    'myapp.middleware.class_middleware.SimpleMiddleware',
    # ...
]
```

### Хуки middleware в Django

Классовые middleware могут определять дополнительные методы для перехвата конкретных этапов обработки запроса и ответа:

```python
class AdvancedMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Базовая обработка запрос-ответ
        response = self.get_response(request)
        return response
    
    def process_view(self, request, view_func, view_args, view_kwargs):
        """
        Вызывается перед выполнением представления, после обработки запроса.
        Можно вернуть None (для продолжения обработки) или HttpResponse.
        """
        print(f"Processing view: {view_func.__name__}")
        return None
    
    def process_exception(self, request, exception):
        """
        Вызывается при возникновении исключения в представлении.
        Можно вернуть None (для стандартной обработки) или HttpResponse.
        """
        print(f"Exception occurred: {exception}")
        return None
    
    def process_template_response(self, request, response):
        """
        Вызывается для ответов с атрибутом render().
        Должен вернуть объект ответа с методом render().
        """
        print("Processing template response")
        return response
```

### Примеры пользовательских middleware

#### Логирование запросов

```python
import time
import logging

logger = logging.getLogger(__name__)

class RequestLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Начало обработки запроса
        start_time = time.time()
        
        # Логирование информации о запросе
        logger.info(f"Request: {request.method} {request.path} from {request.META.get('REMOTE_ADDR')}")
        
        # Обработка запроса
        response = self.get_response(request)
        
        # Расчет времени обработки
        duration = time.time() - start_time
        
        # Логирование информации о ответе
        logger.info(f"Response: {response.status_code} in {duration:.2f}s")
        
        return response
```

#### Ограничение скорости запросов

```python
import time
from django.core.cache import cache
from django.http import HttpResponse

class RateLimitMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.rate_limit = 100  # Запросов в минуту
        self.window = 60  # Окно в секундах
        
    def __call__(self, request):
        # Получение IP-адреса клиента
        ip_address = request.META.get('REMOTE_ADDR')
        
        # Формирование ключа кэша для этого IP
        cache_key = f"rate_limit:{ip_address}"
        
        # Получение счетчика запросов из кэша
        requests_history = cache.get(cache_key, [])
        
        # Фильтрация истории запросов по времени
        current_time = time.time()
        requests_history = [t for t in requests_history if current_time - t < self.window]
        
        # Проверка лимита
        if len(requests_history) >= self.rate_limit:
            return HttpResponse("Rate limit exceeded. Try again later.", status=429)
        
        # Добавление текущего запроса в историю
        requests_history.append(current_time)
        
        # Обновление кэша
        cache.set(cache_key, requests_history, self.window)
        
        # Обработка запроса
        return self.get_response(request)
```

#### Инъекция контекста пользователя

```python
from django.contrib.auth.models import AnonymousUser
from django.utils.deprecation import MiddlewareMixin
import jwt

class JWTAuthMiddleware(MiddlewareMixin):
    def process_request(self, request):
        # Инициализация пользователя как анонимного
        request.user = AnonymousUser()
        
        # Получение токена из заголовка
        auth_header = request.META.get('HTTP_AUTHORIZATION', '')
        
        if auth_header.startswith('Bearer '):
            # Извлечение токена
            token = auth_header.split(' ')[1]
            
            try:
                # Декодирование JWT-токена
                payload = jwt.decode(
                    token, 
                    'your-secret-key',  # В реальном приложении использовать настройки
                    algorithms=['HS256']
                )
                
                # Получение пользователя из базы данных
                from django.contrib.auth import get_user_model
                User = get_user_model()
                
                user_id = payload.get('user_id')
                if user_id:
                    request.user = User.objects.get(id=user_id)
            except (jwt.InvalidTokenError, User.DoesNotExist):
                # В случае ошибки оставляем пользователя анонимным
                pass
```

#### Коррекция содержимого ответа

```python
import re
from django.utils.deprecation import MiddlewareMixin

class ContentReplacementMiddleware(MiddlewareMixin):
    def process_response(self, request, response):
        # Проверяем, что ответ содержит HTML
        if response.get('Content-Type', '').startswith('text/html'):
            # Получаем контент
            content = response.content.decode('utf-8')
            
            # Выполняем замену (пример: замена внутренних URL на абсолютные)
            content = re.sub(
                r'href=["\'](/[^"\']+)["\']',
                r'href="https://example.com\1"',
                content
            )
            
            # Обновляем контент ответа
            response.content = content.encode('utf-8')
            
            # Обновляем Content-Length заголовок
            response['Content-Length'] = len(response.content)
            
        return response
```

## Middleware в Flask

В отличие от Django, Flask не имеет встроенной системы middleware. Вместо этого он предлагает несколько альтернативных механизмов для достижения аналогичной функциональности: декораторы перед/после запроса, WSGI middleware и расширения.

### Декораторы перед и после запроса

Flask позволяет регистрировать функции, которые выполняются до и после каждого запроса, что концептуально похоже на middleware.

```python
from flask import Flask, request, g

app = Flask(__name__)

@app.before_request
def before_request():
    """Выполняется перед каждым запросом."""
    print(f"Processing request: {request.path}")
    # Сохранение данных в контексте запроса (g)
    g.start_time = time.time()

@app.after_request
def after_request(response):
    """
    Выполняется после каждого запроса, но перед отправкой ответа клиенту.
    Получает и должен вернуть объект ответа.
    """
    # Вычисление времени обработки
    duration = time.time() - g.get('start_time', 0)
    
    # Добавление заголовка в ответ
    response.headers['X-Processing-Time'] = str(duration)
    
    print(f"Request processed in {duration:.2f}s")
    
    return response

@app.teardown_request
def teardown_request(exception=None):
    """
    Выполняется после запроса, даже если произошло исключение.
    Используется для закрытия ресурсов.
    """
    if exception:
        print(f"Exception during request: {exception}")
    
    # Закрытие соединений с БД и т.д.
    # db.close()
```

### WSGI middleware в Flask

Flask-приложения реализуют WSGI-интерфейс, что позволяет применять к ним WSGI-middleware.

```python
from flask import Flask
from werkzeug.middleware.proxy_fix import ProxyFix

app = Flask(__name__)

# Применение WSGI middleware для исправления заголовков при работе за прокси
app.wsgi_app = ProxyFix(
    app.wsgi_app, 
    x_for=1,      # Количество прокси для X-Forwarded-For
    x_proto=1,    # Количество прокси для X-Forwarded-Proto
    x_host=1,     # Количество прокси для X-Forwarded-Host
    x_port=1,     # Количество прокси для X-Forwarded-Port
    x_prefix=1    # Количество прокси для X-Forwarded-Prefix
)

@app.route('/')
def index():
    return 'Hello, World!'
```

#### Создание собственного WSGI middleware для Flask

```python
from flask import Flask, request
import time

class TimingMiddleware:
    """
    WSGI middleware для измерения времени обработки запросов.
    """
    def __init__(self, app):
        self.app = app
    
    def __call__(self, environ, start_response):
        # Засекаем время начала обработки
        start_time = time.time()
        
        # Определяем свою функцию start_response для перехвата заголовков
        def custom_start_response(status, headers, exc_info=None):
            # Добавляем заголовок с временем обработки
            duration = time.time() - start_time
            headers.append(('X-Processing-Time', str(duration)))
            
            # Вызываем оригинальную функцию
            return start_response(status, headers, exc_info)
        
        # Вызываем приложение с нашей функцией start_response
        return self.app(environ, custom_start_response)

# Применение middleware к Flask-приложению
app = Flask(__name__)
app.wsgi_app = TimingMiddleware(app.wsgi_app)
```

### Имитация middleware с помощью классов

```python
from flask import Flask, request, g
from functools import wraps
import time

class FlaskMiddleware:
    """
    Базовый класс для реализации middleware-подобной функциональности во Flask.
    """
    def __init__(self, app):
        self.app = app
        self.init_app(app)
    
    def init_app(self, app):
        """Инициализация приложения и регистрация обработчиков."""
        app.before_request(self.before_request)
        app.after_request(self.after_request)
        app.teardown_request(self.teardown_request)
    
    def before_request(self):
        """Выполняется перед запросом."""
        pass
    
    def after_request(self, response):
        """Выполняется после запроса."""
        return response
    
    def teardown_request(self, exception):
        """Выполняется при завершении запроса."""
        pass

# Пример middleware для логирования
class LoggingMiddleware(FlaskMiddleware):
    def before_request(self):
        g.start_time = time.time()
        print(f"Request: {request.method} {request.path}")
    
    def after_request(self, response):
        duration = time.time() - g.start_time
        print(f"Response: {response.status_code} in {duration:.2f}s")
        return response

# Применение middleware
app = Flask(__name__)
logging_middleware = LoggingMiddleware(app)
```

### Расширения Flask как альтернатива middleware

Многие задачи, которые в Django решаются с помощью middleware, во Flask реализуются через расширения.

```python
from flask import Flask
from flask_cors import CORS
from flask_compress import Compress
from flask_talisman import Talisman

app = Flask(__name__)

# CORS middleware
CORS(app, resources={r"/api/*": {"origins": "example.com"}})

# Compression middleware
Compress(app)

# Security headers middleware
Talisman(
    app,
    content_security_policy={
        'default-src': "'self'",
        'img-src': '*',
        'script-src': ["'self'", "'unsafe-inline'"]
    },
    force_https=True
)
```

### Декораторы для фильтрации запросов

Еще один метод реализации middleware-подобной функциональности во Flask — использование декораторов функций представлений.

```python
from flask import Flask, request, abort
from functools import wraps
import time

app = Flask(__name__)

# Декоратор для проверки API-ключа
def require_api_key(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if not api_key or api_key != 'valid-api-key':
            abort(401)  # Unauthorized
        return f(*args, **kwargs)
    return decorated

# Декоратор для ограничения частоты запросов
def rate_limit(limit=100, window=60):
    def decorator(f):
        # Словарь для хранения истории запросов
        requests = {}
        
        @wraps(f)
        def decorated(*args, **kwargs):
            # IP-адрес клиента
            ip = request.remote_addr
            
            # Текущее время
            now = time.time()
            
            # Инициализация истории запросов для IP
            if ip not in requests:
                requests[ip] = []
            
            # Фильтрация устаревших записей
            requests[ip] = [t for t in requests[ip] if now - t < window]
            
            # Проверка лимита
            if len(requests[ip]) >= limit:
                abort(429)  # Too Many Requests
            
            # Добавление текущего запроса
            requests[ip].append(now)
            
            return f(*args, **kwargs)
        return decorated
    return decorator

# Применение декораторов к маршрутам
@app.route('/api/data')
@require_api_key
@rate_limit(limit=10, window=60)
def get_data():
    return {'data': 'example'}
```

## Middleware в FastAPI

FastAPI построен на Starlette и поддерживает как стандартные ASGI middleware, так и собственную систему зависимостей (dependencies) для обработки запросов.

### Встроенные middleware

FastAPI предоставляет доступ к нескольким встроенным middleware через Starlette:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app = FastAPI()

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://example.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Gzip compression middleware
app.add_middleware(GZipMiddleware, minimum_size=1000)

# HTTPS redirect middleware
app.add_middleware(HTTPSRedirectMiddleware)

# Trusted host middleware
app.add_middleware(
    TrustedHostMiddleware, 
    allowed_hosts=["example.com", "*.example.com"]
)
```

### Создание пользовательского middleware

#### Классический ASGI middleware

```python
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.requests import Request
from starlette.responses import Response
import time

class TimingMiddleware(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        # Время начала обработки
        start_time = time.time()
        
        # Обработка запроса и получение ответа
        response = await call_next(request)
        
        # Вычисление времени обработки
        process_time = time.time() - start_time
        
        # Добавление заголовка
        response.headers["X-Process-Time"] = str(process_time)
        
        return response

app = FastAPI()
app.add_middleware(TimingMiddleware)
```

#### Middleware с параметрами

```python
from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging

logger = logging.getLogger(__name__)

class LoggingMiddleware(BaseHTTPMiddleware):
    def __init__(
        self, 
        app,
        log_level=logging.INFO,
        exclude_paths=None
    ):
        super().__init__(app)
        self.log_level = log_level
        self.exclude_paths = exclude_paths or []
    
    async def dispatch(self, request: Request, call_next):
        # Проверка, нужно ли логировать этот путь
        path = request.url.path
        if any(path.startswith(exclude) for exclude in self.exclude_paths):
            # Пропуск логирования для исключенных путей
            return await call_next(request)
        
        # Время начала обработки
        start_time = time.time()
        
        # Логирование запроса
        logger.log(
            self.log_level,
            f"Request: {request.method} {request.url.path} from {request.client.host}"
        )
        
        # Обработка запроса
        try:
            response = await call_next(request)
            
            # Вычисление времени обработки
            process_time = time.time() - start_time
            
            # Логирование ответа
            logger.log(
                self.log_level,
                f"Response: {response.status_code} in {process_time:.2f}s"
            )
            
            return response
        except Exception as e:
            # Логирование ошибок
            logger.error(f"Error during request processing: {e}")
            raise

app = FastAPI()
app.add_middleware(
    LoggingMiddleware,
    log_level=logging.DEBUG,
    exclude_paths=["/health", "/metrics"]
)
```

#### Middleware с асинхронными операциями

```python
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware
import aiohttp
import asyncio

class ExternalAPIMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.session = None
    
    async def dispatch(self, request: Request, call_next):
        # Ленивая инициализация сессии
        if self.session is None:
            self.session = aiohttp.ClientSession()
        
        # Асинхронный запрос к внешнему API
        try:
            async with self.session.get("https://api.example.com/status") as resp:
                api_status = await resp.json()
                
                # Сохранение статуса API в состоянии запроса
                request.state.api_status = api_status
        except Exception as e:
            # В случае ошибки установка значения по умолчанию
            request.state.api_status = {"status": "unknown", "error": str(e)}
        
        # Продолжение обработки запроса
        response = await call_next(request)
        return response
    
    async def __del__(self):
        # Закрытие сессии при уничтожении объекта
        if self.session is not None:
            await self.session.close()

app = FastAPI()
app.add_middleware(ExternalAPIMiddleware)

@app.get("/status")
async def status(request: Request):
    return {
        "app_status": "ok",
        "external_api_status": request.state.api_status
    }
```

### Middleware vs Dependencies

FastAPI предлагает два подхода к перехвату запросов: middleware и зависимости (dependencies). Важно понимать различия между ними:

#### Middleware:
- Выполняется для всех запросов (или по шаблону URL)
- Имеет доступ к необработанному запросу и ответу
- Может модифицировать как запрос, так и ответ
- Выполняется до и после запроса
- Подходит для глобальных операций (логирование, CORS, аутентификация)

#### Dependencies:
- Привязаны к конкретным путям или параметрам
- Интегрированы с системой типов и валидацией
- Могут возвращать данные для использования в обработчиках
- Подходят для логики, специфичной для отдельных эндпоинтов

```python
from fastapi import FastAPI, Depends, HTTPException, Header, Request
from typing import Optional

app = FastAPI()

# Middleware для всех запросов
@app.middleware("http")
async def add_correlation_id(request: Request, call_next):
    # Генерация ID для отслеживания запроса
    import uuid
    correlation_id = str(uuid.uuid4())
    
    # Сохранение ID в состоянии запроса
    request.state.correlation_id = correlation_id
    
    # Обработка запроса
    response = await call_next(request)
    
    # Добавление ID в заголовок ответа
    response.headers["X-Correlation-ID"] = correlation_id
    
    return response

# Зависимость для конкретных эндпоинтов
async def verify_api_key(x_api_key: Optional[str] = Header(None)):
    if x_api_key is None or x_api_key != "valid-api-key":
        raise HTTPException(status_code=401, detail="Invalid API Key")
    return x_api_key

# Использование зависимости
@app.get("/api/secured")
async def secured_endpoint(api_key: str = Depends(verify_api_key)):
    return {"message": "Authentication successful"}

# Доступ к данным из middleware через request.state
@app.get("/api/tracking")
async def tracking(request: Request):
    return {"correlation_id": request.state.correlation_id}
```

## WSGI Middleware

WSGI (Web Server Gateway Interface) — стандартный интерфейс между веб-серверами и Python-приложениями. WSGI middleware находятся между сервером и приложением, обрабатывая запросы и ответы.

### Основы WSGI

WSGI-приложение — это вызываемый объект, который принимает два аргумента:
1. `environ` — словарь с переменными окружения, включая HTTP-заголовки
2. `start_response` — функция для начала отправки ответа

```python
def simple_wsgi_app(environ, start_response):
    """
    Простое WSGI-приложение, которое возвращает Hello World.
    """
    # Подготовка ответа
    status = '200 OK'
    headers = [('Content-Type', 'text/plain')]
    
    # Начало ответа
    start_response(status, headers)
    
    # Возврат тела ответа (должно быть итерируемым)
    return [b'Hello, World!']
```

### Создание WSGI middleware

```python
def logging_middleware(app):
    """
    WSGI middleware для логирования запросов и ответов.
    
    Args:
        app: WSGI-приложение, которое нужно обернуть
    
    Returns:
        WSGI-приложение с добавленным логированием
    """
    def middleware(environ, start_response):
        # Логирование запроса
        path = environ.get('PATH_INFO', '/')
        method = environ.get('REQUEST_METHOD', 'GET')
        print(f"Request: {method} {path}")
        
        # Перехват функции start_response для логирования ответа
        def custom_start_response(status, headers, exc_info=None):
            print(f"Response: {status}")
            return start_response(status, headers, exc_info)
        
        # Вызов оригинального приложения
        return app(environ, custom_start_response)
    
    return middleware
```

### Примеры WSGI middleware

#### Middleware для CORS

```python
def cors_middleware(app, allowed_origins=None, allowed_methods=None):
    """
    WSGI middleware для обработки CORS (Cross-Origin Resource Sharing).
    """
    allowed_origins = allowed_origins or ['*']
    allowed_methods = allowed_methods or ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
    
    def middleware(environ, start_response):
        # Получение заголовков запроса
        origin = environ.get('HTTP_ORIGIN')
        
        # Проверка метода OPTIONS (предварительный запрос)
        if environ.get('REQUEST_METHOD') == 'OPTIONS':
            # Подготовка ответа на предварительный запрос
            headers = [
                ('Access-Control-Allow-Origin', origin if origin in allowed_origins or '*' in allowed_origins else ''),
                ('Access-Control-Allow-Methods', ', '.join(allowed_methods)),
                ('Access-Control-Allow-Headers', 'Content-Type, Authorization'),
                ('Access-Control-Max-Age', '86400'),  # 24 часа
                ('Content-Type', 'text/plain'),
                ('Content-Length', '0')
            ]
            start_response('200 OK', headers)
            return [b'']
        
        # Вспомогательная функция для добавления CORS-заголовков
        def cors_start_response(status, headers, exc_info=None):
            # Добавление CORS-заголовков для обычных запросов
            if origin in allowed_origins or '*' in allowed_origins:
                headers.append(('Access-Control-Allow-Origin', origin))
            
            return start_response(status, headers, exc_info)
        
        # Обработка обычного запроса
        return app(environ, cors_start_response)
    
    return middleware
```

#### Middleware для аутентификации

```python
import base64

def basic_auth_middleware(app, username, password, realm="Restricted"):
    """
    WSGI middleware для Basic Authentication.
    """
    # Кодирование комбинации логин:пароль
    credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
    
    def middleware(environ, start_response):
        # Получение заголовка Authorization
        auth_header = environ.get('HTTP_AUTHORIZATION', '')
        
        # Проверка формата и учетных данных
        if auth_header.startswith('Basic ') and auth_header[6:] == credentials:
            # Аутентификация успешна, продолжаем обработку
            return app(environ, start_response)
        
        # Аутентификация не удалась, возвращаем 401
        headers = [
            ('WWW-Authenticate', f'Basic realm="{realm}"'),
            ('Content-Type', 'text/plain'),
            ('Content-Length', '0')
        ]
        start_response('401 Unauthorized', headers)
        return [b'']
    
    return middleware
```

#### Middleware для сжатия ответов

```python
import gzip

def gzip_middleware(app, minimum_size=500):
    """
    WSGI middleware для сжатия ответов с помощью gzip.
    """
    def middleware(environ, start_response):
        # Проверка, поддерживает ли клиент gzip
        accept_encoding = environ.get('HTTP_ACCEPT_ENCODING', '')
        supports_gzip = 'gzip' in accept_encoding
        
        if not supports_gzip:
            # Если gzip не поддерживается, просто вызываем оригинальное приложение
            return app(environ, start_response)
        
        # Получение ответа от приложения
        buffer = []
        
        def buffered_start_response(status, headers, exc_info=None):
            # Сохраняем статус и заголовки
            buffer.append((status, headers))
            # Возвращаем функцию для записи тела ответа
            return lambda x: buffer.append(x)
        
        # Вызов приложения с буферизацией
        iterable = app(environ, buffered_start_response)
        
        # Собираем тело ответа
        body = b''
        for data in iterable:
            body += data
        
        # Закрытие итератора, если поддерживает
        if hasattr(iterable, 'close'):
            iterable.close()
        
        # Получение статуса и заголовков
        status, headers = buffer[0]
        
        # Проверка размера ответа
        if len(body) < minimum_size:
            # Если ответ слишком маленький, не сжимаем
            start_response(status, headers)
            return [body]
        
        # Сжатие тела ответа
        compressed_body = gzip.compress(body)
        
        # Обновление заголовков
        headers = [
            (name, value) for name, value in headers
            if name.lower() != 'content-length'
        ]
        headers.append(('Content-Encoding', 'gzip'))
        headers.append(('Content-Length', str(len(compressed_body))))
        
        # Отправка сжатого ответа
        start_response(status, headers)
        return [compressed_body]
    
    return middleware
```

### Использование WSGI middleware с фреймворками

#### Django с WSGI middleware

```python
# wsgi.py
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

# Получение базового WSGI-приложения Django
application = get_wsgi_application()

# Применение различных middleware
from middleware import logging_middleware, cors_middleware, gzip_middleware

# Оборачивание приложения в middleware (важен порядок)
application = logging_middleware(application)
application = cors_middleware(application, allowed_origins=['https://example.com'])
application = gzip_middleware(application, minimum_size=1000)
```

#### Flask с WSGI middleware

```python
from flask import Flask
from middleware import logging_middleware, cors_middleware, gzip_middleware

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, World!'

# Получение WSGI-приложения Flask
wsgi_app = app.wsgi_app

# Применение middleware
wsgi_app = logging_middleware(wsgi_app)
wsgi_app = cors_middleware(wsgi_app, allowed_origins=['*'])
wsgi_app = gzip_middleware(wsgi_app)

# Обновление WSGI-приложения Flask
app.wsgi_app = wsgi_app
```

## ASGI Middleware

ASGI (Asynchronous Server Gateway Interface) — эволюция WSGI для асинхронной обработки запросов. ASGI middleware похожи на WSGI middleware, но поддерживают асинхронные операции.

### Основы ASGI

ASGI-приложение — это вызываемый объект, который принимает три аргумента:
1. `scope` — словарь с информацией о типе запроса и его параметрах
2. `receive` — асинхронная функция для получения событий
3. `send` — асинхронная функция для отправки событий

```python
async def simple_asgi_app(scope, receive, send):
    """
    Простое ASGI-приложение, которое возвращает Hello World.
    """
    # Проверка типа запроса
    assert scope['type'] == 'http'
    
    # Получение запроса
    event = await receive()
    assert event['type'] == 'http.request'
    
    # Отправка заголовков ответа
    await send({
        'type': 'http.response.start',
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ],
    })
    
    # Отправка тела ответа
    await send({
        'type': 'http.response.body',
        'body': b'Hello, World!',
    })
```

### Создание ASGI middleware

```python
import time

def timing_middleware(app):
    """
    ASGI middleware для измерения времени обработки запросов.
    """
    async def middleware(scope, receive, send):
        # Проверка типа запроса
        if scope['type'] != 'http':
            # Для WebSocket и других типов просто передаем запрос дальше
            return await app(scope, receive, send)
        
        # Время начала обработки
        start_time = time.time()
        
        # Перехватываем функцию send для модификации ответа
        async def custom_send(message):
            if message['type'] == 'http.response.start':
                # Получение времени обработки
                process_time = time.time() - start_time
                
                # Добавление заголовка с временем обработки
                headers = message.get('headers', [])
                headers.append(
                    [b'X-Process-Time', f'{process_time:.6f}'.encode()]
                )
                message['headers'] = headers
            
            # Отправка сообщения
            await send(message)
        
        # Вызов оригинального приложения
        await app(scope, receive, custom_send)
    
    return middleware
```

### Примеры ASGI middleware

#### Middleware для автоматической трассировки запросов

```python
import uuid
from contextvars import ContextVar

# Контекстная переменная для хранения ID запроса
request_id_var = ContextVar('request_id', default=None)

def tracing_middleware(app):
    """
    ASGI middleware для генерации и распространения ID для трассировки запросов.
    """
    async def middleware(scope, receive, send):
        # Проверка типа запроса
        if scope['type'] != 'http':
            return await app(scope, receive, send)
        
        # Генерация ID запроса
        request_id = str(uuid.uuid4())
        
        # Сохранение ID в контекстной переменной
        token = request_id_var.set(request_id)
        
        # Добавление ID в scope для доступа из приложения
        scope['request_id'] = request_id
        
        # Перехват функции send для добавления заголовка
        async def custom_send(message):
            if message['type'] == 'http.response.start':
                headers = message.get('headers', [])
                headers.append([b'X-Request-ID', request_id.encode()])
                message['headers'] = headers
            
            await send(message)
        
        try:
            # Вызов приложения
            await app(scope, receive, custom_send)
        finally:
            # Сброс контекстной переменной
            request_id_var.reset(token)
    
    return middleware
```

#### Middleware для аутентификации с JWT

```python
import jwt
from jwt.exceptions import InvalidTokenError

def jwt_auth_middleware(app, secret_key, algorithm='HS256'):
    """
    ASGI middleware для аутентификации с использованием JWT токенов.
    """
    async def middleware(scope, receive, send):
        # Проверка типа запроса
        if scope['type'] != 'http':
            return await app(scope, receive, send)
        
        # Извлечение заголовка Authorization
        headers = dict(scope.get('headers', []))
        auth_header = headers.get(b'authorization', b'').decode()
        
        # Проверка наличия Bearer токена
        if auth_header.startswith('Bearer '):
            token = auth_header[7:]
            
            try:
                # Декодирование JWT токена
                payload = jwt.decode(token, secret_key, algorithms=[algorithm])
                
                # Добавление пользователя в scope
                scope['user'] = payload
            except InvalidTokenError:
                # В случае ошибки, добавляем информацию об анонимном пользователе
                scope['user'] = {'authenticated': False}
        else:
            # Если токен не предоставлен
            scope['user'] = {'authenticated': False}
        
        # Вызов приложения
        await app(scope, receive, send)
    
    return middleware
```

#### Middleware для обработки исключений

```python
import traceback
import json

def exception_handler_middleware(app):
    """
    ASGI middleware для перехвата и обработки исключений.
    """
    async def middleware(scope, receive, send):
        if scope['type'] != 'http':
            return await app(scope, receive, send)
        
        try:
            # Попытка выполнить приложение
            await app(scope, receive, send)
        except Exception as exc:
            # Логирование исключения
            traceback.print_exc()
            
            # Подготовка ответа с ошибкой
            error_message = f"Internal Server Error: {str(exc)}"
            error_body = json.dumps({
                'error': error_message,
                'status_code': 500
            }).encode()
            
            # Отправка ответа с ошибкой
            await send({
                'type': 'http.response.start',
                'status': 500,
                'headers': [
                    [b'content-type', b'application/json'],
                    [b'content-length', str(len(error_body)).encode()]
                ]
            })
            
            await send({
                'type': 'http.response.body',
                'body': error_body,
                'more_body': False
            })
    
    return middleware
```

### Использование ASGI middleware с фреймворками

#### FastAPI с ASGI middleware

```python
from fastapi import FastAPI
from middleware import timing_middleware, tracing_middleware, exception_handler_middleware

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

# Применение middleware (важен порядок)
app.add_middleware(exception_handler_middleware)
app.add_middleware(tracing_middleware)
app.add_middleware(timing_middleware)
```

#### Starlette с ASGI middleware

```python
from starlette.applications import Starlette
from starlette.responses import JSONResponse
from starlette.routing import Route
from middleware import timing_middleware, tracing_middleware

async def homepage(request):
    return JSONResponse({"message": "Hello, world!"})

routes = [
    Route("/", endpoint=homepage)
]

# Создание приложения
app = Starlette(routes=routes)

# Применение middleware
app = timing_middleware(app)
app = tracing_middleware(app)
```

#### Django с ASGI middleware

```python
# asgi.py
import os
from django.core.asgi import get_asgi_application
from middleware import timing_middleware, tracing_middleware

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

# Получение ASGI-приложения Django
application = get_asgi_application()

# Применение middleware
application = timing_middleware(application)
application = tracing_middleware(application)
```

## Межсекторные задачи

Middleware широко используются для решения межсекторных задач, которые затрагивают все или большинство запросов приложения.

### Аутентификация и авторизация

```python
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import FastAPI, HTTPException
import jwt
from jwt.exceptions import InvalidTokenError

class JWTAuthMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, secret_key, excluded_paths=None):
        super().__init__(app)
        self.secret_key = secret_key
        self.excluded_paths = excluded_paths or ["/docs", "/openapi.json", "/auth/login"]
    
    async def dispatch(self, request, call_next):
        # Проверка исключенных путей
        path = request.url.path
        if any(path.startswith(excluded) for excluded in self.excluded_paths):
            return await call_next(request)
        
        # Получение токена из заголовка
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=401,
                detail="Missing or invalid authentication token",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Извлечение токена
        token = auth_header.split(" ")[1]
        
        try:
            # Декодирование токена
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            
            # Сохранение информации о пользователе
            request.state.user = payload
        except InvalidTokenError as e:
            raise HTTPException(
                status_code=401,
                detail=f"Invalid authentication token: {str(e)}",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Продолжение обработки запроса
        return await call_next(request)

# Использование middleware
app = FastAPI()
app.add_middleware(JWTAuthMiddleware, secret_key="your-secret-key")
```

### Логирование и мониторинг

```python
import time
import uuid
import logging
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware

# Настройка логгера
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("app")

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # Генерация ID запроса
        request_id = str(uuid.uuid4())
        
        # Время начала запроса
        start_time = time.time()
        
        # Логирование запроса
        logger.info(f"Request {request_id} started: {request.method} {request.url.path}")
        
        # Добавление ID к запросу для использования в эндпоинтах
        request.state.request_id = request_id
        
        # Обработка запроса
        try:
            response = await call_next(request)
            
            # Вычисление времени обработки
            process_time = time.time() - start_time
            
            # Логирование успешного ответа
            logger.info(
                f"Request {request_id} completed: {response.status_code} in {process_time:.2f}s"
            )
            
            # Добавление ID запроса в заголовки ответа
            response.headers["X-Request-ID"] = request_id
            
            return response
        except Exception as e:
            # Логирование ошибки
            logger.error(
                f"Request {request_id} failed: {str(e)}",
                exc_info=True
            )
            raise

# Применение middleware
app = FastAPI()
app.add_middleware(RequestLoggingMiddleware)
```

### Управление CORS

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://example.com",
        "https://app.example.com",
        "http://localhost:8080",
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allow_headers=[
        "Authorization",
        "Content-Type",
        "X-Requested-With",
        "Accept",
        "Origin",
        "X-CSRF-Token",
    ],
    expose_headers=[
        "Content-Length",
        "X-Request-ID",
    ],
    max_age=600,  # 10 минут
)
```

### Кэширование ответов

```python
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse
import hashlib
import time

class CacheMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, cache_time=300):
        super().__init__(app)
        self.cache = {}
        self.cache_time = cache_time
    
    async def dispatch(self, request: Request, call_next):
        # Кэширование только GET-запросов
        if request.method != "GET":
            return await call_next(request)
        
        # Создание ключа кэша на основе URL
        cache_key = hashlib.md5(str(request.url).encode()).hexdigest()
        
        # Проверка кэша
        cached_response = self.cache.get(cache_key)
        if cached_response:
            # Проверка свежести кэша
            timestamp, content_type, content = cached_response
            if time.time() - timestamp < self.cache_time:
                # Возврат закэшированного ответа
                return Response(
                    content=content,
                    media_type=content_type,
                    headers={"X-Cache": "Hit"}
                )
        
        # Кэш отсутствует или устарел, получаем новый ответ
        response = await call_next(request)
        
        # Кэшируем только успешные ответы
        if 200 <= response.status_code < 300:
            # Получение тела ответа
            body = b""
            async for chunk in response.body_iterator:
                body += chunk
            
            # Сохранение в кэше
            self.cache[cache_key] = (
                time.time(),
                response.media_type,
                body
            )
            
            # Возврат нового ответа
            return Response(
                content=body,
                status_code=response.status_code,
                headers=dict(response.headers) | {"X-Cache": "Miss"},
                media_type=response.media_type
            )
        
        return response

# Применение middleware
app = FastAPI()
app.add_middleware(CacheMiddleware, cache_time=60)  # Кэширование на 60 секунд
```

### Ограничение скорости запросов

```python
import time
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import FastAPI, Request, HTTPException

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(
        self,
        app,
        limit=100,  # Максимальное количество запросов
        window=60,  # Временное окно в секундах
        by_ip=True  # Ограничение по IP или по токену
    ):
        super().__init__(app)
        self.limit = limit
        self.window = window
        self.by_ip = by_ip
        self.requests = {}
    
    async def dispatch(self, request: Request, call_next):
        # Определение ключа для ограничения (IP или токен)
        if self.by_ip:
            key = request.client.host
        else:
            # Получение токена из заголовка Authorization
            auth_header = request.headers.get("Authorization", "")
            if auth_header.startswith("Bearer "):
                key = auth_header[7:]
            else:
                key = request.client.host
        
        # Текущее время
        now = time.time()
        
        # Инициализация счетчика для ключа
        if key not in self.requests:
            self.requests[key] = []
        
        # Очистка устаревших запросов
        self.requests[key] = [t for t in self.requests[key] if now - t < self.window]
        
        # Проверка лимита
        if len(self.requests[key]) >= self.limit:
            # Расчет времени до сброса лимита
            reset_time = min(self.requests[key]) + self.window - now
            
            # Формирование заголовков для ответа
            headers = {
                "X-RateLimit-Limit": str(self.limit),
                "X-RateLimit-Remaining": "0",
                "X-RateLimit-Reset": str(int(reset_time)),
                "Retry-After": str(int(reset_time))
            }
            
            # Возврат ошибки о превышении лимита
            raise HTTPException(
                status_code=429,
                detail=f"Rate limit exceeded. Try again in {int(reset_time)} seconds.",
                headers=headers
            )
        
        # Добавление текущего запроса
        self.requests[key].append(now)
        
        # Формирование заголовков лимита для ответа
        response = await call_next(request)
        
        # Оставшееся количество запросов
        remaining = self.limit - len(self.requests[key])
        
        # Добавление заголовков
        response.headers["X-RateLimit-Limit"] = str(self.limit)
        response.headers["X-RateLimit-Remaining"] = str(remaining)
        response.headers["X-RateLimit-Reset"] = str(int(now + self.window))
        
        return response

# Применение middleware
app = FastAPI()
app.add_middleware(
    RateLimitMiddleware,
    limit=100,  # 100 запросов
    window=60,  # за 60 секунд
    by_ip=True  # ограничение по IP
)
```

### Управление сессиями

```python
import json
import time
import base64
import uuid
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import FastAPI, Request, Response
import hashlib
import hmac

class SessionMiddleware(BaseHTTPMiddleware):
    def __init__(
        self, 
        app, 
        secret_key, 
        session_cookie="session",
        max_age=86400,  # 24 часа
        https_only=False,
        domain=None,
        same_site="lax"
    ):
        super().__init__(app)
        self.secret_key = secret_key.encode() if isinstance(secret_key, str) else secret_key
        self.session_cookie = session_cookie
        self.max_age = max_age
        self.https_only = https_only
        self.domain = domain
        self.same_site = same_site
    
    def _sign_session(self, data):
        """Подписывает данные сессии для защиты от подделки."""
        payload = base64.b64encode(json.dumps(data).encode())
        signature = hmac.new(
            self.secret_key,
            payload,
            digestmod=hashlib.sha256
        ).hexdigest()
        return f"{payload.decode()}.{signature}"
    
    def _unsign_session(self, cookie_value):
        """Проверяет подпись данных сессии и возвращает исходные данные."""
        try:
            payload, signature = cookie_value.split(".")
            expected_signature = hmac.new(
                self.secret_key,
                payload.encode(),
                digestmod=hashlib.sha256
            ).hexdigest()
            
            if not hmac.compare_digest(signature, expected_signature):
                return {}
            
            return json.loads(base64.b64decode(payload))
        except (ValueError, json.JSONDecodeError):
            return {}
    
    async def dispatch(self, request: Request, call_next):
        # Получение сессии из cookie
        session_cookie = request.cookies.get(self.session_cookie, "")
        session_data = self._unsign_session(session_cookie) if session_cookie else {}
        
        # Проверка срока действия сессии
        expires_at = session_data.get("expires_at", 0)
        if expires_at < time.time():
            session_data = {}
        
        # Сохранение сессии в запросе
        request.state.session = session_data
        
        # Обработка запроса
        response = await call_next(request)
        
        # Получение обновленной сессии
        updated_session = getattr(request.state, "session", session_data)
        
        # Обновление срока действия
        if updated_session:
            updated_session["expires_at"] = time.time() + self.max_age
        
        # Формирование cookie
        if updated_session:
            cookie_value = self._sign_session(updated_session)
            response.set_cookie(
                self.session_cookie,
                cookie_value,
                max_age=self.max_age,
                path="/",
                domain=self.domain,
                secure=self.https_only,
                httponly=True,
                samesite=self.same_site
            )
        elif session_cookie:
            # Удаление cookie, если сессия очищена
            response.delete_cookie(
                self.session_cookie,
                path="/",
                domain=self.domain
            )
        
        return response

# Применение middleware
app = FastAPI()
app.add_middleware(
    SessionMiddleware,
    secret_key="your-secret-key",
    https_only=True,
    max_age=7200  # 2 часа
)

# Пример работы с сессией
@app.get("/login")
async def login(request: Request):
    # Сохранение данных в сессии
    request.state.session["user_id"] = 123
    request.state.session["username"] = "john_doe"
    return {"status": "logged in"}

@app.get("/user")
async def get_user(request: Request):
    # Получение данных из сессии
    user_id = request.state.session.get("user_id")
    username = request.state.session.get("username")
    
    if not user_id:
        return {"status": "not logged in"}
    
    return {"user_id": user_id, "username": username}

@app.get("/logout")
async def logout(request: Request):
    # Очистка сессии
    request.state.session.clear()
    return {"status": "logged out"}
```

## Паттерны проектирования Middleware

Middleware в веб-фреймворках Python реализуют несколько классических паттернов проектирования, которые важно понимать для эффективного использования и создания собственных middleware.

### Паттерн "Цепочка обязанностей" (Chain of Responsibility)

Middleware образуют цепочку обработчиков, где каждый обработчик решает, выполнить свою часть работы и передать запрос дальше или прервать цепочку.

```python
# Абстрактный обработчик
class MiddlewareHandler:
    def __init__(self, next_handler=None):
        self.next_handler = next_handler
    
    def handle(self, request):
        # Обработка запроса
        result = self.process(request)
        
        # Если есть следующий обработчик и результат не None
        if self.next_handler and result is not None:
            return self.next_handler.handle(result)
        
        return result
    
    def process(self, request):
        # Реализуется в конкретных обработчиках
        raise NotImplementedError

# Конкретные обработчики
class AuthenticationHandler(MiddlewareHandler):
    def process(self, request):
        # Проверка аутентификации
        if not request.get('authenticated'):
            return None  # Прерывание цепочки
        
        return request  # Продолжение цепочки

class LoggingHandler(MiddlewareHandler):
    def process(self, request):
        # Логирование запроса
        print(f"Processing request: {request}")
        
        return request  # Продолжение цепочки

class ValidationHandler(MiddlewareHandler):
    def process(self, request):
        # Валидация данных
        if not self.validate(request):
            return None  # Прерывание цепочки
        
        return request  # Продолжение цепочки
    
    def validate(self, request):
        # Реализация валидации
        return True

# Создание и использование цепочки
validation_handler = ValidationHandler()
logging_handler = LoggingHandler(validation_handler)
auth_handler = AuthenticationHandler(logging_handler)

# Обработка запроса через цепочку
request = {'authenticated': True, 'data': {...}}
result = auth_handler.handle(request)
```

### Паттерн "Декоратор" (Decorator)

Middleware оборачивают базовое приложение и друг друга, добавляя дополнительное поведение.

```python
# Базовое приложение
class Application:
    def process(self, request):
        # Обработка запроса
        return {'status': 'success', 'data': {...}}

# Базовый класс для декораторов (middleware)
class MiddlewareDecorator:
    def __init__(self, app):
        self.app = app
    
    def process(self, request):
        # По умолчанию просто делегирует обработку базовому приложению
        return self.app.process(request)

# Конкретные декораторы (middleware)
class AuthMiddleware(MiddlewareDecorator):
    def process(self, request):
        # Проверка аутентификации
        if not request.get('authenticated'):
            return {'status': 'error', 'message': 'Unauthorized'}
        
        # Продолжение обработки
        return self.app.process(request)

class LoggingMiddleware(MiddlewareDecorator):
    def process(self, request):
        # Логирование до обработки
        print(f"Processing request: {request}")
        
        # Обработка запроса
        response = self.app.process(request)
        
        # Логирование после обработки
        print(f"Response: {response}")
        
        return response

# Применение декораторов (middleware)
app = Application()
app_with_auth = AuthMiddleware(app)
app_with_auth_and_logging = LoggingMiddleware(app_with_auth)

# Обработка запроса
request = {'authenticated': True, 'data': {...}}
response = app_with_auth_and_logging.process(request)
```

### Паттерн "Конвейер" (Pipeline)

Middleware организуются в конвейер, где запрос последовательно проходит через ряд обработчиков, которые могут трансформировать запрос и ответ.

```python
class Pipeline:
    def __init__(self):
        self.handlers = []
    
    def add_handler(self, handler):
        """Добавление обработчика в конвейер."""
        self.handlers.append(handler)
        return self
    
    def process(self, request, response=None):
        """Обработка запроса через конвейер."""
        # Прямой проход (обработка запроса)
        current_request = request
        for handler in self.handlers:
            current_request = handler.process_request(current_request)
            if current_request is None:
                return response  # Прерывание конвейера
        
        # Если ответ не предоставлен, создаем на основе запроса
        if response is None:
            response = self.create_response(current_request)
        
        # Обратный проход (обработка ответа)
        current_response = response
        for handler in reversed(self.handlers):
            current_response = handler.process_response(current_request, current_response)
        
        return current_response
    
    def create_response(self, request):
        """Создание ответа на основе запроса."""
        # Реализация зависит от конкретного приложения
        return {'status': 'success'}

# Интерфейс обработчика
class Handler:
    def process_request(self, request):
        """Обработка запроса."""
        return request
    
    def process_response(self, request, response):
        """Обработка ответа."""
        return response

# Конкретные обработчики
class AuthHandler(Handler):
    def process_request(self, request):
        # Проверка аутентификации
        if not request.get('authenticated'):
            return None  # Прерывание конвейера
        return request

class LoggingHandler(Handler):
    def process_request(self, request):
        print(f"Request: {request}")
        return request
    
    def process_response(self, request, response):
        print(f"Response: {response}")
        return response

# Создание и использование конвейера
pipeline = Pipeline()
pipeline.add_handler(LoggingHandler())
pipeline.add_handler(AuthHandler())

# Обработка запроса
request = {'authenticated': True, 'data': {...}}
response = pipeline.process(request)
```

### Паттерн "Интерсептор" (Interceptor)

Middleware перехватывают события в процессе обработки запроса и ответа для добавления специфического поведения.

```python
# Интерфейс интерсептора
class Interceptor:
    def before_request(self, request):
        """Вызывается перед обработкой запроса."""
        return request
    
    def after_request(self, request, response):
        """Вызывается после обработки запроса."""
        return response
    
    def on_exception(self, request, exception):
        """Вызывается при возникновении исключения."""
        return None  # None означает, что исключение не обработано

# Диспетчер интерсепторов
class InterceptorRegistry:
    def __init__(self):
        self.interceptors = []
    
    def add_interceptor(self, interceptor):
        """Добавление интерсептора."""
        self.interceptors.append(interceptor)
        return self
    
    def before_request(self, request):
        """Вызов всех before_request обработчиков."""
        current_request = request
        for interceptor in self.interceptors:
            current_request = interceptor.before_request(current_request)
            if current_request is None:
                break
        return current_request
    
    def after_request(self, request, response):
        """Вызов всех after_request обработчиков."""
        current_response = response
        for interceptor in reversed(self.interceptors):
            current_response = interceptor.after_request(request, current_response)
        return current_response
    
    def on_exception(self, request, exception):
        """Вызов всех on_exception обработчиков."""
        for interceptor in self.interceptors:
            result = interceptor.on_exception(request, exception)
            if result is not None:
                return result  # Исключение обработано
        return None  # Исключение не обработано

# Конкретные интерсепторы
class AuthInterceptor(Interceptor):
    def before_request(self, request):
        # Проверка аутентификации
        if not request.get('authenticated'):
            return None  # Прервать обработку
        return request
    
    def on_exception(self, request, exception):
        if isinstance(exception, AuthenticationError):
            return {'status': 'error', 'message': 'Authentication failed'}
        return None

class LoggingInterceptor(Interceptor):
    def before_request(self, request):
        print(f"Before request: {request}")
        return request
    
    def after_request(self, request, response):
        print(f"After request: {response}")
        return response
    
    def on_exception(self, request, exception):
        print(f"Exception: {exception}")
        return None

# Приложение с использованием интерсепторов
class Application:
    def __init__(self):
        self.interceptor_registry = InterceptorRegistry()
    
    def add_interceptor(self, interceptor):
        self.interceptor_registry.add_interceptor(interceptor)
        return self
    
    def process(self, request):
        try:
            # Вызов before_request интерсепторов
            processed_request = self.interceptor_registry.before_request(request)
            if processed_request is None:
                return {'status': 'error', 'message': 'Request processing aborted'}
            
            # Основная обработка запроса
            response = self.handle_request(processed_request)
            
            # Вызов after_request интерсепторов
            return self.interceptor_registry.after_request(processed_request, response)
        except Exception as e:
            # Вызов on_exception интерсепторов
            error_response = self.interceptor_registry.on_exception(request, e)
            if error_response is not None:
                return error_response
            
            # Если исключение не обработано, пробрасываем дальше
            raise
    
    def handle_request(self, request):
        # Основная логика обработки запроса
        return {'status': 'success', 'data': {...}}

# Использование
app = Application()
app.add_interceptor(LoggingInterceptor())
app.add_interceptor(AuthInterceptor())

# Обработка запроса
request = {'authenticated': True, 'data': {...}}
response = app.process(request)
```

## Производительность

Middleware могут существенно влиять на производительность приложения, поэтому важно учитывать связанные с ними аспекты.

### Порядок middleware

Порядок выполнения middleware критически важен как для функциональности, так и для производительности.

```python
# settings.py в Django
MIDDLEWARE = [
    # Сначала выполняются middleware для обработки заголовков и URL
    'django.middleware.security.SecurityMiddleware',
    'django.middleware.common.CommonMiddleware',
    
    # Затем middleware для аутентификации и сессий
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    
    # Далее middleware для безопасности
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
    # Затем middleware для сообщений и кэширования
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.cache.UpdateCacheMiddleware',
    
    # В конце пользовательские middleware
    'myapp.middleware.custom_middleware.CustomMiddleware',
    
    # Middleware кэширования ответов должен быть последним
    'django.middleware.cache.FetchFromCacheMiddleware',
]
```

Рекомендации по порядку middleware:
1. **Заголовки и параметры запроса** — middleware, обрабатывающие базовые аспекты запроса
2. **Аутентификация и сессии** — middleware, добавляющие информацию о пользователе
3. **Безопасность** — middleware для защиты от атак
4. **Бизнес-логика** — пользовательские middleware
5. **Кэширование ответов** — должно быть последним для кэширования полного ответа

### Профилирование middleware

```python
import time
import cProfile
import pstats
import io
from django.utils.deprecation import MiddlewareMixin

class ProfilingMiddleware(MiddlewareMixin):
    def process_request(self, request):
        # Профилирование только для определенных путей
        if not request.path.startswith('/admin/'):
            request.profiler = cProfile.Profile()
            request.profiler.enable()
        
        # Сохранение времени начала обработки
        request.start_time = time.time()
    
    def process_response(self, request, response):
        # Проверка, был ли запущен профилировщик
        if hasattr(request, 'profiler'):
            # Остановка профилирования
            request.profiler.disable()
            
            # Расчет общего времени
            total_time = time.time() - request.start_time
            
            # Получение статистики профилирования
            s = io.StringIO()
            ps = pstats.Stats(request.profiler, stream=s).sort_stats('cumulative')
            ps.print_stats(20)  # Вывод топ-20 функций по времени
            
            # Логирование результатов
            print(f"\nProfiling for {request.path}:")
            print(f"Total time: {total_time:.4f}s")
            print(s.getvalue())
            
            # Добавление времени в заголовки ответа
            response['X-Processing-Time'] = str(total_time)
        
        return response
```

### Оптимизация тяжелых операций

```python
from functools import lru_cache
import hashlib
from starlette.middleware.base import BaseHTTPMiddleware

class OptimizedAuthMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, secret_key, **options):
        super().__init__(app)
        self.secret_key = secret_key
        self.options = options
        
        # LRU-кэш для токенов
        self.token_cache = lru_cache(maxsize=1000)(self._verify_token)
    
    async def dispatch(self, request, call_next):
        # Получение токена из заголовка
        auth_header = request.headers.get("Authorization", "")
        if auth_header.startswith("Bearer "):
            token = auth_header[7:]
            
            # Проверка токена через кэш
            user_info = self.token_cache(token)
            
            if user_info:
                # Успешная аутентификация, сохранение информации о пользователе
                request.state.user = user_info
            else:
                # Установка анонимного пользователя
                request.state.user = {"authenticated": False}
        else:
            # Установка анонимного пользователя
            request.state.user = {"authenticated": False}
        
        # Обработка запроса
        response = await call_next(request)
        return response
    
    def _verify_token(self, token):
        """
        Проверка токена с возвратом информации о пользователе.
        Эта функция кэшируется с помощью lru_cache.
        """
        try:
            # Дорогостоящая операция проверки токена
            # jwt.decode(token, self.secret_key, algorithms=["HS256"])
            
            # Имитация проверки для примера
            if len(token) < 10:
                return None
            
            # Возврат информации о пользователе
            return {
                "id": int(hashlib.md5(token.encode()).hexdigest(), 16) % 10000,
                "username": f"user_{token[:5]}",
                "authenticated": True
            }
        except Exception:
            return None
```

### Условное применение middleware

```python
from django.utils.deprecation import MiddlewareMixin

class ConditionalMiddleware(MiddlewareMixin):
    def process_request(self, request):
        # Применение middleware только для определенных путей
        if self._should_process(request):
            # Обработка запроса
            print(f"Processing request: {request.path}")
    
    def process_response(self, request, response):
        # Применение middleware только для определенных путей
        if self._should_process(request):
            # Обработка ответа
            print(f"Processing response for: {request.path}")
        
        return response
    
    def _should_process(self, request):
        """Определяет, должен ли middleware обрабатывать запрос."""
        # Проверка метода запроса
        if request.method not in ['GET', 'POST']:
            return False
        
        # Проверка пути
        if request.path.startswith('/static/') or request.path.startswith('/media/'):
            return False
        
        # Проверка параметров запроса
        if request.GET.get('skip_middleware'):
            return False
        
        # Проверка заголовков
        if request.headers.get('X-Skip-Middleware'):
            return False
        
        return True
```

### Асинхронная обработка для неблокирующих операций

```python
import asyncio
from starlette.middleware.base import BaseHTTPMiddleware

class AsyncMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # Запуск асинхронной задачи, не блокирующей основной поток
        task = asyncio.create_task(self.background_task(request))
        
        # Продолжение обработки запроса
        response = await call_next(request)
        
        # Ожидание завершения фоновой задачи
        if not task.done():
            # Установка таймаута для задачи
            try:
                # Ожидание не более 1 секунды
                await asyncio.wait_for(task, timeout=1.0)
            except asyncio.TimeoutError:
                # Отмена задачи при превышении таймаута
                task.cancel()
                print("Background task timed out")
        
        return response
    
    async def background_task(self, request):
        """Фоновая задача, не блокирующая обработку запроса."""
        try:
            # Имитация длительной операции
            await asyncio.sleep(0.5)
            
            # Логирование или другая обработка
            print(f"Background task completed for: {request.url.path}")
        except asyncio.CancelledError:
            # Обработка отмены задачи
            print("Background task was cancelled")
```

## Сравнительный анализ

### Сравнение подходов к middleware в разных фреймворках

| Аспект | Django | Flask | FastAPI |
|--------|--------|-------|---------|
| **Архитектура** | Встроенная система middleware | Расширения или WSGI middleware | ASGI middleware + dependencies |
| **Типизация** | Нет | Нет | Статическая типизация через Pydantic |
| **Сложность реализации** | Средняя | Низкая | Низкая |
| **Гибкость** | Средняя | Высокая | Высокая |
| **Асинхронность** | Ограниченная | Нет | Полная |
| **Производительность** | Хорошая | Хорошая | Отличная |
| **Стандартизация** | Высокая | Низкая | Средняя |
| **Экосистема** | Обширная | Разрозненная | Растущая |
| **Последовательность выполнения** | Строго определена | Определяется разработчиком | Определяется разработчиком |

### Когда использовать middleware vs другие подходы

#### Middleware подходит для:
- Обработки запросов/ответов, затрагивающей все (или многие) эндпоинты
- Глобальных функций, таких как логирование, аутентификация, CORS
- Добавления информации в запрос или ответ
- Перехвата и обработки исключений
- Модификации заголовков запросов/ответов
- Изменения тела ответа

#### Альтернативы middleware для специфических задач:
- **Зависимости (Dependencies) в FastAPI** — для логики, специфичной для отдельных эндпоинтов
- **Декораторы представлений** — для функциональности, которая применяется к отдельным представлениям
- **Сигналы (в Django)** — для событий, не связанных напрямую с обработкой HTTP
- **Hooks (в Flask)** — для обработки событий жизненного цикла приложения
- **ORM Events** — для логики, связанной с операциями базы данных

```python
# FastAPI Dependencies vs Middleware

# Middleware (глобальный)
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Dependency (для конкретных эндпоинтов)
async def verify_token(authorization: str = Header(None)):
    if not authorization:
        raise HTTPException(status_code=401, detail="Token missing")
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid token format")
    
    token = authorization.replace("Bearer ", "")
    # Проверка токена...
    return token

@app.get("/users/me")
async def read_users_me(token: str = Depends(verify_token)):
    # Получение данных пользователя по токену
    return {"token": token, "user_id": "me"}
```

### Выбор между WSGI и ASGI middleware

#### WSGI middleware подходит когда:
- Требуется совместимость с существующими WSGI-серверами
- Нет необходимости в асинхронной обработке
- Проект использует Django < 3.0 или Flask без ASGI-адаптеров
- Нужны хорошо протестированные, зрелые решения

#### ASGI middleware подходит когда:
- Требуется высокая производительность и масштабируемость
- Необходима поддержка WebSockets или HTTP/2
- Проект использует FastAPI, Starlette или асинхронные возможности Django 3.0+
- Важно неблокирующее I/O для сетевых операций

## Лучшие практики

### Общие рекомендации

1. **Принцип единственной ответственности**
   - Каждый middleware должен выполнять только одну задачу
   - Разделяйте сложные middleware на несколько простых

2. **Оптимизация порядка выполнения**
   - Размещайте часто срабатывающие middleware в начале цепочки
   - Middleware, изменяющие ответ, должны идти после изменяющих запрос

3. **Кэширование результатов**
   - Используйте кэширование для дорогостоящих операций
   - Избегайте повторных вычислений при обработке запроса и ответа

4. **Избегайте блокирующих операций**
   - Не выполняйте долгие операции в синхронных middleware
   - Для тяжелых задач используйте асинхронные решения или фоновые задачи

5. **Тщательное тестирование**
   - Пишите юнит-тесты для каждого middleware
   - Тестируйте middleware как отдельно, так и в цепочке

### Структурирование кода middleware

```python
# middleware/base.py
class BaseMiddleware:
    """Базовый класс для всех middleware."""
    
    def __init__(self, get_response):
        self.get_response = get_response
        # Общая инициализация
    
    def __call__(self, request):
        # Общая реализация middleware
        return self.get_response(request)

# middleware/authentication.py
from .base import BaseMiddleware

class JWTAuthMiddleware(BaseMiddleware):
    """Middleware для аутентификации с помощью JWT токенов."""
    
    def __init__(self, get_response, secret_key=None):
        super().__init__(get_response)
        self.secret_key = secret_key or settings.JWT_SECRET_KEY
    
    def __call__(self, request):
        # Специфичная реализация аутентификации
        # ...
        return self.get_response(request)

# settings.py
MIDDLEWARE = [
    # ...
    'myapp.middleware.authentication.JWTAuthMiddleware',
    # ...
]
```

### Обработка исключений

```python
# Безопасная обработка исключений в middleware
class SafeMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        try:
            # Обработка запроса
            response = self.get_response(request)
            return response
        except Exception as e:
            # Логирование ошибки
            logger.exception(f"Error in middleware: {str(e)}")
            
            # Возврат запасного ответа
            return HttpResponse(
                "An error occurred processing your request.",
                status=500
            )
```

### Тестирование middleware

```python
# Django тест для middleware
from django.test import TestCase, RequestFactory
from myapp.middleware.authentication import JWTAuthMiddleware

class JWTAuthMiddlewareTest(TestCase):
    def setUp(self):
        self.factory = RequestFactory()
        
        # Создание mock-функции get_response
        def get_response(request):
            # Имитация ответа от приложения
            response = HttpResponse("Test response")
            return response
        
        self.middleware = JWTAuthMiddleware(get_response)
    
    def test_no_auth_header(self):
        # Создание тестового запроса без заголовка Authorization
        request = self.factory.get('/api/test')
        
        # Проверка, что middleware корректно обрабатывает запрос
        response = self.middleware(request)
        
        # Проверка, что пользователь анонимный
        self.assertFalse(hasattr(request, 'user') or request.user.is_authenticated)
        
        # Проверка, что ответ не изменен
        self.assertEqual(response.content, b"Test response")
    
    def test_valid_token(self):
        # Создание JWT токена
        import jwt
        token = jwt.encode({"user_id": 1}, "secret", algorithm="HS256")
        
        # Создание тестового запроса с заголовком Authorization
        request = self.factory.get('/api/test', HTTP_AUTHORIZATION=f"Bearer {token}")
        
        # Проверка, что middleware корректно обрабатывает запрос
        response = self.middleware(request)
        
        # Проверка, что пользователь аутентифицирован
        self.assertTrue(hasattr(request, 'user') and request.user.is_authenticated)
        self.assertEqual(request.user.id, 1)
        
        # Проверка, что ответ не изменен
        self.assertEqual(response.content, b"Test response")
```

## Подводные камни

### Распространенные проблемы и их решения

#### 1. Порядок middleware влияет на поведение

**Проблема:** Неправильный порядок middleware может привести к неожиданному поведению или ошибкам.

**Решение:**
- Документируйте зависимости между middleware
- Тестируйте различные конфигурации
- Придерживайтесь логической последовательности обработки

```python
# Неправильный порядок (AuthMiddleware не имеет доступа к сессии)
MIDDLEWARE = [
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    # ...
]

# Правильный порядок
MIDDLEWARE = [
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    # ...
]
```

#### 2. Изменение объекта запроса в middleware

**Проблема:** Изменение объекта запроса может привести к непредсказуемым последствиям для других middleware и представлений.

**Решение:**
- Используйте атрибут `request.META` для хранения данных, связанных с запросом
- В Django добавляйте данные в `request.META` или `request._cached_user`
- В FastAPI используйте `request.state` для хранения данных

```python
# Плохой подход (изменение API запроса)
def middleware(request):
    request.custom_data = get_custom_data()  # Изменяет запрос
    return get_response(request)

# Хороший подход (использование стандартных атрибутов)
def middleware(request):
    request.META['CUSTOM_DATA'] = get_custom_data()  # Django
    # или
    request.state.custom_data = get_custom_data()  # FastAPI
    return get_response(request)
```

#### 3. Производительность и накладные расходы

**Проблема:** Избыточное количество middleware или выполнение тяжелых операций в middleware может снизить производительность.

**Решение:**
- Профилируйте middleware для выявления узких мест
- Оптимизируйте тяжелые операции или переместите их в фоновые задачи
- Используйте кэширование для часто запрашиваемых данных
- Применяйте middleware выборочно, только когда это действительно необходимо

```python
# Тяжелая операция в middleware (плохо)
def heavy_middleware(get_response):
    def middleware(request):
        # Тяжелая операция для каждого запроса
        complex_data = perform_complex_calculation()
        request.META['COMPLEX_DATA'] = complex_data
        return get_response(request)
    return middleware

# Оптимизированная версия с кэшированием (лучше)
def optimized_middleware(get_response):
    # Кэширование результатов тяжелых операций
    complex_data_cache = {}
    
    def middleware(request):
        # Использование кэша или вычисление по необходимости
        key = request.user.id if hasattr(request, 'user') else None
        if key not in complex_data_cache:
            complex_data_cache[key] = perform_complex_calculation(key)
        
        request.META['COMPLEX_DATA'] = complex_data_cache[key]
        return get_response(request)
    return middleware
```

#### 4. Обработка исключений и возврат ответов

**Проблема:** Перехват исключений в middleware может скрыть реальную причину ошибки и усложнить отладку.

**Решение:**
- Логируйте все перехваченные исключения с полным стеком вызовов
- Возвращайте информативные сообщения об ошибках
- Используйте специальные коды состояния HTTP для разных типов ошибок

```python
# Плохой подход (скрытие ошибок)
def error_hiding_middleware(get_response):
    def middleware(request):
        try:
            return get_response(request)
        except Exception:
            # Отсутствие логирования и информации об ошибке
            return HttpResponse("Error", status=500)
    return middleware

# Хороший подход (информативная обработка ошибок)
def error_handling_middleware(get_response):
    def middleware(request):
        try:
            return get_response(request)
        except PermissionDenied:
            logger.warning(f"Permission denied for {request.path}", exc_info=True)
            return HttpResponse("Permission denied", status=403)
        except Http404:
            logger.info(f"Not found: {request.path}")
            return HttpResponse("Not found", status=404)
        except Exception as e:
            # Детальное логирование неожиданных ошибок
            logger.critical(f"Unhandled exception: {str(e)}", exc_info=True)
            return HttpResponse("Server error", status=500)
    return middleware
```

#### 5. Утечки памяти в middleware

**Проблема:** Хранение данных в переменных уровня модуля может привести к утечкам памяти.

**Решение:**
- Избегайте хранения данных в глобальных переменных
- Используйте контекстно-зависимые хранилища (например, ContextVar)
- Учитывайте жизненный цикл запроса при кэшировании данных

```python
# Потенциальная утечка памяти
_request_cache = {}  # Глобальная переменная, которая никогда не очищается

def leaky_middleware(get_response):
    def middleware(request):
        # Добавление данных в глобальный кэш без ограничения размера
        _request_cache[request.path] = {'timestamp': time.time()}
        return get_response(request)
    return middleware

# Предотвращение утечки с ограничением размера кэша
from functools import lru_cache

def safe_middleware(get_response):
    # Кэш с ограниченным размером
    @lru_cache(maxsize=1000)
    def cached_operation(path):
        return perform_expensive_operation(path)
    
    def middleware(request):
        result = cached_operation(request.path)
        request.META['CACHED_RESULT'] = result
        return get_response(request)
    return middleware
```

#### 6. Middleware в асинхронных приложениях

**Проблема:** Смешивание синхронного и асинхронного кода может привести к проблемам с производительностью или блокировкам.

**Решение:**
- В асинхронных приложениях используйте только асинхронные middleware
- Оборачивайте синхронные операции в асинхронные обертки
- Используйте инструменты для запуска блокирующего кода в отдельных потоках

```python
# Проблемный смешанный код
async def async_middleware(request, call_next):
    # Блокирующая операция в асинхронном коде (плохо)
    time.sleep(1)  # Блокирует весь цикл событий!
    
    response = await call_next(request)
    return response

# Правильный асинхронный подход
import asyncio

async def proper_async_middleware(request, call_next):
    # Неблокирующая асинхронная операция
    await asyncio.sleep(1)
    
    response = await call_next(request)
    return response

# Выполнение блокирующей операции в отдельном потоке
import concurrent.futures

async def hybrid_middleware(request, call_next):
    # Выполнение блокирующей операции в пуле потоков
    loop = asyncio.get_event_loop()
    with concurrent.futures.ThreadPoolExecutor() as pool:
        result = await loop.run_in_executor(
            pool, blocking_function, request.path
        )
    
    # Сохранение результата
    request.state.result = result
    
    # Продолжение асинхронной обработки
    response = await call_next(request)
    return response
```

## Полезные ресурсы

### Официальная документация

- [Django Middleware](https://docs.djangoproject.com/en/stable/topics/http/middleware/)
- [Flask WSGI Middleware](https://flask.palletsprojects.com/en/latest/patterns/wsgi-middlewares/)
- [FastAPI Middleware](https://fastapi.tiangolo.com/tutorial/middleware/)
- [Starlette Middleware](https://www.starlette.io/middleware/)
- [WSGI Specification](https://wsgi.readthedocs.io/en/latest/what.html)
- [ASGI Specification](https://asgi.readthedocs.io/en/latest/)

### Библиотеки и расширения

#### Django
- [django-cors-headers](https://github.com/adamchainz/django-cors-headers) - CORS middleware для Django
- [django-axes](https://github.com/jazzband/django-axes) - Безопасность и защита от атак
- [django-csp](https://github.com/mozilla/django-csp) - Content Security Policy
- [django-prometheus](https://github.com/korfuri/django-prometheus) - Мониторинг Prometheus

#### Flask
- [Flask-Cors](https://flask-cors.readthedocs.io/) - CORS поддержка для Flask
- [Flask-Talisman](https://github.com/GoogleCloudPlatform/flask-talisman) - HTTP security headers
- [Flask-Compress](https://github.com/colour-science/flask-compress) - Сжатие ответов
- [Flask-Limiter](https://flask-limiter.readthedocs.io/) - Ограничение скорости запросов

#### FastAPI
- [Starlette Middleware Collection](https://github.com/aogier/starlette-prometheus) - Мониторинг Prometheus
- [fastapi-limiter](https://github.com/long2ice/fastapi-limiter) - Ограничение скорости запросов
- [fastapi-jwt-auth](https://github.com/IndominusByte/fastapi-jwt-auth) - JWT аутентификация
- [fastapi-cache](https://github.com/long2ice/fastapi-cache) - Кэширование для FastAPI

### Статьи и руководства

- ["How Django Middleware Works"](https://testdriven.io/blog/django-middleware/) - TestDriven.io
- ["Understanding Django Middleware"](https://www.djangoproject.com/weblog/2013/apr/24/django-middleware/) - Django Blog
- ["Flask Middleware Pattern"](https://flask.palletsprojects.com/en/latest/patterns/deferredcallbacks/) - Flask Documentation
- ["Understanding ASGI"](https://github.com/encode/starlette/issues/384) - Tom Christie
- ["WSGI vs ASGI"](https://asgi.readthedocs.io/en/latest/introduction.html#what-s-different-vs-wsgi) - ASGI Documentation

### Инструменты и утилиты

- [Django Debug Toolbar](https://django-debug-toolbar.readthedocs.io/) - Отладка Django приложений, включая middleware
- [Locust](https://locust.io/) - Инструмент для нагрузочного тестирования
- [pyinstrument](https://github.com/joerick/pyinstrument) - Профилирование Python-кода
- [ASGI-Tools](https://github.com/django-extensions/django-extensions) - Коллекция инструментов для ASGI-приложений
- [WSGI-Lite](https://github.com/mikeboers/wsgi-lite) - Упрощенная реализация WSGI middleware