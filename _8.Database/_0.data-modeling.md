# Моделирование данных

## Содержание
- [Введение в моделирование данных](#введение-в-моделирование-данных)
- [Концептуальное моделирование](#концептуальное-моделирование)
- [Логическое моделирование](#логическое-моделирование)
  - [Реляционная модель](#реляционная-модель)
  - [Нормализация](#нормализация)
  - [Денормализация](#денормализация)
- [Физическое моделирование](#физическое-моделирование)
- [Моделирование для NoSQL](#моделирование-для-nosql)
  - [Моделирование для документных БД](#моделирование-для-документных-бд)
  - [Моделирование для колоночных БД](#моделирование-для-колоночных-бд)
  - [Моделирование для графовых БД](#моделирование-для-графовых-бд)
- [Моделирование данных в Python](#моделирование-данных-в-python)
- [Паттерны моделирования данных](#паттерны-моделирования-данных)
- [Эволюция моделей данных](#эволюция-моделей-данных)

## Введение в моделирование данных

Моделирование данных — это процесс создания абстрактного представления информации и связей между элементами данных. Оно обеспечивает структуру и организацию для хранения, обработки и анализа данных.

**Цели моделирования данных:**
- Определение структуры данных
- Обеспечение целостности и непротиворечивости данных
- Оптимизация доступа к данным
- Упрощение понимания и работы с данными

**Уровни моделирования данных:**
1. Концептуальный (что собираемся хранить)
2. Логический (как структурируем данные)
3. Физический (как физически организуем данные)

## Концептуальное моделирование

Концептуальное моделирование определяет основные сущности, их атрибуты и взаимосвязи без привязки к конкретной технологии хранения.

**Основные элементы:**
- Сущности (entity) — объекты реального мира
- Атрибуты — свойства сущностей
- Связи — отношения между сущностями

**Инструменты:**
- ER-диаграммы (Entity-Relationship)
- UML-диаграммы классов

**Пример ER-диаграммы в текстовом виде:**
```
Клиент (id, имя, email, телефон)
Заказ (id, дата, сумма, статус)
Товар (id, название, цена, категория)
Связи:
Клиент --1:N--> Заказ (один клиент может иметь много заказов)
Заказ --N:M--> Товар (один заказ содержит много товаров, один товар может быть в разных заказах)
```

**Пример создания ER-диаграммы программно с Python:**

```python
import pygraphviz as pgv

# Создание графа
g = pgv.AGraph(directed=True)

# Добавление узлов (сущностей)
g.add_node("Клиент", shape="box", label="Клиент\n-id\n-имя\n-email\n-телефон")
g.add_node("Заказ", shape="box", label="Заказ\n-id\n-дата\n-сумма\n-статус")
g.add_node("Товар", shape="box", label="Товар\n-id\n-название\n-цена\n-категория")

# Добавление связей
g.add_edge("Клиент", "Заказ", label="1:N")
g.add_edge("Заказ", "Товар", label="N:M")

# Сохранение диаграммы
g.layout(prog='dot')
g.draw('er_diagram.png')
```

## Логическое моделирование

Логическое моделирование преобразует концептуальную модель в более конкретную структуру, ориентированную на определенный тип хранилища данных.

### Реляционная модель

Наиболее распространённая логическая модель данных, которая представляет данные в виде таблиц (отношений).

**Основные понятия:**
- Таблица (отношение)
- Строка (кортеж)
- Столбец (атрибут)
- Первичный ключ (primary key)
- Внешний ключ (foreign key)

**Пример реляционной модели для нашего примера:**

```
Клиенты (id PK, имя, email, телефон)
Заказы (id PK, дата, сумма, статус, клиент_id FK)
Товары (id PK, название, цена, категория)
ЗаказТовары (id PK, заказ_id FK, товар_id FK, количество, цена_за_единицу)
```

**Создание реляционной схемы с Python и SQLAlchemy:**

```python
from sqlalchemy import create_engine, Column, Integer, String, Float, Date, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Клиент(Base):
    __tablename__ = 'клиенты'
    
    id = Column(Integer, primary_key=True)
    имя = Column(String)
    email = Column(String)
    телефон = Column(String)
    
    заказы = relationship("Заказ", back_populates="клиент")
    
class Заказ(Base):
    __tablename__ = 'заказы'
    
    id = Column(Integer, primary_key=True)
    дата = Column(Date)
    сумма = Column(Float)
    статус = Column(String)
    клиент_id = Column(Integer, ForeignKey('клиенты.id'))
    
    клиент = relationship("Клиент", back_populates="заказы")
    товары = relationship("ЗаказТовары", back_populates="заказ")
    
class Товар(Base):
    __tablename__ = 'товары'
    
    id = Column(Integer, primary_key=True)
    название = Column(String)
    цена = Column(Float)
    категория = Column(String)
    
    заказы = relationship("ЗаказТовары", back_populates="товар")
    
class ЗаказТовары(Base):
    __tablename__ = 'заказ_товары'
    
    id = Column(Integer, primary_key=True)
    заказ_id = Column(Integer, ForeignKey('заказы.id'))
    товар_id = Column(Integer, ForeignKey('товары.id'))
    количество = Column(Integer)
    цена_за_единицу = Column(Float)
    
    заказ = relationship("Заказ", back_populates="товары")
    товар = relationship("Товар", back_populates="заказы")

# Создание схемы в базе данных
engine = create_engine('sqlite:///магазин.db')
Base.metadata.create_all(engine)
```

### Нормализация

Нормализация — это процесс организации данных в реляционной базе для минимизации избыточности и зависимостей.

**Основные нормальные формы:**

1. **Первая нормальная форма (1NF)**:
   - Атомарность значений (неделимость)
   - Уникальность строк
   - Наличие первичного ключа

2. **Вторая нормальная форма (2NF)**:
   - Соответствие 1NF
   - Все неключевые атрибуты полностью зависят от первичного ключа

3. **Третья нормальная форма (3NF)**:
   - Соответствие 2NF
   - Отсутствие транзитивных зависимостей

**Пример денормализованной таблицы:**

```
Заказы (id, клиент_имя, клиент_email, клиент_телефон, дата, сумма, 
        товар1_название, товар1_цена, товар1_количество,
        товар2_название, товар2_цена, товар2_количество)
```

**Процесс нормализации до 3NF с Python:**

```python
import pandas as pd

# Исходная денормализованная таблица
data = {
    'id': [1, 2, 3],
    'клиент_имя': ['Иван', 'Мария', 'Алексей'],
    'клиент_email': ['ivan@example.com', 'maria@example.com', 'alex@example.com'],
    'клиент_телефон': ['123-456', '789-012', '345-678'],
    'дата': ['2023-01-15', '2023-01-20', '2023-01-25'],
    'сумма': [5000, 3000, 7000],
    'товар1_название': ['Ноутбук', 'Телефон', 'Планшет'],
    'товар1_цена': [4000, 2000, 3000],
    'товар1_количество': [1, 1, 2],
    'товар2_название': ['Мышь', 'Чехол', 'Клавиатура'],
    'товар2_цена': [500, 500, 500],
    'товар2_количество': [2, 2, 2]
}

df = pd.DataFrame(data)

# Шаг 1: Выделение таблицы клиентов (1NF -> 2NF)
клиенты = df[['клиент_имя', 'клиент_email', 'клиент_телефон']].copy()
клиенты['клиент_id'] = range(1, len(клиенты) + 1)
клиенты = клиенты.rename(columns={
    'клиент_имя': 'имя',
    'клиент_email': 'email',
    'клиент_телефон': 'телефон'})

# Шаг 2: Создание таблицы заказов (2NF -> 3NF)
заказы = df[['id', 'дата', 'сумма']].copy()
заказы['клиент_id'] = range(1, len(заказы) + 1)

# Шаг 3: Выделение товаров
товары = []
товар_id = 1

for i in range(1, 3):  # товар1 и товар2
    товар_данные = df[[f'товар{i}_название', f'товар{i}_цена']].copy()
    товар_данные = товар_данные.rename(columns={
        f'товар{i}_название': 'название',
        f'товар{i}_цена': 'цена'
    })
    
    товар_данные = товар_данные.drop_duplicates()
    товар_данные['id'] = range(товар_id, товар_id + len(товар_данные))
    товар_id += len(товар_данные)
    
    товары.append(товар_данные)

товары_df = pd.concat(товары).drop_duplicates()

# Шаг 4: Создание связующей таблицы заказ-товары
заказ_товары = []

for index, row in df.iterrows():
    заказ_id = row['id']
    
    for i in range(1, 3):  # товар1 и товар2
        название = row[f'товар{i}_название']
        количество = row[f'товар{i}_количество']
        цена = row[f'товар{i}_цена']
        
        # Получение товар_id
        товар_id = товары_df[товары_df['название'] == название]['id'].values[0]
        
        заказ_товары.append({
            'заказ_id': заказ_id,
            'товар_id': товар_id,
            'количество': количество,
            'цена_за_единицу': цена
        })

заказ_товары_df = pd.DataFrame(заказ_товары)

print("Таблица клиентов (3NF):")
print(клиенты)
print("\nТаблица заказов (3NF):")
print(заказы)
print("\nТаблица товаров (3NF):")
print(товары_df)
print("\nТаблица заказ-товары (3NF):")
print(заказ_товары_df)
```

### Денормализация

Денормализация — это намеренное введение избыточности в базу данных для повышения производительности запросов.

**Когда применять:**
- Для часто запрашиваемых данных
- При сложных соединениях таблиц
- Когда производительность чтения важнее целостности записи

**Пример денормализации с Python:**

```python
import pandas as pd

# Предположим, у нас есть нормализованные таблицы
клиенты = pd.DataFrame({
    'id': [1, 2, 3],
    'имя': ['Иван', 'Мария', 'Алексей'],
    'email': ['ivan@example.com', 'maria@example.com', 'alex@example.com']
})

заказы = pd.DataFrame({
    'id': [1, 2, 3, 4],
    'клиент_id': [1, 1, 2, 3],
    'дата': ['2023-01-15', '2023-02-10', '2023-01-20', '2023-01-25'],
    'сумма': [5000, 6000, 3000, 7000]
})

# Денормализация: добавляем информацию о клиенте в таблицу заказов
денормализованные_заказы = pd.merge(
    заказы,
    клиенты,
    left_on='клиент_id',
    right_on='id',
    suffixes=('_заказ', '_клиент')
)

# Выбираем нужные столбцы
денормализованные_заказы = денормализованные_заказы[[
    'id_заказ', 'дата', 'сумма', 'клиент_id', 'имя', 'email'
]]

# Переименовываем столбцы
денормализованные_заказы = денормализованные_заказы.rename(columns={
    'id_заказ': 'id',
    'имя': 'клиент_имя',
    'email': 'клиент_email'
})

print("Денормализованная таблица заказов:")
print(денормализованные_заказы)

# Пример использования для аналитических запросов
print("\nАналитика по клиентам:")
клиентская_аналитика = денормализованные_заказы.groupby('клиент_имя').agg({
    'id': 'count',
    'сумма': 'sum'
}).rename(columns={
    'id': 'количество_заказов',
    'сумма': 'общая_сумма'
})

print(клиентская_аналитика)
```

## Физическое моделирование

Физическое моделирование определяет, как данные будут физически храниться и организовываться в конкретной системе управления базами данных.

**Аспекты физического моделирования:**
- Типы данных и их размеры
- Индексы и их типы
- Партиционирование и шардинг
- Настройки хранения и компрессии

**Пример физической модели в SQLite с Python:**

```python
import sqlite3

# Создание соединения с БД
conn = sqlite3.connect('магазин.db')
cursor = conn.cursor()

# Создание таблиц с физическими параметрами
cursor.execute('''
CREATE TABLE IF NOT EXISTS клиенты (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    имя TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    телефон TEXT,
    дата_регистрации TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS заказы (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    клиент_id INTEGER NOT NULL,
    дата TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    сумма REAL NOT NULL,
    статус TEXT DEFAULT 'новый',
    FOREIGN KEY (клиент_id) REFERENCES клиенты (id)
)
''')

# Создание индексов для оптимизации запросов
cursor.execute('CREATE INDEX IF NOT EXISTS idx_заказы_клиент ON заказы (клиент_id)')
cursor.execute('CREATE INDEX IF NOT EXISTS idx_заказы_дата ON заказы (дата)')
cursor.execute('CREATE INDEX IF NOT EXISTS idx_заказы_статус ON заказы (статус)')

# Создание представления (view) для частого запроса
cursor.execute('''
CREATE VIEW IF NOT EXISTS активные_заказы AS
SELECT з.id, з.дата, з.сумма, з.статус, к.имя AS клиент_имя, к.email
FROM заказы з
JOIN клиенты к ON з.клиент_id = к.id
WHERE з.статус != 'завершен' AND з.статус != 'отменен'
''')

conn.commit()
conn.close()
```

## Моделирование для NoSQL

Моделирование данных для NoSQL баз отличается от реляционного и зависит от конкретного типа базы данных.

### Моделирование для документных БД

Документные базы данных хранят данные в виде документов (обычно JSON или BSON).

**Принципы моделирования:**
- Вложение или ссылки для связей
- Денормализация для частых запросов
- Проектирование с учетом паттернов доступа

**Пример модели для MongoDB:**

```python
import pymongo
from bson.objectid import ObjectId

# Подключение к MongoDB
client = pymongo.MongoClient("mongodb://localhost:27017/")
db = client["магазин"]

# Пример структуры коллекций

# Вариант 1: Вложенные документы (для связей 1:N с небольшим количеством вложенных)
клиент_с_заказами = {
    "_id": ObjectId(),
    "имя": "Иван Петров",
    "email": "ivan@example.com",
    "телефон": "+7-999-123-4567",
    "заказы": [
        {
            "номер": "ORD-001",
            "дата": "2023-01-15",
            "сумма": 5000,
            "статус": "завершен",
            "товары": [
                {"название": "Ноутбук", "цена": 4000, "количество": 1},
                {"название": "Мышь", "цена": 500, "количество": 2}
            ]
        },
        {
            "номер": "ORD-002",
            "дата": "2023-02-10",
            "сумма": 6000,
            "статус": "в обработке",
            "товары": [
                {"название": "Монитор", "цена": 6000, "количество": 1}
            ]
        }
    ]
}

# Вариант 2: Отдельные коллекции со ссылками (для связей с большим объемом данных)
клиент = {
    "_id": ObjectId(),
    "имя": "Мария Сидорова",
    "email": "maria@example.com",
    "телефон": "+7-999-765-4321"
}

заказ = {
    "_id": ObjectId(),
    "клиент_id": клиент["_id"],
    "номер": "ORD-003",
    "дата": "2023-01-20",
    "сумма": 3000,
    "статус": "доставлен"
}

заказ_товары = [
    {
        "_id": ObjectId(),
        "заказ_id": заказ["_id"],
        "название": "Телефон",
        "цена": 2000,
        "количество": 1
    },
    {
        "_id": ObjectId(),
        "заказ_id": заказ["_id"],
        "название": "Чехол",
        "цена": 500,
        "количество": 2
    }
]

# Вставка данных
db.клиенты.insert_one(клиент_с_заказами)  # Для варианта 1
db.клиенты.insert_one(клиент)             # Для варианта 2
db.заказы.insert_one(заказ)               # Для варианта 2
db.заказ_товары.insert_many(заказ_товары) # Для варианта 2

# Пример запроса для варианта 1
результат1 = db.клиенты.find_one(
    {"email": "ivan@example.com"},
    {"имя": 1, "заказы.номер": 1, "заказы.сумма": 1}
)

# Пример запроса для варианта 2
результат2 = db.заказы.aggregate([
    {"$match": {"номер": "ORD-003"}},
    {"$lookup": {
        "from": "клиенты",
        "localField": "клиент_id",
        "foreignField": "_id",
        "as": "клиент"
    }},
    {"$lookup": {
        "from": "заказ_товары",
        "localField": "_id",
        "foreignField": "заказ_id",
        "as": "товары"
    }}
])
```

### Моделирование для колоночных БД

Колоночные базы данных хранят данные по столбцам, что позволяет эффективно выполнять аналитические запросы.

**Принципы моделирования:**
- Широкие строки или узкие столбцы
- Проектирование с учетом паттернов запросов
- Минимизация количества обрабатываемых столбцов

**Пример модели для Cassandra:**

```python
from cassandra.cluster import Cluster

# Подключение к кластеру Cassandra
cluster = Cluster(['127.0.0.1'])
session = cluster.connect()

# Создание пространства ключей и таблиц
session.execute("""
    CREATE KEYSPACE IF NOT EXISTS магазин
    WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}
"""
)

session.execute("USE магазин")

# Таблица для поиска заказов по клиенту
session.execute("""
    CREATE TABLE IF NOT EXISTS заказы_по_клиенту (
        клиент_id uuid,
        заказ_id timeuuid,
        дата timestamp,
        сумма decimal,
        статус text,
        PRIMARY KEY (клиент_id, заказ_id)
    ) WITH CLUSTERING ORDER BY (заказ_id DESC)
""")

# Таблица для поиска заказов по дате
session.execute("""
    CREATE TABLE IF NOT EXISTS заказы_по_дате (
        день date,
        заказ_id timeuuid,
        клиент_id uuid,
        сумма decimal,
        статус text,
        PRIMARY KEY (день, заказ_id)
    ) WITH CLUSTERING ORDER BY (заказ_id DESC)
""")

# Таблица товаров в заказе
session.execute("""
    CREATE TABLE IF NOT EXISTS товары_в_заказе (
        заказ_id timeuuid,
        товар_id uuid,
        название text,
        цена decimal,
        количество int,
        PRIMARY KEY (заказ_id, товар_id)
    )
""")

# Денормализация для частых запросов
session.execute("""
    CREATE TABLE IF NOT EXISTS статистика_по_клиенту (
        клиент_id uuid PRIMARY KEY,
        имя text,
        email text,
        кол_заказов counter,
        сумма_всех_заказов counter
    )
""")

# Пример вставки данных
from cassandra.util import uuid_from_time
import uuid
import datetime

клиент_id = uuid.uuid4()
заказ_id = uuid_from_time(datetime.datetime.now())
день = datetime.datetime.now().strftime('%Y-%m-%d')

# Вставка в несколько таблиц для поддержки разных запросов
session.execute("""
    INSERT INTO заказы_по_клиенту (клиент_id, заказ_id, дата, сумма, статус)
    VALUES (%s, %s, %s, %s, %s)
""", (клиент_id, заказ_id, datetime.datetime.now(), 5000.0, 'новый'))

session.execute("""
    INSERT INTO заказы_по_дате (день, заказ_id, клиент_id, сумма, статус)
    VALUES (%s, %s, %s, %s, %s)
""", (день, заказ_id, клиент_id, 5000.0, 'новый'))

# Инкремент счетчиков
session.execute("""
    UPDATE статистика_по_клиенту
    SET кол_заказов = кол_заказов + 1,
        сумма_всех_заказов = сумма_всех_заказов + %s
    WHERE клиент_id = %s
""", (5000.0, клиент_id))

# Закрытие соединения
cluster.shutdown()
```

### Моделирование для графовых БД

Графовые базы данных хранят данные в виде узлов и связей между ними.

**Принципы моделирования:**
- Определение сущностей как узлов
- Определение отношений как связей
- Оптимизация для обхода графа

**Пример модели для Neo4j:**

```python
from neo4j import GraphDatabase

# Подключение к Neo4j
driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))

def создать_схему_магазина(tx):
    # Создание индексов для быстрого поиска
    tx.run("CREATE INDEX user_id_index IF NOT EXISTS FOR (u:Клиент) ON (u.id)")
    tx.run("CREATE INDEX order_id_index IF NOT EXISTS FOR (o:Заказ) ON (o.id)")
    tx.run("CREATE INDEX product_id_index IF NOT EXISTS FOR (p:Товар) ON (p.id)")

def добавить_данные_магазина(tx):
    # Создание узлов клиентов
    tx.run("""
        CREATE (к1:Клиент {id: 1, имя: 'Иван Петров', email: 'ivan@example.com'})
        CREATE (к2:Клиент {id: 2, имя: 'Мария Сидорова', email: 'maria@example.com'})
    """)
    
    # Создание узлов заказов
    tx.run("""
        CREATE (з1:Заказ {id: 101, дата: date('2023-01-15'), сумма: 5000, статус: 'завершен'})
        CREATE (з2:Заказ {id: 102, дата: date('2023-02-10'), сумма: 6000, статус: 'в обработке'})
        CREATE (з3:Заказ {id: 103, дата: date('2023-01-20'), сумма: 3000, статус: 'доставлен'})
    """)
    
    # Создание узлов товаров
    tx.run("""
        CREATE (т1:Товар {id: 201, название: 'Ноутбук', цена: 4000, категория: 'Электроника'})
        CREATE (т2:Товар {id: 202, название: 'Мышь', цена: 500, категория: 'Аксессуары'})
        CREATE (т3:Товар {id: 203, название: 'Монитор', цена: 6000, категория: 'Электроника'})
        CREATE (т4:Товар {id: 204, название: 'Телефон', цена: 2000, категория: 'Электроника'})
        CREATE (т5:Товар {id: 205, название: 'Чехол', цена: 500, категория: 'Аксессуары'})
    """)
    
    # Создание отношений между клиентами и заказами
    tx.run("""
        MATCH (к:Клиент {id: 1}), (з:Заказ {id: 101})
        CREATE (к)-[:СДЕЛАЛ]->(з)
    """)
    tx.run("""
        MATCH (к:Клиент {id: 1}), (з:Заказ {id: 102})
        CREATE (к)-[:СДЕЛАЛ]->(з)
    """)
    tx.run("""
        MATCH (к:Клиент {id: 2}), (з:Заказ {id: 103})
        CREATE (к)-[:СДЕЛАЛ]->(з)
    """)
    
    # Создание отношений между заказами и товарами
    tx.run("""
        MATCH (з:Заказ {id: 101}), (т:Товар {id: 201})
        CREATE (з)-[:СОДЕРЖИТ {количество: 1}]->(т)
    """)
    tx.run("""
        MATCH (з:Заказ {id: 101}), (т:Товар {id: 202})
        CREATE (з)-[:СОДЕРЖИТ {количество: 2}]->(т)
    """)
    tx.run("""
        MATCH (з:Заказ {id: 102}), (т:Товар {id: 203})
        CREATE (з)-[:СОДЕРЖИТ {количество: 1}]->(т)
    """)
    tx.run("""
        MATCH (з:Заказ {id: 103}), (т:Товар {id: 204})
        CREATE (з)-[:СОДЕРЖИТ {количество: 1}]->(т)
    """)
    tx.run("""
        MATCH (з:Заказ {id: 103}), (т:Товар {id: 205})
        CREATE (з)-[:СОДЕРЖИТ {количество: 2}]->(т)
    """)

def найти_клиентов_купивших_товар(tx, название_товара):
    result = tx.run("""
        MATCH (к:Клиент)-[:СДЕЛАЛ]->(з:Заказ)-[:СОДЕРЖИТ]->(т:Товар {название: $название})
        RETURN к.имя AS имя_клиента, к.email AS email, COUNT(DISTINCT з) AS количество_заказов
    """, название=название_товара)
    return [record.values() for record in result]

def рекомендации_на_основе_покупок(tx, клиент_id):
    result = tx.run("""
        MATCH (к:Клиент {id: $id})-[:СДЕЛАЛ]->(:Заказ)-[:СОДЕРЖИТ]->(т1:Товар)
        MATCH (другой_клиент:Клиент)-[:СДЕЛАЛ]->(:Заказ)-[:СОДЕРЖИТ]->(т1)
        MATCH (другой_клиент)-[:СДЕЛАЛ]->(:Заказ)-[:СОДЕРЖИТ]->(рекомендация:Товар)
        WHERE к <> другой_клиент AND NOT EXISTS(
            (к)-[:СДЕЛАЛ]->(:Заказ)-[:СОДЕРЖИТ]->(рекомендация)
        )
        RETURN рекомендация.название AS товар, COUNT(DISTINCT другой_клиент) AS количество_клиентов
        ORDER BY количество_клиентов DESC
        LIMIT 5
    """, id=клиент_id)
    return [record.values() for record in result]

# Использование созданных функций
with driver.session() as session:
    # Инициализация схемы и данных
    session.write_transaction(создать_схему_магазина)
    session.write_transaction(добавить_данные_магазина)
    
    # Пример запроса: поиск клиентов, купивших конкретный товар
    клиенты = session.read_transaction(найти_клиентов_купивших_товар, "Ноутбук")
    print("Клиенты, купившие ноутбук:", клиенты)
    
    # Пример запроса: рекомендации товаров для клиента
    рекомендации = session.read_transaction(рекомендации_на_основе_покупок, 1)
    print("Рекомендации для клиента с ID 1:", рекомендации)

# Закрытие драйвера
driver.close()
```

## Моделирование данных в Python

Python предоставляет множество инструментов для моделирования данных в различных контекстах.

### ORM (Object-Relational Mapping)

ORM позволяет работать с реляционными базами данных через объекты Python.

**Пример с SQLAlchemy:**

```python
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker

Base = declarative_base()

class Клиент(Base):
    __tablename__ = 'клиенты'
    
    id = Column(Integer, primary_key=True)
    имя = Column(String)
    email = Column(String, unique=True)
    
    заказы = relationship("Заказ", back_populates="клиент")
    
    def __repr__(self):
        return f"<Клиент(имя='{self.имя}', email='{self.email}')>"

class Заказ(Base):
    __tablename__ = 'заказы'
    
    id = Column(Integer, primary_key=True)
    клиент_id = Column(Integer, ForeignKey('клиенты.id'))
    сумма = Column(Float)
    статус = Column(String)
    
    клиент = relationship("Клиент", back_populates="заказы")
    
    def __repr__(self):
        return f"<Заказ(id={self.id}, сумма={self.сумма}, статус='{self.статус}')>"

# Создание БД и сессии
engine = create_engine('sqlite:///orm_пример.db')
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
session = Session()

# Пример использования ORM
# Создание и сохранение объектов
новый_клиент = Клиент(имя='Петр Иванов', email='petr@example.com')
session.add(новый_клиент)
session.commit()

новый_заказ = Заказ(клиент_id=новый_клиент.id, сумма=2500, статус='новый')
session.add(новый_заказ)
session.commit()

# Запросы через ORM
клиент = session.query(Клиент).filter_by(email='petr@example.com').first()
print(f"Найден клиент: {клиент}")
print(f"Его заказы: {клиент.заказы}")

# Обновление через ORM
новый_заказ.статус = 'в обработке'
session.commit()

# Проверка после обновления
обновленный_заказ = session.query(Заказ).get(новый_заказ.id)
print(f"Обновленный статус заказа: {обновленный_заказ.статус}")

session.close()
```

### ODM (Object-Document Mapping)

ODM позволяет работать с документными базами данных через объекты Python.

**Пример с MongoEngine:**

```python
from mongoengine import Document, StringField, FloatField, ReferenceField, ListField, connect

# Подключение к MongoDB
connect('odm_пример')

class Клиент(Document):
    имя = StringField(required=True)
    email = StringField(required=True, unique=True)
    телефон = StringField()
    
    meta = {'collection': 'клиенты'}
    
    def __str__(self):
        return f"Клиент: {self.имя}, Email: {self.email}"

class Товар(Document):
    название = StringField(required=True)
    цена = FloatField(required=True)
    категория = StringField()
    
    meta = {'collection': 'товары'}
    
    def __str__(self):
        return f"Товар: {self.название}, Цена: {self.цена}"

class ТоварВЗаказе(Document):
    товар = ReferenceField(Товар, required=True)
    количество = StringField(required=True, default=1)
    цена_на_момент_заказа = FloatField()
    
    meta = {'collection': 'товары_в_заказе'}

class Заказ(Document):
    клиент = ReferenceField(Клиент, required=True)
    товары = ListField(ReferenceField(ТоварВЗаказе))
    сумма = FloatField(required=True)
    статус = StringField(default="новый")
    
    meta = {'collection': 'заказы'}
    
    def __str__(self):
        return f"Заказ для {self.клиент.имя}, Сумма: {self.сумма}, Статус: {self.статус}"

# Использование ODM
# Создание и сохранение объектов
клиент = Клиент(имя='Ольга Смирнова', email='olga@example.com', телефон='+7-999-111-2233')
клиент.save()

товар1 = Товар(название='Книга', цена=500, категория='Литература')
товар2 = Товар(название='Ручка', цена=50, категория='Канцтовары')
товар1.save()
товар2.save()

товар_в_заказе1 = ТоварВЗаказе(товар=товар1, количество=2, цена_на_момент_заказа=товар1.цена)
товар_в_заказе2 = ТоварВЗаказе(товар=товар2, количество=5, цена_на_момент_заказа=товар2.цена)
товар_в_заказе1.save()
товар_в_заказе2.save()

заказ = Заказ(
    клиент=клиент,
    товары=[товар_в_заказе1, товар_в_заказе2],
    сумма=товар_в_заказе1.цена_на_момент_заказа * 2 + товар_в_заказе2.цена_на_момент_заказа * 5
)
заказ.save()

# Запросы через ODM
найденный_клиент = Клиент.objects(email='olga@example.com').first()
print(найденный_клиент)

заказы_клиента = Заказ.objects(клиент=найденный_клиент)
for з in заказы_клиента:
    print(f"Заказ: {з.id}, Сумма: {з.сумма}")
    for т in з.товары:
        товар = т.товар
        print(f"  - {товар.название}: {т.количество} шт. по {т.цена_на_момент_заказа}")
```

### Dataclasses

Dataclasses - это встроенный механизм Python для создания классов данных.

**Пример с dataclasses:**

```python
from dataclasses import dataclass, field
from typing import List, Optional
import datetime
import uuid

@dataclass
class Адрес:
    улица: str
    город: str
    индекс: str
    страна: str = "Россия"

@dataclass
class Товар:
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    название: str
    цена: float
    описание: Optional[str] = None
    категория: Optional[str] = None
    
    def __post_init__(self):
        # Валидация полей после инициализации
        if self.цена < 0:
            raise ValueError("Цена не может быть отрицательной")

@dataclass
class ПозицияЗаказа:
    товар: Товар
    количество: int
    цена_за_единицу: float
    
    @property
    def стоимость(self) -> float:
        return self.количество * self.цена_за_единицу

@dataclass
class Заказ:
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    клиент_id: str
    дата: datetime.datetime = field(default_factory=datetime.datetime.now)
    позиции: List[ПозицияЗаказа] = field(default_factory=list)
    статус: str = "новый"
    
    @property
    def сумма(self) -> float:
        return sum(позиция.стоимость for позиция in self.позиции)
    
    def добавить_товар(self, товар: Товар, количество: int = 1):
        """Добавляет товар в заказ с текущей ценой товара."""
        позиция = ПозицияЗаказа(
            товар=товар,
            количество=количество,
            цена_за_единицу=товар.цена
        )
        self.позиции.append(позиция)
        return позиция

# Пример использования
# Создание данных
адрес_клиента = Адрес("ул. Пушкина, 10", "Москва", "123456")

книга = Товар(название="Мастер и Маргарита", цена=500, категория="Литература")
ручка = Товар(название="Шариковая ручка", цена=50, категория="Канцтовары")

# Создание заказа
заказ = Заказ(клиент_id="client123")
заказ.добавить_товар(книга, 1)
заказ.добавить_товар(ручка, 3)

# Вывод информации о заказе
print(f"Заказ ID: {заказ.id}")
print(f"Дата: {заказ.дата}")
print(f"Товары:")
for позиция in заказ.позиции:
    print(f"  - {позиция.товар.название}: {позиция.количество} шт. x {позиция.цена_за_единицу} = {позиция.стоимость}")
print(f"Общая сумма: {заказ.сумма}")
print(f"Статус: {заказ.статус}")
```

### Pydantic для валидации данных

Pydantic - это библиотека для валидации и сериализации данных.

**Пример с Pydantic:**

```python
from pydantic import BaseModel, Field, validator, EmailStr
from typing import List, Optional
from datetime import datetime
import uuid

class Адрес(BaseModel):
    улица: str
    город: str
    индекс: str
    страна: str = "Россия"

class Клиент(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    имя: str
    email: EmailStr
    телефон: Optional[str] = None
    адрес: Optional[Адрес] = None
    
    @validator('имя')
    def имя_не_пусто(cls, v):
        if not v.strip():
            raise ValueError('Имя не может быть пустым')
        return v.strip()

class Товар(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    название: str
    цена: float
    описание: Optional[str] = None
    категория: Optional[str] = None
    
    @validator('цена')
    def цена_положительная(cls, v):
        if v <= 0:
            raise ValueError('Цена должна быть положительной')
        return v

class ПозицияЗаказа(BaseModel):
    товар_id: str
    название_товара: str
    количество: int
    цена_за_единицу: float
    
    @property
    def стоимость(self) -> float:
        return self.количество * self.цена_за_единицу
    
    @validator('количество')
    def количество_положительное(cls, v):
        if v <= 0:
            raise ValueError('Количество должно быть положительным')
        return v

class Заказ(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    клиент_id: str
    дата: datetime = Field(default_factory=datetime.now)
    позиции: List[ПозицияЗаказа] = []
    статус: str = "новый"
    
    @property
    def сумма(self) -> float:
        return sum(позиция.количество * позиция.цена_за_единицу for позиция in self.позиции)
    
    @validator('статус')
    def статус_валидный(cls, v):
        допустимые_статусы = ["новый", "оплачен", "отправлен", "доставлен", "отменен"]
        if v not in допустимые_статусы:
            raise ValueError(f'Статус должен быть одним из: {допустимые_статусы}')
        return v
    
    @validator('позиции')
    def позиции_не_пусты(cls, v):
        if not v:
            raise ValueError('Заказ должен содержать хотя бы одну позицию')
        return v

# Пример использования Pydantic для валидации данных
try:
    # Создаем клиента с валидными данными
    клиент = Клиент(
        имя="Иван Иванов",
        email="ivan@example.com",
        телефон="+7-999-123-4567",
        адрес=Адрес(
            улица="ул. Ленина, 15",
            город="Санкт-Петербург",
            индекс="198000"
        )
    )
    print(f"Клиент создан: {клиент.json(indent=2)}")
    
    # Пробуем создать товар с невалидной ценой
    try:
        товар = Товар(название="Бракованный товар", цена=-100)
    except ValueError as e:
        print(f"Ошибка валидации товара: {e}")
    
    # Создаем валидный товар
    товар = Товар(название="Смартфон", цена=15000, категория="Электроника")
    
    # Создаем заказ
    заказ = Заказ(
        клиент_id=клиент.id,
        позиции=[
            ПозицияЗаказа(
                товар_id=товар.id,
                название_товара=товар.название,
                количество=2,
                цена_за_единицу=товар.цена
            )
        ]
    )
    print(f"Заказ создан: {заказ.json(indent=2)}")
    print(f"Сумма заказа: {заказ.сумма}")
    
    # Проверка преобразования в JSON и обратно
    заказ_json = заказ.json()
    восстановленный_заказ = Заказ.parse_raw(заказ_json)
    print(f"Заказ восстановлен из JSON: {восстановленный_заказ.id == заказ.id}")
    
except Exception as e:
    print(f"Произошла ошибка: {e}")
```

## Паттерны моделирования данных

### Шаблон репозитория

Шаблон репозитория абстрагирует доступ к данным, делая приложение более тестируемым и поддерживаемым.

```python
from abc import ABC, abstractmethod
from typing import List, Optional
import sqlite3

# Определение модели
class Товар:
    def __init__(self, id: int = None, название: str = None, цена: float = None, 
                 категория: str = None):
        self.id = id
        self.название = название
        self.цена = цена
        self.категория = категория
    
    def __repr__(self):
        return f"Товар(id={self.id}, название='{self.название}', цена={self.цена})"

# Абстрактный репозиторий
class ТоварРепозиторий(ABC):
    @abstractmethod
    def найти_все(self) -> List[Товар]:
        pass
    
    @abstractmethod
    def найти_по_id(self, id: int) -> Optional[Товар]:
        pass
    
    @abstractmethod
    def создать(self, товар: Товар) -> Товар:
        pass
    
    @abstractmethod
    def обновить(self, товар: Товар) -> Товар:
        pass
    
    @abstractmethod
    def удалить(self, id: int) -> bool:
        pass

# SQLite реализация репозитория
class SQLiteТоварРепозиторий(ТоварРепозиторий):
    def __init__(self, db_path: str):
        self.conn = sqlite3.connect(db_path)
        self.conn.row_factory = sqlite3.Row
        self._создать_таблицу()
    
    def _создать_таблицу(self):
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS товары (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                название TEXT NOT NULL,
                цена REAL NOT NULL,
                категория TEXT
            )
        """)
        self.conn.commit()
    
    def найти_все(self) -> List[Товар]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM товары")
        rows = cursor.fetchall()
        return [self._row_to_товар(row) for row in rows]
    
    def найти_по_id(self, id: int) -> Optional[Товар]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM товары WHERE id = ?", (id,))
        row = cursor.fetchone()
        return self._row_to_товар(row) if row else None
    
    def создать(self, товар: Товар) -> Товар:
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO товары (название, цена, категория) VALUES (?, ?, ?)",
            (товар.название, товар.цена, товар.категория)
        )
        self.conn.commit()
        товар.id = cursor.lastrowid
        return товар
    
    def обновить(self, товар: Товар) -> Товар:
        cursor = self.conn.cursor()
        cursor.execute(
            "UPDATE товары SET название = ?, цена = ?, категория = ? WHERE id = ?",
            (товар.название, товар.цена, товар.категория, товар.id)
        )
        self.conn.commit()
        return товар
    
    def удалить(self, id: int) -> bool:
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM товары WHERE id = ?", (id,))
        self.conn.commit()
        return cursor.rowcount > 0
    
    def _row_to_товар(self, row: sqlite3.Row) -> Товар:
        return Товар(
            id=row['id'],
            название=row['название'],
            цена=row['цена'],
            категория=row['категория']
        )
    
    def __del__(self):
        self.conn.close()

# Пример использования репозитория
repo = SQLiteТоварРепозиторий("товары.db")

# Создание товаров
ноутбук = Товар(название="Ноутбук", цена=50000, категория="Электроника")
мышь = Товар(название="Мышь", цена=1000, категория="Периферия")

ноутбук = repo.создать(ноутбук)
мышь = repo.создать(мышь)

print(f"Созданы товары: {ноутбук}, {мышь}")

# Поиск товаров
все_товары = repo.найти_все()
print(f"Все товары: {все_товары}")

# Обновление товара
ноутбук.цена = 45000
repo.обновить(ноутбук)
обновленный_ноутбук = repo.найти_по_id(ноутбук.id)
print(f"Обновленный ноутбук: {обновленный_ноутбук}")

# Удаление товара
repo.удалить(мышь.id)
все_товары_после_удаления = repo.найти_все()
print(f"Товары после удаления: {все_товары_после_удаления}")
```

### Шаблон Unit of Work

Шаблон Unit of Work обеспечивает атомарность операций с данными.

```python
import sqlite3
from typing import List, Optional, Dict
from contextlib import contextmanager

# Модели
class Товар:
    def __init__(self, id: int = None, название: str = None, цена: float = None):
        self.id = id
        self.название = название
        self.цена = цена
    
    def __repr__(self):
        return f"Товар(id={self.id}, название='{self.название}', цена={self.цена})"

class Заказ:
    def __init__(self, id: int = None, клиент_id: int = None, статус: str = None):
        self.id = id
        self.клиент_id = клиент_id
        self.статус = статус
        self.позиции: List[ПозицияЗаказа] = []
    
    def __repr__(self):
        return f"Заказ(id={self.id}, клиент_id={self.клиент_id}, статус='{self.статус}')"

class ПозицияЗаказа:
    def __init__(self, id: int = None, заказ_id: int = None, 
                 товар_id: int = None, количество: int = None):
        self.id = id
        self.заказ_id = заказ_id
        self.товар_id = товар_id
        self.количество = количество
    
    def __repr__(self):
        return f"ПозицияЗаказа(id={self.id}, заказ_id={self.заказ_id}, товар_id={self.товар_id}, количество={self.количество})"

# Репозитории
class ТоварРепозиторий:
    def __init__(self, connection):
        self.connection = connection
        self.новые: List[Товар] = []
        self.измененные: List[Товар] = []
        self.удаленные: List[int] = []
    
    def найти_по_id(self, id: int) -> Optional[Товар]:
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM товары WHERE id = ?", (id,))
        row = cursor.fetchone()
        if not row:
            return None
        return Товар(id=row[0], название=row[1], цена=row[2])
    
    def добавить(self, товар: Товар):
        self.новые.append(товар)
    
    def обновить(self, товар: Товар):
        self.измененные.append(товар)
    
    def удалить(self, id: int):
        self.удаленные.append(id)

class ЗаказРепозиторий:
    def __init__(self, connection):
        self.connection = connection
        self.новые: List[Заказ] = []
        self.измененные: List[Заказ] = []
        self.удаленные: List[int] = []
    
    def найти_по_id(self, id: int) -> Optional[Заказ]:
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM заказы WHERE id = ?", (id,))
        row = cursor.fetchone()
        if not row:
            return None
        
        заказ = Заказ(id=row[0], клиент_id=row[1], статус=row[2])
        
        # Загрузка позиций заказа
        cursor.execute("SELECT * FROM позиции_заказа WHERE заказ_id = ?", (id,))
        позиции_rows = cursor.fetchall()
        
        for p_row in позиции_rows:
            позиция = ПозицияЗаказа(id=p_row[0], заказ_id=p_row[1], 
                                    товар_id=p_row[2], количество=p_row[3])
            заказ.позиции.append(позиция)
        
        return заказ
    
    def добавить(self, заказ: Заказ):
        self.новые.append(заказ)
    
    def обновить(self, заказ: Заказ):
        self.измененные.append(заказ)
    
    def удалить(self, id: int):
        self.удаленные.append(id)

# Unit of Work
class UnitOfWork:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = None
        self.товары = None
        self.заказы = None
    
    def __enter__(self):
        self.connection = sqlite3.connect(self.db_path)
        self.товары = ТоварРепозиторий(self.connection)
        self.заказы = ЗаказРепозиторий(self.connection)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.rollback()
        else:
            self.commit()
        self.connection.close()
    
    def commit(self):
        self._сохранить_товары()
        self._сохранить_заказы()
        self.connection.commit()
    
    def rollback(self):
        self.connection.rollback()
    
    def _сохранить_товары(self):
        cursor = self.connection.cursor()
        
        # Новые товары
        for товар in self.товары.новые:
            cursor.execute(
                "INSERT INTO товары (название, цена) VALUES (?, ?)",
                (товар.название, товар.цена)
            )
            товар.id = cursor.lastrowid
        
        # Измененные товары
        for товар in self.товары.измененные:
            cursor.execute(
                "UPDATE товары SET название = ?, цена = ? WHERE id = ?",
                (товар.название, товар.цена, товар.id)
            )
        
        # Удаленные товары
        for id in self.товары.удаленные:
            cursor.execute("DELETE FROM товары WHERE id = ?", (id,))
    
    def _сохранить_заказы(self):
        cursor = self.connection.cursor()
        
        # Новые заказы
        for заказ in self.заказы.новые:
            cursor.execute(
                "INSERT INTO заказы (клиент_id, статус) VALUES (?, ?)",
                (заказ.клиент_id, заказ.статус)
            )
            заказ.id = cursor.lastrowid
            
            # Сохранение позиций заказа
            for позиция in заказ.позиции:
                позиция.заказ_id = заказ.id
                cursor.execute(
                    "INSERT INTO позиции_заказа (заказ_id, товар_id, количество) VALUES (?, ?, ?)",
                    (позиция.заказ_id, позиция.товар_id, позиция.количество)
                )
                позиция.id = cursor.lastrowid
        
        # Измененные заказы
        for заказ in self.заказы.измененные:
            cursor.execute(
                "UPDATE заказы SET клиент_id = ?, статус = ? WHERE id = ?",
                (заказ.клиент_id, заказ.статус, заказ.id)
            )
            
            # Удаление существующих позиций
            cursor.execute("DELETE FROM позиции_заказа WHERE заказ_id = ?", (заказ.id,))
            
            # Добавление новых позиций
            for позиция in заказ.позиции:
                cursor.execute(
                    "INSERT INTO позиции_заказа (заказ_id, товар_id, количество) VALUES (?, ?, ?)",
                    (заказ.id, позиция.товар_id, позиция.количество)
                )
        
        # Удаленные заказы
        for id in self.заказы.удаленные:
            cursor.execute("DELETE FROM позиции_заказа WHERE заказ_id = ?", (id,))
            cursor.execute("DELETE FROM заказы WHERE id = ?", (id,))

# Создание схемы базы данных
def создать_схему(db_path: str):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS товары (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            название TEXT NOT NULL,
            цена REAL NOT NULL
        )
    """)
    
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS заказы (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            клиент_id INTEGER NOT NULL,
            статус TEXT NOT NULL
        )
    """)
    
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS позиции_заказа (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            заказ_id INTEGER NOT NULL,
            товар_id INTEGER NOT NULL,
            количество INTEGER NOT NULL,
            FOREIGN KEY (заказ_id) REFERENCES заказы (id),
            FOREIGN KEY (товар_id) REFERENCES товары (id)
        )
    """)
    
    conn.commit()
    conn.close()

# Пример использования Unit of Work
# Создание схемы
db_path = "uow_пример.db"
создать_схему(db_path)

# Использование UnitOfWork для атомарных операций
with UnitOfWork(db_path) as uow:
    # Создание товаров
    ноутбук = Товар(название="Ноутбук Dell", цена=60000)
    клавиатура = Товар(название="Клавиатура", цена=2000)
    
    uow.товары.добавить(ноутбук)
    uow.товары.добавить(клавиатура)
    
    # Создание заказа
    заказ = Заказ(клиент_id=1, статус="новый")
    uow.заказы.добавить(заказ)
    
    # Все изменения будут сохранены атомарно при выходе из контекста

# Теперь прочитаем данные и внесем новые изменения
with UnitOfWork(db_path) as uow:
    # Получение товара
    ноутбук = uow.товары.найти_по_id(1)
    
    # Обновление цены
    ноутбук.цена = 55000
    uow.товары.обновить(ноутбук)
    
    # Получение заказа
    заказ = uow.заказы.найти_по_id(1)
    
    # Добавление позиций в заказ
    позиция1 = ПозицияЗаказа(заказ_id=заказ.id, товар_id=1, количество=1)
    позиция2 = ПозицияЗаказа(заказ_id=заказ.id, товар_id=2, количество=2)
    
    заказ.позиции = [позиция1, позиция2]
    заказ.статус = "оплачен"
    
    uow.заказы.обновить(заказ)
```

### Шаблон Data Mapper

Data Mapper отделяет хранилище данных от доменной модели.

```python
from typing import List, Dict, Any, Optional
import sqlite3

# Доменная модель независима от хранилища
class Клиент:
    def __init__(self, id: int = None, имя: str = None, email: str = None):
        self.id = id
        self.имя = имя
        self.email = email
    
    def __repr__(self):
        return f"Клиент(id={self.id}, имя='{self.имя}', email='{self.email}')"

# Маппер преобразует объекты домена в записи хранилища и обратно
class КлиентMapper:
    def __init__(self, connection: sqlite3.Connection):
        self.connection = connection
        self._создать_таблицу()
    
    def _создать_таблицу(self):
        cursor = self.connection.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS клиенты (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                имя TEXT NOT NULL,
                email TEXT NOT NULL UNIQUE
            )
        """)
        self.connection.commit()
    
    def найти_по_id(self, id: int) -> Optional[Клиент]:
        cursor = self.connection.cursor()
        cursor.execute("SELECT id, имя, email FROM клиенты WHERE id = ?", (id,))
        row = cursor.fetchone()
        if not row:
            return None
        return self._создать_клиента(row)
    
    def найти_по_email(self, email: str) -> Optional[Клиент]:
        cursor = self.connection.cursor()
        cursor.execute("SELECT id, имя, email FROM клиенты WHERE email = ?", (email,))
        row = cursor.fetchone()
        if not row:
            return None
        return self._создать_клиента(row)
    
    def найти_все(self) -> List[Клиент]:
        cursor = self.connection.cursor()
        cursor.execute("SELECT id, имя, email FROM клиенты")
        return [self._создать_клиента(row) for row in cursor.fetchall()]
    
    def вставить(self, клиент: Клиент) -> Клиент:
        cursor = self.connection.cursor()
        cursor.execute(
            "INSERT INTO клиенты (имя, email) VALUES (?, ?)",
            (клиент.имя, клиент.email)
        )
        self.connection.commit()
        клиент.id = cursor.lastrowid
        return клиент
    
    def обновить(self, клиент: Клиент) -> Клиент:
        cursor = self.connection.cursor()
        cursor.execute(
            "UPDATE клиенты SET имя = ?, email = ? WHERE id = ?",
            (клиент.имя, клиент.email, клиент.id)
        )
        self.connection.commit()
        return клиент
    
    def удалить(self, id: int) -> bool:
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM клиенты WHERE id = ?", (id,))
        self.connection.commit()
        return cursor.rowcount > 0
    
    def _создать_клиента(self, row: tuple) -> Клиент:
        return Клиент(id=row[0], имя=row[1], email=row[2])

# Пример использования Data Mapper
conn = sqlite3.connect("mapper_пример.db")

# Создание маппера
клиент_mapper = КлиентMapper(conn)

# Создание новых клиентов
новый_клиент1 = Клиент(имя="Иван Петров", email="ivan@example.com")
новый_клиент2 = Клиент(имя="Анна Сидорова", email="anna@example.com")

# Сохранение в базу данных
клиент_mapper.вставить(новый_клиент1)
клиент_mapper.вставить(новый_клиент2)

print(f"Созданы клиенты: {новый_клиент1}, {новый_клиент2}")

# Поиск клиента по email
найденный_клиент = клиент_mapper.найти_по_email("ivan@example.com")
print(f"Найден клиент по email: {найденный_клиент}")

# Обновление клиента
найденный_клиент.имя = "Иван Иванович Петров"
клиент_mapper.обновить(найденный_клиент)

# Поиск всех клиентов
все_клиенты = клиент_mapper.найти_все()
print(f"Все клиенты: {все_клиенты}")

# Удаление клиента
клиент_mapper.удалить(новый_клиент2.id)
оставшиеся_клиенты = клиент_mapper.найти_все()
print(f"Клиенты после удаления: {оставшиеся_клиенты}")

# Закрытие соединения
conn.close()
```

## Эволюция моделей данных

Управление изменениями модели данных является важным аспектом разработки долгосрочных проектов.

### Миграции БД

Миграции позволяют контролировать изменения схемы базы данных.

**Пример с использованием Alembic:**

```python
# Установка: pip install alembic sqlalchemy

# Инициализация Alembic
# $ alembic init migrations

# Файл env.py в папке migrations
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object
config = context.config

# Интерпретация файла конфигурации для логирования Python
# для Alembic
fileConfig(config.config_file_name)

# Добавление URL подключения к БД
config.set_main_option('sqlalchemy.url', 'sqlite:///эволюция_модели.db')

# Здесь определяем модели
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Пользователь(Base):
    __tablename__ = 'пользователи'
    
    id = Column(Integer, primary_key=True)
    имя = Column(String, nullable=False)
    email = Column(String, nullable=False, unique=True)
    
    def __repr__(self):
        return f"<Пользователь(имя='{self.имя}', email='{self.email}')>"

target_metadata = Base.metadata

def run_migrations_offline():
    """Запуск миграций в 'оффлайн' режиме."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Запуск миграций в 'онлайн' режиме."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# Создание миграции
# $ alembic revision --autogenerate -m "создание таблицы пользователей"

# Применение миграции
# $ alembic upgrade head

# Добавление новой модели и создание новой миграции

# В файле env.py добавляем новую модель
class Адрес(Base):
    __tablename__ = 'адреса'
    
    id = Column(Integer, primary_key=True)
    пользователь_id = Column(Integer, ForeignKey('пользователи.id'), nullable=False)
    улица = Column(String, nullable=False)
    город = Column(String, nullable=False)
    индекс = Column(String, nullable=False)
    
    пользователь = relationship("Пользователь", backref="адреса")
    
    def __repr__(self):
        return f"<Адрес(город='{self.город}', улица='{self.улица}')>"

# $ alembic revision --autogenerate -m "добавление таблицы адресов"
# $ alembic upgrade head

# Добавление поля в существующую таблицу

# В файле env.py обновляем модель Пользователь
class Пользователь(Base):
    __tablename__ = 'пользователи'
    
    id = Column(Integer, primary_key=True)
    имя = Column(String, nullable=False)
    email = Column(String, nullable=False, unique=True)
    дата_регистрации = Column(DateTime)  # Новое поле
    
    def __repr__(self):
        return f"<Пользователь(имя='{self.имя}', email='{self.email}')>"

# $ alembic revision --autogenerate -m "добавление поля дата_регистрации"
# $ alembic upgrade head
```

### Версионирование API

Версионирование API позволяет обеспечить обратную совместимость при изменении моделей данных.

```python
from flask import Flask, jsonify, request, abort
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///версионирование_api.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Модель данных
class Пользователь(db.Model):
    __tablename__ = 'пользователи'
    
    id = db.Column(db.Integer, primary_key=True)
    имя = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), nullable=False, unique=True)
    дата_регистрации = db.Column(db.DateTime, default=datetime.utcnow)
    статус = db.Column(db.String(20), default='активен')
    
    def to_dict_v1(self):
        """API v1: базовая информация"""
        return {
            'id': self.id,
            'имя': self.имя,
            'email': self.email
        }
    
    def to_dict_v2(self):
        """API v2: добавление даты регистрации"""
        return {
            'id': self.id,
            'имя': self.имя,
            'email': self.email,
            'дата_регистрации': self.дата_регистрации.isoformat()
        }
    
    def to_dict_v3(self):
        """API v3: добавление статуса и изменение формата вывода имени"""
        имя_части = self.имя.split()
        форматированное_имя = {
            'полное': self.имя
        }
        
        if len(имя_части) >= 2:
            форматированное_имя['имя'] = имя_части[0]
            форматированное_имя['фамилия'] = имя_части[1]
        
        return {
            'id': self.id,
            'имя': форматированное_имя,
            'email': self.email,
            'дата_регистрации': self.дата_регистрации.isoformat(),
            'статус': self.статус
        }

# Создание таблицы
with app.app_context():
    db.create_all()

# Маршруты API v1
@app.route('/api/v1/пользователи', methods=['GET'])
def get_users_v1():
    пользователи = Пользователь.query.all()
    return jsonify([п.to_dict_v1() for п in пользователи])

@app.route('/api/v1/пользователи/<int:id>', methods=['GET'])
def get_user_v1(id):
    пользователь = Пользователь.query.get_or_404(id)
    return jsonify(пользователь.to_dict_v1())

@app.route('/api/v1/пользователи', methods=['POST'])
def create_user_v1():
    if not request.json or not 'имя' in request.json or not 'email' in request.json:
        abort(400)
    
    пользователь = Пользователь(
        имя=request.json['имя'],
        email=request.json['email']
    )
    
    db.session.add(пользователь)
    db.session.commit()
    
    return jsonify(пользователь.to_dict_v1()), 201

# Маршруты API v2
@app.route('/api/v2/пользователи', methods=['GET'])
def get_users_v2():
    пользователи = Пользователь.query.all()
    return jsonify([п.to_dict_v2() for п in пользователи])

@app.route('/api/v2/пользователи/<int:id>', methods=['GET'])
def get_user_v2(id):
    пользователь = Пользователь.query.get_or_404(id)
    return jsonify(пользователь.to_dict_v2())

# Маршруты API v3
@app.route('/api/v3/пользователи', methods=['GET'])
def get_users_v3():
    пользователи = Пользователь.query.all()
    return jsonify([п.to_dict_v3() for п in пользователи])

@app.route('/api/v3/пользователи/<int:id>', methods=['GET'])
def get_user_v3(id):
    пользователь = Пользователь.query.get_or_404(id)
    return jsonify(пользователь.to_dict_v3())

@app.route('/api/v3/пользователи', methods=['POST'])
def create_user_v3():
    if not request.json or not 'имя' in request.json or not 'email' in request.json:
        abort(400)
    
    пользователь = Пользователь(
        имя=request.json['имя'],
        email=request.json['email'],
        статус=request.json.get('статус', 'активен')
    )
    
    db.session.add(пользователь)
    db.session.commit()
    
    return jsonify(пользователь.to_dict_v3()), 201

if __name__ == '__main__':
    app.run(debug=True)
```

### Схемы и контракты данных

Схемы данных обеспечивают валидацию и документирование формата данных.

```python
from marshmallow import Schema, fields, validate, ValidationError
from datetime import datetime
import json

# Определение схем данных (контрактов)
class АдресСхемаV1(Schema):
    улица = fields.Str(required=True)
    город = fields.Str(required=True)
    индекс = fields.Str(required=True)
    страна = fields.Str(default="Россия")

class ПользовательСхемаV1(Schema):
    id = fields.Int(dump_only=True)  # только для вывода, не для ввода
    имя = fields.Str(required=True, validate=validate.Length(min=2))
    email = fields.Email(required=True)
    адрес = fields.Nested(АдресСхемаV1, required=False)
    дата_регистрации = fields.DateTime(dump_only=True)

# Эволюция схемы в версии 2
class ТелефонСхемаV2(Schema):
    тип = fields.Str(validate=validate.OneOf(["мобильный", "рабочий", "домашний"]))
    номер = fields.Str(required=True)

class АдресСхемаV2(Schema):
    улица = fields.Str(required=True)
    город = fields.Str(required=True)
    индекс = fields.Str(required=True)
    страна = fields.Str(default="Россия")
    координаты = fields.Dict(keys=fields.Str(), values=fields.Float(), required=False)

class ПользовательСхемаV2(Schema):
    id = fields.Int(dump_only=True)
    имя = fields.Str(required=True, validate=validate.Length(min=2))
    фамилия = fields.Str(required=True, validate=validate.Length(min=2))
    email = fields.Email(required=True)
    телефоны = fields.List(fields.Nested(ТелефонСхемаV2), required=False)
    адрес = fields.Nested(АдресСхемаV2, required=False)
    дата_регистрации = fields.DateTime(dump_only=True)
    статус = fields.Str(validate=validate.OneOf(["активен", "неактивен", "заблокирован"]))

# Пример данных для валидации
пользователь_данные_v1 = {
    "имя": "Иван Петров",
    "email": "ivan@example.com",
    "адрес": {
        "улица": "ул. Пушкина, д. 10",
        "город": "Москва",
        "индекс": "123456"
    }
}

пользователь_данные_v2 = {
    "имя": "Иван",
    "фамилия": "Петров",
    "email": "ivan@example.com",
    "телефоны": [
        {"тип": "мобильный", "номер": "+7-999-123-4567"},
        {"тип": "рабочий", "номер": "+7-495-123-4567"}
    ],
    "адрес": {
        "улица": "ул. Пушкина, д. 10",
        "город": "Москва",
        "индекс": "123456",
        "координаты": {"широта": 55.753215, "долгота": 37.622504}
    },
    "статус": "активен"
}

# Функция для валидации и сериализации данных
def валидировать_и_сериализовать(схема, данные):
    try:
        # Валидация данных
        результат = схема.load(данные)
        print("Валидация успешна. Результат:", результат)
        
        # Сериализация данных
        результат['дата_регистрации'] = datetime.now()
        сериализованные = схема.dump(результат)
        print("Сериализованные данные:", json.dumps(сериализованные, ensure_ascii=False, indent=2))
        
        return сериализованные
    except ValidationError as err:
        print("Ошибка валидации:", err.messages)
        return None

# Преобразование данных между версиями схем
def преобразовать_v1_в_v2(данные_v1):
    """Преобразует данные из формата v1 в формат v2"""
    имя_части = данные_v1["имя"].split()
    
    данные_v2 = {
        "имя": имя_части[0] if len(имя_части) > 0 else данные_v1["имя"],
        "фамилия": имя_части[1] if len(имя_части) > 1 else "Неизвестно",
        "email": данные_v1["email"],
        "статус": "активен"
    }
    
    if "адрес" in данные_v1:
        данные_v2["адрес"] = данные_v1["адрес"]
    
    return данные_v2

# Пример использования
print("Валидация данных по схеме v1:")
v1_схема = ПользовательСхемаV1()
валидные_данные_v1 = валидировать_и_сериализовать(v1_схема, пользователь_данные_v1)

print("\nВалидация данных по схеме v2:")
v2_схема = ПользовательСхемаV2()
валидные_данные_v2 = валидировать_и_сериализовать(v2_схема, пользователь_данные_v2)

# Преобразование данных из v1 в v2
if валидные_данные_v1:
    print("\nПреобразование данных из v1 в v2:")
    преобразованные_данные = преобразовать_v1_в_v2(валидные_данные_v1)
    print("Преобразованные данные:", json.dumps(преобразованные_данные, ensure_ascii=False, indent=2))
    
    print("\nВалидация преобразованных данных по схеме v2:")
    валидировать_и_сериализовать(v2_схема, преобразованные_данные)
```

Моделирование данных является ключевым аспектом разработки программного обеспечения, который влияет на производительность, масштабируемость и поддерживаемость системы. Выбор подходящей модели данных зависит от конкретных требований приложения, паттернов доступа к данным и планируемой эволюции системы.
