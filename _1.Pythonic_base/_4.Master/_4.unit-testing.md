# Модульное тестирование в Python

## Содержание
1. [Введение в модульное тестирование](#введение-в-модульное-тестирование)
2. [Модуль unittest](#модуль-unittest)
3. [Фреймворк pytest](#фреймворк-pytest)
4. [Концепции и подходы к тестированию](#концепции-и-подходы-к-тестированию)
5. [Реальные примеры тестирования](#реальные-примеры-тестирования)
6. [Практические задания](#практические-задания)
7. [Мини-проект: тестирование библиотеки работы с данными](#мини-проект-тестирование-библиотеки-работы-с-данными)

## Введение в модульное тестирование

Модульное тестирование (юнит-тестирование) — это процесс проверки отдельных компонентов программы в изоляции от других частей. Цель такого тестирования — убедиться, что каждый модуль работает правильно и соответствует спецификации.

### Почему модульное тестирование важно?

1. **Обнаружение ошибок на ранних этапах** — тесты помогают находить проблемы до того, как они дойдут до пользователей.
2. **Упрощение рефакторинга** — хорошие тесты дают уверенность, что изменения не нарушили существующую функциональность.
3. **Документирование кода** — тесты показывают, как должны работать функции и классы.
4. **Улучшение проектирования** — написание тестов часто ведет к лучшему дизайну кода.
5. **Экономия времени** — хотя на написание тестов требуется время, они экономят гораздо больше времени на отладке.

### Основные принципы модульного тестирования

- **Автоматизация** — тесты должны запускаться автоматически.
- **Независимость** — тесты не должны зависеть от результатов других тестов.
- **Повторяемость** — тесты должны давать одинаковые результаты при многократном выполнении.
- **Изоляция** — тесты должны проверять только одну функцию или метод.
- **Простота** — тесты должны быть понятными и сопровождаемыми.

## Модуль unittest

`unittest` — это встроенный модуль Python для написания и выполнения тестов. Он основан на архитектуре xUnit, которая используется во многих языках программирования.

### Основные компоненты unittest

1. **TestCase** — базовый класс для создания тестов.
2. **TestSuite** — контейнер для тестовых случаев.
3. **TestRunner** — компонент, который выполняет тесты и сообщает о результатах.
4. **Assertions** — методы для проверки условий.

### Пример использования unittest

Допустим, у нас есть простой модуль `calculator.py`:

```python
# calculator.py
class Calculator:
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
    
    def multiply(self, a, b):
        return a * b
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("Деление на ноль недопустимо")
        return a / b
```

Напишем тесты для этого модуля:

```python
# test_calculator.py
import unittest
from calculator import Calculator

class TestCalculator(unittest.TestCase):
    def setUp(self):
        """Метод выполняется перед каждым тестом"""
        self.calc = Calculator()
    
    def test_add(self):
        """Тест операции сложения"""
        self.assertEqual(self.calc.add(3, 5), 8)
        self.assertEqual(self.calc.add(-1, 1), 0)
        self.assertEqual(self.calc.add(-1, -1), -2)
    
    def test_subtract(self):
        """Тест операции вычитания"""
        self.assertEqual(self.calc.subtract(10, 5), 5)
        self.assertEqual(self.calc.subtract(5, 10), -5)
        self.assertEqual(self.calc.subtract(0, 0), 0)
    
    def test_multiply(self):
        """Тест операции умножения"""
        self.assertEqual(self.calc.multiply(3, 4), 12)
        self.assertEqual(self.calc.multiply(-2, 3), -6)
        self.assertEqual(self.calc.multiply(0, 5), 0)
    
    def test_divide(self):
        """Тест операции деления"""
        self.assertEqual(self.calc.divide(10, 2), 5)
        self.assertEqual(self.calc.divide(8, 4), 2)
        self.assertAlmostEqual(self.calc.divide(5, 2), 2.5)
    
    def test_divide_by_zero(self):
        """Тест проверки исключения при делении на ноль"""
        with self.assertRaises(ValueError):
            self.calc.divide(10, 0)
    
    def tearDown(self):
        """Метод выполняется после каждого теста"""
        pass

if __name__ == '__main__':
    unittest.main()
```

### Запуск тестов

Тесты можно запустить несколькими способами:

1. Через командную строку:
   ```bash
   python -m unittest test_calculator.py
   ```

2. Запустив файл с тестами напрямую (если определен блок `if __name__ == '__main__'`):
   ```bash
   python test_calculator.py
   ```

### Основные методы проверки (assertions)

| Метод | Описание |
|-------|----------|
| `assertEqual(a, b)` | Проверяет, что `a == b` |
| `assertNotEqual(a, b)` | Проверяет, что `a != b` |
| `assertTrue(x)` | Проверяет, что `bool(x) is True` |
| `assertFalse(x)` | Проверяет, что `bool(x) is False` |
| `assertIs(a, b)` | Проверяет, что `a is b` |
| `assertIsNot(a, b)` | Проверяет, что `a is not b` |
| `assertIsNone(x)` | Проверяет, что `x is None` |
| `assertIsNotNone(x)` | Проверяет, что `x is not None` |
| `assertIn(a, b)` | Проверяет, что `a in b` |
| `assertNotIn(a, b)` | Проверяет, что `a not in b` |
| `assertRaises(exc, fun, *args, **kwds)` | Проверяет, что `fun(*args, **kwds)` вызывает исключение `exc` |
| `assertAlmostEqual(a, b)` | Проверяет, что `round(a-b, 7) == 0` (полезно для чисел с плавающей точкой) |

### Жизненный цикл тестов

- `setUp()` — метод, который выполняется перед каждым тестовым методом.
- `tearDown()` — метод, который выполняется после каждого тестового метода.
- `setUpClass()` — метод класса, который выполняется один раз перед всеми тестовыми методами.
- `tearDownClass()` — метод класса, который выполняется один раз после всех тестовых методов.

## Фреймворк pytest

`pytest` — это альтернативный фреймворк для тестирования, который проще в использовании и обладает более богатым функционалом по сравнению с `unittest`.

### Установка pytest

```bash
pip install pytest
```

### Основные особенности pytest

1. **Простой синтаксис** — не требуется создавать классы и наследоваться от TestCase.
2. **Мощные фикстуры** — более гибкий механизм для настройки и очистки тестовой среды.
3. **Детальная информация об ошибках** — подробные сообщения при неудачных тестах.
4. **Плагины** — большое количество расширений для pytest.
5. **Параметризованные тесты** — возможность запускать один тест с разными параметрами.

### Пример использования pytest

Перепишем тесты для нашего калькулятора с использованием pytest:

```python
# test_calculator_pytest.py
import pytest
from calculator import Calculator

# Фикстура, которая создает экземпляр калькулятора
@pytest.fixture
def calculator():
    return Calculator()

def test_add(calculator):
    assert calculator.add(3, 5) == 8
    assert calculator.add(-1, 1) == 0
    assert calculator.add(-1, -1) == -2

def test_subtract(calculator):
    assert calculator.subtract(10, 5) == 5
    assert calculator.subtract(5, 10) == -5
    assert calculator.subtract(0, 0) == 0

def test_multiply(calculator):
    assert calculator.multiply(3, 4) == 12
    assert calculator.multiply(-2, 3) == -6
    assert calculator.multiply(0, 5) == 0

def test_divide(calculator):
    assert calculator.divide(10, 2) == 5
    assert calculator.divide(8, 4) == 2
    assert calculator.divide(5, 2) == 2.5

def test_divide_by_zero(calculator):
    with pytest.raises(ValueError):
        calculator.divide(10, 0)
```

### Запуск тестов pytest

```bash
pytest test_calculator_pytest.py
```

### Параметризованные тесты

Параметризация позволяет запускать один тест с разными входными данными:

```python
import pytest
from calculator import Calculator

@pytest.fixture
def calculator():
    return Calculator()

@pytest.mark.parametrize("a, b, expected", [
    (3, 5, 8),       # Обычные числа
    (-1, 1, 0),      # Отрицательное и положительное
    (-1, -1, -2),    # Два отрицательных
    (0, 0, 0)        # Нули
])
def test_add_parametrized(calculator, a, b, expected):
    assert calculator.add(a, b) == expected

@pytest.mark.parametrize("a, b, expected", [
    (10, 2, 5),
    (8, 4, 2),
    (5, 2, 2.5)
])
def test_divide_parametrized(calculator, a, b, expected):
    assert calculator.divide(a, b) == expected
```

### Фикстуры в pytest

Фикстуры в pytest — это функции, которые настраивают ресурсы, необходимые для тестов. Они могут иметь разные области видимости:

```python
import pytest
import tempfile
import os

# Фикстура уровня функции (по умолчанию)
@pytest.fixture
def temp_file():
    # Создаем временный файл
    fd, path = tempfile.mkstemp()
    yield path
    # Удаляем файл после теста
    os.close(fd)
    os.unlink(path)

# Фикстура уровня модуля
@pytest.fixture(scope="module")
def database_connection():
    # Создаем подключение к базе данных
    connection = setup_database()
    yield connection
    # Закрываем подключение после всех тестов в модуле
    connection.close()

# Фикстура уровня сессии
@pytest.fixture(scope="session")
def global_resource():
    # Инициализируем глобальный ресурс
    resource = initialize_resource()
    yield resource
    # Освобождаем ресурс после всех тестов
    cleanup_resource(resource)
```

Области видимости фикстур:
- `function` (по умолчанию) — фикстура вызывается для каждого теста.
- `class` — фикстура вызывается один раз для каждого класса с тестами.
- `module` — фикстура вызывается один раз для каждого модуля.
- `session` — фикстура вызывается один раз для всей тестовой сессии.

## Концепции и подходы к тестированию

### TDD (Test-Driven Development)

TDD — это подход к разработке, при котором сначала пишутся тесты, а затем код, который должен пройти эти тесты. Цикл TDD:

1. Написать тест, который не проходит.
2. Написать код, который проходит тест.
3. Провести рефакторинг кода (улучшение), сохраняя работоспособность тестов.
4. Повторить цикл.

### AAA (Arrange-Act-Assert)

Это паттерн организации тестового кода:

1. **Arrange** — подготовка данных и объектов для теста.
2. **Act** — выполнение тестируемой операции.
3. **Assert** — проверка результатов.

Пример:

```python
def test_add():
    # Arrange
    calculator = Calculator()
    a, b = 3, 5
    
    # Act
    result = calculator.add(a, b)
    
    # Assert
    assert result == 8
```

### Моки и стабы

**Мок (Mock)** — это объект, который имитирует поведение реального объекта контролируемым образом. Моки используются для изоляции тестируемого кода от внешних зависимостей.

**Стаб (Stub)** — это упрощенная реализация интерфейса, которая возвращает заранее определенные результаты.

В Python для создания моков обычно используется модуль `unittest.mock`:

```python
from unittest.mock import Mock, patch

def test_function_with_external_dependency():
    # Создание мока
    mock_object = Mock()
    mock_object.method.return_value = "предопределенный результат"
    
    # Использование мока
    result = function_under_test(mock_object)
    
    # Проверка, что метод мока был вызван
    mock_object.method.assert_called_once()
    
    # Проверка результата
    assert result == "ожидаемый результат"

# Патчинг (замена) объектов в тестируемом коде
@patch('module.ClassName')
def test_with_patched_class(mock_class):
    mock_class.return_value.method.return_value = "предопределенный результат"
    
    # Тестируемый код будет использовать mock_class вместо реального ClassName
    result = function_using_class_name()
    
    # Проверки...
```

### Code Coverage (Покрытие кода)

Покрытие кода — это метрика, которая показывает, какая часть исходного кода была выполнена при запуске тестов. Для измерения покрытия в Python используется инструмент `coverage.py`.

Установка:

```bash
pip install coverage
```

Запуск с измерением покрытия:

```bash
coverage run -m pytest test_file.py
coverage report -m  # Вывод отчета о покрытии
coverage html       # Создание HTML-отчета
```

## Реальные примеры тестирования

### Тестирование API сервиса

Допустим, у нас есть класс, который взаимодействует с API погоды:

```python
# weather_service.py
import requests

class WeatherService:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.weatherapi.com/v1"
    
    def get_current_temperature(self, city):
        """Получает текущую температуру в указанном городе."""
        url = f"{self.base_url}/current.json"
        params = {"key": self.api_key, "q": city}
        
        response = requests.get(url, params=params)
        if response.status_code != 200:
            raise Exception(f"API вернул ошибку: {response.status_code}")
        
        data = response.json()
        return data["current"]["temp_c"]
    
    def is_raining(self, city):
        """Проверяет, идет ли дождь в указанном городе."""
        url = f"{self.base_url}/current.json"
        params = {"key": self.api_key, "q": city}
        
        response = requests.get(url, params=params)
        if response.status_code != 200:
            raise Exception(f"API вернул ошибку: {response.status_code}")
        
        data = response.json()
        condition_code = data["current"]["condition"]["code"]
        # Коды для дождя обычно в диапазоне 1150-1201
        return 1150 <= condition_code <= 1201
```

Тест с использованием моков:

```python
# test_weather_service.py
import unittest
from unittest.mock import patch, Mock
from weather_service import WeatherService

class TestWeatherService(unittest.TestCase):
    def setUp(self):
        self.weather_service = WeatherService("fake_api_key")
    
    @patch('weather_service.requests.get')
    def test_get_current_temperature(self, mock_get):
        # Настраиваем мок для имитации ответа API
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "current": {
                "temp_c": 25.5
            }
        }
        mock_get.return_value = mock_response
        
        # Вызываем тестируемый метод
        temperature = self.weather_service.get_current_temperature("Moscow")
        
        # Проверяем, что метод вернул ожидаемую температуру
        self.assertEqual(temperature, 25.5)
        
        # Проверяем, что запрос был отправлен с правильными параметрами
        mock_get.assert_called_once()
        args, kwargs = mock_get.call_args
        self.assertEqual(kwargs['params']['q'], "Moscow")
    
    @patch('weather_service.requests.get')
    def test_is_raining(self, mock_get):
        # Настраиваем мок для случая, когда идет дождь
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "current": {
                "condition": {
                    "code": 1180  # Код для легкого дождя
                }
            }
        }
        mock_get.return_value = mock_response
        
        # Проверяем, что метод определяет дождь
        is_raining = self.weather_service.is_raining("London")
        self.assertTrue(is_raining)
        
        # Меняем ответ мока для случая, когда дождя нет
        mock_response.json.return_value = {
            "current": {
                "condition": {
                    "code": 1000  # Код для ясной погоды
                }
            }
        }
        
        # Проверяем, что метод определяет отсутствие дождя
        is_raining = self.weather_service.is_raining("London")
        self.assertFalse(is_raining)
    
    @patch('weather_service.requests.get')
    def test_api_error(self, mock_get):
        # Настраиваем мок для имитации ошибки API
        mock_response = Mock()
        mock_response.status_code = 401  # Неавторизованный доступ
        mock_get.return_value = mock_response
        
        # Проверяем, что метод выбрасывает исключение при ошибке API
        with self.assertRaises(Exception):
            self.weather_service.get_current_temperature("Moscow")

if __name__ == '__main__':
    unittest.main()
```

### Тестирование базы данных

Допустим, у нас есть класс для работы с базой данных пользователей:

```python
# user_repository.py
import sqlite3

class UserRepository:
    def __init__(self, db_path):
        self.db_path = db_path
    
    def _get_connection(self):
        return sqlite3.connect(self.db_path)
    
    def create_table(self):
        """Создает таблицу пользователей, если она не существует."""
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE NOT NULL,
                age INTEGER
            )
        ''')
        conn.commit()
        conn.close()
    
    def add_user(self, username, email, age):
        """Добавляет нового пользователя."""
        if not username or not email:
            raise ValueError("Username и email обязательны")
        
        if age is not None and (age < 0 or age > 120):
            raise ValueError("Возраст должен быть от 0 до 120")
        
        conn = self._get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "INSERT INTO users (username, email, age) VALUES (?, ?, ?)",
                (username, email, age)
            )
            conn.commit()
            return cursor.lastrowid
        except sqlite3.IntegrityError as e:
            conn.rollback()
            raise ValueError(f"Пользователь с таким username или email уже существует: {e}")
        finally:
            conn.close()
    
    def get_user_by_id(self, user_id):
        """Получает пользователя по ID."""
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, username, email, age FROM users WHERE id = ?", (user_id,))
        user = cursor.fetchone()
        conn.close()
        
        if user:
            return {
                "id": user[0],
                "username": user[1],
                "email": user[2],
                "age": user[3]
            }
        return None
    
    def delete_user(self, user_id):
        """Удаляет пользователя по ID."""
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
        affected_rows = cursor.rowcount
        conn.commit()
        conn.close()
        
        return affected_rows > 0
```

Тесты для UserRepository:

```python
# test_user_repository.py
import unittest
import os
import tempfile
from user_repository import UserRepository

class TestUserRepository(unittest.TestCase):
    def setUp(self):
        # Создаем временную базу данных для тестов
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.repo = UserRepository(self.db_path)
        self.repo.create_table()
    
    def tearDown(self):
        # Удаляем временную базу данных после тестов
        os.close(self.db_fd)
        os.unlink(self.db_path)
    
    def test_add_user(self):
        # Добавляем пользователя и проверяем, что он получил ID
        user_id = self.repo.add_user("testuser", "test@example.com", 25)
        self.assertIsNotNone(user_id)
        
        # Получаем пользователя по ID и проверяем его данные
        user = self.repo.get_user_by_id(user_id)
        self.assertEqual(user["username"], "testuser")
        self.assertEqual(user["email"], "test@example.com")
        self.assertEqual(user["age"], 25)
    
    def test_add_user_with_invalid_age(self):
        # Проверяем, что добавление пользователя с неверным возрастом вызывает исключение
        with self.assertRaises(ValueError):
            self.repo.add_user("testuser", "test@example.com", -5)
        
        with self.assertRaises(ValueError):
            self.repo.add_user("testuser", "test@example.com", 130)
    
    def test_add_duplicate_user(self):
        # Добавляем пользователя
        self.repo.add_user("testuser", "test@example.com", 25)
        
        # Проверяем, что добавление пользователя с таким же username вызывает исключение
        with self.assertRaises(ValueError):
            self.repo.add_user("testuser", "other@example.com", 30)
        
        # Проверяем, что добавление пользователя с таким же email вызывает исключение
        with self.assertRaises(ValueError):
            self.repo.add_user("otheruser", "test@example.com", 30)
    
    def test_delete_user(self):
        # Добавляем пользователя
        user_id = self.repo.add_user("testuser", "test@example.com", 25)
        
        # Проверяем, что пользователь существует
        user = self.repo.get_user_by_id(user_id)
        self.assertIsNotNone(user)
        
        # Удаляем пользователя
        result = self.repo.delete_user(user_id)
        self.assertTrue(result)
        
        # Проверяем, что пользователь удален
        user = self.repo.get_user_by_id(user_id)
        self.assertIsNone(user)
    
    def test_delete_nonexistent_user(self):
        # Пытаемся удалить несуществующего пользователя
        result = self.repo.delete_user(999)
        self.assertFalse(result)

if __name__ == '__main__':
    unittest.main()
```

## Практические задания

### Задание 1: Тестирование класса работы с файлами

Напишите класс `FileManager`, который обладает следующими методами:
- `read_file(path)` — чтение содержимого файла по указанному пути.
- `write_file(path, content)` — запись содержимого в файл по указанному пути.
- `append_file(path, content)` — добавление содержимого в конец файла.
- `get_file_size(path)` — получение размера файла в байтах.
- `file_exists(path)` — проверка существования файла.

Затем напишите тесты для этого класса, используя unittest или pytest.

#### Решение

```python
# file_manager.py
import os

class FileManager:
    def read_file(self, path):
        """
        Читает содержимое файла.
        
        Args:
            path (str): Путь к файлу.
            
        Returns:
            str: Содержимое файла.
            
        Raises:
            FileNotFoundError: Если файл не существует.
            PermissionError: Если нет прав на чтение файла.
        """
        with open(path, 'r', encoding='utf-8') as file:
            return file.read()
    
    def write_file(self, path, content):
        """
        Записывает содержимое в файл, перезаписывая его если он существует.
        
        Args:
            path (str): Путь к файлу.
            content (str): Содержимое для записи.
            
        Raises:
            PermissionError: Если нет прав на запись в файл.
            OSError: При других ошибках ввода-вывода.
        """
        with open(path, 'w', encoding='utf-8') as file:
            file.write(content)
    
    def append_file(self, path, content):
        """
        Добавляет содержимое в конец файла.
        
        Args:
            path (str): Путь к файлу.
            content (str): Содержимое для добавления.
            
        Raises:
            FileNotFoundError: Если файл не существует.
            PermissionError: Если нет прав на запись в файл.
        """
        with open(path, 'a', encoding='utf-8') as file:
            file.write(content)
    
    def get_file_size(self, path):
        """
        Возвращает размер файла в байтах.
        
        Args:
            path (str): Путь к файлу.
            
        Returns:
            int: Размер файла в байтах.
            
        Raises:
            FileNotFoundError: Если файл не существует.
        """
        return os.path.getsize(path)
    
    def file_exists(self, path):
        """
        Проверяет существование файла.
        
        Args:
            path (str): Путь к файлу.
            
        Returns:
            bool: True, если файл существует, иначе False.
        """
        return os.path.isfile(path)
```

```python
# test_file_manager.py
import unittest
import os
import tempfile
from file_manager import FileManager

class TestFileManager(unittest.TestCase):
    def setUp(self):
        self.file_manager = FileManager()
        # Создаем временную директорию для тестов
        self.test_dir = tempfile.TemporaryDirectory()
        # Путь к тестовому файлу
        self.test_file = os.path.join(self.test_dir.name, "test_file.txt")
    
    def tearDown(self):
        # Удаляем временную директорию после тестов
        self.test_dir.cleanup()
    
    def test_write_and_read_file(self):
        # Записываем содержимое в файл
        content = "Hello, world!"
        self.file_manager.write_file(self.test_file, content)
        
        # Проверяем, что файл существует
        self.assertTrue(self.file_manager.file_exists(self.test_file))
        
        # Читаем файл и проверяем содержимое
        read_content = self.file_manager.read_file(self.test_file)
        self.assertEqual(read_content, content)
    
    def test_append_file(self):
        # Записываем начальное содержимое
        initial_content = "Hello, "
        self.file_manager.write_file(self.test_file, initial_content)
        
        # Добавляем содержимое
        additional_content = "world!"
        self.file_manager.append_file(self.test_file, additional_content)
        
        # Читаем файл и проверяем содержимое
        read_content = self.file_manager.read_file(self.test_file)
        self.assertEqual(read_content, initial_content + additional_content)
    
    def test_get_file_size(self):
        # Записываем содержимое определенной длины
        content = "Hello, world!"
        self.file_manager.write_file(self.test_file, content)
        
        # Проверяем размер файла
        size = self.file_manager.get_file_size(self.test_file)
        self.assertEqual(size, len(content.encode('utf-8')))
    
    def test_file_exists(self):
        # Проверяем, что файл не существует изначально
        self.assertFalse(self.file_manager.file_exists(self.test_file))
        
        # Создаем файл
        self.file_manager.write_file(self.test_file, "Some content")
        
        # Проверяем, что файл существует
        self.assertTrue(self.file_manager.file_exists(self.test_file))
    
    def test_read_nonexistent_file(self):
        # Проверяем, что чтение несуществующего файла вызывает исключение
        nonexistent_file = os.path.join(self.test_dir.name, "nonexistent.txt")
        with self.assertRaises(FileNotFoundError):
            self.file_manager.read_file(nonexistent_file)

if __name__ == '__main__':
    unittest.main()
```

### Задание 2: Тестирование с использованием моков

Создайте класс `EmailService`, который отправляет электронные письма с помощью абстрактного `SmtpProvider`. `SmtpProvider` — это класс, который непосредственно взаимодействует с SMTP-сервером.

Напишите тесты для `EmailService`, используя моки для имитации `SmtpProvider`.

#### Решение

```python
# email_service.py
class SmtpProvider:
    def connect(self, server, port, username, password):
        """Подключается к SMTP-серверу."""
        raise NotImplementedError("Метод должен быть переопределен")
    
    def send_email(self, from_email, to_email, subject, body):
        """Отправляет электронное письмо."""
        raise NotImplementedError("Метод должен быть переопределен")
    
    def disconnect(self):
        """Отключается от SMTP-сервера."""
        raise NotImplementedError("Метод должен быть переопределен")

class EmailService:
    def __init__(self, smtp_provider, config):
        """
        Инициализирует сервис отправки писем.
        
        Args:
            smtp_provider (SmtpProvider): Провайдер для отправки писем.
            config (dict): Конфигурация SMTP-сервера.
        """
        self.smtp_provider = smtp_provider
        self.config = config
        self.connected = False
    
    def connect(self):
        """
        Подключается к SMTP-серверу.
        
        Returns:
            bool: True, если подключение успешно, иначе False.
        """
        try:
            self.smtp_provider.connect(
                self.config["server"],
                self.config["port"],
                self.config["username"],
                self.config["password"]
            )
            self.connected = True
            return True
        except Exception as e:
            print(f"Ошибка подключения к SMTP-серверу: {e}")
            self.connected = False
            return False
    
    def send_email(self, to_email, subject, body):
        """
        Отправляет электронное письмо.
        
        Args:
            to_email (str): Адрес получателя.
            subject (str): Тема письма.
            body (str): Тело письма.
            
        Returns:
            bool: True, если письмо отправлено успешно, иначе False.
            
        Raises:
            RuntimeError: Если нет подключения к SMTP-серверу.
        """
        if not self.connected:
            raise RuntimeError("Нет подключения к SMTP-серверу")
        
        try:
            self.smtp_provider.send_email(
                self.config["from_email"],
                to_email,
                subject,
                body
            )
            return True
        except Exception as e:
            print(f"Ошибка отправки письма: {e}")
            return False
    
    def disconnect(self):
        """
        Отключается от SMTP-сервера.
        
        Returns:
            bool: True, если отключение успешно, иначе False.
        """
        if not self.connected:
            return True
        
        try:
            self.smtp_provider.disconnect()
            self.connected = False
            return True
        except Exception as e:
            print(f"Ошибка отключения от SMTP-сервера: {e}")
            return False
```

```python
# test_email_service.py
import unittest
from unittest.mock import Mock
from email_service import EmailService

class TestEmailService(unittest.TestCase):
    def setUp(self):
        # Создаем мок для SmtpProvider
        self.mock_smtp_provider = Mock()
        
        # Настраиваем конфигурацию
        self.config = {
            "server": "smtp.example.com",
            "port": 587,
            "username": "user@example.com",
            "password": "password",
            "from_email": "noreply@example.com"
        }
        
        # Создаем EmailService с моком
        self.email_service = EmailService(self.mock_smtp_provider, self.config)
    
    def test_connect_success(self):
        # Настраиваем мок, чтобы connect успешно выполнялся
        self.mock_smtp_provider.connect.return_value = None
        
        # Вызываем метод connect
        result = self.email_service.connect()
        
        # Проверяем, что метод connect был вызван с правильными параметрами
        self.mock_smtp_provider.connect.assert_called_once_with(
            self.config["server"],
            self.config["port"],
            self.config["username"],
            self.config["password"]
        )
        
        # Проверяем, что метод вернул True и установил флаг connected
        self.assertTrue(result)
        self.assertTrue(self.email_service.connected)
    
    def test_connect_failure(self):
        # Настраиваем мок, чтобы connect вызывал исключение
        self.mock_smtp_provider.connect.side_effect = Exception("Connection error")
        
        # Вызываем метод connect
        result = self.email_service.connect()
        
        # Проверяем, что метод вернул False и не установил флаг connected
        self.assertFalse(result)
        self.assertFalse(self.email_service.connected)
    
    def test_send_email_without_connection(self):
        # Проверяем, что отправка письма без подключения вызывает исключение
        with self.assertRaises(RuntimeError):
            self.email_service.send_email("recipient@example.com", "Subject", "Body")
    
    def test_send_email_success(self):
        # Устанавливаем подключение
        self.mock_smtp_provider.connect.return_value = None
        self.email_service.connect()
        
        # Настраиваем мок, чтобы send_email успешно выполнялся
        self.mock_smtp_provider.send_email.return_value = None
        
        # Отправляем письмо
        result = self.email_service.send_email("recipient@example.com", "Subject", "Body")
        
        # Проверяем, что метод send_email был вызван с правильными параметрами
        self.mock_smtp_provider.send_email.assert_called_once_with(
            self.config["from_email"],
            "recipient@example.com",
            "Subject",
            "Body"
        )
        
        # Проверяем, что метод вернул True
        self.assertTrue(result)
    
    def test_send_email_failure(self):
        # Устанавливаем подключение
        self.mock_smtp_provider.connect.return_value = None
        self.email_service.connect()
        
        # Настраиваем мок, чтобы send_email вызывал исключение
        self.mock_smtp_provider.send_email.side_effect = Exception("Send error")
        
        # Отправляем письмо
        result = self.email_service.send_email("recipient@example.com", "Subject", "Body")
        
        # Проверяем, что метод вернул False
        self.assertFalse(result)
    
    def test_disconnect_success(self):
        # Устанавливаем подключение
        self.mock_smtp_provider.connect.return_value = None
        self.email_service.connect()
        
        # Настраиваем мок, чтобы disconnect успешно выполнялся
        self.mock_smtp_provider.disconnect.return_value = None
        
        # Вызываем метод disconnect
        result = self.email_service.disconnect()
        
        # Проверяем, что метод disconnect был вызван
        self.mock_smtp_provider.disconnect.assert_called_once()
        
        # Проверяем, что метод вернул True и сбросил флаг connected
        self.assertTrue(result)
        self.assertFalse(self.email_service.connected)
    
    def test_disconnect_without_connection(self):
        # Проверяем, что отключение без подключения возвращает True
        result = self.email_service.disconnect()
        self.assertTrue(result)
        
        # Проверяем, что метод disconnect не был вызван
        self.mock_smtp_provider.disconnect.assert_not_called()

if __name__ == '__main__':
    unittest.main()
```

### Задание 3: Тестирование с параметризацией

Создайте функцию `validate_password`, которая проверяет пароль на соответствие требованиям безопасности:
- Длина не менее 8 символов
- Содержит хотя бы одну заглавную букву
- Содержит хотя бы одну строчную букву
- Содержит хотя бы одну цифру
- Содержит хотя бы один специальный символ из `!@#$%^&*()_+-=[]{}|;:'",.<>?/`

Напишите параметризованные тесты для этой функции с использованием pytest.

#### Решение

```python
# password_validator.py
def validate_password(password):
    """
    Проверяет пароль на соответствие требованиям безопасности.
    
    Требования:
    - Длина не менее 8 символов
    - Содержит хотя бы одну заглавную букву
    - Содержит хотя бы одну строчную букву
    - Содержит хотя бы одну цифру
    - Содержит хотя бы один специальный символ из !@#$%^&*()_+-=[]{}|;:'",.<>?/
    
    Args:
        password (str): Пароль для проверки.
        
    Returns:
        bool: True, если пароль соответствует всем требованиям, иначе False.
    """
    if len(password) < 8:
        return False
    
    has_uppercase = False
    has_lowercase = False
    has_digit = False
    has_special = False
    
    special_chars = "!@#$%^&*()_+-=[]{}|;:'\",.<>?/"
    
    for char in password:
        if char.isupper():
            has_uppercase = True
        elif char.islower():
            has_lowercase = True
        elif char.isdigit():
            has_digit = True
        elif char in special_chars:
            has_special = True
    
    return has_uppercase and has_lowercase and has_digit and has_special
```

```python
# test_password_validator.py
import pytest
from password_validator import validate_password

@pytest.mark.parametrize("password,expected", [
    # Валидные пароли
    ("Abcd1234!", True),  # Обычный валидный пароль
    ("P@ssw0rd", True),   # Минимальная длина с валидными символами
    ("Str0ng&L0ngP@ssw0rd", True),  # Длинный валидный пароль
    
    # Невалидные пароли - недостаточная длина
    ("Abc1!", False),     # Меньше 8 символов
    
    # Невалидные пароли - нет заглавных букв
    ("abcd1234!", False),  # Нет заглавных букв
    
    # Невалидные пароли - нет строчных букв
    ("ABCD1234!", False),  # Нет строчных букв
    
    # Невалидные пароли - нет цифр
    ("AbcdEfgh!", False),  # Нет цифр
    
    # Невалидные пароли - нет специальных символов
    ("Abcd1234", False),   # Нет специальных символов
])
def test_validate_password(password, expected):
    assert validate_password(password) == expected

# Тестирование граничных случаев
def test_validate_password_edge_cases():
    # Пароль ровно 8 символов с всеми требованиями
    assert validate_password("Aa1!5678") == True
    
    # Пароль только из специальных символов (не должен быть валидным)
    assert validate_password("!@#$%^&*") == False
    
    # Пустой пароль
    assert validate_password("") == False
    
    # Пароль только из пробелов (не должен быть валидным)
    assert validate_password("        ") == False

# Тестирование различных специальных символов
@pytest.mark.parametrize("special_char", list("!@#$%^&*()_+-=[]{}|;:'\",.<>?/"))
def test_validate_password_special_chars(special_char):
    # Создаем пароль с конкретным специальным символом
    password = f"Abcd1234{special_char}"
    assert validate_password(password) == True
```

## Мини-проект: тестирование библиотеки работы с данными

Создадим и протестируем простую библиотеку для работы с данными, которая имитирует функциональность работы с CSV файлами.

### Задача

Разработать класс `DataProcessor`, который загружает, обрабатывает и анализирует данные из CSV файлов. Класс должен иметь следующие возможности:
- Загрузка данных из CSV файла
- Фильтрация данных по различным критериям
- Сортировка данных
- Расчет статистических показателей
- Экспорт данных в CSV файл

Затем напишем полный набор тестов для этого класса с использованием pytest.

### Решение

```python
# data_processor.py
import csv
import statistics

class DataProcessor:
    def __init__(self):
        self.data = []
        self.columns = []
    
    def load_csv(self, file_path, delimiter=',', has_header=True):
        """
        Загружает данные из CSV файла.
        
        Args:
            file_path (str): Путь к CSV файлу.
            delimiter (str): Разделитель полей. По умолчанию ','.
            has_header (bool): Имеет ли файл заголовок. По умолчанию True.
            
        Returns:
            bool: True, если загрузка прошла успешно, иначе False.
            
        Raises:
            FileNotFoundError: Если файл не существует.
            Exception: При других ошибках чтения файла.
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                csv_reader = csv.reader(file, delimiter=delimiter)
                
                # Чтение заголовка
                if has_header:
                    self.columns = next(csv_reader)
                
                # Чтение данных
                self.data = [row for row in csv_reader]
            
            return True
        except FileNotFoundError:
            raise FileNotFoundError(f"Файл '{file_path}' не найден")
        except Exception as e:
            raise Exception(f"Ошибка при чтении файла: {e}")
    
    def get_column_index(self, column_name):
        """
        Получает индекс колонки по ее имени.
        
        Args:
            column_name (str): Имя колонки.
            
        Returns:
            int: Индекс колонки.
            
        Raises:
            ValueError: Если колонка не найдена.
        """
        try:
            return self.columns.index(column_name)
        except ValueError:
            raise ValueError(f"Колонка '{column_name}' не найдена")
    
    def filter_data(self, column_name, value, condition='=='):
        """
        Фильтрует данные по значению в указанной колонке.
        
        Args:
            column_name (str): Имя колонки для фильтрации.
            value: Значение для сравнения.
            condition (str): Условие фильтрации ('==', '!=', '>', '<', '>=', '<=', 'contains').
                             По умолчанию '=='.
            
        Returns:
            list: Отфильтрованные данные.
            
        Raises:
            ValueError: Если указана неподдерживаемая операция.
        """
        column_index = self.get_column_index(column_name)
        filtered_data = []
        
        for row in self.data:
            cell_value = row[column_index]
            
            # Пытаемся преобразовать в число, если это возможно
            if condition not in ('contains', 'startswith', 'endswith'):
                try:
                    cell_value = float(cell_value)
                    value = float(value)
                except (ValueError, TypeError):
                    pass
            
            # Применяем условие фильтрации
            if condition == '==':
                if cell_value == value:
                    filtered_data.append(row)
            elif condition == '!=':
                if cell_value != value:
                    filtered_data.append(row)
            elif condition == '>':
                if cell_value > value:
                    filtered_data.append(row)
            elif condition == '<':
                if cell_value < value:
                    filtered_data.append(row)
            elif condition == '>=':
                if cell_value >= value:
                    filtered_data.append(row)
            elif condition == '<=':
                if cell_value <= value:
                    filtered_data.append(row)
            elif condition == 'contains':
                if str(value) in str(cell_value):
                    filtered_data.append(row)
            elif condition == 'startswith':
                if str(cell_value).startswith(str(value)):
                    filtered_data.append(row)
            elif condition == 'endswith':
                if str(cell_value).endswith(str(value)):
                    filtered_data.append(row)
            else:
                raise ValueError(f"Неподдерживаемая операция: '{condition}'")
        
        return filtered_data
    
    def sort_data(self, column_name, ascending=True):
        """
        Сортирует данные по указанной колонке.
        
        Args:
            column_name (str): Имя колонки для сортировки.
            ascending (bool): Порядок сортировки. True для возрастающего,
                              False для убывающего. По умолчанию True.
            
        Returns:
            list: Отсортированные данные.
        """
        column_index = self.get_column_index(column_name)
        
        # Создаем копию данных для сортировки
        sorted_data = sorted(
            self.data,
            key=lambda row: self._convert_value(row[column_index]),
            reverse=not ascending
        )
        
        return sorted_data
    
    def _convert_value(self, value):
        """
        Преобразует строковое значение в число, если это возможно.
        
        Args:
            value (str): Значение для преобразования.
            
        Returns:
            Преобразованное значение (число или строка).
        """
        try:
            return float(value)
        except (ValueError, TypeError):
            return str(value)
    
    def calculate_statistics(self, column_name):
        """
        Рассчитывает статистические показатели для указанной колонки.
        
        Args:
            column_name (str): Имя колонки для расчета статистики.
            
        Returns:
            dict: Словарь со статистическими показателями.
            
        Raises:
            ValueError: Если колонка содержит нечисловые значения.
        """
        column_index = self.get_column_index(column_name)
        
        # Извлекаем значения колонки
        values = []
        for row in self.data:
            try:
                values.append(float(row[column_index]))
            except ValueError:
                raise ValueError(f"Колонка '{column_name}' содержит нечисловые значения")
        
        # Проверяем, что у нас есть данные
        if not values:
            return {
                "count": 0,
                "min": None,
                "max": None,
                "sum": None,
                "mean": None,
                "median": None,
                "std_dev": None
            }
        
        # Рассчитываем статистику
        stats = {
            "count": len(values),
            "min": min(values),
            "max": max(values),
            "sum": sum(values),
            "mean": statistics.mean(values),
            "median": statistics.median(values)
        }
        
        # Стандартное отклонение (если у нас больше одного значения)
        if len(values) > 1:
            stats["std_dev"] = statistics.stdev(values)
        else:
            stats["std_dev"] = 0
        
        return stats
    
    def export_to_csv(self, file_path, data=None, delimiter=',', include_header=True):
        """
        Экспортирует данные в CSV файл.
        
        Args:
            file_path (str): Путь к выходному CSV файлу.
            data (list, optional): Данные для экспорта. По умолчанию None (использует self.data).
            delimiter (str): Разделитель полей. По умолчанию ','.
            include_header (bool): Включать ли заголовок. По умолчанию True.
            
        Returns:
            bool: True, если экспорт прошел успешно, иначе False.
            
        Raises:
            Exception: При ошибках записи файла.
        """
        if data is None:
            data = self.data
        
        try:
            with open(file_path, 'w', encoding='utf-8', newline='') as file:
                csv_writer = csv.writer(file, delimiter=delimiter)
                
                # Записываем заголовок
                if include_header and self.columns:
                    csv_writer.writerow(self.columns)
                
                # Записываем данные
                csv_writer.writerows(data)
            
            return True
        except Exception as e:
            raise Exception(f"Ошибка при записи файла: {e}")
```

```python
# test_data_processor.py
import pytest
import os
import tempfile
import csv
from data_processor import DataProcessor

class TestDataProcessor:
    @pytest.fixture
    def processor(self):
        """Фикстура для создания экземпляра DataProcessor."""
        return DataProcessor()
    
    @pytest.fixture
    def sample_csv_file(self):
        """Фикстура для создания временного CSV файла с тестовыми данными."""
        # Создаем временный файл
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv') as temp_file:
            # Записываем данные в CSV
            writer = csv.writer(temp_file)
            writer.writerow(['id', 'name', 'age', 'salary'])
            writer.writerow(['1', 'John', '30', '5000'])
            writer.writerow(['2', 'Alice', '25', '6000'])
            writer.writerow(['3', 'Bob', '35', '4500'])
            writer.writerow(['4', 'Eve', '28', '7000'])
            writer.writerow(['5', 'Mike', '40', '5500'])
            file_path = temp_file.name
        
        # Возвращаем путь к файлу
        yield file_path
        
        # Удаляем файл после тестов
        os.unlink(file_path)
    
    def test_load_csv(self, processor, sample_csv_file):
        """Тест загрузки CSV файла."""
        # Загружаем CSV файл
        processor.load_csv(sample_csv_file)
        
        # Проверяем, что заголовки загружены правильно
        assert processor.columns == ['id', 'name', 'age', 'salary']
        
        # Проверяем, что данные загружены правильно
        assert len(processor.data) == 5
        assert processor.data[0] == ['1', 'John', '30', '5000']
    
    def test_load_csv_non_existent_file(self, processor):
        """Тест загрузки несуществующего файла."""
        with pytest.raises(FileNotFoundError):
            processor.load_csv('non_existent_file.csv')
    
    def test_get_column_index(self, processor, sample_csv_file):
        """Тест получения индекса колонки."""
        processor.load_csv(sample_csv_file)
        
        assert processor.get_column_index('id') == 0
        assert processor.get_column_index('name') == 1
        assert processor.get_column_index('age') == 2
        assert processor.get_column_index('salary') == 3
    
    def test_get_column_index_non_existent(self, processor, sample_csv_file):
        """Тест получения индекса несуществующей колонки."""
        processor.load_csv(sample_csv_file)
        
        with pytest.raises(ValueError):
            processor.get_column_index('non_existent')
    
    @pytest.mark.parametrize("column,value,condition,expected_count", [
        ('name', 'John', '==', 1),         # Точное совпадение
        ('age', '30', '==', 1),            # Равенство числовых значений
        ('salary', '5000', '>=', 4),       # Больше или равно
        ('name', 'o', 'contains', 2),      # Содержит подстроку
        ('name', 'A', 'startswith', 1),    # Начинается с
        ('name', 'e', 'endswith', 2)       # Заканчивается на
    ])
    def test_filter_data(self, processor, sample_csv_file, column, value, condition, expected_count):
        """Тест фильтрации данных с различными условиями."""
        processor.load_csv(sample_csv_file)
        
        filtered_data = processor.filter_data(column, value, condition)
        assert len(filtered_data) == expected_count
    
    def test_filter_data_invalid_condition(self, processor, sample_csv_file):
        """Тест фильтрации с некорректным условием."""
        processor.load_csv(sample_csv_file)
        
        with pytest.raises(ValueError):
            processor.filter_data('name', 'John', 'invalid_condition')
    
    def test_sort_data(self, processor, sample_csv_file):
        """Тест сортировки данных."""
        processor.load_csv(sample_csv_file)
        
        # Сортировка по возрасту (по возрастанию)
        sorted_data = processor.sort_data('age', ascending=True)
        ages = [row[2] for row in sorted_data]
        assert ages == ['25', '28', '30', '35', '40']
        
        # Сортировка по зарплате (по убыванию)
        sorted_data = processor.sort_data('salary', ascending=False)
        salaries = [row[3] for row in sorted_data]
        assert salaries == ['7000', '6000', '5500', '5000', '4500']
    
    def test_calculate_statistics(self, processor, sample_csv_file):
        """Тест расчета статистических показателей."""
        processor.load_csv(sample_csv_file)
        
        # Рассчитываем статистику по возрасту
        stats = processor.calculate_statistics('age')
        
        assert stats['count'] == 5
        assert stats['min'] == 25
        assert stats['max'] == 40
        assert stats['sum'] == 158
        assert stats['mean'] == 31.6
        assert stats['median'] == 30
        assert pytest.approx(stats['std_dev'], 0.01) == 5.85
    
    def test_calculate_statistics_non_numeric(self, processor, sample_csv_file):
        """Тест расчета статистики для нечисловой колонки."""
        processor.load_csv(sample_csv_file)
        
        with pytest.raises(ValueError):
            processor.calculate_statistics('name')
    
    def test_export_to_csv(self, processor, sample_csv_file):
        """Тест экспорта данных в CSV файл."""
        processor.load_csv(sample_csv_file)
        
        # Создаем временный файл для экспорта
        export_file = tempfile.NamedTemporaryFile(delete=False, suffix='.csv').name
        
        try:
            # Экспортируем данные
            processor.export_to_csv(export_file)
            
            # Создаем новый процессор и загружаем экспортированные данные
            new_processor = DataProcessor()
            new_processor.load_csv(export_file)
            
            # Проверяем, что данные совпадают
            assert new_processor.columns == processor.columns
            assert new_processor.data == processor.data
        finally:
            # Удаляем временный файл
            os.unlink(export_file)
    
    def test_export_filtered_data(self, processor, sample_csv_file):
        """Тест экспорта отфильтрованных данных."""
        processor.load_csv(sample_csv_file)
        
        # Фильтруем данные
        filtered_data = processor.filter_data('age', 30, '>=')
        
        # Создаем временный файл для экспорта
        export_file = tempfile.NamedTemporaryFile(delete=False, suffix='.csv').name
        
        try:
            # Экспортируем отфильтрованные данные
            processor.export_to_csv(export_file, data=filtered_data)
            
            # Создаем новый процессор и загружаем экспортированные данные
            new_processor = DataProcessor()
            new_processor.load_csv(export_file)
            
            # Проверяем, что количество строк соответствует отфильтрованным данным
            assert len(new_processor.data) == len(filtered_data)
        finally:
            # Удаляем временный файл
            os.unlink(export_file)
```

### Идеи для улучшения мини-проекта

1. **Добавление типов данных**:
   - Автоматическое определение типов данных в колонках (число, строка, дата)
   - Поддержка приведения типов при загрузке и экспорте данных

2. **Расширение функциональности**:
   - Добавление агрегирующих функций (GROUP BY)
   - Поддержка объединения данных из нескольких файлов (JOIN)
   - Вычисление новых колонок на основе существующих

3. **Улучшение производительности**:
   - Оптимизация работы с большими файлами (потоковая обработка)
   - Кэширование результатов частых операций

4. **Визуализация данных**:
   - Добавление функций для построения графиков и диаграмм
   - Экспорт результатов в HTML или PDF отчеты

5. **Расширение форматов**:
   - Поддержка загрузки и экспорта данных в других форматах (Excel, JSON, SQL)
   - Конвертация между форматами

## Заключение

Модульное тестирование — важный навык для любого программиста. Хорошие тесты не только помогают обнаруживать ошибки на ранних этапах разработки, но и документируют поведение кода, облегчают рефакторинг и повышают уверенность в работоспособности программы.

В этом материале мы рассмотрели два основных инструмента для тестирования в Python: встроенный модуль `unittest` и более гибкий фреймворк `pytest`. Мы изучили основные концепции тестирования, такие как TDD, AAA и моки, и применили их на практике.

Для закрепления материала попробуйте написать тесты для своих собственных проектов или решите следующие задачи:

1. Напишите тесты для существующего проекта с использованием pytest.
2. Реализуйте подход TDD для новой функциональности.
3. Используйте моки для изоляции внешних зависимостей в тестах.
4. Измерьте покрытие кода тестами с помощью coverage.py.

Помните, что хорошие тесты — это инвестиция в качество кода и снижение затрат на его сопровождение в будущем.
