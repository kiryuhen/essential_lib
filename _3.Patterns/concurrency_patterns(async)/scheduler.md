# Шаблон Scheduler Pattern (Шедулер)

## Описание
Scheduler Pattern — это паттерн управления планированием и выполнением задач, разделяющий очередь задач, политику планирования и исполнителей для гибкого распределения ресурсов.

## Проблема
В системах с множеством задач важно контролировать, какие задачи и когда выполняются: без централизованного планировщика ресурсы могут расходоваться неэффективно, задачи запускаться в неоптимальном порядке или вовсе пропускаться.

## Решение
Scheduler вводит компонент, который принимает задачи, ставит их в очередь, а затем по заданной политике (приоритет, Round Robin, время выполнения) выбирает следующую задачу для исполнения рабочим потоком.

## Структура
1. **Task Queue (Очередь задач)** — хранилище ожидающих задач.
2. **Scheduling Policy (Политика планирования)** — алгоритм (приоритеты, FIFO, Round Robin), определяющий порядок выполнения.
3. **Scheduler** — модуль, извлекающий задачи из очереди по политике и передающий их исполнителю.
4. **Worker/Executor (Исполнитель)** — компонент, выполняющий задачу.

## Пример на Python
```python
import queue, threading, time

class Scheduler:
    def __init__(self):
        self._tasks = queue.PriorityQueue()
        self._running = True
        threading.Thread(target=self._run_loop, daemon=True).start()

    def schedule(self, priority, func, *args):
        # Помещаем кортеж (приоритет, время добавления, функция, аргументы)
        self._tasks.put((priority, time.time(), func, args))

    def _run_loop(self):
        while self._running:
            if not self._tasks.empty():
                priority, _, func, args = self._tasks.get()
                func(*args)
            else:
                time.sleep(0.01)

    def shutdown(self):
        self._running = False

# Пример использования
sched = Scheduler()
sched.schedule(5, print, "Низкий приоритет")
sched.schedule(1, print, "Высокий приоритет")
# Спим, чтобы задачи успели выполниться
import time; time.sleep(0.1)
sched.shutdown()
```

## Применение
- Системы фоновых и отложенных заданий
- Очереди сообщений (message queues)
- ОС-планировщики и виртуальные машины
- Реализация таймаутов и отложенных колбэков

## Плюсы
1. Централизация управления задачами и ресурсами
2. Гибкость в выборе и смене политики планирования
3. Лёгкое масштабирование и расширение (добавление новых политик)
4. Повышение предсказуемости и управляемости системы

## Минусы
1. Дополнительные накладные расходы на управление очередью
2. Увеличенная задержка при большом числе задач в очереди
3. Сложность реализации сложных политик в одном scheduler

## Когда использовать
- Когда нужно контролировать порядок и время выполнения множества задач
- В системах с разными приоритетами и SLA
- При необходимости равномерного распределения ресурсов

