# Основы Computer Science

## Содержание
- [Архитектура компьютера](#архитектура-компьютера)
- [Системы счисления](#системы-счисления)
- [Алгоритмическое мышление](#алгоритмическое-мышление)
- [Булева алгебра и логические операции](#булева-алгебра-и-логические-операции)

## Архитектура компьютера

### Общий обзор

Архитектура компьютера описывает, как организованы и взаимодействуют различные компоненты компьютерной системы. Понимание архитектуры важно для оптимизации кода и осознания того, как программы выполняются "под капотом".

### Архитектура фон Неймана

Большинство современных компьютеров основаны на архитектуре фон Неймана, которая включает:

1. **Центральный процессор (CPU)** - "мозг" компьютера, выполняющий инструкции программы
2. **Память** - хранит данные и инструкции
3. **Устройства ввода/вывода** - взаимодействуют с внешним миром
4. **Шина** - обеспечивает соединение между компонентами

```
┌─────────────┐       ┌───────────────┐
│    Память   │◄─────►│     Шина      │
└─────────────┘       └───────┬───────┘
                             │
                      ┌──────▼──────┐
┌─────────────┐       │     CPU     │
│ Устройства  │◄─────►│             │
│ ввода/вывода│       └─────────────┘
└─────────────┘
```

### Центральный процессор (CPU)

CPU состоит из нескольких ключевых компонентов:

1. **Арифметико-логическое устройство (АЛУ)** - выполняет математические и логические операции
2. **Регистры** - сверхбыстрая память внутри CPU для временного хранения данных
3. **Устройство управления** - координирует работу всех частей компьютера
4. **Кэш** - быстрая память между CPU и основной памятью

#### Цикл выполнения инструкции:

1. **Выборка (Fetch)** - получение инструкции из памяти
2. **Декодирование (Decode)** - определение типа инструкции
3. **Выполнение (Execute)** - выполнение инструкции
4. **Запись результата (Write back)** - сохранение результата

### Память и иерархия памяти

Память организована в иерархию по скорости доступа и объему:

1. **Регистры CPU** - наименьший объем, самый быстрый доступ
2. **Кэш L1/L2/L3** - промежуточная быстрая память
3. **Оперативная память (RAM)** - основная рабочая память
4. **Постоянная память (ROM)** - энергонезависимая, только для чтения
5. **Внешняя память (SSD, HDD)** - большой объем, медленный доступ

```
┌──────────────────┐
│ Регистры (байты) │  ◄── Самая быстрая, ~1 такт CPU
├──────────────────┤
│  Кэш L1 (КБ)     │  ◄── ~3-4 такта CPU
├──────────────────┤
│  Кэш L2 (МБ)     │  ◄── ~10 тактов CPU
├──────────────────┤
│  Кэш L3 (МБ)     │  ◄── ~30-40 тактов CPU
├──────────────────┤
│  RAM (ГБ)        │  ◄── ~100-200 тактов CPU
├──────────────────┤
│  SSD (ТБ)        │  ◄── ~100,000 тактов CPU
├──────────────────┤
│  HDD (ТБ)        │  ◄── ~1,000,000 тактов CPU
└──────────────────┘
```

Понимание этой иерархии критически важно для написания эффективного кода. Алгоритмы, которые учитывают локальность данных и кэш-линии, работают значительно быстрее.

### Параллелизм и многоядерность

Современные CPU имеют множество ядер, которые могут выполнять задачи параллельно:

1. **Многоядерные процессоры** - несколько CPU на одном чипе
2. **Потоки (Threads)** - логические единицы исполнения
3. **SIMD (Одна инструкция - много данных)** - один оператор применяется к множеству данных

Python-пример использования многоядерности:

```python
from multiprocessing import Pool

def process_chunk(data):
    # Обработка данных
    return [x * x for x in data]

if __name__ == '__main__':
    data = list(range(1000000))
    
    # Разделим данные на 4 части для 4 ядер
    chunk_size = len(data) // 4
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
    
    # Параллельная обработка
    with Pool(processes=4) as pool:
        results = pool.map(process_chunk, chunks)
    
    # Объединение результатов
    processed_data = [item for sublist in results for item in sublist]
```

### Влияние на Python-код

Python-интерпретатор абстрагирует нас от низкоуровневой архитектуры, но понимание её влияет на производительность:

1. **GIL (Global Interpreter Lock)** - ограничивает истинный параллелизм в CPython
2. **Работа с памятью** - большие объекты создают нагрузку на сборщик мусора
3. **Векторизация** - библиотеки типа NumPy используют SIMD для быстрых операций

### Дополнительные ресурсы
- [Computer Architecture: A Quantitative Approach](https://www.amazon.com/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/0128119055)
- [Курс на Coursera "From NAND to Tetris"](https://www.coursera.org/learn/build-a-computer)
- [Документация Python по multiprocessing](https://docs.python.org/3/library/multiprocessing.html)

## Системы счисления

### Общий обзор

Системы счисления — это способы представления чисел с использованием определённого набора символов. В программировании регулярно используются несколько систем счисления.

### Основные системы счисления

1. **Десятичная (основание 10)** - обычная система, использует цифры 0-9
2. **Двоичная (основание 2)** - использует только 0 и 1, основа цифровых компьютеров
3. **Восьмеричная (основание 8)** - использует цифры 0-7
4. **Шестнадцатеричная (основание 16)** - использует 0-9 и A-F, удобна для представления байтов

### Преобразование между системами счисления

#### Из десятичной в другую систему:
Делим число на основание системы, записываем остатки от деления снизу вверх.

Пример: Перевод 42 в двоичную:
```
42 ÷ 2 = 21 (остаток 0)
21 ÷ 2 = 10 (остаток 1)
10 ÷ 2 = 5  (остаток 0)
5 ÷ 2 = 2   (остаток 1)
2 ÷ 2 = 1   (остаток 0)
1 ÷ 2 = 0   (остаток 1)
```
Результат: 101010

#### Из другой системы в десятичную:
Умножаем каждую цифру на основание в соответствующей степени и суммируем.

Пример: Перевод 101010 из двоичной в десятичную:
```
1×2^5 + 0×2^4 + 1×2^3 + 0×2^2 + 1×2^1 + 0×2^0 = 32 + 0 + 8 + 0 + 2 + 0 = 42
```

### Преобразование в Python

```python
# Десятичное в двоичное
binary = bin(42)  # '0b101010'

# Десятичное в восьмеричное
octal = oct(42)   # '0o52'

# Десятичное в шестнадцатеричное
hexa = hex(42)    # '0x2a'

# Из других систем в десятичную
decimal_from_binary = int('101010', 2)  # 42
decimal_from_octal = int('52', 8)       # 42
decimal_from_hex = int('2a', 16)        # 42
```

### Битовые операции

С бинарными числами часто выполняют битовые операции:

1. **AND (И)**: `&` - возвращает 1, если оба бита равны 1
2. **OR (ИЛИ)**: `|` - возвращает 1, если хотя бы один из битов равен 1
3. **XOR (исключающее ИЛИ)**: `^` - возвращает 1, если биты различны
4. **NOT (НЕ)**: `~` - инвертирует биты
5. **Сдвиг влево**: `<<` - сдвигает биты влево (умножение на 2ⁿ)
6. **Сдвиг вправо**: `>>` - сдвигает биты вправо (деление на 2ⁿ)

Примеры:
```python
a = 0b1010  # 10 в десятичной
b = 0b1100  # 12 в десятичной

print(bin(a & b))  # 0b1000 (8)
print(bin(a | b))  # 0b1110 (14)
print(bin(a ^ b))  # 0b0110 (6)
print(bin(~a & 0xF))  # 0b0101 (5) - используем маску 0xF для 4 бит
print(bin(a << 1))  # 0b10100 (20)
print(bin(a >> 1))  # 0b101 (5)
```

### Применение битовых операций

1. **Флаги и состояния**: использование отдельных битов для хранения флагов
2. **Оптимизация памяти**: упаковка данных в меньшее количество байт
3. **Быстрые математические операции**: используя побитовые сдвиги
4. **Манипуляция с цветами**: в компьютерной графике
5. **Хеширование**: быстрые хеш-функции

Пример использования битовых флагов:

```python
# Определение констант для битовых флагов
READ_PERMISSION = 0b001  # 1
WRITE_PERMISSION = 0b010  # 2
EXECUTE_PERMISSION = 0b100  # 4

# Функция для проверки разрешений
def check_permission(user_permissions, required_permission):
    return (user_permissions & required_permission) == required_permission

# Установка разрешений пользователю
user_permissions = READ_PERMISSION | WRITE_PERMISSION  # 0b011 (3)

# Проверка разрешений
print(check_permission(user_permissions, READ_PERMISSION))    # True
print(check_permission(user_permissions, EXECUTE_PERMISSION)) # False

# Добавление разрешения
user_permissions |= EXECUTE_PERMISSION
print(check_permission(user_permissions, EXECUTE_PERMISSION)) # True

# Удаление разрешения
user_permissions &= ~WRITE_PERMISSION
print(check_permission(user_permissions, WRITE_PERMISSION))   # False
```

### Дополнительные ресурсы
- [Побитовые операции в Python](https://wiki.python.org/moin/BitwiseOperators)
- [Системы счисления и битовые операции на Khan Academy](https://www.khanacademy.org/computing/computer-science/cryptography/crypt/v/binary-to-decimal-conversion)

## Алгоритмическое мышление

### Общий обзор

Алгоритмическое мышление — это подход к решению проблем, при котором задача разбивается на чётко определенные шаги (алгоритм). Это фундаментальный навык для программистов.

### Основные принципы алгоритмического мышления

1. **Декомпозиция** - разбиение сложной задачи на простые подзадачи
2. **Распознавание паттернов** - выявление повторяющихся шаблонов
3. **Абстракция** - отделение важных деталей от несущественных
4. **Разработка алгоритма** - создание последовательности шагов для решения
5. **Анализ и оптимизация** - оценка эффективности алгоритма

### Процесс алгоритмического решения задач

1. **Понимание проблемы**
   - Определение входных и выходных данных
   - Выявление ограничений
   - Анализ крайних случаев

2. **Разработка стратегии решения**
   - Математическое моделирование
   - Визуализация
   - Декомпозиция на подпроблемы

3. **Формализация алгоритма**
   - Псевдокод
   - Блок-схемы
   - Описание на естественном языке

4. **Реализация на языке программирования**
   - Написание кода
   - Тестирование на примерах
   - Отладка

5. **Проверка и оптимизация**
   - Тестирование на крайних случаях
   - Анализ времени и памяти
   - Рефакторинг

### Пример алгоритмического мышления: Задача нахождения НОД

Найдем наибольший общий делитель (НОД) двух чисел.

**Шаг 1: Понимание проблемы**
- Вход: два положительных целых числа a и b
- Выход: их наибольший общий делитель
- Определение: НОД — наибольшее число, которое делит оба числа без остатка

**Шаг 2: Стратегия решения**
- Можно использовать алгоритм Евклида, основанный на свойстве:
  НОД(a, b) = НОД(b, a mod b)

**Шаг 3: Формализация алгоритма (псевдокод)**
```
функция НОД(a, b):
    пока b ≠ 0:
        temp = b
        b = a mod b
        a = temp
    вернуть a
```

**Шаг 4: Реализация**
```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Проверяем
print(gcd(48, 18))  # Должно вернуть 6
```

**Шаг 5: Анализ**
- Сложность: O(log(min(a, b)))
- Корректность: алгоритм Евклида математически доказан
- Оптимизации: в Python есть встроенная функция `math.gcd(a, b)`

### Практические приемы развития алгоритмического мышления

1. **Решение головоломок и задач на логику**
   - Судоку, шахматы, логические задачи

2. **Участие в соревнованиях по программированию**
   - LeetCode, Codeforces, HackerRank

3. **Реализация известных алгоритмов**
   - Алгоритмы сортировки, поиска, графовые алгоритмы

4. **Анализ существующих решений**
   - Изучение библиотек и фреймворков
   - Чтение чужого кода

5. **Обратный инжиниринг**
   - Разбор как работают существующие продукты

### Дополнительные ресурсы
- [Introduction to Algorithms](https://mitpress.mit.edu/books/introduction-algorithms-third-edition) (CLRS)
- [Алгоритмы: построение и анализ](https://www.ozon.ru/product/algoritmy-postroenie-i-analiz-kormen-tomas-h-leyzerson-charlz-i-rivest-ronald-l-shteyn-klifford-148111238/)
- [LeetCode](https://leetcode.com/) - платформа для практики алгоритмов
- [Визуализация алгоритмов](https://visualgo.net/)

## Булева алгебра и логические операции

### Общий обзор

Булева алгебра — это раздел математики, который работает с логическими величинами, принимающими только два значения: истина (True, 1) и ложь (False, 0). Это основа цифровой логики, используемой во всех компьютерах.

### Основные логические операции

1. **Логическое НЕ (NOT, ¬)** — инверсия, отрицание
   - NOT 0 = 1
   - NOT 1 = 0

2. **Логическое И (AND, ∧)** — конъюнкция
   - 0 AND 0 = 0
   - 0 AND 1 = 0
   - 1 AND 0 = 0
   - 1 AND 1 = 1

3. **Логическое ИЛИ (OR, ∨)** — дизъюнкция
   - 0 OR 0 = 0
   - 0 OR 1 = 1
   - 1 OR 0 = 1
   - 1 OR 1 = 1

4. **Исключающее ИЛИ (XOR, ⊕)** — сложение по модулю 2
   - 0 XOR 0 = 0
   - 0 XOR 1 = 1
   - 1 XOR 0 = 1
   - 1 XOR 1 = 0

### Логические операции в Python

```python
# NOT
not True   # False
not False  # True

# AND
True and True    # True
True and False   # False
False and True   # False
False and False  # False

# OR
True or True     # True
True or False    # True
False or True    # True
False or False   # False

# XOR (в Python нет прямого оператора, используем ^)
True ^ True      # False
True ^ False     # True
False ^ True     # True
False ^ False    # False
```

### Законы булевой алгебры

1. **Коммутативность**
   - A AND B = B AND A
   - A OR B = B OR A

2. **Ассоциативность**
   - (A AND B) AND C = A AND (B AND C)
   - (A OR B) OR C = A OR (B OR C)

3. **Дистрибутивность**
   - A AND (B OR C) = (A AND B) OR (A AND C)
   - A OR (B AND C) = (A OR B) AND (A OR C)

4. **Поглощение**
   - A AND (A OR B) = A
   - A OR (A AND B) = A

5. **Законы де Моргана**
   - NOT (A AND B) = (NOT A) OR (NOT B)
   - NOT (A OR B) = (NOT A) AND (NOT B)

6. **Двойное отрицание**
   - NOT (NOT A) = A

### Таблицы истинности

Таблицы истинности показывают все возможные комбинации входных значений и соответствующие выходные значения для логической функции.

Пример таблицы истинности для выражения `(A AND B) OR (NOT A)`:

| A | B | A AND B | NOT A | (A AND B) OR (NOT A) |
|---|---|---------|-------|----------------------|
| 0 | 0 | 0       | 1     | 1                    |
| 0 | 1 | 0       | 1     | 1                    |
| 1 | 0 | 0       | 0     | 0                    |
| 1 | 1 | 1       | 0     | 1                    |

### Логические вентили

Логические вентили — это электронные компоненты, реализующие логические операции. Они являются строительными блоками для цифровых схем.

```
AND Gate          OR Gate           NOT Gate
   ┌───┐            ┌───┐             ┌───┐
A ─┤   │            ┤   │           ┌─┤   │
   │ & ├─── A&B     │ ≥1├─── A|B  A ─┤ 1 ├─── ~A
B ─┤   │            │   │           └─┤   │
   └───┘          B ┤   │             └───┘
                    └───┘
```

### Практическое применение булевой алгебры

1. **Проектирование цифровых схем**
   - CPU, память, ALU

2. **Условные выражения в программировании**
   ```python
   if (age >= 18 and has_id) or is_vip:
       allow_entry()
   ```

3. **Упрощение логических выражений**
   - Карты Карно
   - Минимизация логических функций

4. **Поисковые запросы**
   ```
   (Python OR JavaScript) AND (NOT PHP)
   ```

5. **Фильтрация данных**
   ```python
   # Фильтрация списка с использованием логических операций
   filtered_data = [
       item for item in data 
       if (item.price < 1000 and item.category == "electronics") 
       or (item.rating > 4.5)
   ]
   ```

### Пример: Реализация полного сумматора

Полный сумматор — это цифровая схема, которая складывает два бита и учитывает перенос. Он имеет три входа (A, B, Cin) и два выхода (Sum, Cout).

```python
def full_adder(a, b, c_in):
    # Сумма
    sum_bit = (a ^ b) ^ c_in
    
    # Перенос
    c_out = (a & b) | ((a ^ b) & c_in)
    
    return sum_bit, c_out

# Проверка
print(full_adder(0, 0, 0))  # (0, 0)
print(full_adder(0, 1, 0))  # (1, 0)
print(full_adder(1, 0, 0))  # (1, 0)
print(full_adder(1, 1, 0))  # (0, 1)
print(full_adder(1, 1, 1))  # (1, 1)
```

### Дополнительные ресурсы
- [Boolean Algebra (Stanford)](https://plato.stanford.edu/entries/boolalg-math/)
- [Логика в программировании](https://www.codecademy.com/learn/introduction-to-javascript/modules/learn-javascript-control-flow)
- [Карты Карно для минимизации логических функций](https://www.electronics-tutorials.ws/boolean/karnaugh-map.html)
