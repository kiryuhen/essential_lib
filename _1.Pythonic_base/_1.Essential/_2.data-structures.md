# 1.3. Структуры данных в Python

## Содержание
- [Списки (Lists)](#списки-lists)
- [Кортежи (Tuples)](#кортежи-tuples)
- [Словари (Dictionaries)](#словари-dictionaries)
- [Множества (Sets)](#множества-sets)
- [Изменяемые и неизменяемые типы](#изменяемые-и-неизменяемые-типы)
- [Практические задачи](#практические-задачи)
- [Полезные ресурсы](#полезные-ресурсы)

## Списки (Lists)

Список - это упорядоченная изменяемая коллекция объектов произвольных типов.

### Создание списков

```python
# Пустой список
empty_list = []
empty_list_2 = list()

# Список с элементами
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True, [1, 2]]  # Список может содержать элементы разных типов

# Создание списка с помощью функции list()
chars = list("hello")  # ['h', 'e', 'l', 'l', 'o']

# Создание списка с повторяющимися элементами
zeros = [0] * 5  # [0, 0, 0, 0, 0]

# Создание списка с помощью генератора списков
squares = [x**2 for x in range(1, 6)]  # [1, 4, 9, 16, 25]
```

### Доступ к элементам списка

```python
fruits = ["яблоко", "банан", "апельсин", "груша", "киви"]

# Доступ по индексу (индексация начинается с 0)
print(fruits[0])    # яблоко
print(fruits[2])    # апельсин

# Отрицательные индексы (счёт с конца)
print(fruits[-1])   # киви (последний элемент)
print(fruits[-2])   # груша (предпоследний элемент)

# Срезы (slices)
print(fruits[1:3])   # ['банан', 'апельсин'] (со 2-го по 3-й)
print(fruits[:3])    # ['яблоко', 'банан', 'апельсин'] (с начала по 3-й)
print(fruits[2:])    # ['апельсин', 'груша', 'киви'] (с 3-го до конца)
print(fruits[:])     # копия всего списка

# Срезы с шагом
print(fruits[::2])   # ['яблоко', 'апельсин', 'киви'] (каждый 2-й элемент)
print(fruits[::-1])  # ['киви', 'груша', 'апельсин', 'банан', 'яблоко'] (в обратном порядке)
```

### Изменение элементов списка

```python
colors = ["красный", "зелёный", "синий"]

# Изменение отдельного элемента
colors[1] = "жёлтый"
print(colors)  # ['красный', 'жёлтый', 'синий']

# Изменение нескольких элементов с помощью срезов
colors[1:3] = ["оранжевый", "фиолетовый", "голубой"]
print(colors)  # ['красный', 'оранжевый', 'фиолетовый', 'голубой']

# Удаление элементов
colors[1:3] = []
print(colors)  # ['красный', 'голубой']
```

### Методы списков

```python
fruits = ["яблоко", "банан", "апельсин"]

# Добавление элементов
fruits.append("груша")         # Добавление в конец
print(fruits)  # ['яблоко', 'банан', 'апельсин', 'груша']

fruits.insert(1, "манго")      # Вставка по индексу
print(fruits)  # ['яблоко', 'манго', 'банан', 'апельсин', 'груша']

fruits.extend(["киви", "ананас"])  # Добавление нескольких элементов
print(fruits)  # ['яблоко', 'манго', 'банан', 'апельсин', 'груша', 'киви', 'ананас']

# Удаление элементов
removed = fruits.pop()         # Удаление и возврат последнего элемента
print(removed, fruits)  # ананас ['яблоко', 'манго', 'банан', 'апельсин', 'груша', 'киви']

removed = fruits.pop(1)        # Удаление и возврат по индексу
print(removed, fruits)  # манго ['яблоко', 'банан', 'апельсин', 'груша', 'киви']

fruits.remove("банан")         # Удаление по значению (первое вхождение)
print(fruits)  # ['яблоко', 'апельсин', 'груша', 'киви']

# Прочие методы
fruits.reverse()               # Разворот списка на месте
print(fruits)  # ['киви', 'груша', 'апельсин', 'яблоко']

sorted_fruits = sorted(fruits)  # Сортировка (возвращает новый список)
print(sorted_fruits)  # ['апельсин', 'груша', 'киви', 'яблоко']

fruits.sort()                   # Сортировка на месте
print(fruits)  # ['апельсин', 'груша', 'киви', 'яблоко']

print(fruits.count("киви"))     # Подсчёт вхождений: 1
print(fruits.index("груша"))    # Индекс первого вхождения: 1

# Создание копии списка
fruits_copy = fruits.copy()
# или
fruits_copy = fruits[:]
```

### Вложенные списки (многомерные массивы)

```python
# Создание матрицы (двумерного массива)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Доступ к элементам
print(matrix[1][2])  # 6 (2-я строка, 3-й элемент)

# Обход всех элементов матрицы
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()  # Перевод строки после каждой строки матрицы

# Изменение элемента
matrix[0][0] = 10
print(matrix)  # [[10, 2, 3], [4, 5, 6], [7, 8, 9]]
```

### Подводные камни при работе со списками

1. **Копирование списков**:
```python
# Неглубокое копирование
a = [1, 2, 3]
b = a  # b и a указывают на один и тот же список
b[0] = 10
print(a)  # [10, 2, 3] - a тоже изменился!

# Правильное копирование
a = [1, 2, 3]
b = a.copy()  # или b = a[:]
b[0] = 10
print(a)  # [1, 2, 3] - a не изменился

# Проблема с вложенными списками
nested = [[1, 2], [3, 4]]
shallow_copy = nested.copy()
shallow_copy[0][0] = 99
print(nested)  # [[99, 2], [3, 4]] - внутренние списки всё равно общие!

# Глубокое копирование
import copy
deep_copy = copy.deepcopy(nested)
deep_copy[0][0] = 100
print(nested)  # [[99, 2], [3, 4]] - теперь без изменений
```

2. **Инициализация двумерного массива**:
```python
# Неправильно
matrix = [[0] * 3] * 3
matrix[0][0] = 1
print(matrix)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]] - все строки это ссылки на один список!

# Правильно
matrix = [[0 for _ in range(3)] for _ in range(3)]
matrix[0][0] = 1
print(matrix)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0]] - теперь всё корректно
```

3. **Производительность**:
```python
# Неэффективно: много перераспределений памяти
result = []
for i in range(10000):
    result.append(i)

# Эффективнее: сразу выделить память для результата
result = [0] * 10000
for i in range(10000):
    result[i] = i

# Наиболее эффективно: использовать генератор списков
result = [i for i in range(10000)]
```

## Кортежи (Tuples)

Кортеж - это упорядоченная неизменяемая коллекция объектов произвольных типов.

### Создание кортежей

```python
# Пустой кортеж
empty_tuple = ()
empty_tuple2 = tuple()

# Кортеж с элементами
numbers = (1, 2, 3, 4, 5)
mixed = (1, "hello", 3.14, True)

# Кортеж с одним элементом (обратите внимание на запятую)
single_item = (42,)  # Без запятой это будет число, а не кортеж!

# Создание кортежа из других коллекций
tuple_from_list = tuple([1, 2, 3])
chars = tuple("hello")  # ('h', 'e', 'l', 'l', 'o')

# Создание кортежа без скобок (tuple packing)
coordinates = 10, 20, 30  # Эквивалентно (10, 20, 30)
```

### Доступ к элементам кортежа

```python
colors = ("красный", "зелёный", "синий", "жёлтый", "фиолетовый")

# Доступ по индексу
print(colors[0])     # красный
print(colors[-1])    # фиолетовый

# Срезы работают так же, как для списков
print(colors[1:3])   # ('зелёный', 'синий')
print(colors[::-1])  # ('фиолетовый', 'жёлтый', 'синий', 'зелёный', 'красный')

# Распаковка кортежа
r, g, b, *rest = colors
print(r, g, b, rest)  # красный зелёный синий ['жёлтый', 'фиолетовый']
```

### Методы кортежей

```python
colors = ("красный", "зелёный", "синий", "зелёный", "фиолетовый")

# Подсчёт вхождений
print(colors.count("зелёный"))  # 2

# Индекс первого вхождения
print(colors.index("синий"))     # 2
```

### Отличия кортежей от списков

1. **Неизменяемость**:
```python
t = (1, 2, 3)
# t[0] = 10  # TypeError: 'tuple' object does not support item assignment
```

2. **Применение**:
   - Кортежи используются для гетерогенных данных (разных типов)
   - Списки используются для гомогенных данных (одного типа)
   - Кортежи могут использоваться как ключи в словарях (в отличие от списков)
   - Кортежи занимают меньше памяти и работают быстрее, чем списки

3. **Использование в функциях**:
```python
# Функция, возвращающая несколько значений
def get_dimensions():
    return 1920, 1080  # Возвращает кортеж

# Распаковка значений при вызове
width, height = get_dimensions()
print(width, height)  # 1920 1080
```

## Словари (Dictionaries)

Словарь - это изменяемая неупорядоченная коллекция пар "ключ-значение".

### Создание словарей

```python
# Пустой словарь
empty_dict = {}
empty_dict2 = dict()

# Словарь с элементами
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва"
}

# Создание словаря с помощью функции dict()
person2 = dict(name="Мария", age=25, city="Санкт-Петербург")

# Словарь из последовательности пар
items = [("a", 1), ("b", 2), ("c", 3)]
d = dict(items)
print(d)  # {'a': 1, 'b': 2, 'c': 3}

# Словарь с помощью генератора словарей
squares = {x: x**2 for x in range(1, 6)}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

### Доступ к элементам словаря

```python
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва",
    "languages": ["Python", "JavaScript", "C++"]
}

# Доступ по ключу
print(person["name"])     # Иван
print(person["languages"])  # ['Python', 'JavaScript', 'C++']

# Проверка наличия ключа
if "age" in person:
    print("Возраст указан:", person["age"])

# Безопасный доступ с методом get()
print(person.get("email"))         # None (ключа нет)
print(person.get("email", "Н/Д"))  # Н/Д (значение по умолчанию)

# Доступ ко вложенным структурам
print(person["languages"][0])  # Python
```

### Изменение словаря

```python
person = {"name": "Иван", "age": 30}

# Добавление или изменение элементов
person["email"] = "ivan@example.com"
person["age"] = 31
print(person)  # {'name': 'Иван', 'age': 31, 'email': 'ivan@example.com'}

# Удаление элементов
del person["age"]
print(person)  # {'name': 'Иван', 'email': 'ivan@example.com'}

# Удаление и возврат значения
email = person.pop("email")
print(email, person)  # ivan@example.com {'name': 'Иван'}

# Удаление и возврат последней добавленной пары (Python 3.7+)
person = {"name": "Иван", "age": 30, "city": "Москва"}
item = person.popitem()
print(item, person)  # ('city', 'Москва') {'name': 'Иван', 'age': 30}
```

### Методы словарей

```python
person = {"name": "Иван", "age": 30}

# Получение всех ключей и значений
keys = person.keys()
values = person.values()
print(list(keys))    # ['name', 'age']
print(list(values))  # ['Иван', 30]

# Получение пар ключ-значение
items = person.items()
print(list(items))   # [('name', 'Иван'), ('age', 30)]

# Обновление словаря другим словарём
person.update({"city": "Москва", "age": 31})
print(person)  # {'name': 'Иван', 'age': 31, 'city': 'Москва'}

# Очистка словаря
person.clear()
print(person)  # {}

# Создание словаря с заданными ключами и одинаковым значением
new_dict = dict.fromkeys(["a", "b", "c"], 0)
print(new_dict)  # {'a': 0, 'b': 0, 'c': 0}
```

### Итерация по словарю

```python
person = {"name": "Иван", "age": 30, "city": "Москва"}

# Итерация по ключам (по умолчанию)
for key in person:
    print(key, "->", person[key])

# Явная итерация по ключам
for key in person.keys():
    print(key)

# Итерация по значениям
for value in person.values():
    print(value)

# Итерация по парам ключ-значение
for key, value in person.items():
    print(f"{key}: {value}")
```

### Сложные структуры данных с использованием словарей

```python
# Список словарей
users = [
    {"id": 1, "name": "Иван", "active": True},
    {"id": 2, "name": "Мария", "active": False},
    {"id": 3, "name": "Петр", "active": True}
]

# Поиск пользователя по id
user_id = 2
for user in users:
    if user["id"] == user_id:
        print(f"Найден пользователь: {user['name']}")
        break

# Словарь словарей
users_by_id = {
    1: {"name": "Иван", "active": True},
    2: {"name": "Мария", "active": False},
    3: {"name": "Петр", "active": True}
}

# Прямой доступ по id
print(users_by_id[2]["name"])  # Мария
```

### Подводные камни при работе со словарями

1. **Ключи должны быть неизменяемыми**:
```python
# Это работает (неизменяемые типы)
d = {
    42: "число",
    "строка": "значение",
    (1, 2): "кортеж",
    True: "булево"
}

# Это вызовет ошибку (изменяемые типы)
# d = {[1, 2]: "список"}  # TypeError: unhashable type: 'list'
```

2. **Порядок элементов**:
```python
# До Python 3.7 порядок элементов в словарях не гарантировался
# В Python 3.7+ порядок вставки сохраняется

# Для гарантированного сохранения порядка вставки в любой версии Python:
from collections import OrderedDict
ordered = OrderedDict([("a", 1), ("b", 2), ("c", 3)])
```

3. **Значения по умолчанию для отсутствующих ключей**:
```python
# Стандартный способ (требует проверки на существование)
counts = {}
word = "hello"
if word in counts:
    counts[word] += 1
else:
    counts[word] = 1

# Более элегантно с методом get()
counts = {}
word = "hello"
counts[word] = counts.get(word, 0) + 1

# Для частых операций подсчёта:
from collections import Counter
text = "hello world hello"
counts = Counter(text.split())
print(counts)  # Counter({'hello': 2, 'world': 1})
```

## Множества (Sets)

Множество - это неупорядоченная коллекция уникальных элементов.

### Создание множеств

```python
# Пустое множество
empty_set = set()  # Не используйте {}, это создаст пустой словарь!

# Множество с элементами
numbers = {1, 2, 3, 4, 5}
chars = set("hello")  # {'h', 'e', 'l', 'o'} - обратите внимание, дубликаты удалены!

# Преобразование других коллекций в множества
list_to_set = set([1, 2, 2, 3, 4, 4])  # {1, 2, 3, 4}

# Создание множества с помощью генератора множеств
even_squares = {x**2 for x in range(10) if x % 2 == 0}
print(even_squares)  # {0, 4, 16, 36, 64}
```

### Операции с множествами

```python
# Множества для демонстрации
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

# Объединение множеств
union = A | B  # или A.union(B)
print(union)  # {1, 2, 3, 4, 5, 6, 7, 8}

# Пересечение множеств
intersection = A & B  # или A.intersection(B)
print(intersection)  # {4, 5}

# Разность множеств
difference = A - B  # или A.difference(B)
print(difference)  # {1, 2, 3}

# Симметрическая разность (элементы, которые есть только в одном из множеств)
sym_diff = A ^ B  # или A.symmetric_difference(B)
print(sym_diff)  # {1, 2, 3, 6, 7, 8}

# Проверка включения
print(A.issubset(union))     # True (A ⊆ union)
print(union.issuperset(A))   # True (union ⊇ A)
print(A.isdisjoint(B))       # False (A и B имеют общие элементы)
```

### Изменение множеств

```python
s = {1, 2, 3}

# Добавление элементов
s.add(4)
print(s)  # {1, 2, 3, 4}

# Добавление нескольких элементов
s.update([4, 5, 6])
print(s)  # {1, 2, 3, 4, 5, 6}

# Удаление элементов
s.remove(3)  # Вызовет ошибку, если элемента нет
print(s)  # {1, 2, 4, 5, 6}

s.discard(10)  # Не вызывает ошибку, если элемента нет
print(s)  # {1, 2, 4, 5, 6}

# Удаление и возврат произвольного элемента
item = s.pop()
print(item, s)  # Например: 1 {2, 4, 5, 6}

# Очистка множества
s.clear()
print(s)  # set()
```

### Неизменяемые множества (frozenset)

```python
# Создание неизменяемого множества
fs = frozenset([1, 2, 3, 4])

# Можно использовать в операциях, но нельзя изменять
union = fs | {5, 6}
print(union)  # frozenset({1, 2, 3, 4, 5, 6})

# fs.add(5)  # AttributeError: 'frozenset' object has no attribute 'add'

# Можно использовать как ключ в словаре
d = {fs: "значение"}
print(d[fs])  # значение
```

### Применение множеств

```python
# Удаление дубликатов из списка
duplicates = [1, 2, 2, 3, 4, 4, 5]
unique = list(set(duplicates))
print(unique)  # [1, 2, 3, 4, 5]

# Нахождение уникальных слов в тексте
text = "to be or not to be that is the question"
unique_words = set(text.split())
print(unique_words)  # {'that', 'be', 'to', 'is', 'question', 'the', 'not', 'or'}

# Проверка вхождения в множество (очень быстрая операция)
allowed_users = {"user1", "user2", "admin"}
if "user1" in allowed_users:
    print("Доступ разрешен")

# Нахождение общих элементов в списках
list1 = [1, 2, 3, 4, 5]
list2 = [4, 5, 6, 7, 8]
common = set(list1) & set(list2)
print(common)  # {4, 5}
```

### Подводные камни при работе с множествами

1. **Элементы множества должны быть хешируемыми (неизменяемыми)**:
```python
# Это работает (неизменяемые типы)
s = {1, "hello", (1, 2)}

# Это вызовет ошибку (изменяемые типы)
# s = {[1, 2]}  # TypeError: unhashable type: 'list'
# s = {{1: 2}}  # TypeError: unhashable type: 'dict'
```

2. **Множества неупорядочены**:
```python
s = {3, 1, 2}
print(s)  # Порядок не гарантирован, например: {1, 2, 3}

# Для сохранения порядка в Python 3.7+:
from collections import OrderedDict
ordered = list(OrderedDict.fromkeys([3, 1, 2, 1]))
print(ordered)  # [3, 1, 2]
```

3. **Операции изменения множества напрямую**:
```python
# Неправильно (создаёт новое множество):
s = {1, 2, 3}
s = s | {4, 5}  # Создаёт новое множество

# Правильно (изменяет существующее множество):
s = {1, 2, 3}
s |= {4, 5}  # Или s.update({4, 5})
print(s)  # {1, 2, 3, 4, 5}
```

## Изменяемые и неизменяемые типы

В Python все типы данных делятся на два класса:

### Неизменяемые (immutable) типы:
- int, float, complex
- str
- tuple
- frozenset
- bool
- None
- bytes

### Изменяемые (mutable) типы:
- list
- dict
- set
- bytearray
- пользовательские классы (по умолчанию)

### Важность понимания изменяемости

```python
# 1. Передача аргументов в функции

# Неизменяемые типы передаются "по значению"
def modify_number(x):
    x = x + 1
    print("Внутри функции:", x)

n = 10
modify_number(n)
print("После функции:", n)  # 10 (не изменилось)

# Изменяемые типы передаются "по ссылке"
def modify_list(lst):
    lst.append(4)
    print("Внутри функции:", lst)

my_list = [1, 2, 3]
modify_list(my_list)
print("После функции:", my_list)  # [1, 2, 3, 4] (изменилось!)

# 2. Использование в качестве ключей словаря

# Неизменяемые типы можно использовать как ключи
d = {(1, 2): "кортеж"}

# Изменяемые типы нельзя использовать как ключи
# d = {[1, 2]: "список"}  # TypeError: unhashable type: 'list'

# 3. Значения по умолчанию в функциях

# НЕПРАВИЛЬНО: изменяемый тип в значении по умолчанию
def add_to_list(item, lst=[]):  # lst создаётся один раз при определении функции!
    lst.append(item)
    return lst

print(add_to_list(1))  # [1]
print(add_to_list(2))  # [1, 2] а не [2]!

# ПРАВИЛЬНО: используйте None как значение по умолчанию
def add_to_list_correctly(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst

print(add_to_list_correctly(1))  # [1]
print(add_to_list_correctly(2))  # [2]
```

### Идентичность объектов и оператор is

```python
# Оператор == проверяет равенство значений
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)  # True (значения равны)

# Оператор is проверяет идентичность объектов (тот же самый объект)
print(a is b)  # False (разные объекты)

# После присваивания переменные ссылаются на один и тот же объект
c = a
print(a is c)  # True

# Некоторые объекты кэшируются интерпретатором
x = 5
y = 5
print(x is y)  # True (обычно для малых целых чисел)

# Но не всегда!
large_x = 1000
large_y = 1000
print(large_x is large_y)  # Зависит от реализации Python
```

## Строки как последовательности

Строки — это последовательности символов. Многие операции, которые работают со списками, также работают и со строками.

### Индексация и срезы строк

```python
text = "Привет, мир!"

# Индексация
first_char = text[0]  # "П"
last_char = text[-1]  # "!"

# Срезы
first_word = text[:6]  # "Привет"
second_word = text[8:]  # "мир!"
```

### Итерация по строкам

```python
text = "Python"

# Итерация по символам
for char in text:
    print(char)

# Итерация с индексами
for i, char in enumerate(text):
    print(f"text[{i}] = {char}")
```

### Неизменяемость строк

Строки в Python неизменяемы, как и кортежи. Любая операция, которая "изменяет" строку, на самом деле создает новую строку.

```python
text = "Python"
# text[0] = "J"  # TypeError: 'str' object does not support item assignment

# Правильный способ "изменения" строки
new_text = "J" + text[1:]  # "Jython"
```

### Полезные методы строк

```python
text = "   Привет, мир!   "

# Удаление пробелов
trimmed = text.strip()  # "Привет, мир!"
left_trimmed = text.lstrip()  # "Привет, мир!   "
right_trimmed = text.rstrip()  # "   Привет, мир!"

# Изменение регистра
upper = text.upper()  # "   ПРИВЕТ, МИР!   "
lower = text.lower()  # "   привет, мир!   "
title = "привет, мир".title()  # "Привет, Мир"
capitalized = "привет, мир".capitalize()  # "Привет, мир"

# Проверка начала и конца
starts_with = "Привет, мир".startswith("Привет")  # True
ends_with = "Привет, мир".endswith("!")  # False

# Поиск подстроки
index = "Привет, мир".find("мир")  # 8
index = "Привет, мир".find("земля")  # -1 (не найдено)

# Замена
replaced = "Привет, мир".replace("мир", "Python")  # "Привет, Python"

# Разделение строки
words = "Яблоко,Банан,Груша".split(",")  # ["Яблоко", "Банан", "Груша"]

# Объединение строк
joined = ", ".join(["Яблоко", "Банан", "Груша"])  # "Яблоко, Банан, Груша"

# Проверка содержимого
is_alpha = "Python".isalpha()  # True (только буквы)
is_digit = "12345".isdigit()  # True (только цифры)
is_alnum = "Python3".isalnum()  # True (буквы и цифры)
is_space = "   ".isspace()  # True (только пробельные символы)
```

## Практические примеры

### Пример 1: Анализ текста

```python
def analyze_text(text):
    """Анализирует текст и возвращает статистику."""
    # Приводим к нижнему регистру и удаляем знаки препинания
    import string
    text = text.lower()
    for punctuation in string.punctuation:
        text = text.replace(punctuation, " ")
    
    # Разбиваем на слова
    words = text.split()
    
    # Общая статистика
    total_words = len(words)
    unique_words = len(set(words))
    
    # Подсчет частоты слов
    word_freq = {}
    for word in words:
        word_freq[word] = word_freq.get(word, 0) + 1
    
    # Поиск самых частых слов
    most_common = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return {
        "total_words": total_words,
        "unique_words": unique_words,
        "word_frequency": word_freq,
        "most_common": most_common
    }

# Тестируем функцию
sample_text = """
Python — это высокоуровневый язык программирования общего назначения.
Python стремится к чистому синтаксису, из-за чего он хорошо читаем.
Python поддерживает несколько парадигм программирования, в том числе
структурное, объектно-ориентированное, функциональное.
"""

result = analyze_text(sample_text)
print(f"Всего слов: {result['total_words']}")
print(f"Уникальных слов: {result['unique_words']}")
print("Самые частые слова:")
for word, count in result['most_common']:
    print(f"  - {word}: {count}")
```

### Пример 2: Телефонная книга

```python
def phone_book():
    """Простая телефонная книга с использованием словаря."""
    contacts = {}
    
    while True:
        print("\nТелефонная книга")
        print("1. Добавить контакт")
        print("2. Найти контакт")
        print("3. Удалить контакт")
        print("4. Показать все контакты")
        print("5. Выход")
        
        choice = input("Выберите действие (1-5): ")
        
        if choice == "1":
            name = input("Введите имя: ")
            phone = input("Введите телефон: ")
            contacts[name] = phone
            print(f"Контакт {name} добавлен")
            
        elif choice == "2":
            name = input("Введите имя для поиска: ")
            if name in contacts:
                print(f"Телефон {name}: {contacts[name]}")
            else:
                print(f"Контакт {name} не найден")
                
        elif choice == "3":
            name = input("Введите имя для удаления: ")
            if name in contacts:
                del contacts[name]
                print(f"Контакт {name} удален")
            else:
                print(f"Контакт {name} не найден")
                
        elif choice == "4":
            if contacts:
                print("\nСписок контактов:")
                for name, phone in contacts.items():
                    print(f"{name}: {phone}")
            else:
                print("Телефонная книга пуста")
                
        elif choice == "5":
            print("До свидания!")
            break
            
        else:
            print("Неверный выбор. Пожалуйста, выберите 1-5.")

# Запуск телефонной книги
# phone_book()
```

### Пример 3: Игра "Крестики-нолики"

```python
def tic_tac_toe():
    """Простая игра в крестики-нолики для двух игроков."""
    # Создаем пустое поле 3x3
    board = [[" " for _ in range(3)] for _ in range(3)]
    
    def print_board():
        """Выводит текущее состояние поля."""
        print("\n  0 1 2")
        for i in range(3):
            print(f"{i} {board[i][0]}|{board[i][1]}|{board[i][2]}")
            if i < 2:
                print("  -+-+-")
    
    def check_winner(player):
        """Проверяет, выиграл ли игрок."""
        # Проверка строк и столбцов
        for i in range(3):
            if all(board[i][j] == player for j in range(3)) or \
               all(board[j][i] == player for j in range(3)):
                return True
        
        # Проверка диагоналей
        if all(board[i][i] == player for i in range(3)) or \
           all(board[i][2-i] == player for i in range(3)):
            return True
        
        return False
    
    def is_board_full():
        """Проверяет, заполнено ли поле."""
        return all(board[i][j] != " " for i in range(3) for j in range(3))
    
    # Основной игровой цикл
    current_player = "X"
    
    while True:
        print_board()
        
        # Ход игрока
        print(f"Ход игрока {current_player}")
        while True:
            try:
                row = int(input("Введите строку (0-2): "))
                col = int(input("Введите столбец (0-2): "))
                
                if 0 <= row <= 2 and 0 <= col <= 2 and board[row][col] == " ":
                    break
                else:
                    print("Неверный ход. Попробуйте снова.")
            except ValueError:
                print("Пожалуйста, введите число от 0 до 2.")
        
        # Делаем ход
        board[row][col] = current_player
        
        # Проверяем на победу
        if check_winner(current_player):
            print_board()
            print(f"Игрок {current_player} победил!")
            break
        
        # Проверяем на ничью
        if is_board_full():
            print_board()
            print("Ничья!")
            break
        
        # Меняем игрока
        current_player = "O" if current_player == "X" else "X"

# Запуск игры
# tic_tac_toe()
```

## Выбор структуры данных

При решении задач важно выбирать наиболее подходящую структуру данных. Вот некоторые рекомендации:

- **Список**: когда важен порядок и элементы могут дублироваться.
- **Кортеж**: когда данные не должны изменяться после создания.
- **Словарь**: когда нужен быстрый доступ по ключу.
- **Множество**: когда нужно хранить только уникальные элементы или выполнять операции над множествами.

### Примеры выбора структуры:

1. **Список дел на день** → **список**: порядок важен, могут быть повторяющиеся задачи.
2. **Координаты точки (x, y, z)** → **кортеж**: фиксированный набор значений, который не должен изменяться.
3. **База данных студентов, где нужен быстрый поиск по ID** → **словарь**: быстрый доступ по ключу.
4. **Собрание всех уникальных слов в тексте** → **множество**: нужны только уникальные элементы.


## Практические задачи

### Задача 1: Анализатор частоты слов
Напишите программу, которая:
1. Принимает текст и подсчитывает частоту встречаемости каждого слова
2. Игнорирует регистр и знаки препинания
3. Выводит топ-10 самых частых слов и их количество
4. Визуализирует результаты (например, сортировкой по частоте)

### Задача 2: Телефонная книга
Реализуйте простую телефонную книгу, которая позволяет:
1. Добавлять контакты (имя, телефон, email, дополнительная информация)
2. Искать контакты по имени или телефону
3. Удалять и редактировать контакты
4. Группировать контакты по категориям
5. Экспортировать и импортировать данные

### Задача 3: Анализ журнала веб-сервера
Напишите программу для анализа лог-файла веб-сервера, которая:
1. Подсчитывает количество запросов по IP-адресам
2. Находит самые часто запрашиваемые страницы
3. Определяет пиковые часы нагрузки
4. Выявляет потенциально подозрительную активность (много запросов с одного IP)

### Задача 4: Кэш с ограниченным размером (LRU Cache)
Реализуйте структуру данных "Кэш с ограниченным размером", которая:
1. Хранит определённое количество последних запрошенных элементов
2. При превышении ёмкости удаляет наиболее давно использованные элементы
3. Обеспечивает быстрый доступ к элементам по ключу
4. Отслеживает статистику "попаданий" и "промахов" кэша

## Полезные ресурсы

- [Официальная документация Python по структурам данных](https://docs.python.org/3/tutorial/datastructures.html)
- [Руководство по коллекциям в Python](https://docs.python.org/3/library/collections.html)
- [Python Data Structures and Algorithms](https://realpython.com/python-data-structures/)
- [Сложность операций для различных структур данных](https://wiki.python.org/moin/TimeComplexity)
- [Руководство по типам данных в Python](https://realpython.com/python-data-types/)
