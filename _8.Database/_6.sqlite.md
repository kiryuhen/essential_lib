# SQLite и модуль sqlite3 в Python

## Введение

Базы данных играют ключевую роль в современной разработке, предоставляя эффективные средства для хранения, организации и получения данных. Python имеет встроенную поддержку для работы с различными базами данных, и SQLite является одной из самых простых и удобных для начала.

SQLite — это легковесная встраиваемая реляционная база данных, которая не требует отдельного сервера. Вся база данных хранится в одном файле, что делает её идеальной для:

- Разработки и тестирования
- Встраиваемых приложений
- Мобильных приложений
- Небольших веб-приложений
- Хранения локальных данных

В этом уроке мы рассмотрим, как использовать модуль `sqlite3`, который входит в стандартную библиотеку Python, для работы с базами данных SQLite.

## Основы модуля sqlite3

Модуль `sqlite3` предоставляет интерфейс для работы с базами данных SQLite в соответствии со спецификацией DB-API 2.0, которая определяет стандартный интерфейс для взаимодействия Python с реляционными базами данных.

### Подключение к базе данных

Для начала работы с SQLite необходимо создать соединение с базой данных. Если указанная база данных не существует, она будет автоматически создана.

```python
import sqlite3

# Подключение к базе данных (создание, если не существует)
conn = sqlite3.connect('example.db')

# Создание курсора для выполнения SQL-запросов
cursor = conn.cursor()

# Выполнение операций с базой данных...

# Закрытие соединения
conn.close()
```

Соединение можно также использовать в качестве контекстного менеджера, что автоматически закрывает соединение после выхода из блока `with`:

```python
import sqlite3

# Использование контекстного менеджера
with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Выполнение операций с базой данных...
```

### Создание таблиц

Для создания таблиц используется SQL-запрос `CREATE TABLE`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Создание таблицы
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT UNIQUE,
        age INTEGER
    )
    ''')
    
    # Сохранение изменений
    conn.commit()
```

В этом примере:
- `IF NOT EXISTS` предотвращает ошибку, если таблица уже существует
- `INTEGER PRIMARY KEY` создает автоинкрементный первичный ключ
- `NOT NULL` указывает, что поле не может быть пустым
- `UNIQUE` создает уникальное ограничение на поле

### Вставка данных

Для вставки данных используется SQL-запрос `INSERT INTO`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Вставка одной записи
    cursor.execute('''
    INSERT INTO users (name, email, age) VALUES (?, ?, ?)
    ''', ('Alice', 'alice@example.com', 25))
    
    # Получение id последней вставленной записи
    user_id = cursor.lastrowid
    print(f"ID новой записи: {user_id}")
    
    # Вставка нескольких записей
    users = [
        ('Bob', 'bob@example.com', 30),
        ('Charlie', 'charlie@example.com', 35),
        ('Dave', 'dave@example.com', 40)
    ]
    
    cursor.executemany('''
    INSERT INTO users (name, email, age) VALUES (?, ?, ?)
    ''', users)
    
    # Сохранение изменений
    conn.commit()
```

Обратите внимание на использование параметризованных запросов с заполнителями `?`. Это важно для предотвращения SQL-инъекций и правильного преобразования типов данных.

### Выполнение запросов и получение данных

Для получения данных используется SQL-запрос `SELECT`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Получение всех пользователей
    cursor.execute('SELECT * FROM users')
    
    # Получение всех строк
    all_users = cursor.fetchall()
    for user in all_users:
        print(user)
    
    # Получение пользователей с определенным условием
    cursor.execute('SELECT * FROM users WHERE age > ?', (30,))
    
    # Получение первой строки
    first_user = cursor.fetchone()
    print(f"Первый пользователь старше 30: {first_user}")
    
    # Получение ограниченного количества строк
    next_two_users = cursor.fetchmany(2)
    print(f"Следующие два пользователя старше 30: {next_two_users}")
```

По умолчанию `cursor.fetchall()` возвращает результаты в виде кортежей. Чтобы получить результаты в виде словарей, можно использовать `sqlite3.Row`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    # Установка Row как фабрики строк
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM users')
    for row in cursor.fetchall():
        # Доступ к полям по имени
        print(f"ID: {row['id']}, Имя: {row['name']}, Email: {row['email']}, Возраст: {row['age']}")
```

### Обновление данных

Для обновления данных используется SQL-запрос `UPDATE`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Обновление записи
    cursor.execute('''
    UPDATE users SET age = ? WHERE name = ?
    ''', (26, 'Alice'))
    
    # Сохранение изменений
    conn.commit()
    
    # Проверка обновления
    cursor.execute('SELECT * FROM users WHERE name = ?', ('Alice',))
    updated_user = cursor.fetchone()
    print(f"Обновленный пользователь: {updated_user}")
```

### Удаление данных

Для удаления данных используется SQL-запрос `DELETE`:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Удаление записи
    cursor.execute('DELETE FROM users WHERE name = ?', ('Dave',))
    
    # Получение количества удаленных строк
    deleted_count = cursor.rowcount
    print(f"Удалено строк: {deleted_count}")
    
    # Сохранение изменений
    conn.commit()
```

### Транзакции

SQLite автоматически начинает транзакцию при первом запросе и фиксирует её при вызове `commit()`. Если вы хотите отменить изменения, вы можете вызвать `rollback()`:

```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

try:
    # Начало неявной транзакции
    cursor.execute("INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
                  ('Eve', 'eve@example.com', 28))
    
    # Намеренно вызываем ошибку
    cursor.execute("INSERT INTO non_existent_table VALUES (1)")
    
    # Этот код не будет выполнен из-за ошибки
    conn.commit()
except sqlite3.Error as e:
    # Откат изменений в случае ошибки
    conn.rollback()
    print(f"Произошла ошибка: {e}")
finally:
    # Закрытие соединения
    conn.close()
```

## Продвинутые возможности sqlite3

### Типы данных SQLite

SQLite поддерживает следующие типы данных:
- `NULL`: Отсутствие значения
- `INTEGER`: Целое число
- `REAL`: Число с плавающей точкой
- `TEXT`: Текстовая строка
- `BLOB`: Бинарные данные

Однако SQLite использует "динамическую типизацию", что означает, что тип данных зависит от фактического значения, а не от объявленного типа столбца.

Python-модуль `sqlite3` автоматически выполняет преобразование между типами данных Python и SQLite:

| Python тип | SQLite тип |
|------------|------------|
| None       | NULL       |
| int        | INTEGER    |
| float      | REAL       |
| str        | TEXT       |
| bytes      | BLOB       |

### Адаптеры и конвертеры

Для работы с нестандартными типами данных можно создать "адаптеры" (для преобразования из типов Python в SQLite) и "конвертеры" (для преобразования из типов SQLite в Python).

#### Пример с datetime

```python
import sqlite3
import datetime

# Адаптер для datetime
def adapt_datetime(dt):
    return dt.isoformat()

# Конвертер для datetime
def convert_datetime(s):
    return datetime.datetime.fromisoformat(s)

# Регистрация адаптера и конвертера
sqlite3.register_adapter(datetime.datetime, adapt_datetime)
sqlite3.register_converter("datetime", convert_datetime)

# Использование с указанием типов столбцов
with sqlite3.connect('example.db', detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    cursor = conn.cursor()
    
    # Создание таблицы с явным указанием типа
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS events (
        id INTEGER PRIMARY KEY,
        name TEXT,
        event_date datetime
    )
    ''')
    
    # Вставка записи с datetime
    now = datetime.datetime.now()
    cursor.execute('''
    INSERT INTO events (name, event_date) VALUES (?, ?)
    ''', ('Meeting', now))
    
    # Получение записи
    cursor.execute('SELECT * FROM events')
    event = cursor.fetchone()
    print(f"Event: {event}")
    print(f"Type of event_date: {type(event[2])}")  # Должен быть datetime.datetime
```

#### Пример с пользовательским классом

```python
import sqlite3
import json

# Пользовательский класс
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

# Адаптер: Person -> TEXT
def adapt_person(person):
    return json.dumps({'name': person.name, 'age': person.age})

# Конвертер: TEXT -> Person
def convert_person(s):
    data = json.loads(s)
    return Person(data['name'], data['age'])

# Регистрация адаптера и конвертера
sqlite3.register_adapter(Person, adapt_person)
sqlite3.register_converter("person", convert_person)

# Использование
with sqlite3.connect('example.db', detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    cursor = conn.cursor()
    
    # Создание таблицы
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS person_data (
        id INTEGER PRIMARY KEY,
        person person
    )
    ''')
    
    # Вставка записи с объектом Person
    p = Person("John Doe", 30)
    cursor.execute('INSERT INTO person_data (person) VALUES (?)', (p,))
    
    # Получение записи
    cursor.execute('SELECT * FROM person_data')
    row = cursor.fetchone()
    retrieved_person = row[1]
    print(f"Retrieved: {retrieved_person}")
    print(f"Type: {type(retrieved_person)}")
```

### Агрегатные и оконные функции

SQLite поддерживает стандартные агрегатные функции SQL:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Подсчет пользователей
    cursor.execute('SELECT COUNT(*) FROM users')
    count = cursor.fetchone()[0]
    print(f"Всего пользователей: {count}")
    
    # Средний возраст
    cursor.execute('SELECT AVG(age) FROM users')
    avg_age = cursor.fetchone()[0]
    print(f"Средний возраст: {avg_age}")
    
    # Минимальный и максимальный возраст
    cursor.execute('SELECT MIN(age), MAX(age) FROM users')
    min_age, max_age = cursor.fetchone()
    print(f"Возрастной диапазон: от {min_age} до {max_age}")
    
    # Группировка и агрегация
    cursor.execute('''
    SELECT age, COUNT(*) FROM users GROUP BY age ORDER BY age
    ''')
    for age, count in cursor.fetchall():
        print(f"Возраст {age}: {count} пользователей")
```

Начиная с SQLite 3.25.0, также поддерживаются оконные функции:

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Добавление записей для примера
    cursor.executescript('''
    CREATE TABLE IF NOT EXISTS sales (
        id INTEGER PRIMARY KEY,
        product TEXT,
        region TEXT,
        amount REAL
    );
    
    INSERT INTO sales (product, region, amount) VALUES
        ('Laptop', 'North', 1000),
        ('Laptop', 'South', 1200),
        ('Laptop', 'East', 900),
        ('Tablet', 'North', 500),
        ('Tablet', 'South', 600),
        ('Tablet', 'East', 400),
        ('Phone', 'North', 700),
        ('Phone', 'South', 650),
        ('Phone', 'East', 800);
    ''')
    
    # Использование оконных функций
    cursor.execute('''
    SELECT 
        product, 
        region, 
        amount,
        SUM(amount) OVER (PARTITION BY product) as product_total,
        AVG(amount) OVER (PARTITION BY region) as region_avg,
        RANK() OVER (ORDER BY amount DESC) as rank
    FROM sales
    ORDER BY product, region
    ''')
    
    print("Продукт | Регион | Сумма | Всего по продукту | Среднее по региону | Ранг")
    print("-" * 75)
    
    for row in cursor.fetchall():
        print(f"{row[0]:<8} | {row[1]:<7} | {row[2]:<5} | {row[3]:<16} | {row[4]:<18.2f} | {row[5]}")
```

### Пользовательские функции

Вы можете создавать собственные SQL-функции на Python и использовать их в запросах:

```python
import sqlite3
import math

with sqlite3.connect('example.db') as conn:
    # Создание пользовательской функции
    conn.create_function("sqrt", 1, math.sqrt)
    
    cursor = conn.cursor()
    
    # Создание тестовой таблицы
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS numbers (
        id INTEGER PRIMARY KEY,
        value REAL
    )
    ''')
    
    # Вставка тестовых данных
    cursor.executemany(
        'INSERT INTO numbers (value) VALUES (?)',
        [(i,) for i in range(1, 11)]
    )
    
    # Использование пользовательской функции в запросе
    cursor.execute('''
    SELECT value, sqrt(value) FROM numbers
    ''')
    
    for value, sqrt_value in cursor.fetchall():
        print(f"√{value} = {sqrt_value}")
```

### Пользовательские агрегатные функции

Вы также можете создавать собственные агрегатные функции:

```python
import sqlite3

class Median:
    def __init__(self):
        self.values = []
    
    def step(self, value):
        self.values.append(value)
    
    def finalize(self):
        if not self.values:
            return None
        
        sorted_values = sorted(self.values)
        n = len(sorted_values)
        
        if n % 2 == 0:
            # Для четного количества элементов
            return (sorted_values[n//2-1] + sorted_values[n//2]) / 2
        else:
            # Для нечетного количества элементов
            return sorted_values[n//2]

with sqlite3.connect('example.db') as conn:
    # Регистрация агрегатной функции
    conn.create_aggregate("median", 1, Median)
    
    cursor = conn.cursor()
    
    # Использование пользовательской агрегатной функции
    cursor.execute('''
    SELECT median(age) FROM users
    ''')
    
    median_age = cursor.fetchone()[0]
    print(f"Медианный возраст: {median_age}")
```

### Виртуальные таблицы и FTS

SQLite поддерживает виртуальные таблицы, которые могут использоваться для различных целей, включая полнотекстовый поиск (FTS - Full Text Search).

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # Создание виртуальной FTS5 таблицы
    cursor.execute('''
    CREATE VIRTUAL TABLE IF NOT EXISTS articles_fts USING fts5(
        title, 
        content
    )
    ''')
    
    # Вставка данных
    articles = [
        ("Python Basics", "Python is a programming language with clear syntax and extensive libraries."),
        ("SQLite Tutorial", "SQLite is a lightweight database engine that is easy to use and embed."),
        ("Python and SQLite", "Python has built-in support for SQLite through the sqlite3 module."),
        ("Web Development", "Python is widely used for web development with frameworks like Flask and Django.")
    ]
    
    cursor.executemany('''
    INSERT INTO articles_fts (title, content) VALUES (?, ?)
    ''', articles)
    
    # Полнотекстовый поиск
    search_term = "python"
    cursor.execute('''
    SELECT title, content FROM articles_fts 
    WHERE articles_fts MATCH ?
    ORDER BY rank
    ''', (search_term,))
    
    print(f"Результаты поиска по запросу '{search_term}':")
    for title, content in cursor.fetchall():
        print(f"- {title}: {content[:50]}...")
```

## Практические примеры

### Пример 1: Библиотека

Создадим простую систему управления библиотекой с таблицами для книг, авторов и заимствований.

```python
import sqlite3
import datetime

def create_library_db(db_name='library.db'):
    """Создает базу данных библиотеки"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        # Создание таблиц
        cursor.executescript('''
        -- Таблица авторов
        CREATE TABLE IF NOT EXISTS authors (
            author_id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            birth_year INTEGER
        );
        
        -- Таблица книг
        CREATE TABLE IF NOT EXISTS books (
            book_id INTEGER PRIMARY KEY,
            title TEXT NOT NULL,
            author_id INTEGER,
            year_published INTEGER,
            isbn TEXT UNIQUE,
            available BOOLEAN NOT NULL DEFAULT 1,
            FOREIGN KEY (author_id) REFERENCES authors (author_id)
        );
        
        -- Таблица заимствований
        CREATE TABLE IF NOT EXISTS borrowings (
            borrowing_id INTEGER PRIMARY KEY,
            book_id INTEGER,
            borrower_name TEXT NOT NULL,
            borrow_date TEXT NOT NULL,
            return_date TEXT,
            FOREIGN KEY (book_id) REFERENCES books (book_id)
        );
        ''')
        
        print("База данных библиотеки успешно создана!")

def add_author(name, birth_year=None, db_name='library.db'):
    """Добавляет автора в базу данных"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO authors (name, birth_year) VALUES (?, ?)
        ''', (name, birth_year))
        
        author_id = cursor.lastrowid
        print(f"Автор '{name}' добавлен с ID {author_id}")
        return author_id

def add_book(title, author_id, year_published=None, isbn=None, db_name='library.db'):
    """Добавляет книгу в базу данных"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT INTO books (title, author_id, year_published, isbn, available)
            VALUES (?, ?, ?, ?, 1)
            ''', (title, author_id, year_published, isbn))
            
            book_id = cursor.lastrowid
            print(f"Книга '{title}' добавлена с ID {book_id}")
            return book_id
        except sqlite3.IntegrityError as e:
            if "UNIQUE constraint failed" in str(e):
                print(f"Ошибка: Книга с ISBN {isbn} уже существует.")
            else:
                print(f"Ошибка при добавлении книги: {e}")
            return None

def borrow_book(book_id, borrower_name, db_name='library.db'):
    """Регистрирует заимствование книги"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        # Проверка доступности книги
        cursor.execute('SELECT available FROM books WHERE book_id = ?', (book_id,))
        result = cursor.fetchone()
        
        if not result:
            print(f"Ошибка: Книга с ID {book_id} не найдена.")
            return False
        
        if not result[0]:
            print(f"Ошибка: Книга с ID {book_id} уже выдана.")
            return False
        
        # Обновление статуса книги
        cursor.execute('''
        UPDATE books SET available = 0 WHERE book_id = ?
        ''', (book_id,))
        
        # Добавление записи о заимствовании
        today = datetime.date.today().isoformat()
        cursor.execute('''
        INSERT INTO borrowings (book_id, borrower_name, borrow_date, return_date)
        VALUES (?, ?, ?, NULL)
        ''', (book_id, borrower_name, today))
        
        print(f"Книга с ID {book_id} выдана {borrower_name}")
        return True

def return_book(book_id, db_name='library.db'):
    """Регистрирует возврат книги"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        # Проверка, что книга была выдана
        cursor.execute('''
        SELECT borrowing_id FROM borrowings 
        WHERE book_id = ? AND return_date IS NULL
        ''', (book_id,))
        
        result = cursor.fetchone()
        if not result:
            print(f"Ошибка: Книга с ID {book_id} не числится как выданная.")
            return False
        
        borrowing_id = result[0]
        
        # Обновление статуса книги
        cursor.execute('''
        UPDATE books SET available = 1 WHERE book_id = ?
        ''', (book_id,))
        
        # Обновление записи о заимствовании
        today = datetime.date.today().isoformat()
        cursor.execute('''
        UPDATE borrowings SET return_date = ? WHERE borrowing_id = ?
        ''', (today, borrowing_id))
        
        print(f"Книга с ID {book_id} возвращена.")
        return True

def search_books(query, db_name='library.db'):
    """Поиск книг по названию или автору"""
    with sqlite3.connect(db_name) as conn:
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT b.book_id, b.title, a.name as author_name, b.year_published, b.isbn, b.available
        FROM books b
        JOIN authors a ON b.author_id = a.author_id
        WHERE b.title LIKE ? OR a.name LIKE ?
        ORDER BY b.title
        ''', (f'%{query}%', f'%{query}%'))
        
        results = cursor.fetchall()
        
        if not results:
            print(f"Книги по запросу '{query}' не найдены.")
            return []
        
        print(f"Найдено {len(results)} книг по запросу '{query}':")
        for book in results:
            status = "доступна" if book['available'] else "выдана"
            print(f"ID: {book['book_id']}, '{book['title']}' ({book['year_published']}), "
                  f"автор: {book['author_name']}, ISBN: {book['isbn']}, статус: {status}")
        
        return results

def list_borrowed_books(db_name='library.db'):
    """Список всех выданных книг"""
    with sqlite3.connect(db_name) as conn:
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT b.book_id, b.title, a.name as author_name, 
               br.borrower_name, br.borrow_date, br.borrowing_id
        FROM books b
        JOIN authors a ON b.author_id = a.author_id
        JOIN borrowings br ON b.book_id = br.book_id
        WHERE br.return_date IS NULL
        ORDER BY br.borrow_date
        ''')
        
        results = cursor.fetchall()
        
        if not results:
            print("В настоящее время нет выданных книг.")
            return []
        
        print(f"Список выданных книг ({len(results)}):")
        for book in results:
            print(f"ID: {book['book_id']}, '{book['title']}', автор: {book['author_name']}, "
                  f"выдана: {book['borrower_name']}, дата: {book['borrow_date']}")
        
        return results

def generate_statistics(db_name='library.db'):
    """Генерирует статистику по библиотеке"""
    with sqlite3.connect(db_name) as conn:
        cursor = conn.cursor()
        
        print("Статистика библиотеки:")
        
        # Общее количество книг
        cursor.execute('SELECT COUNT(*) FROM books')
        total_books = cursor.fetchone()[0]
        print(f"Всего книг: {total_books}")
        
        # Количество доступных книг
        cursor.execute('SELECT COUNT(*) FROM books WHERE available = 1')
        available_books = cursor.fetchone()[0]
        print(f"Доступных книг: {available_books}")
        
        # Количество выданных книг
        cursor.execute('SELECT COUNT(*) FROM books WHERE available = 0')
        borrowed_books = cursor.fetchone()[0]
        print(f"Выданных книг: {borrowed_books}")
        
        # Количество авторов
        cursor.execute('SELECT COUNT(*) FROM authors')
        total_authors = cursor.fetchone()[0]
        print(f"Всего авторов: {total_authors}")
        
        # Топ-5 авторов по количеству книг
        cursor.execute('''
        SELECT a.name, COUNT(b.book_id) as book_count
        FROM authors a
        JOIN books b ON a.author_id = b.author_id
        GROUP BY a.author_id
        ORDER BY book_count DESC
        LIMIT 5
        ''')
        
        print("\nТоп-5 авторов по количеству книг:")
        for author, count in cursor.fetchall():
            print(f"- {author}: {count} книг")
        
        # Статистика по годам публикации
        cursor.execute('''
        SELECT year_published, COUNT(*) as count
        FROM books
        WHERE year_published IS NOT NULL
        GROUP BY year_published
        ORDER BY count DESC
        LIMIT 5
        ''')
        
        print("\nПопулярные годы публикации:")
        for year, count in cursor.fetchall():
            print(f"- {year}: {count} книг")

# Пример использования

if __name__ == '__main__':
    # Создание базы данных
    create_library_db()
    
    # Добавление авторов
    tolkien_id = add_author("J.R.R. Tolkien", 1892)
    rowling_id = add_author("J.K. Rowling", 1965)
    orwell_id = add_author("George Orwell", 1903)
    
    # Добавление книг
    hobbit_id = add_book("The Hobbit", tolkien_id, 1937, "978-0547928227")
    lotr_id = add_book("The Lord of the Rings", tolkien_id, 1954, "978-0544003415")
    hp1_id = add_book("Harry Potter and the Philosopher's Stone", rowling_id, 1997, "978-0747532699")
    hp2_id = add_book("Harry Potter and the Chamber of Secrets", rowling_id, 1998, "978-0747538486")
    farm_id = add_book("Animal Farm", orwell_id, 1945, "978-0451526342")
    
    # Заимствование книг
    borrow_book(hobbit_id, "Alice Smith")
    borrow_book(hp1_id, "Bob Johnson")
    
    # Поиск книг
    search_books("Potter")
    search_books("Tolkien")
    
    # Список выданных книг
    list_borrowed_books()
    
    # Возврат книги
    return_book(hobbit_id)
    
    # Статистика библиотеки
    generate_statistics()
```

### Пример 2: Менеджер задач (TODO)

Создадим простое приложение для управления задачами.

```python
import sqlite3
import datetime

class TodoManager:
    def __init__(self, db_name='todo.db'):
        """Инициализация менеджера задач"""
        self.db_name = db_name
        self.conn = None
        self.create_tables()
    
    def connect(self):
        """Подключение к базе данных"""
        self.conn = sqlite3.connect(self.db_name)
        self.conn.row_factory = sqlite3.Row
        return self.conn
    
    def close(self):
        """Закрытие соединения с базой данных"""
        if self.conn:
            self.conn.close()
            self.conn = None
    
    def create_tables(self):
        """Создание необходимых таблиц"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            cursor.executescript('''
            -- Таблица категорий
            CREATE TABLE IF NOT EXISTS categories (
                category_id INTEGER PRIMARY KEY,
                name TEXT UNIQUE NOT NULL
            );
            
            -- Таблица задач
            CREATE TABLE IF NOT EXISTS tasks (
                task_id INTEGER PRIMARY KEY,
                title TEXT NOT NULL,
                description TEXT,
                due_date TEXT,
                priority INTEGER DEFAULT 1,
                completed BOOLEAN DEFAULT 0,
                category_id INTEGER,
                created_at TEXT NOT NULL,
                completed_at TEXT,
                FOREIGN KEY (category_id) REFERENCES categories (category_id)
            );
            ''')
    
    def add_category(self, name):
        """Добавление новой категории"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            try:
                cursor.execute('''
                INSERT INTO categories (name) VALUES (?)
                ''', (name,))
                
                category_id = cursor.lastrowid
                print(f"Категория '{name}' добавлена с ID {category_id}")
                return category_id
            except sqlite3.IntegrityError:
                print(f"Категория '{name}' уже существует.")
                
                # Получение ID существующей категории
                cursor.execute('''
                SELECT category_id FROM categories WHERE name = ?
                ''', (name,))
                
                result = cursor.fetchone()
                return result['category_id'] if result else None
    
    def get_categories(self):
        """Получение списка всех категорий"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT category_id, name FROM categories ORDER BY name
            ''')
            
            return cursor.fetchall()
    
    def add_task(self, title, description=None, due_date=None, priority=1, category_id=None):
        """Добавление новой задачи"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            now = datetime.datetime.now().isoformat()
            
            cursor.execute('''
            INSERT INTO tasks (title, description, due_date, priority, category_id, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (title, description, due_date, priority, category_id, now))
            
            task_id = cursor.lastrowid
            print(f"Задача '{title}' добавлена с ID {task_id}")
            return task_id
    
    def complete_task(self, task_id):
        """Отметка задачи как выполненной"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            # Проверка существования задачи
            cursor.execute('''
            SELECT task_id, completed FROM tasks WHERE task_id = ?
            ''', (task_id,))
            
            task = cursor.fetchone()
            if not task:
                print(f"Ошибка: Задача с ID {task_id} не найдена.")
                return False
            
            if task['completed']:
                print(f"Задача с ID {task_id} уже отмечена как выполненная.")
                return True
            
            # Отметка задачи как выполненной
            now = datetime.datetime.now().isoformat()
            cursor.execute('''
            UPDATE tasks SET completed = 1, completed_at = ? WHERE task_id = ?
            ''', (now, task_id))
            
            print(f"Задача с ID {task_id} отмечена как выполненная.")
            return True
    
    def update_task(self, task_id, title=None, description=None, due_date=None, 
                   priority=None, category_id=None):
        """Обновление информации о задаче"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            # Проверка существования задачи
            cursor.execute('''
            SELECT * FROM tasks WHERE task_id = ?
            ''', (task_id,))
            
            task = cursor.fetchone()
            if not task:
                print(f"Ошибка: Задача с ID {task_id} не найдена.")
                return False
            
            # Формирование запроса обновления
            update_fields = []
            params = []
            
            if title is not None:
                update_fields.append("title = ?")
                params.append(title)
            
            if description is not None:
                update_fields.append("description = ?")
                params.append(description)
            
            if due_date is not None:
                update_fields.append("due_date = ?")
                params.append(due_date)
            
            if priority is not None:
                update_fields.append("priority = ?")
                params.append(priority)
            
            if category_id is not None:
                update_fields.append("category_id = ?")
                params.append(category_id)
            
            if not update_fields:
                print("Нет данных для обновления.")
                return False
            
            # Выполнение запроса обновления
            query = f"UPDATE tasks SET {', '.join(update_fields)} WHERE task_id = ?"
            params.append(task_id)
            
            cursor.execute(query, params)
            
            print(f"Задача с ID {task_id} обновлена.")
            return True
    
    def delete_task(self, task_id):
        """Удаление задачи"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            # Проверка существования задачи
            cursor.execute('''
            SELECT task_id FROM tasks WHERE task_id = ?
            ''', (task_id,))
            
            task = cursor.fetchone()
            if not task:
                print(f"Ошибка: Задача с ID {task_id} не найдена.")
                return False
            
            # Удаление задачи
            cursor.execute('''
            DELETE FROM tasks WHERE task_id = ?
            ''', (task_id,))
            
            print(f"Задача с ID {task_id} удалена.")
            return True
    
    def get_tasks(self, category_id=None, completed=None, due_date=None, priority=None):
        """Получение списка задач с фильтрацией"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            query = '''
            SELECT t.task_id, t.title, t.description, t.due_date, 
                   t.priority, t.completed, t.created_at, t.completed_at,
                   c.name as category_name
            FROM tasks t
            LEFT JOIN categories c ON t.category_id = c.category_id
            WHERE 1=1
            '''
            
            params = []
            
            if category_id is not None:
                query += " AND t.category_id = ?"
                params.append(category_id)
            
            if completed is not None:
                query += " AND t.completed = ?"
                params.append(1 if completed else 0)
            
            if due_date is not None:
                query += " AND t.due_date = ?"
                params.append(due_date)
            
            if priority is not None:
                query += " AND t.priority = ?"
                params.append(priority)
            
            query += " ORDER BY t.due_date ASC, t.priority DESC, t.title ASC"
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def search_tasks(self, search_term):
        """Поиск задач по заголовку или описанию"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT t.task_id, t.title, t.description, t.due_date, 
                   t.priority, t.completed, t.created_at, t.completed_at,
                   c.name as category_name
            FROM tasks t
            LEFT JOIN categories c ON t.category_id = c.category_id
            WHERE t.title LIKE ? OR t.description LIKE ?
            ORDER BY t.due_date ASC, t.priority DESC, t.title ASC
            ''', (f'%{search_term}%', f'%{search_term}%'))
            
            return cursor.fetchall()
    
    def get_stats(self):
        """Получение статистики по задачам"""
        with self.connect() as conn:
            cursor = conn.cursor()
            
            stats = {}
            
            # Общее количество задач
            cursor.execute('SELECT COUNT(*) FROM tasks')
            stats['total_tasks'] = cursor.fetchone()[0]
            
            # Количество завершенных задач
            cursor.execute('SELECT COUNT(*) FROM tasks WHERE completed = 1')
            stats['completed_tasks'] = cursor.fetchone()[0]
            
            # Количество незавершенных задач
            cursor.execute('SELECT COUNT(*) FROM tasks WHERE completed = 0')
            stats['pending_tasks'] = cursor.fetchone()[0]
            
            # Количество просроченных задач
            today = datetime.date.today().isoformat()
            cursor.execute('''
            SELECT COUNT(*) FROM tasks 
            WHERE completed = 0 AND due_date < ? AND due_date IS NOT NULL
            ''', (today,))
            stats['overdue_tasks'] = cursor.fetchone()[0]
            
            # Количество задач без срока
            cursor.execute('''
            SELECT COUNT(*) FROM tasks WHERE due_date IS NULL
            ''')
            stats['no_due_date_tasks'] = cursor.fetchone()[0]
            
            # Задачи по приоритетам
            cursor.execute('''
            SELECT priority, COUNT(*) FROM tasks GROUP BY priority ORDER BY priority DESC
            ''')
            stats['tasks_by_priority'] = cursor.fetchall()
            
            # Задачи по категориям
            cursor.execute('''
            SELECT c.name, COUNT(t.task_id) 
            FROM categories c
            LEFT JOIN tasks t ON c.category_id = t.category_id
            GROUP BY c.category_id
            ORDER BY COUNT(t.task_id) DESC
            ''')
            stats['tasks_by_category'] = cursor.fetchall()
            
            return stats
    
    def display_tasks(self, tasks):
        """Отображение списка задач"""
        if not tasks:
            print("Нет задач для отображения.")
            return
        
        print(f"\nСписок задач ({len(tasks)}):")
        print("-" * 80)
        print(f"{'ID':<4} | {'Заголовок':<30} | {'Категория':<15} | {'Срок':<10} | {'Приоритет':<9} | {'Статус':<10}")
        print("-" * 80)
        
        for task in tasks:
            status = "Выполнено" if task['completed'] else "Активно"
            priority_map = {1: "Низкий", 2: "Средний", 3: "Высокий"}
            priority = priority_map.get(task['priority'], task['priority'])
            
            title = task['title']
            if len(title) > 27:
                title = title[:27] + "..."
            
            category = task['category_name'] or "Без категории"
            if len(category) > 12:
                category = category[:12] + "..."
            
            due_date = task['due_date'] or "Нет срока"
            if due_date != "Нет срока":
                due_date = due_date.split('T')[0]  # Извлекаем только дату из ISO формата
            
            print(f"{task['task_id']:<4} | {title:<30} | {category:<15} | {due_date:<10} | {priority:<9} | {status:<10}")
        
        print("-" * 80)
    
    def display_stats(self, stats):
        """Отображение статистики"""
        print("\nСтатистика задач:")
        print(f"Всего задач: {stats['total_tasks']}")
        print(f"Выполнено: {stats['completed_tasks']}")
        print(f"Активно: {stats['pending_tasks']}")
        print(f"Просрочено: {stats['overdue_tasks']}")
        print(f"Без срока: {stats['no_due_date_tasks']}")
        
        print("\nЗадачи по приоритетам:")
        priority_map = {1: "Низкий", 2: "Средний", 3: "Высокий"}
        for priority, count in stats['tasks_by_priority']:
            priority_name = priority_map.get(priority, priority)
            print(f"- {priority_name}: {count}")
        
        print("\nЗадачи по категориям:")
        for category, count in stats['tasks_by_category']:
            print(f"- {category}: {count}")

# Пример использования

def interactive_demo():
    """Интерактивная демонстрация менеджера задач"""
    todo = TodoManager()
    
    print("=== Демонстрация менеджера задач ===")
    
    # Создание категорий
    work_cat = todo.add_category("Работа")
    personal_cat = todo.add_category("Личное")
    study_cat = todo.add_category("Учеба")
    
    # Добавление задач
    today = datetime.date.today().isoformat()
    tomorrow = (datetime.date.today() + datetime.timedelta(days=1)).isoformat()
    next_week = (datetime.date.today() + datetime.timedelta(days=7)).isoformat()
    
    todo.add_task("Написать отчет", "Подготовить ежемесячный отчет", tomorrow, 3, work_cat)
    todo.add_task("Сходить в магазин", "Купить молоко, хлеб и фрукты", today, 2, personal_cat)
    todo.add_task("Изучить SQLite", "Пройти урок по SQLite и сделать упражнения", next_week, 1, study_cat)
    todo.add_task("Подготовить презентацию", "Презентация о новом проекте", tomorrow, 3, work_cat)
    todo.add_task("Позвонить родителям", "Обсудить планы на выходные", today, 2, personal_cat)
    
    while True:
        print("\n=== Меню ===")
        print("1. Показать все задачи")
        print("2. Показать активные задачи")
        print("3. Показать выполненные задачи")
        print("4. Добавить задачу")
        print("5. Отметить задачу как выполненную")
        print("6. Обновить задачу")
        print("7. Удалить задачу")
        print("8. Поиск задач")
        print("9. Статистика")
        print("0. Выход")
        
        choice = input("Выберите опцию: ")
        
        if choice == '1':
            tasks = todo.get_tasks()
            todo.display_tasks(tasks)
        
        elif choice == '2':
            tasks = todo.get_tasks(completed=False)
            todo.display_tasks(tasks)
        
        elif choice == '3':
            tasks = todo.get_tasks(completed=True)
            todo.display_tasks(tasks)
        
        elif choice == '4':
            title = input("Введите заголовок задачи: ")
            description = input("Введите описание задачи (опционально): ")
            due_date = input("Введите срок выполнения (ГГГГ-ММ-ДД, опционально): ")
            
            priority = None
            while priority not in [1, 2, 3]:
                try:
                    priority = int(input("Введите приоритет (1-низкий, 2-средний, 3-высокий): "))
                    if priority not in [1, 2, 3]:
                        print("Приоритет должен быть 1, 2 или 3.")
                except ValueError:
                    print("Введите число.")
            
            print("Доступные категории:")
            categories = todo.get_categories()
            for cat in categories:
                print(f"{cat['category_id']}. {cat['name']}")
            
            category_id = input("Введите ID категории (опционально): ")
            category_id = int(category_id) if category_id.isdigit() else None
            
            todo.add_task(title, description, due_date, priority, category_id)
        
        elif choice == '5':
            task_id = input("Введите ID задачи для отметки как выполненной: ")
            if task_id.isdigit():
                todo.complete_task(int(task_id))
            else:
                print("ID задачи должен быть числом.")
        
        elif choice == '6':
            task_id = input("Введите ID задачи для обновления: ")
            if not task_id.isdigit():
                print("ID задачи должен быть числом.")
                continue
            
            title = input("Введите новый заголовок (оставьте пустым, чтобы не менять): ")
            title = title if title else None
            
            description = input("Введите новое описание (оставьте пустым, чтобы не менять): ")
            description = description if description else None
            
            due_date = input("Введите новый срок (ГГГГ-ММ-ДД, оставьте пустым, чтобы не менять): ")
            due_date = due_date if due_date else None
            
            priority_str = input("Введите новый приоритет (1-3, оставьте пустым, чтобы не менять): ")
            priority = int(priority_str) if priority_str.isdigit() else None
            
            category_id_str = input("Введите новый ID категории (оставьте пустым, чтобы не менять): ")
            category_id = int(category_id_str) if category_id_str.isdigit() else None
            
            todo.update_task(int(task_id), title, description, due_date, priority, category_id)
        
        elif choice == '7':
            task_id = input("Введите ID задачи для удаления: ")
            if task_id.isdigit():
                todo.delete_task(int(task_id))
            else:
                print("ID задачи должен быть числом.")
        
        elif choice == '8':
            search_term = input("Введите текст для поиска: ")
            tasks = todo.search_tasks(search_term)
            todo.display_tasks(tasks)
        
        elif choice == '9':
            stats = todo.get_stats()
            todo.display_stats(stats)
        
        elif choice == '0':
            print("Выход из программы...")
            break
        
        else:
            print("Неверный выбор. Пожалуйста, выберите опцию от 0 до 9.")
    
    todo.close()

if __name__ == '__main__':
    interactive_demo()
```

## Практические задания

### Задание 1: Система учета расходов

Создайте систему для отслеживания личных финансов, которая позволит пользователю:

1. Добавлять записи о доходах и расходах с категориями
2. Просматривать историю транзакций
3. Анализировать расходы по категориям за определенный период
4. Создавать бюджеты по категориям и отслеживать их исполнение

**Решение:**

```python
import sqlite3
import datetime
import calendar
import os
from decimal import Decimal, InvalidOperation

class ExpenseTracker:
    def __init__(self, db_name='expenses.db'):
        """Инициализация системы учета расходов"""
        self.db_name = db_name
        self.create_database()
    
    def create_database(self):
        """Создание базы данных и необходимых таблиц"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            cursor.executescript('''
            -- Таблица категорий
            CREATE TABLE IF NOT EXISTS categories (
                category_id INTEGER PRIMARY KEY,
                name TEXT UNIQUE NOT NULL,
                type TEXT NOT NULL CHECK (type IN ('income', 'expense'))
            );
            
            -- Таблица транзакций
            CREATE TABLE IF NOT EXISTS transactions (
                transaction_id INTEGER PRIMARY KEY,
                amount REAL NOT NULL,
                description TEXT,
                date TEXT NOT NULL,
                category_id INTEGER,
                FOREIGN KEY (category_id) REFERENCES categories (category_id)
            );
            
            -- Таблица бюджетов
            CREATE TABLE IF NOT EXISTS budgets (
                budget_id INTEGER PRIMARY KEY,
                category_id INTEGER NOT NULL,
                amount REAL NOT NULL,
                period TEXT NOT NULL,  -- 'monthly', 'yearly'
                start_date TEXT NOT NULL,
                end_date TEXT,
                FOREIGN KEY (category_id) REFERENCES categories (category_id)
            );
            ''')
    
    def add_default_categories(self):
        """Добавление стандартных категорий"""
        income_categories = ["Зарплата", "Подработка", "Инвестиции", "Подарки", "Прочие доходы"]
        expense_categories = ["Продукты", "Жилье", "Транспорт", "Развлечения", "Здоровье", 
                             "Одежда", "Образование", "Рестораны", "Путешествия", "Прочие расходы"]
        
        for category in income_categories:
            self.add_category(category, "income")
        
        for category in expense_categories:
            self.add_category(category, "expense")
    
    def add_category(self, name, type_):
        """Добавление новой категории"""
        if type_ not in ('income', 'expense'):
            print("Ошибка: Тип категории должен быть 'income' или 'expense'.")
            return None
        
        try:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()
                
                cursor.execute('''
                INSERT INTO categories (name, type) VALUES (?, ?)
                ''', (name, type_))
                
                category_id = cursor.lastrowid
                print(f"Категория '{name}' ({type_}) добавлена.")
                return category_id
        
        except sqlite3.IntegrityError:
            print(f"Категория '{name}' уже существует.")
            
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                SELECT category_id FROM categories WHERE name = ?
                ''', (name,))
                
                result = cursor.fetchone()
                return result[0] if result else None
    
    def get_categories(self, type_=None):
        """Получение списка категорий с возможностью фильтрации по типу"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = 'SELECT category_id, name, type FROM categories'
            params = []
            
            if type_:
                query += ' WHERE type = ?'
                params.append(type_)
            
            query += ' ORDER BY name'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def add_transaction(self, amount, description, category_id, date=None):
        """Добавление новой транзакции"""
        # Проверка суммы
        try:
            amount = float(Decimal(amount))
        except (ValueError, InvalidOperation):
            print("Ошибка: Неверный формат суммы.")
            return None
        
        # Проверка категории
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM categories WHERE category_id = ?', (category_id,))
            category = cursor.fetchone()
            
            if not category:
                print(f"Ошибка: Категория с ID {category_id} не существует.")
                return None
        
        # Если дата не указана, используем текущую
        if not date:
            date = datetime.date.today().isoformat()
        
        # Добавление транзакции
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
            INSERT INTO transactions (amount, description, date, category_id)
            VALUES (?, ?, ?, ?)
            ''', (amount, description, date, category_id))
            
            transaction_id = cursor.lastrowid
            print(f"Транзакция добавлена с ID {transaction_id}.")
            return transaction_id
    
    def get_transactions(self, start_date=None, end_date=None, category_id=None, type_=None):
        """Получение списка транзакций с фильтрацией"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = '''
            SELECT t.transaction_id, t.amount, t.description, t.date, 
                   c.category_id, c.name as category_name, c.type
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE 1=1
            '''
            
            params = []
            
            if start_date:
                query += ' AND t.date >= ?'
                params.append(start_date)
            
            if end_date:
                query += ' AND t.date <= ?'
                params.append(end_date)
            
            if category_id:
                query += ' AND t.category_id = ?'
                params.append(category_id)
            
            if type_:
                query += ' AND c.type = ?'
                params.append(type_)
            
            query += ' ORDER BY t.date DESC, t.transaction_id DESC'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def delete_transaction(self, transaction_id):
        """Удаление транзакции"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            cursor.execute('SELECT * FROM transactions WHERE transaction_id = ?', (transaction_id,))
            transaction = cursor.fetchone()
            
            if not transaction:
                print(f"Ошибка: Транзакция с ID {transaction_id} не найдена.")
                return False
            
            cursor.execute('DELETE FROM transactions WHERE transaction_id = ?', (transaction_id,))
            print(f"Транзакция с ID {transaction_id} удалена.")
            return True
    
    def create_budget(self, category_id, amount, period='monthly', start_date=None):
        """Создание бюджета по категории"""
        # Проверка суммы
        try:
            amount = float(Decimal(amount))
            if amount <= 0:
                print("Ошибка: Сумма бюджета должна быть положительной.")
                return None
        except (ValueError, InvalidOperation):
            print("Ошибка: Неверный формат суммы.")
            return None
        
        # Проверка категории
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM categories WHERE category_id = ? AND type = "expense"', 
                          (category_id,))
            category = cursor.fetchone()
            
            if not category:
                print(f"Ошибка: Категория расходов с ID {category_id} не существует.")
                return None
        
        # Проверка периода
        if period not in ('monthly', 'yearly'):
            print("Ошибка: Период должен быть 'monthly' или 'yearly'.")
            return None
        
        # Определение дат начала и окончания
        if not start_date:
            start_date = datetime.date.today().replace(day=1).isoformat()  # Начало текущего месяца
        
        # Для месячного бюджета - конец месяца
        if period == 'monthly':
            date_obj = datetime.date.fromisoformat(start_date)
            last_day = calendar.monthrange(date_obj.year, date_obj.month)[1]
            end_date = date_obj.replace(day=last_day).isoformat()
        
        # Для годового бюджета - конец года
        else:
            date_obj = datetime.date.fromisoformat(start_date)
            end_date = date_obj.replace(month=12, day=31).isoformat()
        
        # Создание бюджета
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
            INSERT INTO budgets (category_id, amount, period, start_date, end_date)
            VALUES (?, ?, ?, ?, ?)
            ''', (category_id, amount, period, start_date, end_date))
            
            budget_id = cursor.lastrowid
            print(f"Бюджет создан с ID {budget_id}.")
            return budget_id
    
    def get_budgets(self, active_only=True):
        """Получение списка бюджетов"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = '''
            SELECT b.budget_id, b.amount, b.period, b.start_date, b.end_date,
                   c.category_id, c.name as category_name
            FROM budgets b
            JOIN categories c ON b.category_id = c.category_id
            '''
            
            params = []
            
            if active_only:
                today = datetime.date.today().isoformat()
                query += ' WHERE b.start_date <= ? AND b.end_date >= ?'
                params.extend([today, today])
            
            query += ' ORDER BY b.end_date DESC'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def get_budget_status(self, budget_id):
        """Получение статуса бюджета - сколько потрачено и осталось"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Получение информации о бюджете
            cursor.execute('''
            SELECT b.budget_id, b.amount, b.start_date, b.end_date,
                   c.category_id, c.name as category_name
            FROM budgets b
            JOIN categories c ON b.category_id = c.category_id
            WHERE b.budget_id = ?
            ''', (budget_id,))
            
            budget = cursor.fetchone()
            if not budget:
                print(f"Ошибка: Бюджет с ID {budget_id} не найден.")
                return None
            
            # Расчет потраченной суммы
            cursor.execute('''
            SELECT SUM(amount) as spent
            FROM transactions
            WHERE category_id = ? AND date >= ? AND date <= ?
            ''', (budget['category_id'], budget['start_date'], budget['end_date']))
            
            result = cursor.fetchone()
            spent = result['spent'] if result['spent'] is not None else 0
            
            # Расчет остатка
            remaining = budget['amount'] - spent
            
            # Расчет процента использования
            if budget['amount'] > 0:
                percentage_used = (spent / budget['amount']) * 100
            else:
                percentage_used = 0
            
            return {
                'budget_id': budget['budget_id'],
                'category_name': budget['category_name'],
                'amount': budget['amount'],
                'start_date': budget['start_date'],
                'end_date': budget['end_date'],
                'spent': spent,
                'remaining': remaining,
                'percentage_used': percentage_used
            }
    
    def get_spending_by_category(self, start_date=None, end_date=None):
        """Анализ расходов по категориям за период"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = '''
            SELECT c.category_id, c.name as category_name, SUM(t.amount) as total_amount
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'expense'
            '''
            
            params = []
            
            if start_date:
                query += ' AND t.date >= ?'
                params.append(start_date)
            
            if end_date:
                query += ' AND t.date <= ?'
                params.append(end_date)
            
            query += ' GROUP BY c.category_id ORDER BY total_amount DESC'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def get_income_by_category(self, start_date=None, end_date=None):
        """Анализ доходов по категориям за период"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = '''
            SELECT c.category_id, c.name as category_name, SUM(t.amount) as total_amount
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'income'
            '''
            
            params = []
            
            if start_date:
                query += ' AND t.date >= ?'
                params.append(start_date)
            
            if end_date:
                query += ' AND t.date <= ?'
                params.append(end_date)
            
            query += ' GROUP BY c.category_id ORDER BY total_amount DESC'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def get_monthly_summary(self, year=None, month=None):
        """Получение ежемесячной сводки доходов и расходов"""
        # Если год и месяц не указаны, используем текущий месяц
        if not year or not month:
            today = datetime.date.today()
            year = today.year
            month = today.month
        
        # Определение начала и конца месяца
        start_date = datetime.date(year, month, 1).isoformat()
        last_day = calendar.monthrange(year, month)[1]
        end_date = datetime.date(year, month, last_day).isoformat()
        
        # Получение сумм доходов и расходов
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Общая сумма доходов
            cursor.execute('''
            SELECT SUM(t.amount) as total_income
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'income' AND t.date >= ? AND t.date <= ?
            ''', (start_date, end_date))
            
            total_income = cursor.fetchone()[0] or 0
            
            # Общая сумма расходов
            cursor.execute('''
            SELECT SUM(t.amount) as total_expense
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'expense' AND t.date >= ? AND t.date <= ?
            ''', (start_date, end_date))
            
            total_expense = cursor.fetchone()[0] or 0
            
            # Баланс
            balance = total_income - total_expense
            
            # Данные по расходам по категориям
            cursor.execute('''
            SELECT c.name as category_name, SUM(t.amount) as amount
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'expense' AND t.date >= ? AND t.date <= ?
            GROUP BY c.category_id
            ORDER BY amount DESC
            ''', (start_date, end_date))
            
            expenses_by_category = cursor.fetchall()
            
            # Данные по доходам по категориям
            cursor.execute('''
            SELECT c.name as category_name, SUM(t.amount) as amount
            FROM transactions t
            JOIN categories c ON t.category_id = c.category_id
            WHERE c.type = 'income' AND t.date >= ? AND t.date <= ?
            GROUP BY c.category_id
            ORDER BY amount DESC
            ''', (start_date, end_date))
            
            income_by_category = cursor.fetchall()
        
        return {
            'year': year,
            'month': month,
            'start_date': start_date,
            'end_date': end_date,
            'total_income': total_income,
            'total_expense': total_expense,
            'balance': balance,
            'expenses_by_category': expenses_by_category,
            'income_by_category': income_by_category
        }
    
    def generate_annual_report(self, year=None):
        """Генерация годового отчета"""
        # Если год не указан, используем текущий
        if not year:
            year = datetime.date.today().year
        
        # Определение начала и конца года
        start_date = f"{year}-01-01"
        end_date = f"{year}-12-31"
        
        # Получение данных по месяцам
        monthly_data = []
        
        for month in range(1, 13):
            summary = self.get_monthly_summary(year, month)
            monthly_data.append(summary)
        
        # Расчет годовых итогов
        total_income = sum(data['total_income'] for data in monthly_data)
        total_expense = sum(data['total_expense'] for data in monthly_data)
        annual_balance = total_income - total_expense
        
        # Данные по категориям за год
        expenses_by_category = self.get_spending_by_category(start_date, end_date)
        income_by_category = self.get_income_by_category(start_date, end_date)
        
        return {
            'year': year,
            'monthly_data': monthly_data,
            'total_income': total_income,
            'total_expense': total_expense,
            'annual_balance': annual_balance,
            'expenses_by_category': expenses_by_category,
            'income_by_category': income_by_category
        }

def display_menu():
    """Отображение главного меню"""
    print("\n=== Система учета расходов ===")
    print("1. Добавить транзакцию")
    print("2. Просмотреть транзакции")
    print("3. Управление категориями")
    print("4. Управление бюджетами")
    print("5. Аналитика")
    print("0. Выход")
    print("=" * 30)

def format_amount(amount):
    """Форматирование суммы с двумя десятичными знаками"""
    return f"{amount:.2f}"

def interactive_demo():
    """Интерактивная демонстрация системы учета расходов"""
    
    # Создание экземпляра системы
    expense_tracker = ExpenseTracker()
    
    # Добавление стандартных категорий, если их еще нет
    expense_tracker.add_default_categories()
    
    while True:
        display_menu()
        choice = input("Выберите действие (0-5): ")
        
        if choice == '0':
            print("Выход из программы...")
            break
        
        elif choice == '1':
            # Добавление транзакции
            print("\n=== Добавление транзакции ===")
            
            # Определение типа транзакции
            type_choice = input("Выберите тип (1-Доход, 2-Расход): ")
            
            if type_choice == '1':
                transaction_type = 'income'
                print("\nДоступные категории доходов:")
            elif type_choice == '2':
                transaction_type = 'expense'
                print("\nДоступные категории расходов:")
            else:
                print("Неверный выбор. Возврат в главное меню.")
                continue
            
            # Отображение доступных категорий
            categories = expense_tracker.get_categories(type_=transaction_type)
            for cat in categories:
                print(f"{cat['category_id']}. {cat['name']}")
            
            # Ввод данных транзакции
            try:
                category_id = int(input("\nВведите ID категории: "))
                amount = input("Введите сумму: ")
                description = input("Введите описание (опционально): ")
                date_str = input("Введите дату (ГГГГ-ММ-ДД, пусто - сегодня): ")
                
                date = date_str if date_str else None
                
                if transaction_type == 'expense':
                    # Для расходов сумма отрицательная
                    if float(amount) > 0:
                        amount = -float(amount)
                
                expense_tracker.add_transaction(amount, description, category_id, date)
            
            except ValueError:
                print("Ошибка: Неверный формат данных.")
        
        elif choice == '2':
            # Просмотр транзакций
            print("\n=== Просмотр транзакций ===")
            print("1. Все транзакции")
            print("2. Только доходы")
            print("3. Только расходы")
            print("4. За определенный период")
            
            view_choice = input("\nВыберите опцию (1-4): ")
            
            start_date = None
            end_date = None
            type_ = None
            
            if view_choice == '2':
                type_ = 'income'
            elif view_choice == '3':
                type_ = 'expense'
            elif view_choice == '4':
                start_date = input("Введите начальную дату (ГГГГ-ММ-ДД): ")
                end_date = input("Введите конечную дату (ГГГГ-ММ-ДД): ")
            
            transactions = expense_tracker.get_transactions(start_date, end_date, type_=type_)
            
            if not transactions:
                print("Транзакции не найдены.")
                continue
            
            print("\n=== Список транзакций ===")
            print(f"{'ID':<5} | {'Дата':<10} | {'Сумма':<10} | {'Категория':<15} | Описание")
            print("-" * 80)
            
            for t in transactions:
                # Форматирование суммы с учетом типа транзакции
                if t['type'] == 'income':
                    amount_str = f"+{format_amount(t['amount'])}"
                else:
                    amount_str = f"{format_amount(t['amount'])}"
                
                print(f"{t['transaction_id']:<5} | {t['date']:<10} | {amount_str:<10} | "
                      f"{t['category_name']:<15} | {t['description']}")
        
        elif choice == '3':
            # Управление категориями
            print("\n=== Управление категориями ===")
            print("1. Просмотреть категории")
            print("2. Добавить категорию")
            
            cat_choice = input("\nВыберите опцию (1-2): ")
            
            if cat_choice == '1':
                print("\nСписок категорий:")
                print("Доходы:")
                for cat in expense_tracker.get_categories(type_='income'):
                    print(f"  {cat['category_id']}. {cat['name']}")
                
                print("\nРасходы:")
                for cat in expense_tracker.get_categories(type_='expense'):
                    print(f"  {cat['category_id']}. {cat['name']}")
            
            elif cat_choice == '2':
                name = input("Введите название категории: ")
                type_choice = input("Выберите тип (1-Доход, 2-Расход): ")
                
                if type_choice == '1':
                    cat_type = 'income'
                elif type_choice == '2':
                    cat_type = 'expense'
                else:
                    print("Неверный выбор.")
                    continue
                
                expense_tracker.add_category(name, cat_type)
        
        elif choice == '4':
            # Управление бюджетами
            print("\n=== Управление бюджетами ===")
            print("1. Просмотреть бюджеты")
            print("2. Создать бюджет")
            print("3. Просмотреть статус бюджета")
            
            budget_choice = input("\nВыберите опцию (1-3): ")
            
            if budget_choice == '1':
                budgets = expense_tracker.get_budgets()
                
                if not budgets:
                    print("Активные бюджеты не найдены.")
                    continue
                
                print("\nАктивные бюджеты:")
                print(f"{'ID':<5} | {'Категория':<15} | {'Сумма':<10} | {'Начало':<10} | {'Конец':<10} | Период")
                print("-" * 80)
                
                for b in budgets:
                    period_str = "Месячный" if b['period'] == 'monthly' else "Годовой"
                    print(f"{b['budget_id']:<5} | {b['category_name']:<15} | "
                          f"{format_amount(b['amount']):<10} | {b['start_date']:<10} | "
                          f"{b['end_date']:<10} | {period_str}")
            
            elif budget_choice == '2':
                # Отображение категорий расходов
                print("\nДоступные категории расходов:")
                categories = expense_tracker.get_categories(type_='expense')
                for cat in categories:
                    print(f"{cat['category_id']}. {cat['name']}")
                
                try:
                    category_id = int(input("\nВведите ID категории: "))
                    amount = input("Введите сумму бюджета: ")
                    period = input("Выберите период (1-Месяц, 2-Год): ")
                    
                    if period == '1':
                        period_str = 'monthly'
                    elif period == '2':
                        period_str = 'yearly'
                    else:
                        print("Неверный выбор периода.")
                        continue
                    
                    start_date = input("Введите дату начала (ГГГГ-ММ-ДД, пусто - текущий месяц): ")
                    if not start_date:
                        start_date = None
                    
                    expense_tracker.create_budget(category_id, amount, period_str, start_date)
                
                except ValueError:
                    print("Ошибка: Неверный формат данных.")
            
            elif budget_choice == '3':
                try:
                    budget_id = int(input("Введите ID бюджета: "))
                    status = expense_tracker.get_budget_status(budget_id)
                    
                    if status:
                        print(f"\nСтатус бюджета по категории '{status['category_name']}':")
                        print(f"Период: {status['start_date']} - {status['end_date']}")
                        print(f"Сумма бюджета: {format_amount(status['amount'])}")
                        print(f"Потрачено: {format_amount(status['spent'])}")
                        print(f"Осталось: {format_amount(status['remaining'])}")
                        print(f"Использовано: {status['percentage_used']:.1f}%")
                        
                        # Визуализация в консоли
                        progress = int(status['percentage_used'] / 5)  # 20 шагов для 100%
                        bar = '#' * progress + '-' * (20 - progress)
                        print(f"[{bar}] {status['percentage_used']:.1f}%")
                
                except ValueError:
                    print("Ошибка: Неверный формат ID бюджета.")
        
        elif choice == '5':
            # Аналитика
            print("\n=== Аналитика ===")
            print("1. Ежемесячный отчет")
            print("2. Годовой отчет")
            print("3. Расходы по категориям")
            print("4. Доходы по категориям")
            
            analytics_choice = input("\nВыберите опцию (1-4): ")
            
            if analytics_choice == '1':
                # Ежемесячный отчет
                year_str = input("Введите год (ГГГГ, пусто - текущий): ")
                month_str = input("Введите месяц (1-12, пусто - текущий): ")
                
                year = int(year_str) if year_str else None
                month = int(month_str) if month_str else None
                
                report = expense_tracker.get_monthly_summary(year, month)
                
                month_name = datetime.date(report['year'], report['month'], 1).strftime('%B')
                
                print(f"\n=== Отчет за {month_name} {report['year']} ===")
                print(f"Общий доход: {format_amount(report['total_income'])}")
                print(f"Общий расход: {format_amount(report['total_expense'])}")
                print(f"Баланс: {format_amount(report['balance'])}")
                
                print("\nДоходы по категориям:")
                for cat in report['income_by_category']:
                    print(f"  {cat['category_name']}: {format_amount(cat['amount'])}")
                
                print("\nРасходы по категориям:")
                for cat in report['expenses_by_category']:
                    print(f"  {cat['category_name']}: {format_amount(cat['amount'])}")
            
            elif analytics_choice == '2':
                # Годовой отчет
                year_str = input("Введите год (ГГГГ, пусто - текущий): ")
                year = int(year_str) if year_str else None
                
                report = expense_tracker.generate_annual_report(year)
                
                print(f"\n=== Годовой отчет за {report['year']} ===")
                print(f"Общий годовой доход: {format_amount(report['total_income'])}")
                print(f"Общий годовой расход: {format_amount(report['total_expense'])}")
                print(f"Годовой баланс: {format_amount(report['annual_balance'])}")
                
                print("\nДоходы по месяцам:")
                for monthly in report['monthly_data']:
                    month_name = datetime.date(monthly['year'], monthly['month'], 1).strftime('%B')
                    print(f"  {month_name}: {format_amount(monthly['total_income'])}")
                
                print("\nРасходы по месяцам:")
                for monthly in report['monthly_data']:
                    month_name = datetime.date(monthly['year'], monthly['month'], 1).strftime('%B')
                    print(f"  {month_name}: {format_amount(monthly['total_expense'])}")
                
                print("\nТоп-5 категорий доходов за год:")
                for i, cat in enumerate(report['income_by_category'][:5], 1):
                    print(f"  {i}. {cat['category_name']}: {format_amount(cat['total_amount'])}")
                
                print("\nТоп-5 категорий расходов за год:")
                for i, cat in enumerate(report['expenses_by_category'][:5], 1):
                    print(f"  {i}. {cat['category_name']}: {format_amount(cat['total_amount'])}")
            
            elif analytics_choice == '3':
                # Расходы по категориям за период
                start_date = input("Введите начальную дату (ГГГГ-ММ-ДД, пусто - начало года): ")
                end_date = input("Введите конечную дату (ГГГГ-ММ-ДД, пусто - сегодня): ")
                
                if not start_date:
                    start_date = f"{datetime.date.today().year}-01-01"
                
                if not end_date:
                    end_date = datetime.date.today().isoformat()
                
                expenses = expense_tracker.get_spending_by_category(start_date, end_date)
                
                if not expenses:
                    print("Расходы не найдены за указанный период.")
                    continue
                
                total = sum(cat['total_amount'] for cat in expenses)
                
                print(f"\n=== Расходы по категориям ({start_date} - {end_date}) ===")
                for cat in expenses:
                    percentage = (cat['total_amount'] / total) * 100 if total else 0
                    print(f"  {cat['category_name']}: {format_amount(cat['total_amount'])} "
                          f"({percentage:.1f}%)")
            
            elif analytics_choice == '4':
                # Доходы по категориям за период
                start_date = input("Введите начальную дату (ГГГГ-ММ-ДД, пусто - начало года): ")
                end_date = input("Введите конечную дату (ГГГГ-ММ-ДД, пусто - сегодня): ")
                
                if not start_date:
                    start_date = f"{datetime.date.today().year}-01-01"
                
                if not end_date:
                    end_date = datetime.date.today().isoformat()
                
                income = expense_tracker.get_income_by_category(start_date, end_date)
                
                if not income:
                    print("Доходы не найдены за указанный период.")
                    continue
                
                total = sum(cat['total_amount'] for cat in income)
                
                print(f"\n=== Доходы по категориям ({start_date} - {end_date}) ===")
                for cat in income:
                    percentage = (cat['total_amount'] / total) * 100 if total else 0
                    print(f"  {cat['category_name']}: {format_amount(cat['total_amount'])} "
                          f"({percentage:.1f}%)")
            
        else:
            print("Неверный выбор. Пожалуйста, выберите опцию от 0 до 5.")

if __name__ == '__main__':
    interactive_demo()
```

### Задание 2: Журнал чтения книг

Разработайте приложение для ведения журнала прочитанных книг, которое позволит:

1. Добавлять книги с информацией о названии, авторе, жанре, рейтинге и отзывом
2. Вести учет прогресса чтения (начало, конец, заметки по главам)
3. Отслеживать личную статистику (количество прочитанных книг, страниц, любимые жанры и т.д.)
4. Создавать списки книг для чтения и делиться рекомендациями

**Решение:**

```python
import sqlite3
import datetime
import os
import time
from collections import Counter

class BookJournal:
    def __init__(self, db_name='book_journal.db'):
        """Инициализация журнала чтения"""
        self.db_name = db_name
        self.create_database()
    
    def create_database(self):
        """Создание базы данных и необходимых таблиц"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            cursor.executescript('''
            -- Таблица авторов
            CREATE TABLE IF NOT EXISTS authors (
                author_id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                nationality TEXT,
                birth_year INTEGER
            );
            
            -- Таблица жанров
            CREATE TABLE IF NOT EXISTS genres (
                genre_id INTEGER PRIMARY KEY,
                name TEXT UNIQUE NOT NULL
            );
            
            -- Таблица книг
            CREATE TABLE IF NOT EXISTS books (
                book_id INTEGER PRIMARY KEY,
                title TEXT NOT NULL,
                author_id INTEGER,
                year_published INTEGER,
                genre_id INTEGER,
                total_pages INTEGER,
                isbn TEXT UNIQUE,
                FOREIGN KEY (author_id) REFERENCES authors (author_id),
                FOREIGN KEY (genre_id) REFERENCES genres (genre_id)
            );
            
            -- Таблица статусов чтения
            CREATE TABLE IF NOT EXISTS reading_statuses (
                status_id INTEGER PRIMARY KEY,
                name TEXT UNIQUE NOT NULL
            );
            
            -- Таблица записей о чтении
            CREATE TABLE IF NOT EXISTS reading_entries (
                entry_id INTEGER PRIMARY KEY,
                book_id INTEGER NOT NULL,
                status_id INTEGER NOT NULL,
                start_date TEXT,
                finish_date TEXT,
                rating INTEGER CHECK (rating BETWEEN 1 AND 5 OR rating IS NULL),
                review TEXT,
                FOREIGN KEY (book_id) REFERENCES books (book_id),
                FOREIGN KEY (status_id) REFERENCES reading_statuses (status_id)
            );
            
            -- Таблица прогресса чтения
            CREATE TABLE IF NOT EXISTS reading_progress (
                progress_id INTEGER PRIMARY KEY,
                entry_id INTEGER NOT NULL,
                date TEXT NOT NULL,
                pages_read INTEGER NOT NULL,
                current_page INTEGER NOT NULL,
                notes TEXT,
                FOREIGN KEY (entry_id) REFERENCES reading_entries (entry_id)
            );
            
            -- Таблица списков для чтения
            CREATE TABLE IF NOT EXISTS reading_lists (
                list_id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                created_date TEXT NOT NULL
            );
            
            -- Таблица элементов списка для чтения
            CREATE TABLE IF NOT EXISTS reading_list_items (
                item_id INTEGER PRIMARY KEY,
                list_id INTEGER NOT NULL,
                book_id INTEGER NOT NULL,
                added_date TEXT NOT NULL,
                notes TEXT,
                FOREIGN KEY (list_id) REFERENCES reading_lists (list_id),
                FOREIGN KEY (book_id) REFERENCES books (book_id),
                UNIQUE(list_id, book_id)
            );
            ''')
            
            # Добавление предопределенных статусов чтения
            cursor.executescript('''
            INSERT OR IGNORE INTO reading_statuses (name) VALUES ('Хочу прочитать');
            INSERT OR IGNORE INTO reading_statuses (name) VALUES ('Читаю');
            INSERT OR IGNORE INTO reading_statuses (name) VALUES ('Прочитано');
            INSERT OR IGNORE INTO reading_statuses (name) VALUES ('Отложено');
            INSERT OR IGNORE INTO reading_statuses (name) VALUES ('Заброшено');
            ''')
            
            # Добавление основных жанров
            basic_genres = [
                'Фантастика', 'Фэнтези', 'Детектив', 'Триллер', 'Романтика',
                'Приключения', 'Исторический роман', 'Научно-популярная', 'Биография',
                'Классическая литература', 'Драма', 'Ужасы', 'Поэзия', 'Комедия',
                'Философия', 'Бизнес', 'Самопомощь', 'Детская литература'
            ]
            
            for genre in basic_genres:
                cursor.execute('INSERT OR IGNORE INTO genres (name) VALUES (?)', (genre,))
            
            conn.commit()
    
    def add_author(self, name, nationality=None, birth_year=None):
        """Добавление нового автора"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверка, существует ли автор с таким именем
            cursor.execute('SELECT author_id FROM authors WHERE name = ?', (name,))
            existing_author = cursor.fetchone()
            
            if existing_author:
                print(f"Автор '{name}' уже существует с ID {existing_author[0]}")
                return existing_author[0]
            
            # Добавление нового автора
            cursor.execute('''
            INSERT INTO authors (name, nationality, birth_year) VALUES (?, ?, ?)
            ''', (name, nationality, birth_year))
            
            author_id = cursor.lastrowid
            print(f"Автор '{name}' добавлен с ID {author_id}")
            return author_id
    
    def add_genre(self, name):
        """Добавление нового жанра"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            try:
                cursor.execute('INSERT INTO genres (name) VALUES (?)', (name,))
                genre_id = cursor.lastrowid
                print(f"Жанр '{name}' добавлен с ID {genre_id}")
                return genre_id
            except sqlite3.IntegrityError:
                cursor.execute('SELECT genre_id FROM genres WHERE name = ?', (name,))
                existing_genre = cursor.fetchone()
                print(f"Жанр '{name}' уже существует с ID {existing_genre[0]}")
                return existing_genre[0]
    
    def add_book(self, title, author_id=None, year_published=None, genre_id=None, 
                total_pages=None, isbn=None, author_name=None):
        """
        Добавление новой книги
        
        Можно указать либо author_id, либо author_name. Если указан author_name, 
        и такого автора нет, он будет создан
        """
        # Проверка наличия автора
        if author_id is None and author_name:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT author_id FROM authors WHERE name = ?', (author_name,))
                result = cursor.fetchone()
                
                if result:
                    author_id = result[0]
                else:
                    author_id = self.add_author(author_name)
        
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверка, существует ли книга с таким ISBN
            if isbn:
                cursor.execute('SELECT book_id FROM books WHERE isbn = ?', (isbn,))
                existing_book = cursor.fetchone()
                
                if existing_book:
                    print(f"Книга с ISBN {isbn} уже существует с ID {existing_book[0]}")
                    return existing_book[0]
            
            # Добавление книги
            cursor.execute('''
            INSERT INTO books (title, author_id, year_published, genre_id, total_pages, isbn)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (title, author_id, year_published, genre_id, total_pages, isbn))
            
            book_id = cursor.lastrowid
            print(f"Книга '{title}' добавлена с ID {book_id}")
            return book_id
    
    def get_status_id(self, status_name):
        """Получение ID статуса по имени"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT status_id FROM reading_statuses WHERE name = ?', (status_name,))
            result = cursor.fetchone()
            
            if result:
                return result[0]
            else:
                print(f"Статус '{status_name}' не найден")
                return None
    
    def add_to_reading_list(self, title, book_id=None, author_name=None, notes=None):
        """Добавление книги в список 'Хочу прочитать'"""
        # Получение ID статуса "Хочу прочитать"
        status_id = self.get_status_id("Хочу прочитать")
        if not status_id:
            return None
        
        # Если book_id не указан, ищем или создаем книгу
        if book_id is None:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()
                
                # Ищем книгу по названию и автору
                if author_name:
                    cursor.execute('''
                    SELECT b.book_id FROM books b
                    JOIN authors a ON b.author_id = a.author_id
                    WHERE b.title = ? AND a.name = ?
                    ''', (title, author_name))
                else:
                    cursor.execute('SELECT book_id FROM books WHERE title = ?', (title,))
                
                result = cursor.fetchone()
                
                if result:
                    book_id = result[0]
                else:
                    # Добавляем новую книгу
                    book_id = self.add_book(title, author_name=author_name)
        
        # Добавляем запись о чтении со статусом "Хочу прочитать"
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверяем, существует ли уже запись для этой книги
            cursor.execute('''
            SELECT entry_id FROM reading_entries WHERE book_id = ?
            ''', (book_id,))
            
            existing_entry = cursor.fetchone()
            
            if existing_entry:
                # Обновляем существующую запись
                cursor.execute('''
                UPDATE reading_entries SET status_id = ?, review = ?
                WHERE entry_id = ?
                ''', (status_id, notes, existing_entry[0]))
                
                print(f"Книга с ID {book_id} обновлена в списке чтения")
                return existing_entry[0]
            else:
                # Создаем новую запись
                current_date = datetime.date.today().isoformat()
                
                cursor.execute('''
                INSERT INTO reading_entries (book_id, status_id, start_date, review)
                VALUES (?, ?, ?, ?)
                ''', (book_id, status_id, current_date, notes))
                
                entry_id = cursor.lastrowid
                print(f"Книга с ID {book_id} добавлена в список 'Хочу прочитать'")
                return entry_id
    
    def start_reading(self, book_id, start_date=None):
        """Отметка о начале чтения книги"""
        # Получение ID статуса "Читаю"
        status_id = self.get_status_id("Читаю")
        if not status_id:
            return None
        
        if start_date is None:
            start_date = datetime.date.today().isoformat()
        
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверяем, существует ли уже запись для этой книги
            cursor.execute('''
            SELECT entry_id, status_id FROM reading_entries WHERE book_id = ?
            ''', (book_id,))
            
            existing_entry = cursor.fetchone()
            
            if existing_entry:
                entry_id, current_status = existing_entry
                
                # Если книга уже в статусе "Прочитано", спрашиваем, хочет ли пользователь перечитать
                if current_status == self.get_status_id("Прочитано"):
                    print("Эта книга уже отмечена как прочитанная.")
                    return None
                
                # Обновляем статус и дату начала
                cursor.execute('''
                UPDATE reading_entries 
                SET status_id = ?, start_date = ?
                WHERE entry_id = ?
                ''', (status_id, start_date, entry_id))
                
                print(f"Начато чтение книги с ID {book_id}")
                return entry_id
            else:
                # Создаем новую запись
                cursor.execute('''
                INSERT INTO reading_entries (book_id, status_id, start_date)
                VALUES (?, ?, ?)
                ''', (book_id, status_id, start_date))
                
                entry_id = cursor.lastrowid
                print(f"Начато чтение книги с ID {book_id}")
                return entry_id
    
    def update_reading_progress(self, book_id, current_page, pages_read=None, notes=None):
        """Обновление прогресса чтения книги"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Получаем запись о чтении и информацию о книге
            cursor.execute('''
            SELECT e.entry_id, b.total_pages 
            FROM reading_entries e
            JOIN books b ON e.book_id = b.book_id
            WHERE e.book_id = ? AND e.status_id = ?
            ''', (book_id, self.get_status_id("Читаю")))
            
            result = cursor.fetchone()
            
            if not result:
                print(f"Книга с ID {book_id} не числится как читаемая в данный момент")
                return None
            
            entry_id, total_pages = result
            
            # Проверка корректности current_page
            if total_pages and current_page > total_pages:
                print(f"Ошибка: текущая страница ({current_page}) превышает общее количество страниц ({total_pages})")
                return None
            
            # Если pages_read не указано, вычисляем на основе предыдущего прогресса
            if pages_read is None:
                cursor.execute('''
                SELECT current_page FROM reading_progress 
                WHERE entry_id = ? 
                ORDER BY date DESC, progress_id DESC 
                LIMIT 1
                ''', (entry_id,))
                
                prev_result = cursor.fetchone()
                
                if prev_result:
                    prev_page = prev_result[0]
                    pages_read = current_page - prev_page
                else:
                    pages_read = current_page
            
            # Добавляем запись о прогрессе
            current_date = datetime.date.today().isoformat()
            
            cursor.execute('''
            INSERT INTO reading_progress (entry_id, date, pages_read, current_page, notes)
            VALUES (?, ?, ?, ?, ?)
            ''', (entry_id, current_date, pages_read, current_page, notes))
            
            # Если достигнут конец книги, предлагаем отметить как прочитанную
            if total_pages and current_page >= total_pages:
                print("Вы достигли конца книги. Хотите отметить ее как прочитанную? (Y/N)")
                response = input().strip().lower()
                
                if response == 'y' or response == 'yes':
                    self.finish_reading(book_id)
            
            print(f"Прогресс чтения обновлен: {current_page} страниц прочитано")
            return cursor.lastrowid
    
    def finish_reading(self, book_id, finish_date=None, rating=None, review=None):
        """Отметка о завершении чтения книги с рейтингом и отзывом"""
        # Получение ID статуса "Прочитано"
        status_id = self.get_status_id("Прочитано")
        if not status_id:
            return None
        
        if finish_date is None:
            finish_date = datetime.date.today().isoformat()
        
        # Проверка рейтинга
        if rating is not None and (rating < 1 or rating > 5):
            print("Ошибка: рейтинг должен быть от 1 до 5")
            return None
        
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверяем, существует ли запись для этой книги
            cursor.execute('''
            SELECT entry_id FROM reading_entries WHERE book_id = ?
            ''', (book_id,))
            
            result = cursor.fetchone()
            
            if result:
                entry_id = result[0]
                
                # Обновляем статус, дату завершения, рейтинг и отзыв
                cursor.execute('''
                UPDATE reading_entries 
                SET status_id = ?, finish_date = ?, rating = ?, review = ?
                WHERE entry_id = ?
                ''', (status_id, finish_date, rating, review, entry_id))
                
                print(f"Книга с ID {book_id} отмечена как прочитанная")
                return entry_id
            else:
                # Создаем новую запись
                cursor.execute('''
                INSERT INTO reading_entries (book_id, status_id, finish_date, rating, review)
                VALUES (?, ?, ?, ?, ?)
                ''', (book_id, status_id, finish_date, rating, review))
                
                entry_id = cursor.lastrowid
                print(f"Книга с ID {book_id} отмечена как прочитанная")
                return entry_id
    
    def create_reading_list(self, name, description=None):
        """Создание нового списка для чтения"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            # Проверка, существует ли список с таким именем
            cursor.execute('SELECT list_id FROM reading_lists WHERE name = ?', (name,))
            existing_list = cursor.fetchone()
            
            if existing_list:
                print(f"Список '{name}' уже существует с ID {existing_list[0]}")
                return existing_list[0]
            
            # Создание нового списка
            current_date = datetime.date.today().isoformat()
            
            cursor.execute('''
            INSERT INTO reading_lists (name, description, created_date)
            VALUES (?, ?, ?)
            ''', (name, description, current_date))
            
            list_id = cursor.lastrowid
            print(f"Список '{name}' создан с ID {list_id}")
            return list_id
    
    def add_book_to_list(self, list_id, book_id, notes=None):
        """Добавление книги в список для чтения"""
        with sqlite3.connect(self.db_name) as conn:
            cursor = conn.cursor()
            
            try:
                # Добавление книги в список
                current_date = datetime.date.today().isoformat()
                
                cursor.execute('''
                INSERT INTO reading_list_items (list_id, book_id, added_date, notes)
                VALUES (?, ?, ?, ?)
                ''', (list_id, book_id, current_date, notes))
                
                item_id = cursor.lastrowid
                print(f"Книга с ID {book_id} добавлена в список с ID {list_id}")
                return item_id
            
            except sqlite3.IntegrityError:
                print(f"Книга с ID {book_id} уже есть в списке с ID {list_id}")
                
                # Обновление заметок, если они предоставлены
                if notes:
                    cursor.execute('''
                    UPDATE reading_list_items SET notes = ?
                    WHERE list_id = ? AND book_id = ?
                    ''', (notes, list_id, book_id))
                    
                    print("Заметки обновлены")
                
                # Получение ID элемента
                cursor.execute('''
                SELECT item_id FROM reading_list_items 
                WHERE list_id = ? AND book_id = ?
                ''', (list_id, book_id))
                
                return cursor.fetchone()[0]
    
    def get_books(self, status=None, author_id=None, genre_id=None):
        """Получение списка книг с возможностью фильтрации"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = '''
            SELECT b.book_id, b.title, b.year_published, b.total_pages, b.isbn,
                   a.author_id, a.name as author_name,
                   g.genre_id, g.name as genre_name,
                   rs.status_id, rs.name as status_name,
                   re.start_date, re.finish_date, re.rating, re.review
            FROM books b
            LEFT JOIN authors a ON b.author_id = a.author_id
            LEFT JOIN genres g ON b.genre_id = g.genre_id
            LEFT JOIN reading_entries re ON b.book_id = re.book_id
            LEFT JOIN reading_statuses rs ON re.status_id = rs.status_id
            WHERE 1=1
            '''
            
            params = []
            
            if status:
                query += ' AND rs.name = ?'
                params.append(status)
            
            if author_id:
                query += ' AND a.author_id = ?'
                params.append(author_id)
            
            if genre_id:
                query += ' AND g.genre_id = ?'
                params.append(genre_id)
            
            query += ' ORDER BY b.title'
            
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def get_reading_progress(self, book_id):
        """Получение прогресса чтения для конкретной книги"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT rp.progress_id, rp.date, rp.pages_read, rp.current_page, rp.notes,
                   b.total_pages
            FROM reading_progress rp
            JOIN reading_entries re ON rp.entry_id = re.entry_id
            JOIN books b ON re.book_id = b.book_id
            WHERE re.book_id = ?
            ORDER BY rp.date, rp.progress_id
            ''', (book_id,))
            
            progress = cursor.fetchall()
            
            # Получаем информацию о книге
            cursor.execute('''
            SELECT b.title, a.name as author_name, b.total_pages,
                   re.start_date, re.finish_date
            FROM books b
            LEFT JOIN authors a ON b.author_id = a.author_id
            LEFT JOIN reading_entries re ON b.book_id = re.book_id
            WHERE b.book_id = ?
            ''', (book_id,))
            
            book_info = cursor.fetchone()
            
            return {
                'book_info': book_info,
                'progress': progress
            }
    
    def get_reading_lists(self):
        """Получение списков для чтения"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT rl.list_id, rl.name, rl.description, rl.created_date,
                   COUNT(rli.item_id) as book_count
            FROM reading_lists rl
            LEFT JOIN reading_list_items rli ON rl.list_id = rli.list_id
            GROUP BY rl.list_id
            ORDER BY rl.name
            ''')
            
            return cursor.fetchall()
    
    def get_books_in_list(self, list_id):
        """Получение книг в списке для чтения"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT rli.item_id, rli.added_date, rli.notes,
                   b.book_id, b.title, b.year_published,
                   a.name as author_name,
                   g.name as genre_name,
                   rs.name as status_name
            FROM reading_list_items rli
            JOIN books b ON rli.book_id = b.book_id
            LEFT JOIN authors a ON b.author_id = a.author_id
            LEFT JOIN genres g ON b.genre_id = g.genre_id
            LEFT JOIN reading_entries re ON b.book_id = re.book_id
            LEFT JOIN reading_statuses rs ON re.status_id = rs.status_id
            WHERE rli.list_id = ?
            ORDER BY rli.added_date DESC
            ''', (list_id,))
            
            books = cursor.fetchall()
            
            # Получаем информацию о списке
            cursor.execute('''
            SELECT list_id, name, description, created_date
            FROM reading_lists
            WHERE list_id = ?
            ''', (list_id,))
            
            list_info = cursor.fetchone()
            
            return {
                'list_info': list_info,
                'books': books
            }
    
    def search_books(self, query):
        """Поиск книг по названию или автору"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT b.book_id, b.title, b.year_published,
                   a.name as author_name,
                   g.name as genre_name,
                   rs.name as status_name
            FROM books b
            LEFT JOIN authors a ON b.author_id = a.author_id
            LEFT JOIN genres g ON b.genre_id = g.genre_id
            LEFT JOIN reading_entries re ON b.book_id = re.book_id
            LEFT JOIN reading_statuses rs ON re.status_id = rs.status_id
            WHERE b.title LIKE ? OR a.name LIKE ?
            ORDER BY b.title
            ''', (f'%{query}%', f'%{query}%'))
            
            return cursor.fetchall()
    
    def get_statistics(self):
        """Получение статистики чтения"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            stats = {}
            
            # Общее количество книг
            cursor.execute('SELECT COUNT(*) FROM books')
            stats['total_books'] = cursor.fetchone()[0]
            
            # Количество прочитанных книг
            cursor.execute('''
            SELECT COUNT(*) FROM reading_entries
            WHERE status_id = ?
            ''', (self.get_status_id("Прочитано"),))
            stats['books_read'] = cursor.fetchone()[0]
            
            # Количество читаемых книг
            cursor.execute('''
            SELECT COUNT(*) FROM reading_entries
            WHERE status_id = ?
            ''', (self.get_status_id("Читаю"),))
            stats['books_reading'] = cursor.fetchone()[0]
            
            # Количество книг в списке "Хочу прочитать"
            cursor.execute('''
            SELECT COUNT(*) FROM reading_entries
            WHERE status_id = ?
            ''', (self.get_status_id("Хочу прочитать"),))
            stats['books_to_read'] = cursor.fetchone()[0]
            
            # Общее количество прочитанных страниц
            cursor.execute('''
            SELECT SUM(rp.pages_read) FROM reading_progress rp
            JOIN reading_entries re ON rp.entry_id = re.entry_id
            ''')
            stats['total_pages_read'] = cursor.fetchone()[0] or 0
            
            # Среднее количество страниц в день
            cursor.execute('''
            SELECT date, SUM(pages_read) as pages
            FROM reading_progress
            GROUP BY date
            ''')
            daily_pages = [row['pages'] for row in cursor.fetchall()]
            stats['avg_pages_per_day'] = sum(daily_pages) / len(daily_pages) if daily_pages else 0
            
            # Средний рейтинг книг
            cursor.execute('''
            SELECT AVG(rating) FROM reading_entries
            WHERE rating IS NOT NULL
            ''')
            stats['avg_rating'] = cursor.fetchone()[0] or 0
            
            # Любимые жанры (на основе рейтинга)
            cursor.execute('''
            SELECT g.name as genre_name, AVG(re.rating) as avg_rating, COUNT(*) as book_count
            FROM reading_entries re
            JOIN books b ON re.book_id = b.book_id
            JOIN genres g ON b.genre_id = g.genre_id
            WHERE re.rating IS NOT NULL
            GROUP BY g.genre_id
            ORDER BY avg_rating DESC, book_count DESC
            LIMIT 5
            ''')
            stats['favorite_genres'] = cursor.fetchall()
            
            # Самые активные периоды чтения
            cursor.execute('''
            SELECT strftime('%Y-%m', date) as month, SUM(pages_read) as pages
            FROM reading_progress
            GROUP BY month
            ORDER BY pages DESC
            LIMIT 5
            ''')
            stats['best_reading_months'] = cursor.fetchall()
            
            return stats
    
    def get_recommendations(self, limit=5):
        """Получение рекомендаций на основе рейтингов и жанров"""
        with sqlite3.connect(self.db_name) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Находим любимые жанры на основе высоких рейтингов
            cursor.execute('''
            SELECT g.genre_id, g.name as genre_name, AVG(re.rating) as avg_rating
            FROM reading_entries re
            JOIN books b ON re.book_id = b.book_id
            JOIN genres g ON b.genre_id = g.genre_id
            WHERE re.rating >= 4
            GROUP BY g.genre_id
            ORDER BY avg_rating DESC
            LIMIT 3
            ''')
            
            favorite_genres = cursor.fetchall()
            
            # Если нет любимых жанров (нет рейтингов), предлагаем популярные книги
            if not favorite_genres:
                cursor.execute('''
                SELECT b.book_id, b.title, a.name as author_name, g.name as genre_name
                FROM books b
                LEFT JOIN authors a ON b.author_id = a.author_id
                LEFT JOIN genres g ON b.genre_id = g.genre_id
                LEFT JOIN reading_entries re ON b.book_id = re.book_id
                WHERE re.entry_id IS NULL OR re.status_id != ?
                ORDER BY b.year_published DESC
                LIMIT ?
                ''', (self.get_status_id("Прочитано"), limit))
                
                return {
                    'type': 'popular',
                    'books': cursor.fetchall()
                }
            
            # Ищем книги из любимых жанров, которые еще не прочитаны
            genre_ids = [g['genre_id'] for g in favorite_genres]
            placeholders = ', '.join(['?'] * len(genre_ids))
            
            query = f'''
            SELECT b.book_id, b.title, a.name as author_name, g.name as genre_name
            FROM books b
            LEFT JOIN authors a ON b.author_id = a.author_id
            LEFT JOIN genres g ON b.genre_id = g.genre_id
            LEFT JOIN reading_entries re ON b.book_id = re.book_id
            WHERE b.genre_id IN ({placeholders})
            AND (re.entry_id IS NULL OR re.status_id != ?)
            ORDER BY RANDOM()
            LIMIT ?
            '''
            
            params = genre_ids + [self.get_status_id("Прочитано"), limit]
            cursor.execute(query, params)
            
            return {
                'type': 'genre_based',
                'favorite_genres': favorite_genres,
                'books': cursor.fetchall()
            }

# Вспомогательные функции для интерактивного интерфейса

def display_book_details(book):
    """Отображение подробной информации о книге"""
    print("\n=== Информация о книге ===")
    print(f"Название: {book['title']}")
    print(f"Автор: {book['author_name'] if book['author_name'] else 'Не указан'}")
    print(f"Жанр: {book['genre_name'] if book['genre_name'] else 'Не указан'}")
    print(f"Год публикации: {book['year_published'] if book['year_published'] else 'Не указан'}")
    
    if book['total_pages']:
        print(f"Количество страниц: {book['total_pages']}")
    
    if book['isbn']:
        print(f"ISBN: {book['isbn']}")
    
    print(f"Статус: {book['status_name'] if book['status_name'] else 'Не указан'}")
    
    if book['start_date']:
        print(f"Дата начала чтения: {book['start_date']}")
    
    if book['finish_date']:
        print(f"Дата завершения: {book['finish_date']}")
    
    if book['rating']:
        print(f"Рейтинг: {'★' * book['rating']}")
    
    if book['review']:
        print("\nОтзыв:")
        print(book['review'])

def display_reading_progress(progress_data):
    """Отображение прогресса чтения книги"""
    book_info = progress_data['book_info']
    progress = progress_data['progress']
    
    print("\n=== Прогресс чтения ===")
    print(f"Книга: {book_info['title']}")
    print(f"Автор: {book_info['author_name']}")
    
    if book_info['total_pages']:
        print(f"Общее количество страниц: {book_info['total_pages']}")
    
    if book_info['start_date']:
        print(f"Начало чтения: {book_info['start_date']}")
    
    if book_info['finish_date']:
        print(f"Завершение чтения: {book_info['finish_date']}")
    
    if not progress:
        print("\nНет записей о прогрессе чтения")
        return
    
    print("\nДата         | Прочитано | Текущая страница | Примечания")
    print("-" * 70)
    
    total_read = 0
    last_page = 0
    
    for entry in progress:
        total_read += entry['pages_read']
        last_page = entry['current_page']
        
        notes = entry['notes'] or ''
        if len(notes) > 30:
            notes = notes[:27] + '...'
        
        print(f"{entry['date']} | {entry['pages_read']:9} | {entry['current_page']:16} | {notes}")
    
    # Общий прогресс
    if book_info['total_pages']:
        percentage = (last_page / book_info['total_pages']) * 100
        print(f"\nОбщий прогресс: {last_page} из {book_info['total_pages']} страниц ({percentage:.1f}%)")
        
        # Визуализация прогресса
        progress_bar_length = 50
        filled_length = int(progress_bar_length * percentage / 100)
        bar = '█' * filled_length + '░' * (progress_bar_length - filled_length)
        print(f"[{bar}]")
    
    print(f"\nВсего прочитано страниц: {total_read}")
    
    # Расчет средней скорости чтения
    if len(progress) > 1:
        first_date = datetime.date.fromisoformat(progress[0]['date'])
        last_date = datetime.date.fromisoformat(progress[-1]['date'])
        days = (last_date - first_date).days
        
        if days > 0:
            avg_pages_per_day = total_read / (days + 1)  # +1 чтобы включить первый день
            print(f"Средняя скорость чтения: {avg_pages_per_day:.1f} страниц в день")
            
            # Оценка времени до завершения
            if book_info['total_pages'] and last_page < book_info['total_pages']:
                remaining_pages = book_info['total_pages'] - last_page
                days_to_finish = remaining_pages / avg_pages_per_day
                finish_date = datetime.date.today() + datetime.timedelta(days=days_to_finish)
                print(f"Ожидаемая дата завершения: {finish_date.isoformat()} "
                      f"(через {days_to_finish:.1f} дней)")

def display_statistics(stats):
    """Отображение статистики чтения"""
    print("\n=== Статистика чтения ===")
    print(f"Всего книг в библиотеке: {stats['total_books']}")
    print(f"Прочитано книг: {stats['books_read']}")
    print(f"Читаю сейчас: {stats['books_reading']}")
    print(f"Хочу прочитать: {stats['books_to_read']}")
    print(f"Всего прочитано страниц: {stats['total_pages_read']}")
    
    if stats['avg_pages_per_day'] > 0:
        print(f"Средняя скорость чтения: {stats['avg_pages_per_day']:.1f} страниц в день")
    
    if stats['avg_rating'] > 0:
        print(f"Средний рейтинг книг: {stats['avg_rating']:.1f} из 5")
    
    if stats['favorite_genres']:
        print("\nЛюбимые жанры:")
        for genre in stats['favorite_genres']:
            print(f"  - {genre['genre_name']}: {genre['avg_rating']:.1f} звезд "
                  f"({genre['book_count']} книг)")
    
    if stats['best_reading_months']:
        print("\nСамые продуктивные месяцы:")
        for month in stats['best_reading_months']:
            print(f"  - {month['month']}: {month['pages']} страниц")

def interactive_demo():
    """Интерактивный демонстрационный режим для журнала чтения"""
    journal = BookJournal()
    
    print("=== Журнал чтения книг ===")
    
    # Добавление тестовых данных
    def add_sample_data():
        # Добавление авторов
        tolstoy_id = journal.add_author("Лев Толстой", "Россия", 1828)
        dostoevsky_id = journal.add_author("Федор Достоевский", "Россия", 1821)
        rowling_id = journal.add_author("Дж. К. Роулинг", "Великобритания", 1965)
        martin_id = journal.add_author("Джордж Р. Р. Мартин", "США", 1948)
        
        # Добавление жанров (основные жанры уже добавлены при создании БД)
        classics_id = journal.add_genre("Классическая литература")
        fantasy_id = journal.add_genre("Фэнтези")
        
        # Добавление книг
        war_peace_id = journal.add_book("Война и мир", tolstoy_id, 1869, classics_id, 1225, "978-5-389-15350-0")
        crime_id = journal.add_book("Преступление и наказание", dostoevsky_id, 1866, classics_id, 672, "978-5-17-078776-1")
        hp1_id = journal.add_book("Гарри Поттер и философский камень", rowling_id, 1997, fantasy_id, 332, "978-5-389-07780-7")
        hp2_id = journal.add_book("Гарри Поттер и Тайная комната", rowling_id, 1998, fantasy_id, 480, "978-5-389-07781-4")
        got1_id = journal.add_book("Игра престолов", martin_id, 1996, fantasy_id, 768, "978-5-17-114463-0")
        
        # Создание списков для чтения
        classics_list_id = journal.create_reading_list("Классика", "Классические произведения для чтения")
        fantasy_list_id = journal.create_reading_list("Фэнтези", "Фэнтези книги для чтения")
        
        # Добавление книг в списки
        journal.add_book_to_list(classics_list_id, war_peace_id, "Обязательно к прочтению")
        journal.add_book_to_list(classics_list_id, crime_id)
        journal.add_book_to_list(fantasy_list_id, hp1_id)
        journal.add_book_to_list(fantasy_list_id, hp2_id)
        journal.add_book_to_list(fantasy_list_id, got1_id, "Начать после сессии")
        
        # Отметки о чтении
        journal.start_reading(hp1_id, "2023-01-10")
        for i in range(1, 6):
            journal.update_reading_progress(hp1_id, i * 50, 50, f"Заметки к части {i}")
        journal.finish_reading(hp1_id, "2023-01-20", 5, "Отличная книга, открывающая волшебный мир!")
        
        journal.start_reading(got1_id, "2023-02-01")
        journal.update_reading_progress(got1_id, 100, 100, "Начало захватывающее")
        journal.update_reading_progress(got1_id, 250, 150, "Развитие сюжета интересное")
        
        journal.add_to_reading_list("Анна Каренина", author_name="Лев Толстой")
        
        print("Тестовые данные добавлены.")
    
    # Меню управления
    while True:
        print("\n=== Главное меню ===")
        print("1. Управление книгами")
        print("2. Управление чтением")
        print("3. Списки для чтения")
        print("4. Статистика и анализ")
        print("5. Рекомендации")
        print("6. Добавить тестовые данные")
        print("0. Выход")
        
        choice = input("\nВыберите действие (0-6): ")
        
        if choice == '0':
            print("Выход из программы...")
            break
        
        elif choice == '1':
            # Управление книгами
            print("\n=== Управление книгами ===")
            print("1. Показать все книги")
            print("2. Добавить книгу")
            print("3. Добавить автора")
            print("4. Добавить жанр")
            print("5. Поиск книг")
            print("0. Назад")
            
            book_choice = input("\nВыберите действие (0-5): ")
            
            if book_choice == '1':
                books = journal.get_books()
                
                if not books:
                    print("В библиотеке нет книг.")
                    continue
                
                print("\n=== Список книг ===")
                print(f"{'ID':<4} | {'Название':<30} | {'Автор':<20} | {'Жанр':<15} | {'Статус':<15}")
                print("-" * 90)
                
                for book in books:
                    title = book['title']
                    if len(title) > 27:
                        title = title[:24] + "..."
                    
                    author = book['author_name'] or "Не указан"
                    if len(author) > 17:
                        author = author[:14] + "..."
                    
                    genre = book['genre_name'] or "Не указан"
                    status = book['status_name'] or "Не указан"
                    
                    print(f"{book['book_id']:<4} | {title:<30} | {author:<20} | {genre:<15} | {status:<15}")
                
                # Опция просмотра деталей книги
                book_id = input("\nВведите ID книги для просмотра деталей (или 0 для возврата): ")
                if book_id.isdigit() and int(book_id) > 0:
                    for book in books:
                        if book['book_id'] == int(book_id):
                            display_book_details(book)
                            break
                    else:
                        print(f"Книга с ID {book_id} не найдена.")
            
            elif book_choice == '2':
                # Добавление книги
                title = input("Введите название книги: ")
                author_name = input("Введите имя автора: ")
                
                # Поиск автора или добавление нового
                with sqlite3.connect(journal.db_name) as conn:
                    conn.row_factory = sqlite3.Row
                    cursor = conn.cursor()
                    cursor.execute('SELECT author_id, name FROM authors WHERE name LIKE ?', 
                                 (f'%{author_name}%',))
                    authors = cursor.fetchall()
                
                author_id = None
                if authors:
                    print("\nНайдены похожие авторы:")
                    for i, author in enumerate(authors, 1):
                        print(f"{i}. {author['name']} (ID: {author['author_id']})")
                    
                    choice = input("\nВыберите автора или 0 для добавления нового: ")
                    if choice.isdigit() and 0 < int(choice) <= len(authors):
                        author_id = authors[int(choice) - 1]['author_id']
                    else:
                        nationality = input("Введите национальность автора (опционально): ")
                        birth_year = input("Введите год рождения автора (опционально): ")
                        birth_year = int(birth_year) if birth_year.isdigit() else None
                        author_id = journal.add_author(author_name, nationality, birth_year)
                else:
                    nationality = input("Введите национальность автора (опционально): ")
                    birth_year = input("Введите год рождения автора (опционально): ")
                    birth_year = int(birth_year) if birth_year.isdigit() else None
                    author_id = journal.add_author(author_name, nationality, birth_year)
                
                # Выбор жанра
                with sqlite3.connect(journal.db_name) as conn:
                    conn.row_factory = sqlite3.Row
                    cursor = conn.cursor()
                    cursor.execute('SELECT genre_id, name FROM genres ORDER BY name')
                    genres = cursor.fetchall()
                
                print("\nДоступные жанры:")
                for i, genre in enumerate(genres, 1):
                    print(f"{i}. {genre['name']}")
                
                choice = input("\nВыберите жанр или 0 для добавления нового: ")
                genre_id = None
                if choice.isdigit() and 0 < int(choice) <= len(genres):
                    genre_id = genres[int(choice) - 1]['genre_id']
                elif choice == '0':
                    genre_name = input("Введите название нового жанра: ")
                    genre_id = journal.add_genre(genre_name)
                
                # Дополнительная информация
                year = input("Введите год публикации (опционально): ")
                year = int(year) if year.isdigit() else None
                
                pages = input("Введите количество страниц (опционально): ")
                pages = int(pages) if pages.isdigit() else None
                
                isbn = input("Введите ISBN (опционально): ")
                isbn = isbn if isbn else None
                
                # Добавление книги
                book_id = journal.add_book(title, author_id, year, genre_id, pages, isbn)
                
                # Спрашиваем о статусе книги
                print("\nВыберите статус книги:")
                print("1. Хочу прочитать")
                print("2. Читаю сейчас")
                print("3. Уже прочитана")
                print("0. Без статуса")
                
                status_choice = input("\nВыберите опцию (0-3): ")
                
                if status_choice == '1':
                    notes = input("Добавьте заметки (опционально): ")
                    journal.add_to_reading_list(title, book_id, notes=notes)
                
                elif status_choice == '2':
                    start_date = input("Введите дату начала (ГГГГ-ММ-ДД, пусто - сегодня): ")
                    start_date = start_date if start_date else None
                    journal.start_reading(book_id, start_date)
                    
                    if pages:
                        current_page = input(f"Введите текущую страницу (1-{pages}): ")
                        if current_page.isdigit() and 1 <= int(current_page) <= pages:
                            notes = input("Добавьте заметки о прогрессе (опционально): ")
                            journal.update_reading_progress(book_id, int(current_page), notes=notes)
                
                elif status_choice == '3':
                    start_date = input("Введите дату начала (ГГГГ-ММ-ДД, опционально): ")
                    start_date = start_date if start_date else None
                    
                    finish_date = input("Введите дату завершения (ГГГГ-ММ-ДД, пусто - сегодня): ")
                    finish_date = finish_date if finish_date else None
                    
                    rating = input("Введите рейтинг (1-5, опционально): ")
                    rating = int(rating) if rating.isdigit() and 1 <= int(rating) <= 5 else None
                    
                    review = input("Напишите отзыв (опционально): ")
                    review = review if review else None
                    
                    journal.finish_reading(book_id, finish_date, rating, review)
            
            elif book_choice == '3':
                # Добавление автора
                name = input("Введите имя автора: ")
                nationality = input("Введите национальность (опционально): ")
                birth_year = input("Введите год рождения (опционально): ")
                birth_year = int(birth_year) if birth_year.isdigit() else None
                
                journal.add_author(name, nationality, birth_year)
            
            elif book_choice == '4':
                # Добавление жанра
                name = input("Введите название жанра: ")
                journal.add_genre(name)
            
            elif book_choice == '5':
                # Поиск книг
                query = input("Введите поисковый запрос: ")
                
                if not query:
                    print("Поисковый запрос не может быть пустым.")
                    continue
                
                books = journal.search_books(query)
                
                if not books:
                    print(f"Книги по запросу '{query}' не найдены.")
                    continue
                
                print(f"\nНайдено {len(books)} книг по запросу '{query}':")
                print(f"{'ID':<4} | {'Название':<30} | {'Автор':<20} | {'Жанр':<15} | {'Статус':<15}")
                print("-" * 90)
                
                for book in books:
                    title = book['title']
                    if len(title) > 27:
                        title = title[:24] + "..."
                    
                    author = book['author_name'] or "Не указан"
                    if len(author) > 17:
                        author = author[:14] + "..."
                    
                    genre = book['genre_name'] or "Не указан"
                    status = book['status_name'] or "Не указан"
                    
                    print(f"{book['book_id']:<4} | {title:<30} | {author:<20} | {genre:<15} | {status:<15}")
                
                # Опция просмотра деталей книги
                book_id = input("\nВведите ID книги для просмотра деталей (или 0 для возврата): ")
                if book_id.isdigit() and int(book_id) > 0:
                    for book in books:
                        if book['book_id'] == int(book_id):
                            display_book_details(book)
                            break
                    else:
                        print(f"Книга с ID {book_id} не найдена.")
        
        elif choice == '2':
            # Управление чтением
            print("\n=== Управление чтением ===")
            print("1. Показать читаемые книги")
            print("2. Начать чтение книги")
            print("3. Обновить прогресс чтения")
            print("4. Завершить чтение книги")
            print("5. Просмотреть прогресс чтения")
            print("0. Назад")
            
            reading_choice = input("\nВыберите действие (0-5): ")
            
            if reading_choice == '1':
                # Показать читаемые книги
                books = journal.get_books(status="Читаю")
                
                if not books:
                    print("Нет читаемых книг.")
                    continue
                
                print("\n=== Читаемые книги ===")
                print(f"{'ID':<4} | {'Название':<30} | {'Автор':<20} | {'Начато':<10}")
                print("-" * 70)
                
                for book in books:
                    title = book['title']
                    if len(title) > 27:
                        title = title[:24] + "..."
                    
                    author = book['author_name'] or "Не указан"
                    if len(author) > 17:
                        author = author[:14] + "..."
                    
                    start_date = book['start_date'] or "Не указано"
                    
                    print(f"{book['book_id']:<4} | {title:<30} | {author:<20} | {start_date:<10}")
            
            elif reading_choice == '2':
                # Начать чтение книги
                book_id = input("Введите ID книги для начала чтения: ")
                
                if not book_id.isdigit():
                    print("ID книги должен быть числом.")
                    continue
                
                start_date = input("Введите дату начала (ГГГГ-ММ-ДД, пусто - сегодня): ")
                start_date = start_date if start_date else None
                
                journal.start_reading(int(book_id), start_date)
            
            elif reading_choice == '3':
                # Обновить прогресс чтения
                books = journal.get_books(status="Читаю")
                
                if not books:
                    print("Нет читаемых книг.")
                    continue
                
                print("\n=== Читаемые книги ===")
                for i, book in enumerate(books, 1):
                    print(f"{i}. {book['title']} (ID: {book['book_id']})")
                
                choice = input("\nВыберите книгу или введите ID книги: ")
                
                book_id = None
                if choice.isdigit():
                    if 1 <= int(choice) <= len(books):
                        book_id = books[int(choice) - 1]['book_id']
                    else:
                        # Проверяем, есть ли книга с таким ID
                        for book in books:
                            if book['book_id'] == int(choice):
                                book_id = int(choice)
                                break
                
                if book_id is None:
                    print("Книга не найдена.")
                    continue
                
                # Определяем выбранную книгу
                selected_book = next((book for book in books if book['book_id'] == book_id), None)
                
                current_page = input("Введите текущую страницу: ")
                if not current_page.isdigit():
                    print("Страница должна быть числом.")
                    continue
                
                current_page = int(current_page)
                
                # Если известно общее количество страниц, проверяем корректность
                if selected_book['total_pages'] and current_page > selected_book['total_pages']:
                    print(f"Ошибка: в книге всего {selected_book['total_pages']} страниц.")
                    continue
                
                pages_read = input("Введите количество прочитанных страниц (пусто - рассчитать): ")
                pages_read = int(pages_read) if pages_read.isdigit() else None
                
                notes = input("Добавьте заметки (опционально): ")
                
                journal.update_reading_progress(book_id, current_page, pages_read, notes)
            
            elif reading_choice == '4':
                # Завершить чтение книги
                book_id = input("Введите ID книги для завершения чтения: ")
                
                if not book_id.isdigit():
                    print("ID книги должен быть числом.")
                    continue
                
                finish_date = input("Введите дату завершения (ГГГГ-ММ-ДД, пусто - сегодня): ")
                finish_date = finish_date if finish_date else None
                
                rating = input("Введите рейтинг (1-5): ")
                rating = int(rating) if rating.isdigit() and 1 <= int(rating) <= 5 else None
                
                review = input("Напишите отзыв (опционально): ")
                
                journal.finish_reading(int(book_id), finish_date, rating, review)
            
            elif reading_choice == '5':
                # Просмотреть прогресс чтения
                book_id = input("Введите ID книги для просмотра прогресса: ")
                
                if not book_id.isdigit():
                    print("ID книги должен быть числом.")
                    continue
                
                progress_data = journal.get_reading_progress(int(book_id))
                
                if not progress_data['book_info']:
                    print(f"Книга с ID {book_id} не найдена.")
                    continue
                
                display_reading_progress(progress_data)
        
        elif choice == '3':
            # Списки для чтения
            print("\n=== Списки для чтения ===")
            print("1. Показать все списки")
            print("2. Создать новый список")
            print("3. Добавить книгу в список")
            print("4. Показать список 'Хочу прочитать'")
            print("0. Назад")
            
            list_choice = input("\nВыберите действие (0-4): ")
            
            if list_choice == '1':
                # Показать все списки
                reading_lists = journal.get_reading_lists()
                
                if not reading_lists:
                    print("Нет списков для чтения.")
                    continue
                
                print("\n=== Списки для чтения ===")
                print(f"{'ID':<4} | {'Название':<20} | {'Книг':<5} | {'Создан':<10} | Описание")
                print("-" * 70)
                
                for lst in reading_lists:
                    description = lst['description'] or ""
                    if len(description) > 30:
                        description = description[:27] + "..."
                    
                    created = lst['created_date'].split('T')[0] if 'T' in lst['created_date'] else lst['created_date']
                    
                    print(f"{lst['list_id']:<4} | {lst['name']:<20} | {lst['book_count']:<5} | {created:<10} | {description}")
                
                # Опция просмотра содержимого списка
                list_id = input("\nВведите ID списка для просмотра содержимого (или 0 для возврата): ")
                if list_id.isdigit() and int(list_id) > 0:
                    list_data = journal.get_books_in_list(int(list_id))
                    
                    if not list_data['list_info']:
                        print(f"Список с ID {list_id} не найден.")
                        continue
                    
                    list_info = list_data['list_info']
                    books = list_data['books']
                    
                    print(f"\n=== Список: {list_info['name']} ===")
                    if list_info['description']:
                        print(f"Описание: {list_info['description']}")
                    print(f"Создан: {list_info['created_date']}")
                    print(f"Количество книг: {len(books)}")
                    
                    if not books:
                        print("\nСписок пуст.")
                        continue
                    
                    print("\n" + "=" * 80)
                    print(f"{'ID':<4} | {'Название':<30} | {'Автор':<20} | {'Статус':<15}")
                    print("-" * 80)
                    
                    for book in books:
                        title = book['title']
                        if len(title) > 27:
                            title = title[:24] + "..."
                        
                        author = book['author_name'] or "Не указан"
                        if len(author) > 17:
                            author = author[:14] + "..."
                        
                        status = book['status_name'] or "Не указан"
                        
                        print(f"{book['book_id']:<4} | {title:<30} | {author:<20} | {status:<15}")
                    
                    if any(book['notes'] for book in books):
                        print("\nЗаметки:")
                        for book in books:
                            if book['notes']:
                                print(f"- {book['title']}: {book['notes']}")
            
            elif list_choice == '2':
                # Создать новый список
                name = input("Введите название списка: ")
                description = input("Введите описание (опционально): ")
                
                journal.create_reading_list(name, description)
            
            elif list_choice == '3':
                # Добавить книгу в список
                # Выбор списка
                reading_lists = journal.get_reading_lists()
                
                if not reading_lists:
                    print("Нет списков для чтения. Создайте список сначала.")
                    continue
                
                print("\nДоступные списки:")
                for i, lst in enumerate(reading_lists, 1):
                    print(f"{i}. {lst['name']} (ID: {lst['list_id']})")
                
                list_choice = input("\nВыберите список или введите ID списка: ")
                
                list_id = None
                if list_choice.isdigit():
                    if 1 <= int(list_choice) <= len(reading_lists):
                        list_id = reading_lists[int(list_choice) - 1]['list_id']
                    else:
                        # Проверяем, есть ли список с таким ID
                        for lst in reading_lists:
                            if lst['list_id'] == int(list_choice):
                                list_id = int(list_choice)
                                break
                
                if list_id is None:
                    print("Список не найден.")
                    continue
                
                # Выбор книги
                book_id = input("Введите ID книги для добавления в список: ")
                
                if not book_id.isdigit():
                    print("ID книги должен быть числом.")
                    continue
                
                notes = input("Добавьте заметки (опционально): ")
                
                journal.add_book_to_list(list_id, int(book_id), notes)
            
            elif list_choice == '4':
                # Показать список "Хочу прочитать"
                books = journal.get_books(status="Хочу прочитать")
                
                if not books:
                    print("Список 'Хочу прочитать' пуст.")
                    continue
                
                print("\n=== Список 'Хочу прочитать' ===")
                print(f"{'ID':<4} | {'Название':<30} | {'Автор':<20} | {'Жанр':<15}")
                print("-" * 75)
                
                for book in books:
                    title = book['title']
                    if len(title) > 27:
                        title = title[:24] + "..."
                    
                    author = book['author_name'] or "Не указан"
                    if len(author) > 17:
                        author = author[:14] + "..."
                    
                    genre = book['genre_name'] or "Не указан"
                    
                    print(f"{book['book_id']:<4} | {title:<30} | {author:<20} | {genre:<15}")
                
                # Опции действий с книгами
                print("\nДействия:")
                print("1. Начать чтение книги из списка")
                print("0. Назад")
                
                action_choice = input("\nВыберите действие (0-1): ")
                
                if action_choice == '1':
                    book_id = input("Введите ID книги для начала чтения: ")
                    
                    if not book_id.isdigit():
                        print("ID книги должен быть числом.")
                        continue
                    
                    journal.start_reading(int(book_id))
        
        elif choice == '4':
            # Статистика и анализ
            stats = journal.get_statistics()
            display_statistics(stats)
        
        elif choice == '5':
            # Рекомендации
            recommendations = journal.get_recommendations()
            
            print("\n=== Рекомендации для чтения ===")
            
            if recommendations['type'] == 'genre_based':
                print("На основе ваших любимых жанров:")
                for genre in recommendations['favorite_genres']:
                    print(f"- {genre['genre_name']} (средний рейтинг: {genre['avg_rating']:.1f})")
            else:
                print("Популярные книги:")
            
            if not recommendations['books']:
                print("\nНет рекомендаций. Добавьте больше книг и оценок.")
                continue
            
            print("\nРекомендуемые книги:")
            for i, book in enumerate(recommendations['books'], 1):
                print(f"{i}. {book['title']} - {book['author_name']} ({book['genre_name']})")
            
            # Опция добавления в список "Хочу прочитать"
            book_choice = input("\nВведите номер книги для добавления в 'Хочу прочитать' (или 0 для возврата): ")
            
            if book_choice.isdigit() and 1 <= int(book_choice) <= len(recommendations['books']):
                selected_book = recommendations['books'][int(book_choice) - 1]
                journal.add_to_reading_list("", selected_book['book_id'])
        
        elif choice == '6':
            # Добавление тестовых данных
            add_sample_data()

if __name__ == '__main__':
    interactive_demo()
