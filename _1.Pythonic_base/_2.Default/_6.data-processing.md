# 2.3. Расширенная работа с данными в Python

## Содержание
- [Регулярные выражения](#регулярные-выражения)
- [Сериализация и десериализация](#сериализация-и-десериализация)
- [Работа с датами и временем](#работа-с-датами-и-временем)
- [Двоичные данные и байты](#двоичные-данные-и-байты)
- [Продвинутая работа с JSON и XML](#продвинутая-работа-с-json-и-xml)
- [Работа с API](#работа-с-api)
- [Практические задачи](#практические-задачи)
- [Полезные ресурсы](#полезные-ресурсы)

## Регулярные выражения

Регулярные выражения (regex) — это мощный инструмент для работы с текстовыми данными, позволяющий выполнять поиск, извлечение и замену текста по заданным шаблонам.

### Основы регулярных выражений

```python
import re

# Простой поиск подстроки
text = "Привет, мой номер телефона: 123-456-7890."
pattern = r'\d{3}-\d{3}-\d{4}'
match = re.search(pattern, text)

if match:
    print("Найден телефон:", match.group())  # Найден телефон: 123-456-7890
else:
    print("Телефон не найден")

# Поиск всех совпадений
text = "Телефоны: 123-456-7890, 987-654-3210, 555-555-5555"
pattern = r'\d{3}-\d{3}-\d{4}'
matches = re.findall(pattern, text)
print("Найденные телефоны:", matches)
# Найденные телефоны: ['123-456-7890', '987-654-3210', '555-555-5555']

# Использование re.match (совпадение только в начале строки)
text = "123-456-7890 - это мой телефон"
match = re.match(pattern, text)
print("Match в начале строки:", match.group() if match else "Нет совпадения")
# Match в начале строки: 123-456-7890

text = "Мой телефон 123-456-7890"
match = re.match(pattern, text)
print("Match в начале строки:", match.group() if match else "Нет совпадения")
# Match в начале строки: Нет совпадения
```

### Группы и захват

```python
# Использование групп для извлечения данных
text = "Имя: Иван, Email: ivan@example.com"
pattern = r'Имя: (\w+), Email: (\S+)'
match = re.search(pattern, text)

if match:
    name = match.group(1)
    email = match.group(2)
    print(f"Имя: {name}, Email: {email}")  # Имя: Иван, Email: ivan@example.com
    
    # Все группы сразу
    print(match.groups())  # ('Иван', 'ivan@example.com')

# Именованные группы
pattern = r'Имя: (?P<name>\w+), Email: (?P<email>\S+)'
match = re.search(pattern, text)

if match:
    print("Имя:", match.group('name'))     # Имя: Иван
    print("Email:", match.group('email'))  # Email: ivan@example.com
    
    # Получение именованных групп как словаря
    print(match.groupdict())  # {'name': 'Иван', 'email': 'ivan@example.com'}

# Незахватывающие группы (без сохранения)
text = "Телефон: (123) 456-7890"
pattern = r'Телефон: \((\d{3})\) (\d{3})-(\d{4})'
match = re.search(pattern, text)

if match:
    area_code, prefix, line = match.groups()
    print(f"Код: {area_code}, Префикс: {prefix}, Номер: {line}")
    # Код: 123, Префикс: 456, Номер: 7890
```

### Специальные символы и квантификаторы

```python
# Специальные символы
# \d - цифра, \D - не цифра
# \w - буква, цифра или _, \W - не \w
# \s - пробельный символ, \S - не пробельный символ
# . - любой символ кроме новой строки

# Примеры использования
text = "abc123 def456"
print(re.findall(r'\d+', text))  # ['123', '456'] - все последовательности цифр
print(re.findall(r'\D+', text))  # ['abc', ' def'] - все последовательности не-цифр

# Квантификаторы
# * - 0 или более повторений
# + - 1 или более повторений
# ? - 0 или 1 повторение
# {n} - ровно n повторений
# {n,} - n или более повторений
# {n,m} - от n до m повторений

text = "aaa bbb ccccc"
print(re.findall(r'\w{3}', text))    # ['aaa', 'bbb', 'ccc']
print(re.findall(r'\w{3,}', text))   # ['aaa', 'bbb', 'ccccc']
print(re.findall(r'\w{3,4}', text))  # ['aaa', 'bbb', 'cccc']
```

### Модификаторы и флаги

```python
# Флаги регулярных выражений
# re.I или re.IGNORECASE - игнорировать регистр
# re.M или re.MULTILINE - включить многострочный режим
# re.S или re.DOTALL - точка соответствует любому символу, включая новую строку
# re.X или re.VERBOSE - позволяет форматировать регулярное выражение и добавлять комментарии

# Игнорирование регистра
text = "Python PYTHON python"
pattern = r'python'
print(re.findall(pattern, text))             # ['python']
print(re.findall(pattern, text, re.I))       # ['Python', 'PYTHON', 'python']

# Многострочный режим (^ и $ соответствуют началу и концу каждой строки)
text = """Line 1
Line 2
Line 3"""
pattern = r'^Line \d'
print(re.findall(pattern, text))             # ['Line 1']
print(re.findall(pattern, text, re.M))       # ['Line 1', 'Line 2', 'Line 3']

# Режим DOTALL (. соответствует любому символу, включая новую строку)
text = "Line 1\nLine 2"
pattern = r'Line 1.Line 2'
print(re.findall(pattern, text))             # []
print(re.findall(pattern, text, re.S))       # ['Line 1\nLine 2']

# Режим VERBOSE (позволяет писать читаемые регулярные выражения)
pattern = re.compile(r'''
    \d{3}  # Код города
    -      # Разделитель
    \d{3}  # Префикс
    -      # Разделитель
    \d{4}  # Номер
''', re.VERBOSE)

text = "Телефон: 123-456-7890"
print(re.search(pattern, text).group())      # 123-456-7890

# Комбинирование флагов
pattern = re.compile(r'^python', re.I | re.M)
```

### Замена и разделение текста

```python
# Замена текста с помощью re.sub
text = "Мой email: user@example.com"
pattern = r'[\w\.-]+@[\w\.-]+'
replacement = "[EMAIL]"
anonymized = re.sub(pattern, replacement, text)
print(anonymized)  # Мой email: [EMAIL]

# Замена с использованием групп
text = "Иван Иванов"
pattern = r'(\w+) (\w+)'
replacement = r'\2, \1'  # \1, \2 ссылаются на захваченные группы
formatted = re.sub(pattern, replacement, text)
print(formatted)  # Иванов, Иван

# Использование функции для замены
def upper_case_group(match):
    return match.group(0).upper()

text = "python java c++"
pattern = r'python'
result = re.sub(pattern, upper_case_group, text)
print(result)  # PYTHON java c++

# Использование функции для сложной замены
text = "Телефоны: 123-456-7890, 987-654-3210"
pattern = r'(\d{3})-(\d{3})-(\d{4})'

def format_phone(match):
    area, prefix, number = match.groups()
    return f"({area}) {prefix}-{number}"

formatted = re.sub(pattern, format_phone, text)
print(formatted)  # Телефоны: (123) 456-7890, (987) 654-3210

# Разделение строки с помощью re.split
text = "apple,banana;cherry,orange;grapefruit"
pattern = r'[,;]'  # Разделение по запятой или точке с запятой
fruits = re.split(pattern, text)
print(fruits)  # ['apple', 'banana', 'cherry', 'orange', 'grapefruit']

# Разделение с сохранением разделителей
text = "apple,banana;cherry"
pattern = r'([,;])'  # Скобки сохраняют разделители
parts = re.split(pattern, text)
print(parts)  # ['apple', ',', 'banana', ';', 'cherry']
```

### Жадные и ленивые квантификаторы

```python
# Жадные квантификаторы (по умолчанию) захватывают максимально возможное количество символов
text = "<div>Содержимое 1</div><div>Содержимое 2</div>"
pattern = r'<div>.*</div>'
matches = re.findall(pattern, text)
print(matches)  # ['<div>Содержимое 1</div><div>Содержимое 2</div>']

# Ленивые квантификаторы захватывают минимально возможное количество символов
pattern = r'<div>.*?</div>'
matches = re.findall(pattern, text)
print(matches)  # ['<div>Содержимое 1</div>', '<div>Содержимое 2</div>']

# Еще один пример
text = '"first quote" and "second quote"'
greedy = re.findall(r'".*"', text)
lazy = re.findall(r'".*?"', text)
print(greedy)  # ['"first quote" and "second quote"']
print(lazy)    # ['"first quote"', '"second quote"']
```

### Использование опережающих и ретроспективных проверок

```python
# Положительная опережающая проверка (?=...)
# Проверяет, что после текущей позиции идет указанный шаблон, но не включает его в результат
text = "price1: $10, price2: $20, price3: $30"
pattern = r'\$\d+(?=,)'  # Находит цены, за которыми следует запятая
matches = re.findall(pattern, text)
print(matches)  # ['$10', '$20']

# Отрицательная опережающая проверка (?!...)
# Проверяет, что после текущей позиции НЕ идет указанный шаблон
pattern = r'\$\d+(?!,)'  # Находит цены, за которыми НЕ следует запятая
matches = re.findall(pattern, text)
print(matches)  # ['$30']

# Положительная ретроспективная проверка (?<=...)
# Проверяет, что перед текущей позицией идет указанный шаблон, но не включает его в результат
pattern = r'(?<=price)\d+'  # Находит числа, перед которыми идет слово 'price'
matches = re.findall(pattern, text)
print(matches)  # ['1', '2', '3']

# Отрицательная ретроспективная проверка (?<!...)
# Проверяет, что перед текущей позицией НЕ идет указанный шаблон
text = "$10 @20 #30"
pattern = r'(?<![#@])\d+'  # Находит числа, перед которыми НЕ идет символ '#' или '@'
matches = re.findall(pattern, text)
print(matches)  # ['10']

# Комбинирование проверок
text = "password123, username456, admin789"
# Находит числа, перед которыми идет 'password' и после которых идет запятая
pattern = r'(?<=password)\d+(?=,)'
matches = re.findall(pattern, text)
print(matches)  # ['123']
```

### Часто используемые регулярные выражения

```python
# Email
email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
email = "user@example.com"
print(re.match(email_pattern, email))  # Match object

# URL
url_pattern = r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+'
url = "https://www.example.com/path?query=value"
print(re.match(url_pattern, url))  # Match object

# Дата в формате ДД.ММ.ГГГГ
date_pattern = r'\b(0[1-9]|[12]\d|3[01])\.(0[1-9]|1[0-2])\.(\d{4})\b'
date = "31.12.2023"
match = re.match(date_pattern, date)
if match:
    day, month, year = match.groups()
    print(f"День: {day}, Месяц: {month}, Год: {year}")
    # День: 31, Месяц: 12, Год: 2023

# IP адрес
ip_pattern = r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
ip = "192.168.1.1"
print(re.match(ip_pattern, ip))  # Match object

# Пароль (минимум 8 символов, хотя бы одна буква, одна цифра и один специальный символ)
password_pattern = r'^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$'
strong_password = "Password1!"
weak_password = "password"
print(re.match(password_pattern, strong_password))  # Match object
print(re.match(password_pattern, weak_password))    # None

# Валидация имени файла с расширением
filename_pattern = r'^[\w,\s-]+\.[A-Za-z]{1,4}$'
filename = "document.txt"
print(re.match(filename_pattern, filename))  # Match object
```

### Оптимизация производительности регулярных выражений

```python
import time
import re

# Предварительная компиляция регулярного выражения для многократного использования
start_time = time.time()
pattern = re.compile(r'\d{3}-\d{3}-\d{4}')
text = "Телефоны: 123-456-7890, 987-654-3210"
for _ in range(100000):
    pattern.findall(text)
print(f"Время с компиляцией: {time.time() - start_time:.6f} сек")

# Без предварительной компиляции
start_time = time.time()
text = "Телефоны: 123-456-7890, 987-654-3210"
for _ in range(100000):
    re.findall(r'\d{3}-\d{3}-\d{4}', text)
print(f"Время без компиляции: {time.time() - start_time:.6f} сек")

# Оптимизация сложных регулярных выражений
# Избегайте излишней сложности и вложенных повторений

# Неоптимальное выражение: вложенные повторения требуют экспоненциального времени
def slow_regex(text):
    pattern = re.compile(r'(a+)*b')
    return pattern.match(text)

# Оптимизированное выражение: избегаем вложенных повторений
def fast_regex(text):
    pattern = re.compile(r'a*b')
    return pattern.match(text)

# Тестирование на входных данных, вызывающих проблемы с производительностью
# slow_regex("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX")  # Может вызвать зависание
fast_regex("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX")    # Быстро возвращает None
```

## Сериализация и десериализация

Сериализация — это процесс преобразования объектов в формат, который можно сохранить или передать, а десериализация — обратный процесс восстановления объектов из сериализованного формата.

### JSON

JSON (JavaScript Object Notation) — это легкий формат обмена данными, который часто используется в веб-приложениях.

```python
import json

# Сериализация (Python -> JSON)
data = {
    "name": "Иван",
    "age": 30,
    "city": "Москва",
    "languages": ["Python", "JavaScript", "SQL"],
    "is_active": True,
    "height": 180.5,
    "info": None
}

# Преобразование в строку JSON
json_string = json.dumps(data)
print(json_string)

# Форматирование JSON для читаемости
json_string = json.dumps(data, indent=4, sort_keys=True, ensure_ascii=False)
print(json_string)

# Запись в файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, indent=4, ensure_ascii=False)

# Десериализация (JSON -> Python)
with open("data.json", "r", encoding="utf-8") as f:
    loaded_data = json.load(f)

print(type(loaded_data))  # <class 'dict'>
print(loaded_data["name"])  # Иван
print(loaded_data["languages"][0])  # Python
```

### Обработка нестандартных типов в JSON

```python
import json
from datetime import datetime, date
import decimal

# JSON не поддерживает некоторые типы Python по умолчанию
data = {
    "datetime": datetime.now(),
    "date": date.today(),
    "decimal": decimal.Decimal("10.5"),
    "set": {1, 2, 3},
    # "complex": 1 + 2j  # Комплексные числа не сериализуются
}

# Определение пользовательского JSONEncoder
class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, (datetime, date)):
            return obj.isoformat()
        elif isinstance(obj, decimal.Decimal):
            return float(obj)
        elif isinstance(obj, set):
            return list(obj)
        # Можно добавить обработку других типов
        return super().default(obj)

# Использование пользовательского энкодера
json_string = json.dumps(data, cls=CustomJSONEncoder, indent=4)
print(json_string)

# Альтернативный подход с помощью функции default
def custom_serializer(obj):
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    elif isinstance(obj, decimal.Decimal):
        return float(obj)
    elif isinstance(obj, set):
        return list(obj)
    raise TypeError(f"Тип {type(obj)} не сериализуется")

json_string = json.dumps(data, default=custom_serializer, indent=4)
print(json_string)

# Пользовательская десериализация
def custom_deserializer(json_dict):
    for key, value in json_dict.items():
        if key == "datetime" or key == "date" and isinstance(value, str):
            try:
                json_dict[key] = datetime.fromisoformat(value)
            except ValueError:
                pass
        elif key == "decimal" and isinstance(value, (int, float)):
            json_dict[key] = decimal.Decimal(str(value))
    return json_dict

# Использование пользовательского десериализатора
loaded_data = json.loads(json_string, object_hook=custom_deserializer)
print(type(loaded_data["datetime"]))  # <class 'datetime.datetime'>
print(type(loaded_data["decimal"]))   # <class 'decimal.Decimal'>
```

### Pickle

Pickle — это стандартный модуль Python для сериализации и десериализации объектов Python.

```python
import pickle

# Сериализация с помощью pickle
data = {
    "name": "Иван",
    "languages": ["Python", "JavaScript"],
    "age": 30
}

# Запись в бинарный файл
with open("data.pickle", "wb") as f:
    pickle.dump(data, f)

# Чтение из бинарного файла
with open("data.pickle", "rb") as f:
    loaded_data = pickle.load(f)

print(loaded_data)  # {'name': 'Иван', 'languages': ['Python', 'JavaScript'], 'age': 30}

# Сериализация нескольких объектов
with open("multiple.pickle", "wb") as f:
    pickle.dump("first string", f)
    pickle.dump([1, 2, 3], f)
    pickle.dump({"key": "value"}, f)

# Десериализация нескольких объектов
objects = []
with open("multiple.pickle", "rb") as f:
    while True:
        try:
            obj = pickle.load(f)
            objects.append(obj)
        except EOFError:
            break

print(objects)  # ['first string', [1, 2, 3], {'key': 'value'}]
```

### Сериализация классов и функций с pickle

```python
import pickle

# Определение класса для сериализации
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        return f"Привет, меня зовут {self.name}!"

# Создание экземпляра класса
person = Person("Иван", 30)

# Сериализация экземпляра класса
with open("person.pickle", "wb") as f:
    pickle.dump(person, f)

# Десериализация экземпляра класса
with open("person.pickle", "rb") as f:
    loaded_person = pickle.load(f)

print(loaded_person.name)        # Иван
print(loaded_person.age)         # 30
print(loaded_person.greet())     # Привет, меня зовут Иван!

# Использование протоколов pickle для оптимизации
data = [i for i in range(10000)]

# Различные протоколы (0 - текстовый, 1-5 - бинарные, выше = эффективнее)
for protocol in range(6):
    with open(f"data_protocol_{protocol}.pickle", "wb") as f:
        pickle.dump(data, f, protocol=protocol)
        
    # Проверка размера файла для каждого протокола
    import os
    size = os.path.getsize(f"data_protocol_{protocol}.pickle")
    print(f"Протокол {protocol}: {size} байт")
```

### Безопасность и ограничения pickle

```python
import pickle

# ВАЖНО: Никогда не загружайте pickle-файлы из недоверенных источников!
# Злоумышленник может создать вредоносный pickle-файл, выполняющий произвольный код.

# Пример вредоносного pickle-файла (НЕ ЗАПУСКАЙТЕ В РЕАЛЬНОЙ СРЕДЕ)
class Exploit:
    def __reduce__(self):
        # Это приведет к выполнению os.system("echo Уязвимость!") при десериализации
        import os
        return (os.system, ("echo Уязвимость!",))

# exploit = Exploit()
# with open("exploit.pickle", "wb") as f:
#     pickle.dump(exploit, f)

# with open("exploit.pickle", "rb") as f:
#     pickle.load(f)  # ЭТО ВЫПОЛНИТ КОМАНДУ!

# Альтернативы pickle для безопасной сериализации:
# 1. json - безопасно, но ограничено в типах
# 2. marshmallow - библиотека для сериализации/десериализации объектов
# 3. dill - расширение pickle с большей функциональностью
# 4. cloudpickle - для сериализации Python-функций и классов
```

### Другие форматы сериализации

#### YAML

```python
# pip install pyyaml
import yaml

# Данные для сериализации
data = {
    "name": "Иван",
    "age": 30,
    "address": {
        "city": "Москва",
        "street": "Ленина",
        "building": 10
    },
    "languages": ["Python", "JavaScript", "SQL"],
    "is_active": True
}

# Сериализация в YAML
yaml_string = yaml.dump(data, allow_unicode=True, default_flow_style=False)
print(yaml_string)

# Запись в файл
with open("data.yaml", "w", encoding="utf-8") as f:
    yaml.dump(data, f, allow_unicode=True, default_flow_style=False)

# Десериализация из YAML
with open("data.yaml", "r", encoding="utf-8") as f:
    loaded_data = yaml.safe_load(f)  # safe_load для защиты от вредоносного кода

print(loaded_data)
print(loaded_data["address"]["city"])  # Москва
```

#### Protocol Buffers

```python
# pip install protobuf

# Определение схемы (в файле person.proto):
"""
syntax = "proto3";

message Person {
    string name = 1;
    int32 age = 2;
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}
"""

# Компиляция схемы:
# protoc --python_out=. person.proto

# Использование сгенерированного кода:
import person_pb2

# Создание объекта сообщения
person = person_pb2.Person()
person.name = "Иван"
person.age = 30
person.email = "ivan@example.com"

# Добавление телефонов
phone = person.phones.add()
phone.number = "123-456-7890"
phone.type = person_pb2.Person.PhoneType.MOBILE

# Сериализация
serialized = person.SerializeToString()
print(serialized)  # Бинарные данные

# Десериализация
deserialized_person = person_pb2.Person()
deserialized_person.ParseFromString(serialized)
print(deserialized_person.name)  # Иван
print(deserialized_person.age)   # 30
```

#### MessagePack

```python
# pip install msgpack
import msgpack

# Данные для сериализации
data = {
    "name": "Иван",
    "age": 30,
    "languages": ["Python", "JavaScript", "SQL"]
}

# Сериализация в MessagePack
packed = msgpack.packb(data, use_bin_type=True)
print(packed)  # Бинарные данные

# Запись в файл
with open("data.msgpack", "wb") as f:
    f.write(packed)

# Чтение из файла и десериализация
with open("data.msgpack", "rb") as f:
    binary_data = f.read()
    unpacked = msgpack.unpackb(binary_data, raw=False)

print(unpacked)  # {'name': 'Иван', 'age': 30, 'languages': ['Python', 'JavaScript', 'SQL']}
```

## Работа с датами и временем

### Основы модуля datetime

```python
from datetime import datetime, date, time, timedelta

# Получение текущей даты и времени
now = datetime.now()
print("Текущая дата и время:", now)

# Получение компонентов даты и времени
print("Год:", now.year)
print("Месяц:", now.month)
print("День:", now.day)
print("Час:", now.hour)
print("Минута:", now.minute)
print("Секунда:", now.second)
print("Микросекунда:", now.microsecond)

# Создание объекта datetime
dt = datetime(2023, 12, 31, 23, 59, 59)
print("Заданная дата и время:", dt)

# Создание объекта date
d = date(2023, 12, 31)
print("Заданная дата:", d)

# Получение текущей даты
today = date.today()
print("Сегодня:", today)

# Создание объекта time
t = time(12, 30, 45)
print("Заданное время:", t)

# Комбинирование date и time в datetime
dt_combined = datetime.combine(d, t)
print("Комбинированные дата и время:", dt_combined)

# Форматирование даты и времени
formatted = now.strftime("%Y-%m-%d %H:%M:%S")
print("Форматированная дата и время:", formatted)

# Разбор строки в дату и время
parsed = datetime.strptime("2023-12-31 23:59:59", "%Y-%m-%d %H:%M:%S")
print("Разобранная дата и время:", parsed)
```

### Операции с датами и временем

```python
from datetime import datetime, timedelta

# Текущая дата и время
now = datetime.now()
print("Текущая дата и время:", now)

# Добавление временного интервала
one_day = timedelta(days=1)
tomorrow = now + one_day
print("Завтра:", tomorrow)

# Вычитание временного интервала
yesterday = now - one_day
print("Вчера:", yesterday)

# Создание составного интервала
interval = timedelta(days=2, hours=3, minutes=15, seconds=30)
future = now + interval
print("Дата и время в будущем:", future)

# Разница между датами
new_year = datetime(now.year + 1, 1, 1)
time_to_new_year = new_year - now
print("Дней до Нового года:", time_to_new_year.days)
print("Секунд до Нового года:", time_to_new_year.total_seconds())

# Получение дня недели
weekday = now.weekday()  # 0 - понедельник, 6 - воскресенье
print("День недели (0-6):", weekday)
print("День недели (1-7):", now.isoweekday())  # 1 - понедельник, 7 - воскресенье

# Проверка на високосный год
is_leap = (lambda y: (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0))(now.year)
print("Високосный год:", is_leap)

# Получение первого и последнего дня месяца
import calendar
first_day = date(now.year, now.month, 1)
last_day = date(now.year, now.month, calendar.monthrange(now.year, now.month)[1])
print("Первый день месяца:", first_day)
print("Последний день месяца:", last_day)
```

### Работа с часовыми поясами

```python
from datetime import datetime
import pytz  # pip install pytz

# Текущее время без указания часового пояса (наивное)
naive_now = datetime.now()
print("Наивное текущее время:", naive_now)

# Текущее время в UTC
utc_now = datetime.now(pytz.UTC)
print("Текущее время в UTC:", utc_now)

# Указание часового пояса для наивного времени
local_tz = pytz.timezone('Europe/Moscow')
local_now = local_tz.localize(naive_now)
print("Локальное время с часовым поясом:", local_now)

# Преобразование времени между часовыми поясами
new_york_tz = pytz.timezone('America/New_York')
ny_time = local_now.astimezone(new_york_tz)
print("Время в Нью-Йорке:", ny_time)

# Список всех доступных часовых поясов
# print(pytz.all_timezones)

# Создание времени в конкретном часовом поясе
tokyo_dt = datetime(2023, 12, 31, 23, 59, 59, tzinfo=pytz.timezone('Asia/Tokyo'))
print("Время в Токио:", tokyo_dt)

# Преобразование из строки с указанием часового пояса
from dateutil import parser  # pip install python-dateutil
dt_str = "2023-12-31T23:59:59+09:00"  # ISO 8601 формат
parsed_dt = parser.isoparse(dt_str)
print("Разобранное время с часовым поясом:", parsed_dt)
```

### Работа с временными интервалами

```python
from datetime import datetime, timedelta
import time

# Создание временного интервала
delta = timedelta(days=5, hours=3, minutes=10, seconds=15)
print("Интервал:", delta)
print("Общее количество секунд:", delta.total_seconds())

# Разделение интервала на компоненты
days = delta.days
seconds = delta.seconds
microseconds = delta.microseconds
total_seconds = delta.total_seconds()
print(f"Дней: {days}, секунд: {seconds}, микросекунд: {microseconds}")

# Вычисление часов, минут и секунд из секунд
hours, remainder = divmod(seconds, 3600)
minutes, seconds = divmod(remainder, 60)
print(f"Часов: {hours}, минут: {minutes}, секунд: {seconds}")

# Создание списка дат через равные интервалы
start_date = datetime(2023, 1, 1)
end_date = datetime(2023, 1, 10)
interval = timedelta(days=2)

current_date = start_date
dates = []
while current_date <= end_date:
    dates.append(current_date)
    current_date += interval

for date in dates:
    print(date.strftime("%Y-%m-%d"))

# Измерение времени выполнения кода
start_time = time.time()
# Выполняем какие-то операции
time.sleep(1)
end_time = time.time()
execution_time = end_time - start_time
print(f"Время выполнения: {execution_time:.2f} секунд")

# Использование контекстного менеджера для измерения времени
import contextlib

@contextlib.contextmanager
def timer():
    start_time = time.time()
    yield
    end_time = time.time()
    print(f"Время выполнения: {end_time - start_time:.2f} секунд")

with timer():
    # Код, время выполнения которого нужно измерить
    time.sleep(1.5)
```

### Формат ISO 8601 и RFC 3339

```python
from datetime import datetime
import pytz

# Получение текущего времени
now = datetime.now(pytz.UTC)

# Форматирование в ISO 8601
iso_format = now.isoformat()
print("ISO 8601:", iso_format)  # 2023-10-15T14:30:45.123456+00:00

# Форматирование в RFC 3339
rfc3339_format = now.strftime('%Y-%m-%dT%H:%M:%S%z')
print("RFC 3339:", rfc3339_format)  # 2023-10-15T14:30:45+0000

# Форматирование с указанием долей секунды
iso_with_ms = now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + now.strftime('%z')
print("ISO с миллисекундами:", iso_with_ms)  # 2023-10-15T14:30:45.123+0000

# Разбор даты из строки в формате ISO 8601
iso_string = "2023-10-15T14:30:45.123456+00:00"
parsed_iso = datetime.fromisoformat(iso_string)  # Python 3.7+
print("Разобранная ISO дата:", parsed_iso)

# Разбор даты из строки в различных форматах
from dateutil import parser

date_strings = [
    "2023-10-15T14:30:45.123456+00:00",  # ISO 8601
    "2023-10-15 14:30:45",               # Простой формат
    "15/10/2023 14:30:45",               # Формат с разделителями
    "15 Oct 2023 14:30:45",              # Формат с названием месяца
    "Sun, 15 Oct 2023 14:30:45 +0000"    # RFC 2822
]

for date_string in date_strings:
    try:
        parsed_date = parser.parse(date_string)
        print(f"'{date_string}' -> {parsed_date}")
    except ValueError as e:
        print(f"Ошибка при разборе '{date_string}': {e}")
```

### Библиотека pendulum

Pendulum — это более дружественная к разработчику альтернатива стандартному модулю datetime.

```python
# pip install pendulum
import pendulum

# Создание объекта datetime
dt = pendulum.datetime(2023, 12, 31, 23, 59, 59)
print("Дата и время:", dt)

# Текущее время в указанном часовом поясе
local_dt = pendulum.now('Europe/Moscow')
print("Местное время (Москва):", local_dt)

# Текущее время в UTC
utc_dt = pendulum.now('UTC')
print("UTC время:", utc_dt)

# Преобразование между часовыми поясами
ny_dt = local_dt.in_timezone('America/New_York')
print("Время в Нью-Йорке:", ny_dt)

# Форматирование
formatted = local_dt.format('YYYY-MM-DD HH:mm:ss')
print("Форматированная дата:", formatted)

# Парсинг строк
parsed = pendulum.parse('2023-12-31T23:59:59+03:00')
print("Разобранная дата:", parsed)

# Доступ к компонентам
print("Год:", local_dt.year)
print("Месяц:", local_dt.month)
print("День:", local_dt.day)
print("День недели:", local_dt.day_of_week)  # 0 (Воскресенье) по 6 (Суббота)

# Операции с датами
tomorrow = local_dt.add(days=1)
print("Завтра:", tomorrow)

next_week = local_dt.add(weeks=1)
print("Через неделю:", next_week)

# Разница между датами
diff = next_week - local_dt
print("Разница:", diff)
print("Разница в днях:", diff.in_days())
print("Разница в часах:", diff.in_hours())

# Относительные даты
yesterday = pendulum.yesterday('Europe/Moscow')
print("Вчера:", yesterday)

tomorrow = pendulum.tomorrow('Europe/Moscow')
print("Завтра:", tomorrow)

# Работа с периодами
period = pendulum.period(local_dt, local_dt.add(days=7))
for dt in period.range('days'):
    print(dt.format('YYYY-MM-DD'))

# Человекочитаемое представление дат
print(local_dt.diff_for_humans())  # "несколько секунд назад"
print(tomorrow.diff_for_humans())  # "через 1 день"
```

## Двоичные данные и байты

### Основы работы с байтами

```python
# Создание объектов bytes
b1 = bytes([65, 66, 67])   # Из списка ASCII-кодов
print(b1)  # b'ABC'

b2 = bytes("Hello", "utf-8")  # Из строки с указанием кодировки
print(b2)  # b'Hello'

b3 = b"World"  # Литерал bytes
print(b3)  # b'World'

# Создание изменяемых объектов bytearray
ba1 = bytearray([65, 66, 67])
print(ba1)  # bytearray(b'ABC')

ba2 = bytearray("Hello", "utf-8")
print(ba2)  # bytearray(b'Hello')

# Преобразование типов
s = "Привет"
b = s.encode("utf-8")  # Строка -> bytes
print(b)  # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'

s_back = b.decode("utf-8")  # bytes -> Строка
print(s_back)  # Привет

# Доступ к отдельным байтам
b = b"Python"
print(b[0])  # 80 (ASCII-код 'P')
print(bytes([b[0]]))  # b'P'

# Перебор байтов
for byte in b:
    print(byte, end=" ")  # 80 121 116 104 111 110
print()

# Изменение bytearray
ba = bytearray(b"Python")
ba[0] = 74  # ASCII-код 'J'
print(ba)  # bytearray(b'Jython')

# Срезы
b = b"Python"
print(b[1:4])  # b'yth'

# Конкатенация
b1 = b"Hello"
b2 = b" World"
b3 = b1 + b2
print(b3)  # b'Hello World'

# Повторение
b = b"Na" * 8 + b" Batman!"
print(b)  # b'NaNaNaNaNaNaNaNa Batman!'
```

### Работа с бинарными файлами

```python
# Запись байтов в файл
with open("binary_data.bin", "wb") as f:
    f.write(b"Hello World")
    f.write(bytes([65, 66, 67]))

# Чтение байтов из файла
with open("binary_data.bin", "rb") as f:
    data = f.read()
    print(data)  # b'Hello WorldABC'
    
    # Чтение определенного количества байтов
    f.seek(0)  # Возврат к началу файла
    first_five = f.read(5)
    print(first_five)  # b'Hello'

# Запись нескольких объектов
data1 = b"First data"
data2 = b"Second data"

with open("multiple_data.bin", "wb") as f:
    # Записываем длину и данные для каждого блока
    for data in (data1, data2):
        length = len(data)
        f.write(length.to_bytes(4, byteorder='big'))  # 4-байтовый размер
        f.write(data)

# Чтение нескольких объектов
objects = []
with open("multiple_data.bin", "rb") as f:
    while True:
        # Чтение размера блока
        length_bytes = f.read(4)
        if not length_bytes:  # Конец файла
            break
        
        length = int.from_bytes(length_bytes, byteorder='big')
        data = f.read(length)
        objects.append(data)

print(objects)  # [b'First data', b'Second data']
```

### Бинарные структуры с модулем struct

```python
import struct

# Упаковка данных в байтовую строку
# Форматы:
# < - порядок байтов little-endian
# > - порядок байтов big-endian
# ! - порядок байтов сетевой (big-endian)
# i - 4-байтовое целое
# f - 4-байтовое с плавающей точкой
# s - строка (требуется указать длину)
# c - символ как байтовая строка длиной 1
# ? - булево значение
# h - 2-байтовое целое
# d - 8-байтовое с плавающей точкой (double)

# Упаковка целого числа, с плавающей точкой и строки
format_string = "<if10s"
packed = struct.pack(format_string, 123, 45.67, b"Hello")
print(packed)  # b'{\x00\x00\x00\xcd\xcc\x36BHello\x00\x00\x00\x00\x00'
print(len(packed))  # 18 байт (4 + 4 + 10)

# Распаковка
unpacked = struct.unpack(format_string, packed)
print(unpacked)  # (123, 45.67000198364258, b'Hello\x00\x00\x00\x00\x00')

int_val, float_val, string_val = unpacked
print(f"Int: {int_val}, Float: {float_val}, String: {string_val.decode('ascii').rstrip('\x00')}")
# Int: 123, Float: 45.67000198364258, String: Hello

# Упаковка нескольких значений одного типа
numbers = [1, 2, 3, 4, 5]
format_string = "!5i"  # 5 целых чисел, сетевой порядок байтов
packed = struct.pack(format_string, *numbers)
print(packed)  # b'\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05'

# Распаковка нескольких значений
unpacked = struct.unpack(format_string, packed)
print(unpacked)  # (1, 2, 3, 4, 5)

# Определение размера структуры
size = struct.calcsize(format_string)
print(f"Размер структуры: {size} байт")  # Размер структуры: 20 байт

# Упаковка структуры переменной длины
def pack_variable_string(s):
    encoded = s.encode('utf-8')
    length = len(encoded)
    return struct.pack("!I", length) + encoded

def unpack_variable_string(data):
    length = struct.unpack("!I", data[:4])[0]
    return data[4:4+length].decode('utf-8'), 4 + length

packed = pack_variable_string("Hello, World!")
print(packed)  # b'\x00\x00\x00\rHello, World!'

unpacked, next_pos = unpack_variable_string(packed)
print(unpacked)  # Hello, World!
```

### MemoryView и буферный протокол

```python
# MemoryView предоставляет доступ к внутренним данным объекта без копирования
s = b"Hello, World!"
view = memoryview(s)

# Доступ к отдельным байтам
print(view[0])  # 72 (ASCII-код 'H')
print(bytes(view[0:5]))  # b'Hello'

# Создание среза без копирования данных
slice_view = view[7:12]
print(bytes(slice_view))  # b'World'

# Работа с числовыми данными
import array
numbers = array.array('i', [1, 2, 3, 4, 5])
view = memoryview(numbers)

# Преобразование к другому формату
view_uint8 = view.cast('B')  # 'B' - unsigned char (uint8)
print(list(view_uint8))  # Список байтов

# Изменение данных через MemoryView
data = bytearray(b"Hello")
view = memoryview(data)
view[0] = 74  # ASCII-код 'J'
print(data)  # bytearray(b'Jello')

# Использование буферного протокола с NumPy
import numpy as np

# Создание массива NumPy
arr = np.array([1, 2, 3, 4, 5], dtype=np.int32)
print(arr)  # [1 2 3 4 5]

# Создание MemoryView из массива NumPy
view = memoryview(arr)
print(view.format)  # 'i' (32-битное целое)
print(view.itemsize)  # 4 (4 байта на элемент)
print(view.shape)  # (5,) (форма массива)

# Преобразование MemoryView в bytes
bytes_data = bytes(view)
print(bytes_data)  # b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00'

# Изменение данных через MemoryView
view[0] = 99
print(arr)  # [99  2  3  4  5]
```

### Работа с битами

```python
# Битовые операции
a = 0b10101010  # 170 в десятичной системе
b = 0b11001100  # 204 в десятичной системе

# Побитовое И (AND)
result = a & b
print(bin(result))  # 0b10001000 (136)

# Побитовое ИЛИ (OR)
result = a | b
print(bin(result))  # 0b11101110 (238)

# Побитовое исключающее ИЛИ (XOR)
result = a ^ b
print(bin(result))  # 0b1100110 (102)

# Побитовое отрицание (NOT)
result = ~a
print(bin(result & 0xFF))  # 0b1010101 (85 в 8-битном представлении)

# Битовый сдвиг влево
result = a << 2
print(bin(result))  # 0b1010101000 (680)

# Битовый сдвиг вправо
result = a >> 2
print(bin(result))  # 0b101010 (42)

# Проверка установки бита
def is_bit_set(value, bit_index):
    return (value & (1 << bit_index)) != 0

print(is_bit_set(a, 3))  # True - 4-й бит установлен (индексация с 0)
print(is_bit_set(a, 2))  # False - 3-й бит не установлен

# Установка бита
def set_bit(value, bit_index):
    return value | (1 << bit_index)

print(bin(set_bit(a, 2)))  # 0b10101110 (174)

# Сброс бита
def clear_bit(value, bit_index):
    return value & ~(1 << bit_index)

print(bin(clear_bit(a, 3)))  # 0b10100010 (162)

# Переключение бита
def toggle_bit(value, bit_index):
    return value ^ (1 << bit_index)

print(bin(toggle_bit(a, 3)))  # 0b10100010 (162)
print(bin(toggle_bit(a, 2)))  # 0b10101110 (174)

# Подсчет установленных битов
def count_set_bits(value):
    count = 0
    while value:
        count += value & 1
        value >>= 1
    return count

print(count_set_bits(a))  # 4

# Более эффективный способ подсчета битов
def count_set_bits_efficient(value):
    return bin(value).count('1')

print(count_set_bits_efficient(a))  # 4
```

### Упаковка и распаковка битовых полей

```python
# Упаковка нескольких значений в одно целое число
def pack_bits(values, bit_lengths):
    """
    Упаковывает несколько значений в одно целое число,
    используя указанное количество битов для каждого значения.
    
    Args:
        values: Список значений
        bit_lengths: Список длин в битах для каждого значения
        
    Returns:
        Упакованное целое число
    """
    result = 0
    bit_position = 0
    
    for value, bit_length in zip(values, bit_lengths):
        # Маскируем значение, чтобы оно не превышало указанную длину в битах
        masked_value = value & ((1 << bit_length) - 1)
        # Сдвигаем значение в нужную позицию и добавляем к результату
        result |= masked_value << bit_position
        bit_position += bit_length
    
    return result

# Распаковка значений из целого числа
def unpack_bits(packed_value, bit_lengths):
    """
    Распаковывает несколько значений из целого числа,
    используя указанное количество битов для каждого значения.
    
    Args:
        packed_value: Упакованное целое число
        bit_lengths: Список длин в битах для каждого значения
        
    Returns:
        Список распакованных значений
    """
    result = []
    bit_position = 0
    
    for bit_length in bit_lengths:
        # Создаем маску для извлечения значения
        mask = (1 << bit_length) - 1
        # Извлекаем значение из нужной позиции
        value = (packed_value >> bit_position) & mask
        result.append(value)
        bit_position += bit_length
    
    return result

# Пример использования
# Упаковываем RGB-значения (красный, зеленый, синий) в одно целое число
# Каждый цвет представлен 8 битами (0-255)
rgb_values = [255, 128, 64]  # Красный, зеленый, синий
bit_lengths = [8, 8, 8]
packed = pack_bits(rgb_values, bit_lengths)
print(f"Упакованное значение: {packed} (0x{packed:06X})")
# Упакованное значение: 16744512 (0xFF8040)

# Распаковываем значения обратно
unpacked = unpack_bits(packed, bit_lengths)
print(f"Распакованные значения: {unpacked}")
# Распакованные значения: [255, 128, 64]

# Пример с разными длинами битов
# Допустим, мы хотим упаковать флаги (3 бита), идентификатор (5 битов) и счетчик (10 битов)
values = [5, 20, 789]  # Флаги, идентификатор, счетчик
bit_lengths = [3, 5, 10]
packed = pack_bits(values, bit_lengths)
print(f"Упакованное значение: {packed} (0x{packed:04X})")
# Упакованное значение: 40805 (0x9F65)

unpacked = unpack_bits(packed, bit_lengths)
print(f"Распакованные значения: {unpacked}")
# Распакованные значения: [5, 20, 789]
```

## Продвинутая работа с JSON и XML

### Работа с большими JSON файлами

```python
import json
import ijson  # pip install ijson

# Создание большого JSON-файла для демонстрации
def create_large_json_file(filename, n_items=10000):
    """Создает большой JSON-файл с n_items элементами."""
    with open(filename, 'w') as f:
        f.write('{\n')
        f.write('  "items": [\n')
        for i in range(n_items):
            f.write(f'    {{"id": {i}, "name": "Item {i}", "value": {i * 10}}}')
            if i < n_items - 1:
                f.write(',\n')
            else:
                f.write('\n')
        f.write('  ]\n')
        f.write('}\n')

# Создаем тестовый файл
create_large_json_file("large_data.json", 1000)

# Загрузка всего файла в память (не рекомендуется для больших файлов)
def load_entire_file(filename):
    with open(filename, 'r') as f:
        data = json.load(f)
    return data["items"]

# Потоковая обработка с использованием ijson
def process_items_streaming(filename):
    """Обрабатывает элементы из JSON-файла по одному."""
    results = []
    with open(filename, 'rb') as f:
        # Итерация по элементам массива 'items'
        for item in ijson.items(f, 'items.item'):
            # Обработка каждого элемента
            if item["value"] > 9000:
                results.append(item)
    return results

# Потоковая запись JSON
def write_json_stream(filename, n_items=10000):
    """Демонстрирует потоковую запись JSON без загрузки всего файла в память."""
    with open(filename, 'w') as f:
        f.write('{\n')
        f.write('  "items": [\n')
        for i in range(n_items):
            item = {"id": i, "name": f"Item {i}", "value": i * 10}
            if i > 0:
                f.write(',\n')
            f.write('    ' + json.dumps(item))
        f.write('\n  ]\n')
        f.write('}\n')

# Тестирование функций
print("Обработка с помощью потоковой обработки:")
large_items = process_items_streaming("large_data.json")
print(f"Найдено {len(large_items)} элементов со значением > 9000")

# Демонстрация потоковой записи
write_json_stream("streamed_output.json", 1000)
print("Файл записан с использованием потоковой записи")
```

### JSON-схемы и валидация

```python
# pip install jsonschema
import json
from jsonschema import validate, ValidationError, Draft7Validator

# Определение JSON-схемы
schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string", "minLength": 2},
        "age": {"type": "integer", "minimum": 0, "maximum": 120},
        "email": {"type": "string", "format": "email"},
        "tags": {
            "type": "_1.arrays",
            "items": {"type": "string"},
            "minItems": 1
        },
        "address": {
            "type": "object",
            "properties": {
                "city": {"type": "string"},
                "zipcode": {"type": "string", "pattern": "^[0-9]{5}$"}
            },
            "required": ["city"]
        }
    },
    "required": ["name", "age", "email"]
}

# Валидные данные
valid_data = {
    "name": "John Doe",
    "age": 30,
    "email": "john@example.com",
    "tags": ["user", "admin"],
    "address": {
        "city": "New York",
        "zipcode": "10001"
    }
}

# Невалидные данные
invalid_data = {
    "name": "J",  # слишком короткое имя
    "age": 150,   # возраст больше максимума
    "email": "not-an-email",  # некорректный email
    "tags": [],   # пустой массив
    "address": {
        "zipcode": "ABC"  # неверный формат zipcode
    }
}

# Проверка валидных данных
try:
    validate(instance=valid_data, schema=schema)
    print("Валидные данные прошли проверку")
except ValidationError as e:
    print(f"Ошибка валидации: {e}")

# Проверка невалидных данных
try:
    validate(instance=invalid_data, schema=schema)
    print("Данные прошли проверку")
except ValidationError as e:
    print(f"Ошибка валидации: {e}")

# Получение всех ошибок валидации
validator = Draft7Validator(schema)
errors = list(validator.iter_errors(invalid_data))
print(f"Количество ошибок: {len(errors)}")
for error in errors:
    print(f"Путь: {'.'.join(str(p) for p in error.path)}, Сообщение: {error.message}")

# Создание новой схемы на основе данных
def generate_schema_from_data(data):
    """Генерирует простую JSON-схему на основе структуры данных."""
    schema = {"type": "object", "properties": {}, "required": []}
    
    for key, value in data.items():
        schema["required"].append(key)
        
        if isinstance(value, str):
            schema["properties"][key] = {"type": "string"}
        elif isinstance(value, int):
            schema["properties"][key] = {"type": "integer"}
        elif isinstance(value, float):
            schema["properties"][key] = {"type": "number"}
        elif isinstance(value, bool):
            schema["properties"][key] = {"type": "boolean"}
        elif isinstance(value, list):
            schema["properties"][key] = {
                "type": "_1.arrays",
                "items": {"type": "string"} if all(isinstance(x, str) for x in value) else {}
            }
        elif isinstance(value, dict):
            schema["properties"][key] = generate_schema_from_data(value)
        else:
            schema["properties"][key] = {}
    
    return schema

# Генерация схемы из данных
generated_schema = generate_schema_from_data(valid_data)
print("Сгенерированная схема:", json.dumps(generated_schema, indent=2))
```

### Работа с XML и XPath

```python
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom

# Создание XML
def create_xml():
    # Создаем корневой элемент
    root = ET.Element("catalog")
    
    # Добавляем комментарий
    comment = ET.Comment("Каталог книг")
    root.append(comment)
    
    # Добавляем книги
    for i in range(1, 4):
        book = ET.SubElement(root, "book", id=f"bk{i}")
        
        ET.SubElement(book, "title").text = f"Book Title {i}"
        
        author = ET.SubElement(book, "author")
        ET.SubElement(author, "name").text = f"Author {i}"
        ET.SubElement(author, "email").text = f"author{i}@example.com"
        
        ET.SubElement(book, "price").text = f"{10 * i:.2f}"
        ET.SubElement(book, "year").text = str(2000 + i)
    
    # Создаем дерево XML
    tree = ET.ElementTree(root)
    return tree

# Запись XML в файл
def write_xml(tree, filename):
    tree.write(filename, encoding="utf-8", xml_declaration=True)
    
    # Для красивого форматирования XML
    with open(filename, "r", encoding="utf-8") as f:
        xml_string = f.read()
    
    pretty_xml = minidom.parseString(xml_string).toprettyxml(indent="  ")
    
    with open(filename, "w", encoding="utf-8") as f:
        f.write(pretty_xml)

# Чтение XML из файла
def read_xml(filename):
    tree = ET.parse(filename)
    root = tree.getroot()
    return root

# Поиск элементов с помощью XPath
def find_with_xpath(root, xpath):
    return root.findall(xpath)

# Изменение существующего XML
def modify_xml(root):
    # Изменение атрибута
    books = root.findall(".//book")
    for book in books:
        book.set("language", "English")
    
    # Изменение текста элемента
    book = root.find(".//book[@id='bk1']")
    if book is not None:
        title = book.find("title")
        if title is not None:
            title.text = "Updated Book Title"
    
    # Добавление нового элемента
    book = root.find(".//book[@id='bk2']")
    if book is not None:
        ET.SubElement(book, "genre").text = "Fiction"
    
    # Удаление элемента
    book = root.find(".//book[@id='bk3']")
    if book is not None:
        price = book.find("price")
        if price is not None:
            book.remove(price)

# Создаем и записываем XML
tree = create_xml()
write_xml(tree, "catalog.xml")

# Читаем XML
root = read_xml("catalog.xml")

# Выводим все книги
books = find_with_xpath(root, ".//book")
print(f"Найдено {len(books)} книг")

for book in books:
    book_id = book.get("id")
    title = book.find("title").text
    price = book.find("price").text
    author_name = book.find(".//author/name").text
    
    print(f"Книга {book_id}: {title} от {author_name}, цена: {price}")

# XPath запросы
print("\nПоиск книг с ценой больше 15:")
expensive_books = find_with_xpath(root, ".//book[price>15]")
for book in expensive_books:
    print(book.find("title").text)

print("\nПоиск книг, выпущенных после 2001 года:")
new_books = find_with_xpath(root, ".//book[year>2001]")
for book in new_books:
    print(f"{book.find('title').text} ({book.find('year').text})")

# Модифицируем XML
modify_xml(root)
tree = ET.ElementTree(root)
write_xml(tree, "modified_catalog.xml")
print("\nXML был модифицирован и сохранен в modified_catalog.xml")
```

### XML с пространствами имен

```python
import xml.etree.ElementTree as ET

# Создание XML с пространствами имен
def create_namespaced_xml():
    # Регистрируем пространства имен
    ET.register_namespace("h", "http://www.w3.org/1999/xhtml")
    ET.register_namespace("m", "http://example.org/math")
    
    # Создаем корневой элемент с пространством имен
    root = ET.Element("{http://www.w3.org/1999/xhtml}html")
    
    # Создаем элементы с разными пространствами имен
    body = ET.SubElement(root, "{http://www.w3.org/1999/xhtml}body")
    
    h1 = ET.SubElement(body, "{http://www.w3.org/1999/xhtml}h1")
    h1.text = "Математический пример"
    
    equation = ET.SubElement(body, "{http://example.org/math}equation")
    
    ET.SubElement(equation, "{http://example.org/math}variable").text = "x"
    ET.SubElement(equation, "{http://example.org/math}operator").text = "+"
    ET.SubElement(equation, "{http://example.org/math}variable").text = "y"
    ET.SubElement(equation, "{http://example.org/math}operator").text = "="
    ET.SubElement(equation, "{http://example.org/math}result").text = "z"
    
    # Создаем дерево XML
    tree = ET.ElementTree(root)
    return tree

# Запись XML в файл
def write_namespaced_xml(tree, filename):
    tree.write(filename, encoding="utf-8", xml_declaration=True)

# Чтение XML с пространствами имен
def read_namespaced_xml(filename):
    tree = ET.parse(filename)
    root = tree.getroot()
    return root

# Поиск с учетом пространств имен
def find_with_namespaces(root):
    # Определяем отображение префиксов на URI пространств имен
    namespaces = {
        "h": "http://www.w3.org/1999/xhtml",
        "m": "http://example.org/math"
    }
    
    # Поиск элементов с использованием пространств имен
    h1 = root.find(".//h:h1", namespaces)
    print("Заголовок:", h1.text if h1 is not None else "Не найден")
    
    variables = root.findall(".//m:variable", namespaces)
    print("Переменные:", [var.text for var in variables] if variables else "Не найдены")
    
    equation_elements = root.findall(".//m:equation/*", namespaces)
    equation_text = " ".join(elem.text for elem in equation_elements)
    print("Уравнение:", equation_text)

# Создаем и записываем XML с пространствами имен
tree = create_namespaced_xml()
write_namespaced_xml(tree, "namespaced.xml")

# Читаем XML и выполняем поиск с учетом пространств имен
root = read_namespaced_xml("namespaced.xml")
find_with_namespaces(root)
```

### XML-схемы и валидация

```python
# pip install xmlschema
import xmlschema

# XML-схема (XSD)
xsd_content = '''<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="catalog">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="book" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="title" type="xs:string"/>
              <xs:element name="author">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="name" type="xs:string"/>
                    <xs:element name="email" type="xs:string"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="price" type="xs:decimal"/>
              <xs:element name="year" type="xs:integer"/>
              <xs:element name="genre" type="xs:string" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="language" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>'''

# Сохраняем схему в файл
with open("catalog.xsd", "w", encoding="utf-8") as f:
    f.write(xsd_content)

# Валидация XML по схеме
def validate_xml(xml_file, xsd_file):
    try:
        schema = xmlschema.XMLSchema(xsd_file)
        is_valid = schema.is_valid(xml_file)
        if is_valid:
            print(f"XML-файл {xml_file} соответствует схеме {xsd_file}")
        else:
            print(f"XML-файл {xml_file} НЕ соответствует схеме {xsd_file}")
            
            # Получаем ошибки валидации
            try:
                schema.validate(xml_file)
            except xmlschema.XMLSchemaValidationError as e:
                print(f"Ошибка валидации: {e}")
        
        return is_valid
    except Exception as e:
        print(f"Ошибка при валидации: {e}")
        return False

# Проверяем валидность ранее созданных XML-файлов
validate_xml("catalog.xml", "catalog.xsd")
validate_xml("modified_catalog.xml", "catalog.xsd")

# Преобразование XML в словарь Python
def xml_to_dict(xml_file, xsd_file):
    schema = xmlschema.XMLSchema(xsd_file)
    data = schema.to_dict(xml_file)
    return data

# Преобразуем XML в словарь
data_dict = xml_to_dict("catalog.xml", "catalog.xsd")
print("\nXML в виде словаря:")
import json
print(json.dumps(data_dict, indent=2))
```

## Работа с API

### Основы HTTP запросов

```python
import requests

# Базовый GET запрос
response = requests.get("https://jsonplaceholder.typicode.com/posts/1")
print(f"Статус: {response.status_code}")
print(f"Заголовки: {response.headers}")
print(f"Текст ответа: {response.text}")

# Парсинг JSON ответа
data = response.json()
print(f"Данные: {data}")
print(f"Заголовок: {data['title']}")

# GET запрос с параметрами
params = {"userId": 1, "sort": "desc", "limit": 5}
response = requests.get("https://jsonplaceholder.typicode.com/posts", params=params)
print(f"URL с параметрами: {response.url}")
print(f"Количество постов: {len(response.json())}")

# POST запрос с данными
new_post = {
    "title": "Новый пост",
    "body": "Содержание нового поста",
    "userId": 1
}
response = requests.post("https://jsonplaceholder.typicode.com/posts", json=new_post)
print(f"Статус создания: {response.status_code}")
print(f"Созданный пост: {response.json()}")

# PUT запрос (обновление)
updated_post = {
    "id": 1,
    "title": "Обновленный заголовок",
    "body": "Обновленное содержание",
    "userId": 1
}
response = requests.put("https://jsonplaceholder.typicode.com/posts/1", json=updated_post)
print(f"Статус обновления: {response.status_code}")
print(f"Обновленный пост: {response.json()}")

# DELETE запрос
response = requests.delete("https://jsonplaceholder.typicode.com/posts/1")
print(f"Статус удаления: {response.status_code}")
```

### Заголовки, куки и сессии

```python
import requests

# Запрос с пользовательскими заголовками
headers = {
    "User-Agent": "Python Requests Example",
    "Accept": "application/json",
    "X-Custom-Header": "Custom-Value"
}
response = requests.get("https://httpbin.org/headers", headers=headers)
print(f"Отправленные заголовки: {response.json()['headers']}")

# Работа с куки
response = requests.get("https://httpbin.org/cookies/set?name=value&name2=value2")
print(f"Полученные куки: {response.cookies}")
print(f"Значение куки 'name': {response.cookies['name']}")

# Отправка куки в запросе
cookies = {"session_id": "123456789", "user_id": "abcdef"}
response = requests.get("https://httpbin.org/cookies", cookies=cookies)
print(f"Отправленные куки: {response.json()['cookies']}")

# Использование сессий
session = requests.Session()

# Сессия сохраняет куки между запросами
session.get("https://httpbin.org/cookies/set?session_id=987654321")
response = session.get("https://httpbin.org/cookies")
print(f"Куки в сессии: {response.json()['cookies']}")

# Сессия также сохраняет заголовки
session.headers.update({"User-Agent": "My Session Agent", "X-Session-Header": "Session-Value"})
response = session.get("https://httpbin.org/headers")
print(f"Заголовки в сессии: {response.json()['headers']}")

# Закрытие сессии после использования
session.close()
```

### Асинхронные запросы

```python
import asyncio
import aiohttp  # pip install aiohttp

# Асинхронная функция для выполнения HTTP-запроса
async def fetch(session, url):
    async with session.get(url) as response:
        return await response.json()

# Асинхронная функция для выполнения множества запросов
async def fetch_multiple(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [fetch(session, url) for url in urls]
        return await asyncio.gather(*tasks)

# Подготовка списка URL для тестирования
urls = [
    f"https://jsonplaceholder.typicode.com/posts/{i}" 
    for i in range(1, 6)
]

# Функция для запуска асинхронных задач
def run_async_requests():
    # Получение или создание цикла событий
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        # Если нет цикла событий (например, в некоторых средах)
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    
    # Выполнение асинхронной функции
    results = loop.run_until_complete(fetch_multiple(urls))
    
    # Обработка результатов
    for url, result in zip(urls, results):
        print(f"URL: {url}, Title: {result['title']}")

# Запускаем асинхронные запросы
run_async_requests()

# Более сложный пример с ограничением числа одновременных запросов
async def fetch_all_with_semaphore(urls, limit=5):
    """
    Выполняет HTTP-запросы с ограничением числа одновременных запросов.
    
    Args:
        urls: Список URL для запросов
        limit: Максимальное число одновременных запросов
    
    Returns:
        Список результатов
    """
    semaphore = asyncio.Semaphore(limit)
    
    async def fetch_with_semaphore(session, url):
        async with semaphore:
            return await fetch(session, url)
    
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_with_semaphore(session, url) for url in urls]
        return await asyncio.gather(*tasks)

# Подготовка большего списка URL
many_urls = [
    f"https://jsonplaceholder.typicode.com/posts/{i}" 
    for i in range(1, 20)
]

# Функция для запуска асинхронных задач с семафором
def run_async_requests_with_semaphore():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    results = loop.run_until_complete(fetch_all_with_semaphore(many_urls, limit=3))
    
    print(f"Получено {len(results)} результатов с ограничением в 3 одновременных запроса")

# Запускаем асинхронные запросы с ограничением
run_async_requests_with_semaphore()
```

### Аутентификация

```python
import requests

# Базовая аутентификация
response = requests.get(
    "https://httpbin.org/basic-auth/user/pass",
    auth=("user", "pass")
)
print(f"Базовая аутентификация: {response.status_code} {response.reason}")
if response.status_code == 200:
    print(f"Аутентифицированный пользователь: {response.json()['user']}")

# OAuth2 аутентификация (пример, требует настройки OAuth2 провайдера)
def oauth2_example():
    # Токен доступа, полученный ранее
    access_token = "YOUR_ACCESS_TOKEN"
    
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    
    response = requests.get("https://api.example.com/user", headers=headers)
    return response

# Token-based аутентификация
def token_auth_example():
    # API ключ или токен
    api_key = "YOUR_API_KEY"
    
    # Вариант 1: через заголовок
    headers = {
        "Authorization": f"Token {api_key}"
    }
    response1 = requests.get("https://api.example.com/data", headers=headers)
    
    # Вариант 2: через параметр запроса
    params = {
        "api_key": api_key
    }
    response2 = requests.get("https://api.example.com/data", params=params)
    
    return response1, response2

# Обработка ошибок аутентификации
def auth_error_handling():
    try:
        # Неправильные учетные данные
        response = requests.get(
            "https://httpbin.org/basic-auth/user/pass",
            auth=("wrong_user", "wrong_pass")
        )
        
        response.raise_for_status()  # Вызывает исключение для 4XX/5XX статусов
        
        return response.json()
    
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            print("Ошибка аутентификации: неверные учетные данные")
        elif e.response.status_code == 403:
            print("Ошибка авторизации: недостаточно прав")
        else:
            print(f"HTTP ошибка: {e}")
    
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса: {e}")
    
    return None

# Вызов функции с обработкой ошибок
auth_result = auth_error_handling()
```

### Обработка ошибок и тайм-ауты

```python
import requests
from requests.exceptions import Timeout, ConnectionError, HTTPError, RequestException

def safe_request(url, method="get", timeout=5, max_retries=3, **kwargs):
    """
    Выполняет HTTP-запрос с обработкой ошибок и повторными попытками.
    
    Args:
        url: URL для запроса
        method: Метод запроса (get, post, put, delete)
        timeout: Тайм-аут запроса в секундах
        max_retries: Максимальное число повторных попыток
        **kwargs: Дополнительные аргументы для передачи в requests
    
    Returns:
        Ответ сервера или None в случае ошибки
    """
    # Добавление тайм-аута к аргументам
    kwargs.setdefault("timeout", timeout)
    
    # Получение соответствующего метода requests
    request_method = getattr(requests, method.lower())
    
    retries = 0
    while retries < max_retries:
        try:
            response = request_method(url, **kwargs)
            
            # Проверка статуса ответа
            response.raise_for_status()
            
            return response
        
        except Timeout:
            retries += 1
            print(f"Тайм-аут запроса. Повторная попытка {retries}/{max_retries}...")
        
        except ConnectionError:
            retries += 1
            print(f"Ошибка соединения. Повторная попытка {retries}/{max_retries}...")
        
        except HTTPError as e:
            # Не повторяем запрос при ошибках 4XX (кроме 429 - Too Many Requests)
            if e.response.status_code == 429:
                retries += 1
                print(f"Слишком много запросов. Повторная попытка {retries}/{max_retries}...")
            elif 400 <= e.response.status_code < 500:
                print(f"Ошибка клиента HTTP: {e}")
                return e.response  # Возвращаем ответ с ошибкой для дальнейшей обработки
            else:
                retries += 1
                print(f"Ошибка сервера HTTP: {e}. Повторная попытка {retries}/{max_retries}...")
        
        except RequestException as e:
            # Другие ошибки requests
            retries += 1
            print(f"Ошибка запроса: {e}. Повторная попытка {retries}/{max_retries}...")
    
    print(f"Запрос не удался после {max_retries} попыток")
    return None

# Примеры использования
print("\nУспешный запрос:")
response = safe_request("https://httpbin.org/get", params={"q": "test"})
if response:
    print(f"Статус: {response.status_code}")
    print(f"Данные: {response.json()}")

print("\nЗапрос с ошибкой 404:")
response = safe_request("https://httpbin.org/status/404")
if response:
    print(f"Статус: {response.status_code}")

print("\nЗапрос с тайм-аутом:")
response = safe_request("https://httpbin.org/delay/10", timeout=2)
if response:
    print(f"Статус: {response.status_code}")
```

### API клиенты и генерация кода

```python
# Пример создания простого API клиента
class ApiClient:
    """Простой клиент для работы с API."""
    
    def __init__(self, base_url, api_key=None, timeout=10):
        self.base_url = base_url
        self.api_key = api_key
        self.timeout = timeout
        self.session = requests.Session()
        
        # Устанавливаем базовые заголовки
        self.session.headers.update({
            "User-Agent": "ApiClient/1.0",
            "Accept": "application/json"
        })
        
        # Добавляем API ключ, если указан
        if api_key:
            self.session.headers.update({"Authorization": f"Bearer {api_key}"})
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.session.close()
    
    def _build_url(self, endpoint):
        """Формирует полный URL для запроса."""
        return f"{self.base_url}/{endpoint.lstrip('/')}"
    
    def _handle_response(self, response):
        """Обрабатывает ответ API."""
        try:
            response.raise_for_status()
            return response.json()
        except ValueError:
            # Ответ не является JSON
            return response.text
        except HTTPError as e:
            # Обработка ошибок HTTP
            if e.response.status_code == 401:
                raise ValueError("Ошибка аутентификации: неверный API ключ")
            elif e.response.status_code == 404:
                raise ValueError(f"Ресурс не найден: {response.url}")
            else:
                raise
    
    def get(self, endpoint, params=None):
        """Выполняет GET-запрос к API."""
        url = self._build_url(endpoint)
        response = self.session.get(url, params=params, timeout=self.timeout)
        return self._handle_response(response)
    
    def post(self, endpoint, data=None, json=None):
        """Выполняет POST-запрос к API."""
        url = self._build_url(endpoint)
        response = self.session.post(url, data=data, json=json, timeout=self.timeout)
        return self._handle_response(response)
    
    def put(self, endpoint, data=None, json=None):
        """Выполняет PUT-запрос к API."""
        url = self._build_url(endpoint)
        response = self.session.put(url, data=data, json=json, timeout=self.timeout)
        return self._handle_response(response)
    
    def delete(self, endpoint):
        """Выполняет DELETE-запрос к API."""
        url = self._build_url(endpoint)
        response = self.session.delete(url, timeout=self.timeout)
        return self._handle_response(response)

# Пример использования API клиента
def use_api_client():
    # Создаем клиент для работы с JSONPlaceholder API
    with ApiClient("https://jsonplaceholder.typicode.com") as client:
        # GET-запрос
        posts = client.get("posts", params={"userId": 1})
        print(f"Получено {len(posts)} постов пользователя 1")
        
        # POST-запрос
        new_post = {
            "title": "Новая запись",
            "body": "Содержимое новой записи",
            "userId": 1
        }
        created_post = client.post("posts", json=new_post)
        print(f"Создана запись с ID: {created_post['id']}")
        
        # PUT-запрос
        updated_post = {
            "id": 1,
            "title": "Обновленная запись",
            "body": "Новое содержимое",
            "userId": 1
        }
        client.put("posts/1", json=updated_post)
        print("Запись обновлена")
        
        # DELETE-запрос
        client.delete("posts/1")
        print("Запись удалена")

# Автоматическая генерация клиента API по OpenAPI/Swagger спецификации
def generate_api_client():
    # Для автоматической генерации клиентов можно использовать:
    # - openapi-generator: https://github.com/OpenAPITools/openapi-generator
    # - swagger-codegen: https://github.com/swagger-api/swagger-codegen
    # - bravado: https://github.com/Yelp/bravado
    
    # Пример с bravado:
    # pip install bravado
    from bravado.client import SwaggerClient
    
    # Загрузка спецификации Swagger
    petstore_client = SwaggerClient.from_url(
        "https://petstore.swagger.io/v2/swagger.json"
    )
    
    # Использование сгенерированного клиента
    pet = petstore_client.pet.getPetById(petId=1).response().result
    print(f"Получен питомец: {pet.name}")
```

## Практические задачи

### Задача 1: Парсер логов сервера
Напишите скрипт, который:
1. Читает лог-файл веб-сервера построчно
2. Извлекает IP-адреса, URL запросов и коды ответов с помощью регулярных выражений
3. Подсчитывает количество запросов по каждому IP-адресу
4. Определяет самые часто запрашиваемые URL
5. Анализирует коды ответов и выявляет запросы с ошибками
6. Сохраняет результаты анализа в JSON-файл

### Задача 2: Конвертер форматов данных
Создайте утилиту командной строки, которая:
1. Принимает входной файл в одном из форматов (JSON, XML, YAML, CSV)
2. Определяет формат автоматически по расширению или содержимому
3. Преобразует данные в выбранный выходной формат
4. Поддерживает пользовательские схемы преобразования
5. Корректно обрабатывает различные кодировки
6. Имеет возможность валидации данных перед преобразованием

### Задача 3: Клиент для работы с REST API
Разработайте клиент для работы с публичным API (например, GitHub, Twitter или WeatherAPI):
1. Реализуйте авторизацию и обработку токенов
2. Создайте методы для основных операций API
3. Реализуйте кэширование запросов для оптимизации
4. Добавьте обработку ошибок и повторные попытки при сбоях
5. Реализуйте асинхронные запросы для повышения производительности
6. Добавьте документацию и примеры использования

### Задача 4: Анализатор двоичных файлов
Напишите программу для анализа двоичных файлов, которая:
1. Определяет тип файла по сигнатуре (magic bytes)
2. Извлекает метаданные из различных форматов (например, EXIF для изображений)
3. Позволяет просматривать содержимое файла в шестнадцатеричном виде
4. Ищет паттерны или строки в двоичных данных
5. Выполняет простые модификации файла, сохраняя его структуру
6. Генерирует отчет о структуре двоичного файла

### Задача 5: Планировщик задач с поддержкой cron
Создайте библиотеку для планирования и выполнения задач, которая:
1. Позволяет планировать задачи с использованием синтаксиса cron
2. Поддерживает однократные и повторяющиеся задачи
3. Сохраняет состояние между запусками в постоянное хранилище
4. Обрабатывает зависимости между задачами
5. Предоставляет информацию о выполненных задачах и их результатах
6. Позволяет распределять задачи по нескольким исполнителям

## Полезные ресурсы

### Регулярные выражения
- [Документация Python по модулю re](https://docs.python.org/3/library/re.html)
- [RegExr](https://regexr.com/) - Онлайн-инструмент для тестирования регулярных выражений
- [Regular Expressions: The Complete Tutorial](https://www.regular-expressions.info/)
- [Экспресс-курс по регулярным выражениям](https://www.youtube.com/watch?v=rhzKDrUiJVk)

### Сериализация и десериализация
- [Документация Python по модулю json](https://docs.python.org/3/library/json.html)
- [Документация Python по модулю pickle](https://docs.python.org/3/library/pickle.html)
- [PyYAML документация](https://pyyaml.org/wiki/PyYAMLDocumentation)
- [Protocol Buffers Developer Guide](https://developers.google.com/protocol-buffers/docs/pythontutorial)

### Работа с датами и временем
- [Документация Python по модулю datetime](https://docs.python.org/3/library/datetime.html)
- [pytz документация](https://pypi.org/project/pytz/)
- [Pendulum документация](https://pendulum.eustace.io/docs/)
- [Arrow: Better dates & times for Python](https://arrow.readthedocs.io/en/latest/)

### Двоичные данные и байты
- [Работа с двоичными данными в Python](https://docs.python.org/3/library/binary.html)
- [Документация Python по модулю struct](https://docs.python.org/3/library/struct.html)
- [Bitwise operations in Python](https://wiki.python.org/moin/BitwiseOperators)
- [MemoryViews and the Buffer Protocol](https://docs.python.org/3/c-api/buffer.html)

### Работа с JSON и XML
- [JSON Schema](https://json-schema.org/)
- [jsonschema документация](https://python-jsonschema.readthedocs.io/en/stable/)
- [Документация Python по XML](https://docs.python.org/3/library/xml.html)
- [lxml - XML и HTML с Python](https://lxml.de/)

### Работа с API
- [Requests документация](https://requests.readthedocs.io/en/latest/)
- [aiohttp документация](https://docs.aiohttp.org/en/stable/)
- [OpenAPI Specification](https://swagger.io/specification/)
- [REST API Design Rulebook](https://www.oreilly.com/library/view/rest-api-design/9781449317904/)